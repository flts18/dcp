-- phpMyAdmin SQL Dump
-- version 3.5.8
-- http://www.phpmyadmin.net
--
-- Host: localhost
-- Generation Time: Feb 08, 2017 at 08:51 AM
-- Server version: 5.5.32
-- PHP Version: 5.4.17

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- Database: `1273659`
--

-- --------------------------------------------------------

--
-- Table structure for table `fts_actionable_letter`
--

CREATE TABLE IF NOT EXISTS `fts_actionable_letter` (
  `action_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `letter_id` bigint(20) NOT NULL,
  `deadline_dt` date NOT NULL,
  `action_details` varchar(255) NOT NULL,
  `trail_letter_id` bigint(20) NOT NULL,
  `action_status` varchar(10) NOT NULL,
  PRIMARY KEY (`action_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=22 ;

--
-- Dumping data for table `fts_actionable_letter`
--

INSERT INTO `fts_actionable_letter` (`action_id`, `letter_id`, `deadline_dt`, `action_details`, `trail_letter_id`, `action_status`) VALUES
(1, 1, '0000-00-00', 'Not Actionable', 1, 'No'),
(2, 1, '2017-01-17', 'Send Report', 2, 'C'),
(3, 5, '0000-00-00', 'Not Actionable', 3, 'No'),
(4, 7, '0000-00-00', 'Not Actionable', 4, 'No'),
(5, 7, '0000-00-00', 'Not Actionable', 5, 'No'),
(6, 8, '0000-00-00', 'Not Actionable', 6, 'No'),
(7, 8, '2017-01-18', 'Discuss the Matter', 7, 'C'),
(8, 7, '2017-01-20', 'Send Report', 8, 'C'),
(9, 12, '0000-00-00', 'Not Actionable', 9, 'No'),
(10, 7, '0000-00-00', 'Not Actionable', 10, 'No'),
(11, 2, '0000-00-00', 'Not Actionable', 11, 'No'),
(12, 13, '0000-00-00', 'Not Actionable', 12, 'No'),
(13, 6, '0000-00-00', 'Not Actionable', 1, 'No'),
(14, 3, '0000-00-00', 'Not Actionable', 2, 'No'),
(15, 2, '0000-00-00', 'Not Actionable', 3, 'No'),
(16, 2, '2017-02-09', 'Send Report', 4, 'C'),
(17, 4, '2017-02-09', 'Discuss the Matter', 5, 'C'),
(18, 8, '2017-02-08', 'testing fts', 6, 'AT'),
(19, 10, '2017-02-17', 'Discuss the Matter', 7, 'C'),
(20, 10, '0000-00-00', 'Not Actionable', 8, 'No'),
(21, 10, '0000-00-00', 'Not Actionable', 9, 'No');

-- --------------------------------------------------------

--
-- Table structure for table `fts_authority`
--

CREATE TABLE IF NOT EXISTS `fts_authority` (
  `authority_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `authority_name` varchar(255) NOT NULL,
  PRIMARY KEY (`authority_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=61 ;

--
-- Dumping data for table `fts_authority`
--

INSERT INTO `fts_authority` (`authority_id`, `authority_name`) VALUES
(1, 'Homicide Squad'),
(2, 'DRBT Section'),
(3, 'Motor Theft Squad'),
(4, 'Special Operation Group (SOG)'),
(5, 'Railway & Highway Crime Cell'),
(6, 'Special Crime Unit'),
(7, 'Cyber Crime Cell ( also covering Cyber Forensics)'),
(8, 'Narcotic Cell'),
(9, 'Economic Offence Wing (EOW)'),
(10, 'Cheating & Fraud Section'),
(11, 'Protection of Women & Children Cell (POWC)'),
(12, 'Anti Human Trafficking Unit (AHTU) '),
(24, 'SECY WB WDU & MEMBER SECY,WBTGDB'),
(25, 'COMMANDANT, SAP, 13TH BN., BANJORA, BANKURA'),
(26, 'DIG (O) PDWB'),
(27, 'DIG (A) PDWB'),
(28, 'DIG (HQ) PDWB'),
(29, 'Special IG & DIG (O) PDWB'),
(30, 'Special IG & DIG (A) PDWB'),
(31, 'IGP (O) WB'),
(32, 'IGP (A) WB'),
(33, 'IGP (HQ) WB'),
(34, 'IGP (L & O) WB'),
(35, 'Special IG & DIG (HQ) WB'),
(36, 'ADG (O) WB'),
(37, 'ADG (A) WB'),
(38, 'ADG (Est.) WB'),
(39, 'ADG (L & O) WB'),
(40, 'IGP II (HQ) WB'),
(41, 'DG & IGP WB'),
(42, 'SO (A) WB'),
(43, 'SO (Fin.) WB'),
(44, 'IG (Wel.) WB'),
(45, 'ADG (wel.) WB'),
(46, 'Chief Secretory Home Police Dept.'),
(47, 'Special Secretory Home Police Dept.'),
(48, 'Joint Secretory Home Police Dept.'),
(49, 'Deputy Secretory Home Police Dept.'),
(50, 'Asst. Secretory Home Police Dept.'),
(51, 'Chief Secretory Finance Dept.'),
(52, 'Special Secretory Finance Dept.'),
(53, 'Joint Secretory Finance Dept.'),
(54, 'Deputy Secretory Finance Dept.'),
(55, 'Asst. Secretory Finance Dept.'),
(56, 'A.K. BISWAS, DG & IGP(O), WB'),
(57, 'SPL. SECY. TO THE GOV OF WB, FINANCE (AUDIT) DEPT.'),
(58, 'SPL. SECY. TO THE GOVT OF WB, FINANCE DEPT.'),
(59, 'POLICE OFFICE'),
(60, 'COMPUTER SECTION');

-- --------------------------------------------------------

--
-- Table structure for table `fts_authority_old`
--

CREATE TABLE IF NOT EXISTS `fts_authority_old` (
  `authority_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `authority_name` varchar(255) NOT NULL,
  PRIMARY KEY (`authority_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=26 ;

--
-- Dumping data for table `fts_authority_old`
--

INSERT INTO `fts_authority_old` (`authority_id`, `authority_name`) VALUES
(1, 'Homicide Squad'),
(2, 'DRBT Section'),
(3, 'Motor Theft Squad'),
(4, 'Special Operation Group (SOG)'),
(5, 'Railway & Highway Crime Cell'),
(6, 'Special Crime Unit'),
(7, 'Cyber Crime Cell ( also covering Cyber Forensics)'),
(8, 'Narcotic Cell'),
(9, 'Economic Offence Wing (EOW)'),
(10, 'Cheating & Fraud Section'),
(11, 'Protection of Women & Children Cell (POWC)'),
(12, 'Anti Human Trafficking Unit (AHTU) '),
(13, 'Srt'),
(14, 'Mm'),
(15, 'KKKKK'),
(16, 'PWD'),
(17, 'TEST'),
(18, 'TESST'),
(19, 'VVVVVVVVVVVVVVV'),
(20, 'SP SOUTH 24 PGS'),
(21, 'TTTTTTTTTTTTTTTTTT'),
(22, 'KKKKKKKKKKKKKK'),
(23, 'AVIK'),
(24, 'EB'),
(25, 'ADSEQWE');

-- --------------------------------------------------------

--
-- Table structure for table `fts_category`
--

CREATE TABLE IF NOT EXISTS `fts_category` (
  `cat_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `sec_id` bigint(20) NOT NULL,
  `category` varchar(255) NOT NULL,
  PRIMARY KEY (`cat_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=12 ;

--
-- Dumping data for table `fts_category`
--

INSERT INTO `fts_category` (`cat_id`, `sec_id`, `category`) VALUES
(1, 1, 'Modernization'),
(2, 1, 'Account'),
(3, 0, 'Recruitment'),
(4, 0, 'Wer'),
(5, 0, 'M123'),
(6, 67, 'PAY'),
(7, 74, ''),
(8, 73, ''),
(9, 76, ''),
(10, 76, ''),
(11, 56, 'ARMS');

-- --------------------------------------------------------

--
-- Table structure for table `fts_designation`
--

CREATE TABLE IF NOT EXISTS `fts_designation` (
  `desig_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `desig_name` varchar(255) NOT NULL,
  PRIMARY KEY (`desig_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=59 ;

--
-- Dumping data for table `fts_designation`
--

INSERT INTO `fts_designation` (`desig_id`, `desig_name`) VALUES
(1, 'ADGP,CID'),
(2, 'IGP I,CID'),
(3, 'DIG,OPS'),
(4, 'DIG,CID'),
(5, 'IGP II,CID'),
(6, 'SS,SOUTH'),
(7, 'SS,SPECIAL'),
(8, 'SS,HQ'),
(9, 'OS'),
(10, 'OC'),
(11, 'developer'),
(12, 'DDI'),
(13, 'LDA'),
(14, 'Data Entry Operator'),
(15, 'HA/GO'),
(16, 'GL I'),
(17, 'GL II'),
(18, 'Pension'),
(19, 'Leave'),
(20, 'Reference Section'),
(21, 'GPF'),
(22, 'C.C'),
(23, 'Mod'),
(24, 'T.A'),
(25, 'D.A/ Telephone'),
(26, 'H.A Crime'),
(27, 'Form Section Incharge'),
(28, 'Dispatch Section Incharge'),
(31, 'Headquarter Unit Incharge'),
(32, 'DIG,SPECIAL'),
(33, 'SS,WEST'),
(34, 'SS,OPS'),
(35, 'SS,N/B'),
(36, 'SS,NORTH'),
(37, 'SS.MALDA'),
(38, 'DS Hqrs & DDO'),
(39, 'DS Hqrs-II'),
(40, 'Director, QDEB'),
(41, 'Director-in-Charge, FPB'),
(42, 'DS (South)'),
(43, 'DS Murshidabad'),
(44, 'DS Highway'),
(45, 'DS Burdwan'),
(46, 'DS ATS'),
(47, 'Astt. Commandant'),
(48, 'DS Malda'),
(49, 'DS Siliguri'),
(50, 'DS Anti Cheating & Fraud'),
(51, 'DS (Spl) & DS T/C'),
(52, 'OSD Medinapore'),
(53, 'OSD FPB'),
(54, 'OSD Traning'),
(55, 'OSD Trial Monitoring'),
(56, 'DS Bankura'),
(57, 'DS North 24 PGS'),
(58, 'DS (Spl) Siliguri');

-- --------------------------------------------------------

--
-- Table structure for table `fts_designation2`
--

CREATE TABLE IF NOT EXISTS `fts_designation2` (
  `desig_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `desig_name` varchar(255) NOT NULL,
  PRIMARY KEY (`desig_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=15 ;

--
-- Dumping data for table `fts_designation2`
--

INSERT INTO `fts_designation2` (`desig_id`, `desig_name`) VALUES
(1, 'ADGP,CID'),
(2, 'IGP,CID'),
(3, 'DIG,OPS'),
(4, 'DIG,CID'),
(5, 'IPS'),
(6, 'SS,CID'),
(7, 'SS,SPECIAL'),
(8, 'SS,HQ'),
(9, 'OS'),
(10, 'OC'),
(11, 'SUPERVISOR II'),
(12, 'Inspector'),
(13, 'SUPERINTENDENT '),
(14, 'DEO');

-- --------------------------------------------------------

--
-- Table structure for table `fts_employee`
--

CREATE TABLE IF NOT EXISTS `fts_employee` (
  `emp_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `gpf_id` varchar(200) NOT NULL,
  `emp_name` varchar(255) NOT NULL,
  PRIMARY KEY (`emp_id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;

-- --------------------------------------------------------

--
-- Table structure for table `fts_external_address`
--

CREATE TABLE IF NOT EXISTS `fts_external_address` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `organization` varchar(255) NOT NULL,
  `address` varchar(255) NOT NULL,
  `org_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;

-- --------------------------------------------------------

--
-- Table structure for table `fts_file_history_info`
--

CREATE TABLE IF NOT EXISTS `fts_file_history_info` (
  `trail_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `file_id` bigint(20) NOT NULL,
  `user_id` bigint(50) NOT NULL,
  `sender_desig_id` varchar(90) NOT NULL,
  `sender_section_id` varchar(90) NOT NULL,
  `note_id` bigint(20) NOT NULL,
  `addressing_id` varchar(20) NOT NULL,
  `addressing_desig_id` varchar(90) NOT NULL,
  `addressing_section_id` varchar(90) NOT NULL,
  `date_of_action` datetime NOT NULL,
  `action_type` enum('D','R','A') NOT NULL,
  `delete_status` enum('N','Y') NOT NULL,
  PRIMARY KEY (`trail_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=6 ;

--
-- Dumping data for table `fts_file_history_info`
--

INSERT INTO `fts_file_history_info` (`trail_id`, `file_id`, `user_id`, `sender_desig_id`, `sender_section_id`, `note_id`, `addressing_id`, `addressing_desig_id`, `addressing_section_id`, `date_of_action`, `action_type`, `delete_status`) VALUES
(1, 3, 53, '10', '58', 3, '57', '1', '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,29,30,31,32,33,34,', '2017-02-08 17:19:18', 'D', 'N'),
(2, 3, 57, '', '', 0, '', '', '', '2017-02-08 17:28:05', 'R', 'N'),
(3, 3, 57, '1', '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,29,30,31,32,33,34,', 4, '7', '10', '1', '2017-02-08 17:29:47', 'D', 'N'),
(4, 3, 7, '', '', 0, '', '', '', '2017-02-08 17:30:13', 'R', 'N'),
(5, 3, 7, '', '', 0, '', '', '', '2017-02-08 17:30:18', 'A', 'N');

-- --------------------------------------------------------

--
-- Table structure for table `fts_file_movement`
--

CREATE TABLE IF NOT EXISTS `fts_file_movement` (
  `movement_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `file_id` bigint(20) NOT NULL,
  `qrcode_image` varchar(250) NOT NULL,
  `qrcode_text` varchar(250) NOT NULL,
  `received_date_time` datetime NOT NULL,
  `current_dept` varchar(100) NOT NULL,
  `sender_user_id` varchar(50) NOT NULL,
  `reciver_user_id` bigint(20) NOT NULL,
  `from_desig_id` varchar(100) NOT NULL,
  `file_receive_key` varchar(50) NOT NULL,
  `addressing_desig_id` varchar(50) NOT NULL,
  `dispatch_date_time` datetime NOT NULL,
  `dispatch_key` varchar(50) NOT NULL,
  `file_status` varchar(20) NOT NULL,
  `delete_status` varchar(10) NOT NULL,
  PRIMARY KEY (`movement_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=2 ;

--
-- Dumping data for table `fts_file_movement`
--

INSERT INTO `fts_file_movement` (`movement_id`, `file_id`, `qrcode_image`, `qrcode_text`, `received_date_time`, `current_dept`, `sender_user_id`, `reciver_user_id`, `from_desig_id`, `file_receive_key`, `addressing_desig_id`, `dispatch_date_time`, `dispatch_key`, `file_status`, `delete_status`) VALUES
(1, 3, '', '', '2017-02-08 17:30:13', '', '57', 7, '1', '8602', '10', '2017-02-08 17:29:47', '8602', 'A', 'N');

-- --------------------------------------------------------

--
-- Table structure for table `fts_file_note`
--

CREATE TABLE IF NOT EXISTS `fts_file_note` (
  `note_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `nsp_id` varchar(50) NOT NULL,
  `note_text` varchar(255) NOT NULL,
  `signature` varchar(255) NOT NULL,
  `file_ref_sl_no` varchar(100) NOT NULL,
  `file_id` bigint(20) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  PRIMARY KEY (`note_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=5 ;

--
-- Dumping data for table `fts_file_note`
--

INSERT INTO `fts_file_note` (`note_id`, `nsp_id`, `note_text`, `signature`, `file_ref_sl_no`, `file_id`, `user_id`) VALUES
(1, '', '<p>diucucsicodcldsjj</p>\r\n<p>djcksjcjklcjskc</p>\r\n<p>cjdsodjcoidjcsculgvhcgscdjkcidcd</p>\r\n<p>dsjchldshosahcuas</p>\r\n<p>ndshcssjclhc</p>\r\n<p>djhncodjsjcoijio7547554095t459t8544</p>\r\n<p>90858t7ykmru788hrkjgkmmgkg</p>\r\n<p>7r8t87546478r90t89hyjjhjhui3iu3ou3u', 'aaaa', 'CID/ACCOUNTS-PAYBILL/PAY/DA/1/2017', 1, 91),
(2, '', '<p>This is a very important doc files.</p>', 'os', 'CID/ACCOUNTS-GPF///1/2017', 3, 53),
(3, '', '<p>Dear madam</p>', 'os', 'CID/ACCOUNTS-GPF///1/2017', 3, 53),
(4, '', '<p>jkc,hjdscvdhcbj.dsnj.skjc,hsdckj64587</p>', 'af', 'CID/ACCOUNTS-GPF///1/2017', 3, 57);

-- --------------------------------------------------------

--
-- Table structure for table `fts_file_registration`
--

CREATE TABLE IF NOT EXISTS `fts_file_registration` (
  `file_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `file_ref_sl_no` varchar(100) NOT NULL,
  `file_shadow` varchar(100) NOT NULL,
  `part_label` varchar(10) NOT NULL,
  `parent_file` bigint(20) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  `desig_id` varchar(50) NOT NULL,
  `br_image_name` varchar(100) NOT NULL,
  `br_value` varchar(255) NOT NULL,
  `sec_id` bigint(20) NOT NULL,
  `file_reg_date` datetime NOT NULL,
  `sub_cat` varchar(50) NOT NULL,
  `issuing_authority` bigint(20) NOT NULL,
  `category_id` bigint(20) NOT NULL,
  `issue_dt` date NOT NULL,
  `description` varchar(250) NOT NULL,
  `file_priority` varchar(20) NOT NULL,
  `file_status` varchar(20) NOT NULL,
  `subject` varchar(200) NOT NULL,
  `type_of_paper` varchar(20) NOT NULL,
  `folder_name` varchar(200) NOT NULL,
  `file_move_status` enum('P','M','A') NOT NULL,
  `delete_status` enum('Y','N') NOT NULL,
  PRIMARY KEY (`file_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=11 ;

--
-- Dumping data for table `fts_file_registration`
--

INSERT INTO `fts_file_registration` (`file_id`, `file_ref_sl_no`, `file_shadow`, `part_label`, `parent_file`, `user_id`, `desig_id`, `br_image_name`, `br_value`, `sec_id`, `file_reg_date`, `sub_cat`, `issuing_authority`, `category_id`, `issue_dt`, `description`, `file_priority`, `file_status`, `subject`, `type_of_paper`, `folder_name`, `file_move_status`, `delete_status`) VALUES
(1, 'CID/ACCOUNTS-MEDICAL//DA/1/2017', '5', '', 0, 91, '1', '', '', 10, '2017-02-08 16:50:27', 'DA', 76, 10, '2017-02-08', 'KDSCIUHVYUGHILUJ'';./5646778847', 'Very Urgent', 'Confidencial', 'apollllllkkk', '', 'CID_ACCOUNTS-PAYBILL_PAY_DA_1_2017', 'P', 'N'),
(2, 'CID/ACCOUNTS-MEDICAL///1/2017', '4', '', 0, 53, '10', '', '', 58, '2017-02-08 16:55:37', '', 76, 9, '2017-02-06', '', 'Normal', 'Normal', 'test3', '', 'CID_POLICEOFFICE___1_2017', 'P', 'N'),
(3, 'CID/ACCOUNTS-GPF///1/2017', '0', 'Part-I', 0, 53, '10', '', '', 58, '2017-02-08 17:06:17', '', 73, 8, '2017-02-08', 'FOR SUCCESS MSG', 'Normal', 'Normal', 'test2', '', 'CID_ACCOUNTS-GPF___1_2017', 'M', 'N'),
(4, 'CID/POLICEOFFICE///1/2017', '4', '', 0, 53, '10', '', '', 58, '2017-02-08 16:55:37', '', 74, 7, '2017-02-08', '', 'Normal', 'Normal', 'test1', '', 'CID_POLICEOFFICE___1_2017', 'P', 'N'),
(5, 'CID/ACCOUNTS-PAYBILL/PAY/DA/1/2017', '5', '', 0, 91, '1', '', '', 10, '2017-02-08 16:50:27', 'DA', 67, 6, '2017-02-08', 'KDSCIUHVYUGHILUJ'';./5646778847', 'Urgent', 'Confidencial', 'apol', '', 'CID_ACCOUNTS-PAYBILL_PAY_DA_1_2017', 'P', 'N'),
(6, 'CID/ACCOUNTS-GPF///1/2017', '0', 'Part-II', 3, 53, '10', '', '', 58, '2017-02-08 17:42:05', '', 73, 8, '2017-02-08', 'FOR SUCCESS MSG', 'Normal', 'Normal', 'test2', '', 'CID_ACCOUNTS-GPF___1_2017', 'P', 'N'),
(7, 'CID/ACCOUNTS-GPF///1/2017', '0', 'Part-III', 3, 53, '10', '', '', 58, '2017-02-08 17:43:38', '', 73, 8, '2017-02-08', 'FOR SUCCESS MSG', 'Normal', 'Normal', 'test2', '', 'CID_ACCOUNTS-GPF___1_2017', 'P', 'N'),
(8, 'CID/ARMOURARYSEC/ARM/TESTING/1/2017', '9', 'Part-I', 0, 46, '13', '', '', 51, '2017-02-08 20:01:01', 'TESTING', 56, 11, '2017-02-08', 'YYYYYY', 'Normal', 'Normal', 'xxxx', '', 'CID_ARMOURARYSEC_ARM_PROCUREMENTS_1_2017', 'P', 'N'),
(9, 'CID/ARMOURARYSEC/ARM/TESTING/1/2017', '9', '', 0, 46, '13', '', '', 51, '2017-02-08 20:01:01', 'TESTING', 56, 11, '2017-02-08', 'YYYYYY', 'Normal', 'Normal', 'xxxx', '', 'CID_ARMOURARYSEC_ARM_PROCUREMENTS_1_2017', 'P', 'N'),
(10, 'CID/ARMOURARYSEC/ARM/TESTING/1/2017', '0', 'Part-II', 8, 46, '13', '', '', 51, '2017-02-08 20:19:04', 'TESTING', 56, 11, '2017-02-08', 'YYYYYY', 'Normal', 'Normal', 'xxxx', '', 'CID_ARMOURARYSEC_ARM_PROCUREMENTS_1_2017', 'P', 'N');

-- --------------------------------------------------------

--
-- Table structure for table `fts_letter_history_info`
--

CREATE TABLE IF NOT EXISTS `fts_letter_history_info` (
  `trail_letter_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `letter_id` bigint(20) NOT NULL,
  `recv_id` bigint(20) NOT NULL,
  `receiver_section_id` varchar(90) NOT NULL,
  `receiver_desig_id` varchar(90) NOT NULL,
  `sender_user_id` bigint(20) NOT NULL,
  `sender_section_id` varchar(90) NOT NULL,
  `sender_desig_id` varchar(90) NOT NULL,
  `date_of_action` date NOT NULL,
  PRIMARY KEY (`trail_letter_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=10 ;

--
-- Dumping data for table `fts_letter_history_info`
--

INSERT INTO `fts_letter_history_info` (`trail_letter_id`, `letter_id`, `recv_id`, `receiver_section_id`, `receiver_desig_id`, `sender_user_id`, `sender_section_id`, `sender_desig_id`, `date_of_action`) VALUES
(1, 6, 1, '10', '10', 46, '51', '13', '2017-02-08'),
(2, 3, 6, '16', '10', 7, '1', '10', '2017-02-08'),
(3, 2, 91, '10', '1', 7, '1', '10', '2017-02-08'),
(4, 2, 6, '16', '10', 91, '10', '1', '2017-02-08'),
(5, 4, 7, '1', '10', 91, '10', '1', '2017-02-08'),
(6, 8, 7, '1', '10', 91, '10', '1', '2017-02-08'),
(7, 10, 7, '1', '10', 91, '10', '1', '2017-02-08'),
(8, 10, 57, '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,29,30,31,32,33,34,', '1', 7, '1', '10', '2017-02-08'),
(9, 10, 91, '10', '1', 57, '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,29,30,31,32,33,34,', '1', '2017-02-08');

-- --------------------------------------------------------

--
-- Table structure for table `fts_letter_movement`
--

CREATE TABLE IF NOT EXISTS `fts_letter_movement` (
  `move_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `letter_id` bigint(20) NOT NULL,
  `received_date_time` datetime NOT NULL,
  `receiver_id` bigint(20) NOT NULL,
  `sender_id` bigint(20) NOT NULL,
  `recv_desig_id` bigint(20) NOT NULL,
  `sender_desig_id` bigint(20) NOT NULL,
  `ext_receiver` varchar(100) DEFAULT NULL,
  `action_id` bigint(20) NOT NULL,
  `dispatch_dt_time` varchar(100) NOT NULL,
  `recv_status` varchar(50) NOT NULL,
  `delete_status` enum('N','Y') NOT NULL,
  PRIMARY KEY (`move_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=7 ;

--
-- Dumping data for table `fts_letter_movement`
--

INSERT INTO `fts_letter_movement` (`move_id`, `letter_id`, `received_date_time`, `receiver_id`, `sender_id`, `recv_desig_id`, `sender_desig_id`, `ext_receiver`, `action_id`, `dispatch_dt_time`, `recv_status`, `delete_status`) VALUES
(1, 6, '0000-00-00 00:00:00', 1, 46, 10, 13, '', 13, '2017-02-08 15:14:42', '', 'N'),
(2, 3, '0000-00-00 00:00:00', 6, 7, 10, 10, '', 14, '2017-02-08 15:15:32', '', 'N'),
(3, 2, '0000-00-00 00:00:00', 6, 91, 10, 1, '', 16, '2017-02-08 16:16:37', '', 'N'),
(4, 4, '0000-00-00 00:00:00', 7, 91, 10, 1, NULL, 17, '2017-02-08 16:25:40', '', 'N'),
(5, 8, '0000-00-00 00:00:00', 7, 91, 10, 1, NULL, 18, '2017-02-08 16:29:28', '', 'N'),
(6, 10, '0000-00-00 00:00:00', 91, 57, 1, 1, NULL, 21, '2017-02-08 17:21:59', '', 'N');

-- --------------------------------------------------------

--
-- Table structure for table `fts_letter_record`
--

CREATE TABLE IF NOT EXISTS `fts_letter_record` (
  `letter_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `sl_no` bigint(20) NOT NULL,
  `memo_no` varchar(200) NOT NULL,
  `issue_dt` date NOT NULL,
  `reg_type_id` bigint(20) NOT NULL,
  `ref_serial` bigint(50) NOT NULL,
  `cp_no` int(11) NOT NULL,
  `page_count` bigint(20) NOT NULL,
  `file_id` bigint(20) NOT NULL,
  `letter_name` varchar(100) NOT NULL,
  `user_id` bigint(11) NOT NULL,
  `content` longtext NOT NULL,
  `sending_authority` bigint(20) NOT NULL,
  `subject` varchar(255) NOT NULL,
  `addressing_desig_id` bigint(20) NOT NULL,
  `reg_dt` date NOT NULL,
  `location_path` varchar(255) NOT NULL,
  `regis_status` enum('L','F') NOT NULL,
  `letter_move_status` enum('P','M') NOT NULL,
  `addressing_user_id` bigint(20) NOT NULL,
  `register_id` bigint(20) NOT NULL,
  `attached_by` bigint(20) NOT NULL,
  PRIMARY KEY (`letter_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=20 ;

--
-- Dumping data for table `fts_letter_record`
--

INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(1, 1, '1323', '2017-02-08', 1, 1, 0, 4, 0, '1486540091.pdf', 7, 'belcher   1 \n• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • •  \nwriting the academic book review by wendy laura belcher \nwhy write a book review? \nwriting book reviews is not only the easiest and quickest route to publication, it is a good way to \nimprove your writing skills, develop your analytical skills, learn how the journal publishing \nprocess works, and get to know editors. since some libraries can’t buy books unless they have \nbeen reviewed and many individuals won’t buy books unless they have read a review, reviewing \nbooks can definitely advance your field. indeed, scholars in smaller fields sometimes get together \nand assign books for review so that every book published in their field is reviewed somewhere. \njust remember that book reviews do not “count” as much on a curriculum vitae as an academic \nessay. if you are doing more than two book reviews a year, you may be spending too much time \non book reviews and not enough on your other writing.  \nchoosing a book \nthink about what kind of book would be most useful to you in writing your dissertation, \nfinalizing a paper for publication, or passing your exams. since book reviews do take time, like \nany writing, it is best to chose a book that will work for you twice, as a publication and as \nresearch. alternatively, some recommend that graduate students focus on reviewing textbooks or \nanthologies, since such reviews take less background knowledge and editors can find it difficult \nto find people willing to do such reviews. although the traditional book review is of one book, \neditors will often welcome book reviews that address two or more related books. \nchoose a book that (1) is in your field, (2) is on a topic for which you have sound background \nknowledge, (3) has been published in the past two or three years, and (4) has been published by a \nreputable publisher (i.e., any press affiliated with a university, or large commercial presses). \nbooks on hot topics are often of special interest to editors. it can also be rewarding to pick an \nobscure but useful book in order to bring attention to it. to avoid complications, it is best not to \nreview books written by your advisor, spouse, or ex. \nto identify a suitable book in your field: \n• look up the call number of the favorite book in your field and go to the stacks of your \nuniversity library. do a shelf search around the call number to see if anything similar or \nrelated has been published in the past couple of years. \n• go to any book database—your university library on-line, amazon.com, the library of \ncongress—and search using two or three keywords related to your field (e.g., chicano \nfiction, chicana politics, latino demographics, latina high school education) to find books in \nyour area. \n• read magazines that review books before publication—such as choice, library journal, or \nkirkus reviews—to get a sense for interesting books that will be coming out. you can get \ncopies of books for review before they are published. editors especially like reviews of just \npublished books.  \n• read those academic journals that list books recently received for review or recently \npublished in their area. (aztlán will have such a section starting in fall 2003.) \n• ask faculty members in your department for recommendations.  \nonce you have identified several books, locate copies and skim them. pick the book that seems \nthe strongest. do not pick a book that has major problems or with which you disagree violently.\n\nbelcher   2 \nas a graduate student, you do not have the protection of tenure and may one day be evaluated by \nthe person whose book you put to the ax. if you really feel strongly that you must write a negative \nreview of a certain book, go ahead and write the review. academia is, after all, quite oedipal and \nyoung scholars do sometimes make their reputations by deflating those who came before them. \njust realize that going on record in such a public way may have consequences.\n \nchoosing a journal \nidentify several leading journals in your field that publish book reviews. one way to do this is to \nsearch an on-line article database. using several key words from your field, limit your search to \nbook reviews and note the journals where the results were published. \nbefore\n starting to write your review, contact the book review editor of one of the journals. this is \nimportant standard practice; most journals do not accept unsolicited reviews. you do not want to \nwrite an entire review of a book and send it to a journal, only to be told that a review of that very \nbook is to appear in the next issue.  \njust send a short e-mail to the book review editor (most journals have websites with such \ninformation) identifying the book you would like to review and your qualifications for reviewing \nit. this e-mail need not be longer than two sentences: “i am writing to find out if you would \nwelcome a review from me of [book title], edited by [editor] and published in 2012 by \n[pubisher]. i am currently writing my dissertation at stanford on the history of the field of [name \nof a field related to book].” \nanother reason why you want to contact the book review editor is that they often can get you the \nbook for free. publishers frequently send books for review straight to journals or, if the book \neditor directly contacts them, straight to you. of course, you don’t need to wait for the book to \nstart your review if you have access to a library copy. if you get a free book, make sure to write \nthe review. a book review editor will never send you another book if you don’t deliver on the \nfirst. \nif the book review editor says yes, they would like a review of the book from you, make sure to \nask if the journal has any book review submission guidelines. in particular, you want to make \nsure you understand how long their book reviews tend to be. if the book review editor says the \nbook is already under review, move on to your next journal choice or ask the editor if they have \nany books on the topic that they would like reviewed. you are under no obligation to review a \nbook they suggest, just make sure to get back to them with a decision. it is perfectly acceptable to \nsay “thanks for the suggestion, i’ve decided to focus on writing my prospectus/dissertation.” \nreading the book \nit is best, when writing a book review, to be an active reader of the book. sit at a desk with pen \nand paper in hand. as you read, stop frequently to summarize the argument, to note particularly \nclear statements of the book’s argument or purpose, and to describe your own responses. if you \nhave read in this active way, putting together the book review should be quick and \nstraightforward. some people prefer to read at the computer but if you’re a good typist, you often \nstart typing up long quotes from the book instead of analyzing it. paper and pen provides a little \nfriction to prevent such drifting. \ntake particular note of the title (does the book deliver what the title suggests it is going to \ndeliver?), the table of contents (does the book cover all the ground you think it should?), the \npreface (often the richest source of information about the book), and the index (is it accurate, \nbroad, deep?).  \nsome questions to keep in mind as you are reading:\n\nbelcher   3 \n• what is the book’s argument? \n• does the book do what it says it is going to do?  \n• is the book a contribution to the field or discipline? \n• does the book relate to a current debate or trend in the field and if so, how?  \n• what is the theoretical lineage or school of thought out of which the book rises? \n• is the book well-written?  \n• what are the books terms and are they defined? \n• how accurate is the information (e.g., the footnotes, bibliography, dates)? \n• are the illustrations helpful? if there are no illustrations, should there have been?  \n• who would benefit from reading this book? \n• how does the book compare to other books in the field? \n• if it is a textbook, what courses can it be used in and how clear is the book’s structure and \nexamples? \nit can be worthwhile to do an on-line search to get a sense for the author’s history, other books, \nuniversity appointments, graduate advisor, and so on. this can provide you with useful context.. \nmaking a plan \nbook reviews are usually 600 to 2,000 words in length. it is best to aim for about 1,000 words, as \nyou can say a fair amount in 1,000 words without getting bogged down. there’s no point in \nmaking a book review into a 20-page masterpiece since the time would have been better spent on \nan academic essay that would count for more on your c.v. some say a review should be written in \na month: two weeks reading the book, one week planning your review, and one week writing it. \nalthough many don’t write an outline for an essay, you should really try to outline your book \nreview before you write it. this will keep you on task and stop you from straying into writing an \nacademic essay.  \nclassic book review structure is as follows: \n• title including complete bibliographic citation for the work (i.e., title in full, author, place, \npublisher, date of publication, edition statement, pages, special features [maps, color plates, \netc.], price, and isbn.  \n• one paragraph identifying the thesis, and whether the author achieves the stated purpose of \nthe book.  \n• one or two paragraphs summarizing the book. \n• one paragraph on the book’s strengths. \n• one paragraph on the book’s weaknesses. \n• one paragraph on your assessment of the book’s strengths and weaknesses. \nwriting the review \nonce you’ve read the book, try to spend no more than one or two weeks writing the review. \nallowing a great deal of time to fall between reading the book and writing about it is unfair to\n\nbelcher   4 \nyou and the author. the point of writing something short like a book review is to do it quickly. \nsending a publication to a journal is always scary, sitting on the review won’t make it less so. \navoiding five common pitfalls \n1. evaluate the text, don’t just summarize it. while a succinct restatement of the text’s points is \nimportant, part of writing a book review is making a judgment. is the book a contribution to \nthe field? does it add to our knowledge? should this book be read and by whom? one \nneedn’t be negative to evaluate; for instance, explaining how a text relates to current debates \nin the field is a form of evaluation. \n2. do not cover everything in the book. in other words, don’t use the table of contents as a \nstructuring principle for your review. try to organize your review around the book’s \nargument or your argument about the book. \n3. judge the book by its intentions not yours. don’t criticize the author for failing to write the \nbook you think that he or she should have written. as john updike puts it, “do not imagine \nyourself the caretaker of any tradition, an enforcer of any party standards, a warrior in any \nideological battle, a corrections officer of any kind.”  \n4. likewise, don’t spend too much time focusing on gaps. since a book is only 200 to 500 \npages, it cannot possibly address the richness of any topic. for this reason, the most common \ncriticism in any review is that the book doesn’t address some part of the topic. if the book \npurports to be about ethnicity and film and yet lacks a chapter on latinos, by all means, \nmention it. just don’t belabor the point. another tic of reviewers is to focus too much on \nbooks the author did not cite. if you are using their bibliography just to display your own \nknowledge it will be obvious to the reader. keep such criticisms brief. \n5. don’t use too many quotes from the book. it is best to paraphrase or use short telling quotes \nwithin sentences. \nother \nfor further advice about writing for publication, see writing your journal article in twelve \nweeks: a guide to academic publishing success by wendy laura belcher (sage, 2009). \n \nthis article was originally written to aid participants in a workshop sponsored by the ucla \nchicano studies research center and to encourage book review submissions to aztlán: a journal \nof chicano studies. book reviews in the field of chicano studies can be sent to to david o''grady, \nassistant editor of aztlán, whose contact can be found at www.chicano.ucla.edu/press.', 7, 'academic book', 10, '2017-02-08', 'letter', 'L', 'P', 6, 4, 0);
INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(2, 1, '134', '2017-02-08', 1, 2, 0, 55, 0, '1486540645.pdf', 7, '''touching the sun'': sunita williams on\nspacewalk\n10 september 2012\n \nnasa astronaut sunita williams. credit: nasa\n(phys.org)—nasa astronaut sunita williams,\nexpedition 32 flight engineer, appears to touch the\nbright sun during the mission''s third session of \nextravehicular activity (eva) on sept. 5, 2012 . \nduring the six-hour, 28-minute spacewalk, williams\nand japan aerospace exploration agency\nastronaut aki hoshide (visible in the reflections of\nwilliams'' helmet visor), flight engineer, completed\nthe installation of a main bus switching unit\n(mbsu) that was hampered by a possible\nmisalignment and damaged threads where a bolt\nmust be placed. \nthey also installed a camera on the international\nspace station''s robotic arm, canadarm2.\nprovided by nasa\napa citation: ''touching the sun'': sunita williams on spacewalk (2012, september 10) retrieved 18\nnovember 2014 from  http://phys.org/news/2012-09-sun-sunita-williams-spacewalk.html\n                               1 / 2\n\nthis document is subject to copyright. apart from any fair dealing for the purpose of private study or research, no part\nmay be reproduced without the written permission. the content is provided for information purposes only.\npowered by tcpdf (www.tcpdf.org)                                2 / 2\n\n1  \na  t u to ria l o n p o in ter s a nd a rr ays i n  c   \nby  t ed  j e n se n   \nv ers io n 1 .2  ( p d f v ers io n)\n \ns ep t. 2 003 \nt his  m ate ria l i s  h ere b y p la ced  i n  t h e p ublic  d om ain   \na vaila b le  i n  v ario us f o rm ats  v ia   \nh ttp ://p w eb .n etc o m .c o m /~ tje n se n /p tr /c p oin t.h tm  \n \nt a ble o f c o n ten ts \npr efa ce  2 \ni n tr o ductio n  4 \nc h apt er  1 : w hat i s  a  p oin te r?   5 \nc h apt er  2 : p oin te r t y p es a n d a rra ys  9 \nc h apt er  3 : p oin te rs a n d s tr in gs  14 \nc h apt er  4 : m ore o n  s tr in gs  19 \nc h apt er  5 : p oin te rs a n d s tr u ctu res  22 \nc h apt er  6 : s om e m ore o n  s tr in gs, a n d  a rra ys o f s tr in gs  26 \nc h apt er  7 : m ore o n  m ult i- d im en sio n al a rra y s  30 \nc h apt er  8 : p oin te rs t o  a rra ys  32 \nc h apt er  9 : p oin te rs a n d d yn am ic  a llo ca tio n  o f m em ory   34 \nc h apt er  1 0: p oin te rs t o  f unctio n s  42 \ne pil o g  53\n\n2  \np r efa ce  \nt his  d ocu m en t i s  i n te n ded  t o  i n tr o duce p oin te rs  t o  b eg in nin g p ro gra m mers  i n  t h e c  \np ro gra m min g l a n gu ag e.  o ver s e v era l y ears  o f r e a d in g a n d c o ntr ib utin g t o  v ario us \nc o nfe re n ces o n c  i n clu din g t h ose  o n t h e f id on et a n d u se n et,  i  h av e n ote d  a  l a rg e \nn um ber o f n ew co m ers  t o  c  a p pear t o  h av e a  d if fic u lt t im e i n  g ra sp in g t h e f u ndam en ta ls  \no f p oin te rs .  i  t h ere fo re  u nderto ok t h e t a sk  o f t r y in g t o  e x pla in  t h em  i n  p la in  l a n gu ag e w ith  \nl o ts  o f e x am ple s. \nt he f ir s t v ers io n o f t h is  d ocu m en t w as p la c ed  i n  t h e p ublic  d om ain , a s i s  t h is  o ne.  i t w as \np ic k ed  u p b y b ob s to ut w ho i n clu ded  i t a s a  f ile  c alle d  p t r -h elp.t x t i n  h is  w id ely  \nd is tr ib ute d  c o lle ctio n o f s n ip pe ts. s in ce t h at o rig in al 1 995 r e le ase ,  i  h av e a d ded  a  \ns ig n if ic an t a m ount o f m ate ria l a n d m ad e s o m e m in or c o rr e ctio ns i n  t h e o rig in al w ork . \ni  s u bse q uen tl y  p oste d  a n  h tm l v ers io n a ro und 1 998 o n m y w eb site  a t: \n \nh ttp ://p w eb .n etc o m .c o m /~ tje n se n /p tr /c p oin t.h tm  \na fte r n um ero us r e q u ests ,  i ’ v e f in all y  c o m e o ut w ith  t h is  p d f v ers io n w hic h  i s  i d en ti c al \nt o  t h at h tm l v ers io n c ite d  a b ove,  a n d w hic h  c an  b e o bta in ed  f ro m  t h at s a m e w eb  s ite .  \na ck n ow le d gem en ts :  \nt here  a re  s o  m an y p eo ple  w ho h av e u nkno w in gly  c o ntr ib ute d  t o  t h is  w ork  b ecau se  o f t h e \nq uestio ns t h ey  h av e p ose d  i n  t h e f id on et c  e ch o, o r t h e u se n et n ew sg ro u p \nc o m p.l a n g.c , o r s e v era l o th er c o nfe re n ces i n  o th er n etw ork s, t h at i t w ould  b e i m possib le  \nt o  l is t t h em  a ll. s pecia l t h an ks g o  t o  b ob s to ut w ho w as k in d e n ou gh  t o  i n clu de t h e f ir s t \nv ers io n o f t h is  m ate ria l i n  h is  s n ip pe ts f ile .  \na bou t t h e a uth or:  \nt ed  j e n se n  i s  a  r e tir e d  e le ctr o nic s e ngin eer w ho w ork ed  a s a  h ard w are  d esig n er o r \nm an ag er o f h ard w are  d esig n ers  i n  t h e f ie ld  o f m ag netic  r e co rd in g. p ro gra m min g h as b een  \na  h obb y o f h is  o ff a n d o n  s in ce 1 968 w hen  h e l e arn ed  h ow  t o  k ey p unch  c ard s f o r \ns u bm is sio n t o  b e r u n o n a  m ain fra m e. ( t he m ain fra m e h ad  6 4k  o f m ag n eti c  c o re  \nm em ory !).  \nu se  o f t h is  m ate ria l:  \ne very th in g c o nta in ed  h ere in  i s  h ere b y r e le ase d  t o  t h e p ublic  d om ain . a ny p ers o n m ay  \nc o p y o r d is tr ib ute  t h is  m ate ria l i n  a n y m an ner t h ey  w is h . t he o nly  t h in g i  a sk  i s  t h at i f  \nt h is  m ate ria l i s  u se d  a s a  t e ach in g a id  i n  a  c la ss,  i  w ould  a p pre cia te  i t i f  i t w ere  d is tr ib ute d  \ni n  i ts  e n tir e ty , i .e . i n clu din g a ll c h ap te rs , t h e p re fa ce a n d t h e i n tr o du ctio n.  i  w ould  a ls o  \na p pre cia te  i t i f , u nder s u ch  c ir c u m sta n ces, t h e i n str u cto r o f s u ch  a  c la ss w ou ld  d ro p m e a\n\n3  \nn\note  a t o ne o f t h e a d dre ss e s b elo w  i n fo rm in g m e o f t h is .  i  h av e w ritte n  t h is  w ith  t h e h ope \nt h at i t w ill b e u se fu l t o  o th ers  a n d s in ce  i ©m  n ot a sk in g a n y f in an cia l r e m un era tio n, t h e \no nly  w ay  i  k now  t h at i  h av e a t l e ast p artia ll y  r e ac h ed  t h at g o al i s  v ia  f e ed b ack  f ro m  t h ose  \nw ho f in d t h is  m ate ria l u se fu l. \nb y t h e w ay ,  y o u n eed n ©t  b e a n  i n str u cto r o r t e ach er t o  c o nta ct m e.  i  w ould  a p pre cia te  a  \nn ote  f ro m  a n yo ne\n w ho f in ds t h e m ate ria l u se fu l, o r w ho h as c o nstr u ctiv e c ritic is m  t o  \no ffe r.  i ©m  a ls o  w illin g t o  a n sw er q u estio ns s u bm itte d  b y e m ail a t t h e a d d re sse s s h ow n \nb elo w . \nt ed  j e n se n   \nr ed w ood c it y , c alif o rn ia  \nt je n se n @ ix .n etc o m .c o m   \nj u ly  1 998\n\n4  \ni n tr o du ctio n \nif  y o u w an t t o  b e p ro fic ie n t i n  t h e w ritin g o f c o d e i n  t h e c  p ro gra m min g l a n gu ag e,  y o u \nm ust h av e a  t h oro u gh  w ork in g k now le d ge o f h ow  t o  u se  p oin te rs . u nfo rtu n ate ly , c  \np oin te rs  a p pea r t o  r e p re se n t a  s tu m blin g b lo ck  t o  n ew co m ers , p artic u la rly  t h ose  c o m in g \nf ro m  o th er c o m pute r l a n gu ag es s u ch  a s f ortr a n , p asc al o r b asic .  \nt o a id  t h ose  n ew co m ers  i n  t h e u nders ta n din g o f p oin te rs  i  h av e w ritte n  t h e f o llo w in g \nm ate ria l. t o g et t h e m ax im um  b en efit f ro m  t h is  m ate ria l,  i  f e el i t i s  i m porta n t t h at t h e \nu se r b e a b le  t o  r u n t h e c o de i n  t h e v ario us l is tin gs c o nta in ed  i n  t h e a rtic le .  i  h av e \na tte m pte d , t h ere fo re , t o  k eep  a ll c o d e a nsi c o m plia n t s o  t h at i t w ill w ork  w ith  a n y a nsi \nc o m plia n t c o m pile r.  i  h av e a ls o  t r ie d  t o  c a re fu ll y  b lo ck  t h e c o de w ith in  t h e t e x t. t hat \nw ay , w ith  t h e h elp  o f a n  a sc ii t e x t e d ito r,  y o u c a n  c o p y a  g iv en  b lo ck  o f c o de t o  a  n ew  \nf ile  a n d c o m pile  i t o n y o ur s y ste m .  i  r e co m men d t h at r e ad ers  d o t h is  a s i t w ill h elp  i n  \nu nders ta n din g t h e m ate ria l.\n\n5  \nc h apt er  1 : w hat i s  a  p oin te r?   \no ne o f t h ose  t h in gs b eg in ners  i n  c  f in d d if fic u lt i s  t h e c o ncep t o f p oin te rs . t he p urp o se  \no f t h is  t u to ria l i s  t o  p ro vid e a n  i n tr o ductio n t o  p oin te rs  a n d t h eir  u se  t o  t h ese  b eg in ners .  \ni  h av e f o und t h at o fte n  t h e m ain  r e aso n b eg in ners  h av e a  p ro ble m  w ith  p oin te rs  i s  t h at \nt h ey  h av e a  w eak  o r m in im al f e elin g f o r v aria b le s, ( a s t h ey  a re  u se d  i n  c ).  t hus w e s ta rt \nw ith  a  d is c u ssio n o f c  v aria b le s i n  g en era l.  \na  v aria b le  i n  a  p ro gra m  i s  s o m eth in g w ith  a  n am e, t h e v alu e o f w hic h  c an  v ary . t he w ay  \nt h e c o m pile r a n d l in ker h an dle s t h is  i s  t h at i t a ssig n s a  s p ecif ic  b lo ck  o f m em ory  w ith in  \nt h e c o m pute r t o  h old  t h e v alu e o f t h at v aria b le . t he s iz e o f t h at b lo ck  d ep en ds o n t h e \nr a n ge o ver w hic h  t h e v aria b le  i s  a llo w ed  t o  v ary .  f or e x am ple , o n p c ©s  t h e s iz e o f a n  \ni n te g er v aria b le  i s  2  b yte s, a n d t h at o f a  l o n g i n te g er i s  4  b yte s.  i n  c  t h e s iz e o f a  v aria b le  \nt y p e s u ch  a s a n  i n te g er n eed  n ot b e t h e s a m e o n a ll t y p es o f m ach in es.  \nw hen  w e d ecla re  a  v aria b le  w e i n fo rm  t h e c o m pile r o f t w o t h in gs, t h e n am e o f t h e \nv aria b le  a n d t h e t y p e o f t h e v aria b le .  f or e x am ple , w e d ecla re  a  v aria b le  o f t y p e i n te g er \nw ith  t h e n am e k  b y w ritin g:  \n     int k;  \no n s e ein g t h e " in t"  p art o f t h is  s ta te m en t t h e c o m pile r s e ts  a sid e 2  b yte s o f m em ory  ( o n a  \np c ) t o  h old  t h e v alu e o f t h e i n te g er.  i t a ls o  s e ts  u p a  s y m bol t a b le .  i n  t h at t a b le  i t a d ds t h e \ns y m bol k  a n d t h e r e la tiv e a d dre ss i n  m em ory  w here  t h ose  2  b yte s w ere  s e t a sid e.  \nt hus, l a te r i f  w e w rite :  \n     k = 2;  \nw e e x pect t h at, a t r u n t im e w hen  t h is  s ta te m en t i s  e x ecu te d , t h e v alu e 2  w il l b e p la ced  i n  \nt h at m em ory  l o catio n r e se rv ed  f o r t h e s to ra g e o f t h e v alu e o f k .  i n  c  w e r e fe r t o  a  \nv aria b le  s u ch  a s t h e i n te g er k  a s a n  " o bje ct" .  \ni n  a  s e n se  t h ere  a re  t w o " v alu es"  a sso cia te d  w ith  t h e o bje ct k . o ne i s  t h e v alu e o f t h e \ni n te g er s to re d  t h ere  ( 2  i n  t h e a b ove e x am ple ) a n d t h e o th er t h e " v alu e" o f t h e m em ory  \nl o catio n, i .e ., t h e a d dre ss o f k . s om e t e x ts  r e fe r t o  t h ese  t w o v alu es w ith  t h e n om en cla tu re  \nr v a lu e ( rig h t v alu e, p ro n ounced  " a re  v alu e") a n d l v a lu e ( le ft v alu e, p ro nou nced  " e l \nv alu e") r e sp ectiv ely .  \ni n  s o m e l a n gu ag es, t h e l v alu e i s  t h e v alu e p erm itte d  o n t h e l e ft s id e o f t h e a ssig n m en t \no pera to r ©= ©  ( i.e . t h e a d dre ss w here  t h e r e su lt o f e v alu atio n o f t h e r ig h t s id e e n ds u p).  t he \nr v alu e i s  t h at w hic h  i s  o n  t h e r ig h t s id e o f t h e a ssig n m en t s ta te m en t, t h e 2  a b ove. r valu es \nc an not b e u se d  o n t h e l e ft s id e o f t h e a ssig n m en t s ta te m en t. t hus: 2  =  k ; i s  i lle g al.\n\n6  \na\nctu all y , t h e a b ove d efin itio n o f " lv alu e" i s  s o m ew hat m odif ie d  f o r c . a cco rd in g t o  \nk & r i i ( p ag e 1 97 ): [ 1 ]  \n" a n o bje ct i s  a  n am ed  r e g io n o f s to ra g e; a n  l v a lu e i s  a n  e x pre ssio n \nr e fe rrin g t o  a n  o bje ct."   \nh ow ev er, a t t h is  p oin t, t h e d efin itio n o rig in all y  c it e d  a b ove i s  s u ffic ie n t. a s w e b eco m e \nm ore  f a m ilia r w ith  p oin te rs  w e w ill g o  i n to  m ore  d eta il o n t h is .  \no kay , n ow  c o nsid er:  \n    int j, k;  \n       k = 2;  \n     j = 7;    <-- line 1  \n     k = j;    <-- line 2  \nin  t h e a b ove, t h e c o m pile r i n te rp re ts  t h e j  i n  l in e 1  a s t h e a d dre ss o f t h e v aria b le  j  ( its  \nl v alu e) a n d c re ate s c o de t o  c o p y t h e v alu e 7  t o  t h at a d dre ss.  i n  l in e 2 , h ow ev er, t h e j  i s  \ni n te rp re te d  a s i ts  r v alu e ( s in ce i t i s  o n t h e r ig h t h an d s id e o f t h e a ssig n m en t o pera to r ©= ©) . \nt hat i s , h ere  t h e j  r e fe rs  t o  t h e v alu e s to re d  a t t h e m em ory  l o catio n s e t a sid e f o r j , i n  t h is  \nc ase  7 . s o, t h e 7  i s  c o pie d  t o  t h e a d dre ss d esig n ate d  b y t h e l v alu e o f k .  \ni n  a ll o f t h ese  e x am ple s,  w e a re  u sin g 2  b yte  i n te g ers  s o  a ll c o p yin g o f r v alu es f ro m  o ne \ns to ra g e l o catio n t o  t h e o th er i s  d one b y c o p yin g 2  b yte s. h ad  w e b een  u sin g l o n g i n te g ers , \nw e w ould  b e c o p yin g 4  b yte s.  \nn ow , l e t©s  s a y  t h at w e h av e a  r e aso n f o r w an tin g a  v aria b le  d esig n ed  t o  h old  a n  l v alu e ( a n  \na d dre ss). t he s iz e r e q uir e d  t o  h old  s u ch  a  v alu e d ep en ds o n t h e s y ste m . o n o ld er d esk  t o p \nc o m pute rs  w ith  6 4k  o f m em ory  t o ta l, t h e a d dre ss o f a n y p oin t i n  m em ory  c an  b e \nc o nta in ed  i n  2  b yte s. c om pute rs  w ith  m ore  m em ory  w ould  r e q uir e  m ore  b yte s t o  h old  a n  \na d dre ss. s om e c o m pute rs , s u ch  a s t h e i b m  p c  m ig h t r e q uir e  s p ecia l h an dli n g t o  h old  a  \ns e g m en t a n d o ffs e t u nder c erta in  c ir c u m sta n ces. t he a ctu al s iz e r e q uir e d  i s  n ot t o o \ni m porta n t s o  l o ng a s w e h av e a  w ay  o f i n fo rm in g t h e c o m pile r t h at w hat w e w an t t o  s to re  \ni s  a n  a d dre ss.  \ns uch  a  v aria b le  i s  c alle d  a  p oin te r v a ria ble  ( fo r r e aso ns w hic h  h opefu ll y  w ill b eco m e \nc le are r a  l ittle  l a te r).  i n  c  w hen  w e d efin e a  p oin te r v aria b le  w e d o s o  b y p re ced in g i t s  \nn am e w ith  a n  a ste ris k .  i n  c  w e a ls o  g iv e o ur p oin te r a  t y p e w hic h , i n  t h is  c ase , r e fe rs  t o  \nt h e t y p e o f d ata  s to re d  a t t h e a d dre ss w e w ill b e s to rin g i n  o ur p oin te r.  f or e x am ple , \nc o nsid er t h e v aria b le  d ecla ra tio n:  \n    int *ptr; \np tr  i s  t h e n am e o f o ur v aria b le  ( ju st a s k  w as t h e n am e o f o ur i n te g er v aria b le ). t he ©* © \ni n fo rm s t h e c o m pile r t h at w e w an t a  p oin te r v aria b le , i .e . t o  s e t a sid e h ow ev er m an y b yte s \ni s  r e q uir e d  t o  s to re  a n  a d dre ss i n  m em ory . t he i n t s a y s t h at w e i n te n d t o  u se  o ur p oin te r\n\n7  \nv\naria b le  t o  s to re  t h e a d dre ss o f a n  i n te g er. s uch  a  p oin te r i s  s a id  t o  " p oin t t o " a n  i n te g er. \nh ow ev er, n ote  t h at w hen  w e w ro te  i n t k ; w e d id  n ot g iv e k  a  v alu e.  i f  t h is  d efin itio n i s  \nm ad e o uts id e o f a n y f u n ctio n a nsi c o m plia n t c o m pile rs  w ill i n itia liz e i t t o  z ero . \ns im ila rly , p tr  h as n o v alu e, t h at i s  w e h av en ©t  s to re d  a n  a d dre ss i n  i t i n  t h e a b ove \nd ecla ra tio n.  i n  t h is  c ase ,  a g ain  i f  t h e d ecla ra tio n i s  o uts id e o f a n y f u nctio n,  i t i s  i n iti a liz ed  \nt o  a  v alu e g u ara n te ed  i n  s u ch  a  w ay  t h at i t i s  g u ara n te ed  t o  n ot p oin t t o  a n y c  o bje ct o r \nf u nctio n. a  p oin te r i n itia liz ed  i n  t h is  m an ner i s  c alle d  a  " n ull "  p oin te r.  \nt he a ctu al b it p atte rn  u se d  f o r a  n ull p oin te r m ay  o r m ay  n ot e v alu ate  t o  z ero  s in ce i t  \nd ep en ds o n t h e s p ecif ic  s y ste m  o n w hic h  t h e c o de i s  d ev elo ped . t o m ak e t h e s o urc e c o de \nc o m patib le  b etw een  v ario us c o m pile rs  o n v ario us s y ste m s, a  m acro  i s  u se d  t o  r e p re se n t a  \nn ull p oin te r. t hat m acro  g o es u nd er t h e n am e n u ll. t hus, s e ttin g t h e v alu e o f a  p oin te r \nu sin g t h e n u ll m acro ,  a s w ith  a n  a ssig n m en t s ta te m en t s u ch  a s p tr  =  n ull,  g u ara n te es \nt h at t h e p oin te r h as b eco m e a  n ull p oin te r. s im ila rly , j u st a s o ne c an  t e st f o r a n  i n te g er \nv alu e o f z ero , a s i n  i f (k  = = 0 ), w e c an  t e st f o r a  n ull p oin te r u sin g i f  ( p tr  = = n ull).  \nb ut, b ack  t o  u sin g o ur n ew  v aria b le  p tr . s uppose  n ow  t h at w e w an t t o  s to re  i n  p tr  t h e \na d dre ss o f o u r i n te g er v aria b le  k . t o d o t h is  w e u se  t h e u nary  &  o pera to r a n d w rite : \n     ptr = &k;  \nw hat t h e &  o pera to r d o es i s  r e tr ie v e t h e l v alu e ( a d dre ss) o f k , e v en  t h ough  k  i s  o n t h e \nr ig h t h an d s id e o f t h e a ss ig n m en t o pera to r ©= ©,   a n d c o pie s t h at t o  t h e c o nte n ts  o f o ur \np oin te r p tr . n ow , p tr  i s  s a id  t o  " p oin t t o " k . b ear w ith  u s n ow , t h ere  i s  o nly  o ne m ore  \no pera to r w e n eed  t o  d is c u ss.  \nt he " d ere fe re n cin g o pera to r"  i s  t h e a ste ris k  a n d i t i s  u se d  a s f o llo w s:  \n     *ptr = 7;  \nw ill c o p y 7  t o  t h e a d d re ss p oin te d  t o  b y p tr . t hus i f  p tr  " p oin ts  t o " ( c o nta in s t h e a d dre ss \no f) k , t h e a b ove s ta te m en t w ill s e t t h e v alu e o f k  t o  7 . t hat i s , w hen  w e u se  t h e ©* ©  t h is  \nw ay  w e a re  r e fe rrin g t o  t h e v alu e o f t h at w hic h  p tr  i s  p oin tin g t o , n ot t h e v alu e o f t h e \np oin te r i ts e lf .  \ns im ila rly , w e c o uld  w rite :  \n  printf("%d\\n",*ptr);  \nto  p rin t t o  t h e s c re en  t h e i n te g er v alu e s to re d  a t t h e a d dre ss p oin te d  t o  b y p tr ;.  \no ne w ay  t o  s e e h ow  a ll t h is  s tu ff f its  t o geth er w ould  b e t o  r u n t h e f o llo w in g p ro gra m  a n d \nt h en  r e v ie w  t h e c o de a n d  t h e o utp ut c are fu ll y .  \n- ----------- program 1.1 ---------------------------------  \n  / * program 1.1 from ptrtut10.txt   6/10/97 */\n\n8  \n# include <stdio.h> \n  i nt j, k; \ni nt *ptr; \n  i nt main(void) \n{  \n     j = 1; \n     k = 2; \n     ptr = &k; \n     printf("\\n"); \n     printf("j has the value %d and is stored at %p\\n", j, (void *)&j ); \n     printf("k has the value %d and is stored at %p\\n", k, (void *)&k ); \n     printf("ptr has the value %p and is stored at %p\\n", ptr, (void \n* )&ptr); \n     printf("the value of the integer pointed to by ptr is %d\\n", *pt r); \n       return 0; \n}  \nn ote : w e h av e y et t o  d is c u ss t h ose  a sp ects  o f c  w hic h  r e q uir e  t h e u se  o f t h e ( v oid  * ) \ne x pre ssio n u se d  h ere .  f or n ow , i n clu de i t i n  y o ur t e st c o de. w e©l l e x pla in  t h e r e aso n \nb eh in d t h is  e x pre ssio n l a te r.  \nt o r e v ie w :  \n·  a  v aria b le  i s  d ecla re d  b y g iv in g i t a  t y p e a n d a  n am e ( e .g . i n t k ;)  \n·  a  p oin te r v aria b le  i s  d ecla re d  b y g iv in g i t a  t y p e a n d a  n am e ( e .g . i n t * p tr ) w here  \nt h e a ste ris k  t e lls  t h e c o m pile r t h at t h e v aria b le  n am ed  p tr  i s  a  p oin te r v aria b le  a n d \nt h e t y p e t e lls  t h e c o m pile r w hat t y p e t h e p oin te r i s  t o  p oin t t o  ( in te g er i n  t h is  \nc ase ).  \n·  o nce a  v aria b le  i s  d ecla re d , w e c an  g et i ts  a d dre ss b y p re ced in g i ts  n am e w ith  t h e \nu nary  &  o pera to r,  a s i n  & k.  \n·  w e c an  " d ere fe re n ce" a  p oin te r, i .e . r e fe r t o  t h e v alu e o f t h at w hic h  i t p oin ts  t o , b y \nu sin g t h e u nary  ©* ©  o pera to r a s i n  * p tr .  \n·  a n " lv alu e" o f a  v aria b le  i s  t h e v alu e o f i ts  a d dre ss , i .e . w here  i t i s  s to re d  i n  \nm em ory . t he " rv alu e" o f a  v aria b le  i s  t h e v alu e s to re d  i n  t h at v aria b le  ( a t t h at \na d dre ss).  \nr efe re n ces f o r c hap te r 1 :  \n1 .  "t he c  p ro gra m min g l an gu ag e" 2 nd e ditio n \nb . k ern ig h an  a n d d . r itc h ie   \np re n tic e h all  \ni s b n  0 -1 3-1 10362 -8\n\n9  \nc h apt er  2 : p oin te r t y p es a n d a rra y s  \no kay , l e t©s  m ove o n.  l et u s c o nsid er w hy w e n eed  t o  i d en tif y  t h e t y p e o f v aria b le  t h at a  \np oin te r p oin ts  t o , a s i n :  \n      int *ptr; \no ne r e aso n f o r d oin g t h is  i s  s o  t h at l a te r, o nce p tr  " p oin ts  t o " s o m eth in g, i f  w e w rite :  \n     *ptr = 2; \nth e c o m pile r w ill k now  h ow  m an y b yte s t o  c o p y i n to  t h at m em ory  l o catio n p oin te d  t o  b y \np tr .  i f  p tr  w as d ecla re d  a s p oin tin g t o  a n  i n te g er, 2  b yte s w ould  b e c o pie d , i f  a  l o ng,  4  \nb yte s w ould  b e c o pie d . s im ila rly  f o r f lo ats  a n d d o uble s t h e a p pro pria te  n u m ber w ill b e \nc o pie d . b ut, d efin in g t h e t y p e t h at t h e p oin te r p oin ts  t o  p erm its  a  n um ber o f o th er \ni n te re stin g w ay s a  c o m pile r c an  i n te rp re t c o d e. f or e x am ple , c o nsid er a  b lo ck  i n  m em ory  \nc o nsis tin g i f  t e n  i n te g ers  i n  a  r o w . t hat i s , 2 0 b yte s o f m em ory  a re  s e t a sid e t o  h old  1 0 \ni n te g ers .  \nn ow , l e t©s  s a y  w e p oin t o ur i n te g er p oin te r p tr  a t t h e f ir s t o f t h ese  i n te g ers .  f urth erm ore  \nl e ts  s a y  t h at i n te g er i s  l o cate d  a t m em ory  l o catio n 1 00 ( d ecim al) . w hat h ap pen s w hen  w e \nw rite :  \n     ptr + 1;  \nb ec au se  t h e c o m pile r " k now s"  t h is  i s  a  p oin te r ( i.e . i ts  v alu e i s  a n  a d dre ss) a n d t h at i t \np oin ts  t o  a n  i n te g er ( its  c u rre n t a d dre ss, 1 00, i s  t h e a d dre ss o f a n  i n te g er), i t a d ds 2  t o  p tr  \ni n ste ad  o f 1 , s o  t h e p oin te r " p oin ts  t o " t h e n ex t i n te g er,  a t m em ory  l o catio n 1 02. \ns im ila rly , w ere  t h e p tr  d ecla re d  a s a  p oin te r t o  a  l o ng, i t w ould  a d d 4  t o  i t i n ste ad  o f 1 . \nt he s a m e g o es f o r o th er d ata  t y p es s u ch  a s f lo ats , d ouble s, o r e v en  u se r d efin ed  d ata  \nt y p es s u ch  a s s tr u ctu re s.  t his  i s  o bvio usly  n ot t h e s a m e k in d o f " a d ditio n" t h at w e \nn orm all y  t h in k o f.  i n  c  i t  i s  r e fe rre d  t o  a s a d ditio n u sin g " p oin te r a rith m etic ", a  t e rm  \nw hic h  w e w ill c o m e b ack  t o  l a te r.  \ns im ila rly , s in ce + +ptr  a n d p tr + + a re  b oth  e q uiv ale n t t o  p tr  +  1  ( th ough  t h e p oin t i n  t h e \np ro gra m  w hen  p tr  i s  i n cre m en te d  m ay  b e d if fe re n t) , i n cre m en tin g a  p oin te r u sin g t h e \nu nary  + + o pera to r, e ith er p re - o r p ost- , i n cre m en ts  t h e a d dre ss i t s to re s b y t h e a m ount \ns iz eo f(ty p e) w here  " ty p e" i s  t h e t y p e o f t h e o bje ct p oin te d  t o . ( i.e . 2  f o r a n  i n te g er, 4  f o r a  \nl o ng, e tc .) .  \ns in ce a  b lo ck  o f 1 0 i n te g ers  l o cate d  c o ntig u ously  i n  m em ory  i s , b y d efin iti o n, a n  a rr a y  o f \ni n te g ers , t h is  b rin gs u p a n  i n te re stin g r e la tio nsh ip  b etw een  a rr a y s a n d p oin te rs .\n\n1 0 \n \n \nc onsid er t h e f o llo w in g:  \n     int my_array[] = {1,23,17,4,-5,100};  \nh ere  w e h av e a n  a rra y  c o nta in in g 6  i n te g ers . w e r e fe r t o  e ach  o f t h ese  i n te g ers  b y m ean s \no f a  s u bsc rip t t o  m y_arra y, i .e . u sin g m y_a rra y[0 ] t h ro ugh  m y_arra y[5 ]. b ut, w e c o uld  \na lte rn ativ ely  a ccess t h em  v ia  a  p oin te r a s f o llo w s:  \n     int *ptr; \n     ptr = &my_array[0];       /* point our pointer at the first \n                                  integer in our array */  \na nd t h en  w e c o uld  p rin t o ut o ur a rra y  e ith er u sin g t h e a rr a y  n ota tio n o r b y d ere fe re n cin g \no ur p oin te r. t he f o llo w in g c o d e i llu str a te s t h is :  \n- ----------  program 2.1  ----------------------------------- \n  / * program 2.1 from ptrtut10.htm   6/13/97 */ \n # include <stdio.h> \n i nt my_array[] = {1,23,17,4,-5,100}; \ni nt *ptr; \n i nt main(void) \n{  \n     int i; \n     ptr = &my_array[0];     /* point our pointer to the first \n                                       element of the array */ \n     printf("\\n\\n"); \n     for (i = 0; i < 6; i++) \n     { \n       printf("my_array[%d] = %d   ",i,my_array[i]);   /*<-- a */ \n       printf("ptr + %d = %d\\n",i, *(ptr + i));        /*<-- b */ \n     } \n     return 0; \n}  \nc om pile  a n d r u n t h e a b o ve p ro gra m  a n d c a re fu ll y  n ote  l in es a  a n d b  a n d t h at t h e \np ro gra m  p rin ts  o ut t h e s a m e v alu es i n  e ith er c ase .  a ls o  o bse rv e h ow  w e d ere fe re n ced  o ur \np oin te r i n  l in e b , i .e . w e f ir s t a d ded  i  t o  i t a n d t h en  d ere fe re n ced  t h e n ew  p oin te r. c han ge \nl in e b  t o  r e ad :  \n     printf("ptr + %d = %d\\n",i, *ptr++); \nan d r u n i t a g ain ... t h en  c h an ge i t t o :  \n     printf("ptr + %d = %d\\n",i, *(++ptr));\n\n1 1 \na\nn d t r y  o nce m ore . e ach  t im e t r y  a n d p re d ic t t h e o utc o m e a n d c are fu ll y  l o o k a t t h e a c tu al \no utc o m e.  \ni n  c , t h e s ta n d ard  s ta te s t h at w here v er w e m ig h t u se  & var_ n am e[0 ] w e c a n  r e p la c e t h at \nw ith  v ar_ n am e, t h us i n  o ur c o de w here  w e w ro te :  \n     ptr = &my_array[0]; \nw e c an  w rite :  \n     ptr = my_array; \nto  a ch ie v e t h e s a m e r e su lt.  \nt his  l e ad s m an y t e x ts  t o  s ta te  t h at t h e n am e o f a n  a rra y  i s  a  p oin te r.  i  p re fe r t o  m en ta ll y  \nt h in k " th e n am e o f t h e a rra y  i s  t h e a d dre ss o f f ir s t e le m en t i n  t h e a rr a y ". m an y b eg in n ers  \n( in clu din g m yse lf  w hen  i  w as l e arn in g) h av e a  t e n den cy  t o  b eco m e c o nfu se d  b y t h in k in g \no f i t a s a  p oin te r. f or e x am ple , w hile  w e c an  w rite   \n     ptr = my_array; \nw e c an not w rite   \n     my_array = ptr; \nt he r e aso n i s  t h at w hile  p tr  i s  a  v aria b le ,  m y_arra y i s  a  c o nsta n t. t hat i s , t h e l o catio n a t \nw hic h  t h e f ir s t e le m en t o f m y_arra y w ill b e s to re d  c an not b e c h an ged  o n ce m y_arra y [] \nh as b een  d ecla re d .  \ne arlie r w hen  d is c u ssin g t h e t e rm  " lv alu e" i  c ite d  k & r-2  w here  i t s ta te d :  \n" a n o b je ct i s  a  n am ed  r e g io n o f s to ra g e; a n  l v alu e i s  a n  e x pre ssio n \nr e fe rrin g t o  a n  o bje ct" .  \nt his  r a is e s a n  i n te re stin g p ro ble m . s in ce m y_arra y i s  a  n am ed  r e g io n o f s to ra g e, w hy i s  \nm y_a rra y i n  t h e a b ov e a ssig n m en t s ta te m en t n ot a n  l v alu e?  t o r e so lv e t h is  p ro ble m , \ns o m e r e fe r t o  m y_arra y a s a n  " u nm odif ia b le  l v alu e".  \nm odif y  t h e e x am ple  p ro gra m  a b ove b y c h an gin g  \n     ptr = &my_array[0]; \nto   \n     ptr = my_array; \nan d r u n i t a g ain  t o  v erif y  t h e r e su lts  a re  i d en tic al.\n\n1 2 \nn\now , l e t©s  d elv e a  l ittle  f u rth er i n to  t h e d if fe re n ce b etw een  t h e n am es p tr  a n d m y_a rra y \na s u se d  a b ove. s om e w rite rs  w ill r e fe r t o  a n  a rra y ©s  n am e a s a  c o n sta n t p oin te r. w hat d o \nw e m ean  b y t h at?  w ell, t o  u nders ta n d t h e t e rm  " c o nsta n t"  i n  t h is  s e n se , l e t©s  g o  b ack  t o  \no ur d efin itio n o f t h e t e rm  " v aria b le ". w hen  w e d ecla re  a  v aria b le  w e s e t a sid e a  s p ot i n  \nm em ory  t o  h old  t h e v alu e o f t h e a p p ro pria te  t y p e. o nce t h at i s  d one t h e n am e o f t h e \nv aria b le  c an  b e i n te rp re te d  i n  o ne o f t w o w ay s. w hen  u se d  o n t h e l e ft s id e o f t h e \na ssig n m en t o pera to r, t h e c o m pile r i n te rp re ts  i t a s t h e m em ory  l o catio n t o  w hic h  t o  m ove \nt h at v alu e r e su ltin g f ro m  e v alu atio n o f t h e r ig h t s id e o f t h e a ssig n m en t o pera to r. b ut, \nw hen  u se d  o n t h e r ig h t s id e o f t h e a ssig n m en t o pera to r, t h e n am e o f a  v aria b le  i s  \ni n te rp re te d  t o  m ea n  t h e c o nte n ts  s to re d  a t t h at m em ory  a d d re ss s e t a sid e t o  h old  t h e v alu e \no f t h at v aria b le .  \nw ith  t h at i n  m in d, l e t©s  n ow  c o nsid er t h e s im ple st o f c o nsta n ts , a s i n :  \n     int i, k; \n     i = 2; \nh ere ,  w hile  i  i s  a  v aria b le  a n d t h en  o ccu pie s s p ace i n  t h e d ata  p ortio n o f m em ory , 2  i s  a  \nc o nsta n t a n d, a s s u ch , i n ste ad  o f s e ttin g a sid e m em ory  i n  t h e d ata  s e g m en t, i t i s  i m bed ded  \nd ir e ctl y  i n  t h e c o de s e g m en t o f m em ory . t hat i s ,  w hile  w ritin g s o m eth in g l ik e k  =  i ;  t e lls  \nt h e c o m pile r t o  c re ate  c o de w hic h  a t r u n t im e w ill  l o ok a t m em ory  l o catio n & i t o  \nd ete rm in e t h e v alu e t o  b e m oved  t o  k , c o de c re ate d  b y i  =  2 ; s im ply  p uts  t h e 2  i n  t h e c o de \na n d t h ere  i s  n o r e fe re n cin g o f t h e d ata  s e g m en t. t hat i s , b oth  k  a n d i  a re  o bje cts , b ut 2  i s  \nn ot a n  o bje ct.  \ns im ila rly , i n  t h e a b ove, s in ce m y_arra y i s  a  c o nsta n t, o nce t h e c o m pile r e sta b lis h es \nw here  t h e a rr a y  i ts e lf  i s  t o  b e s to re d , i t " k now s" t h e a d dre ss o f m y_arra y[0 ] a n d o n \ns e ein g:  \n     ptr = my_array; \nit s im ply  u se s t h is  a d dre ss a s a  c o nsta n t i n  t h e c o d e s e g m en t a n d t h ere  i s  n o  r e fe re n cin g \no f t h e d ata  s e g m en t b ey o nd t h at.  \nt his  m ig h t b e a  g o od p la ce e x pla in  f u rth er t h e u se  o f t h e ( v oid  * ) e x pre ssio n u se d  i n  \np ro gra m  1 .1  o f c hap te r 1 . a s w e h av e s e en  w e c an  h av e p oin te rs  o f v ario u s t y p es. s o f a r \nw e h av e d is c u ss e d  p oin te rs  t o  i n te g ers  a n d p oin te rs  t o  c h ara cte rs .  i n  c o m in g c h ap te rs  w e \nw ill b e l e arn in g a b out p o in te rs  t o  s tr u ctu re s a n d e v en  p oin te r t o  p oin te rs .  \na ls o  w e h av e l e arn ed  t h at o n d if fe re n t s y ste m s t h e s iz e o f a  p oin te r c an  v ary . a s i t t u rn s \no ut i t i s  a ls o  p ossib le  t h at t h e s iz e o f a  p oin te r c an  v ary  d ep en din g o n t h e d ata  t y p e o f t h e \no bje ct t o  w hic h  i t p oin ts . t hus, a s w ith  i n te g ers  w here  y o u c an  r u n i n to  t r o uble  \na tte m ptin g t o  a ssig n  a  l o ng i n te g er t o  a  v aria b le  o f t y p e s h o rt i n te g er,  y o u c an  r u n i n to  \nt r o uble  a tte m ptin g t o  a ssig n  t h e v alu es o f p oin te rs  o f v ario us t y p es t o  p oin te r v aria b le s o f \no th er t y p es.\n\n1 3 \nt\no m in im iz e t h is  p ro ble m , c  p ro vid es f o r a  p oin te r o f t y p e v oid . w e c an  d ecla re  s u ch  a  \np oin te r b y w ritin g:  \nv oid *vptr; \na  v oid  p oin te r i s  s o rt o f a  g en eric  p oin te r.  f or e x am ple , w hile  c  w ill n ot p erm it t h e \nc o m paris o n o f a  p oin te r t o  t y p e i n te g er w ith  a  p oin te r t o  t y p e c h ara cte r, f o r e x am ple , \ne ith er o f t h ese  c an  b e c o m pare d  t o  a  v oid  p oin te r. o f c o urs e , a s w ith  o th er v aria b le s,  c asts  \nc an  b e u se d  t o  c o nvert f ro m  o ne t y p e o f p oin te r t o  a n oth er u nder t h e p ro per \nc ir c u m sta n ces.  i n  p ro gra m  1 .1 . o f c hap te r 1  i  c ast t h e p oin te rs  t o  i n te g ers  i n to  v oid  \np oin te rs  t o  m ak e t h em  c o m patib le  w ith  t h e % p c o nvers io n s p ecif ic atio n.  i n  l a te r c h ap te rs  \no th er c asts  w ill b e m ad e f o r r e aso ns d efin ed  t h ere in .  \nw ell, t h at©s  a  l o t o f t e ch n ic al s tu ff t o  d ig est a n d i  d on©t  e x pect a  b eg in ner t o  u nders ta n d a ll \no f i t o n f ir s t r e ad in g. w ith  t im e a n d e x perim en ta tio n y o u w ill w an t t o  c o m e b ack  a n d  r e -\nr e ad  t h e f ir s t 2  c h ap te rs .  b ut f o r n ow , l e t©s  m ove o n t o  t h e r e la tio nsh ip  b etw een  p oin te rs , \nc h ara cte r a rr a y s, a n d s tr in gs.\n\n1 4 \nc h apt er  3 : p oin te rs a n d s tr in gs  \nt he s tu d y o f s tr in gs i s  u se fu l t o  f u rth er t ie  i n  t h e r e la tio nsh ip  b etw een  p oin te rs  a n d a rra y s. \ni t a ls o  m ak es i t e asy  t o  i llu str a te  h ow  s o m e o f t h e s ta n dard  c  s tr in g f u nctio n s c an  b e \ni m ple m en te d . f in all y  i t i l lu str a te s h ow  a n d w hen  p oin te rs  c an  a n d s h ould  b e p asse d  t o  \nf u nctio ns.  \ni n  c , s tr in gs a re  a rra y s o f c h ara cte rs . t his  i s  n ot n ecessa ril y  t r u e i n  o th er l a n gu ag es.  i n  \nb a sic , p asc al,  f ortr a n  a n d v ario us o th er l a n gu ag es, a  s tr in g h as i ts  o w n d ata  t y p e. b ut i n  \nc  i t d oes n ot.  i n  c  a  s tr in g i s  a n  a rra y  o f c h ara cte rs  t e rm in ate d  w ith  a  b in ary  z ero  \nc h ara cte r ( w ritte n  a s '' \\0 '') . t o s ta rt o ff o ur d is c u ssio n w e w ill w rite  s o m e c o de w hic h , \nw hile  p re fe rr e d  f o r i llu str a tiv e p urp ose s,  y o u w ould  p ro bab ly  n ev er w rite  i n  a n  a ctu al \np ro gra m . c onsid er, f o r e x am ple :  \n     char my_string[40]; \n       my_string[0] = ''t''; \n     my_string[1] = ''e''; \n     my_string[2] = ''d'': \n     my_string[3] = ''\\0''; \nw hile  o ne w ould  n ev er b uild  a  s tr in g l ik e t h is , t h e e n d r e su lt i s  a  s tr in g i n  t h at i t i s  a n  \na rra y  o f c h ara cte rs  t e r m in ate d  w it h  a  n ul c h ara cte r.  b y d efin itio n, i n  c , a  s tr in g i s  a n  \na rra y  o f c h ara cte rs  t e rm in ate d  w ith  t h e n ul c h ara c te r. b e a w are  t h at " n ul"  i s  n ot t h e s a m e \na s " n ull". t he n ul r e fe rs  t o  a  z ero  a s d efin ed  b y t h e e sc ap e s e q uen ce '' \\0 ''. t hat i s  i t  \no ccu pie s o ne b yte  o f m em ory . n ull, o n t h e o th er h an d, i s  t h e n am e o f t h e m acro  u se d  t o  \ni n itia liz e n ull p oin te rs . n u ll i s  # d efin ed  i n  a  h ea d er f ile  i n  y o ur c  c o m pil e r, n ul m ay  n ot \nb e # defin ed  a t a ll.  \ns in ce w ritin g t h e a b ove c o de w ould  b e v ery  t im e c o nsu m in g, c  p erm its  t w o a lte rn ate  \nw ay s o f a ch ie v in g t h e s a m e t h in g. f ir s t, o n e m ig h t w rite :  \n     char my_string[40] = {''t'', ''e'', ''d'', ''\\0'',};     \nb ut t h is  a ls o  t a k es m ore  t y p in g t h an  i s  c o nven ie n t. s o, c  p erm its :  \n     char my_string[40] = "ted"; \nw hen  t h e d ouble  q uote s a re  u se d , i n ste ad  o f t h e s in gle  q uote s a s w as d on e i n  t h e p re v io us \ne x am ple s, t h e n ul c h ara cte r (  '' \\0 ©  )  i s  a u to m atic all y  a p pen ded  t o  t h e e n d o f t h e s tr in g.  \ni n  a ll o f t h e a b ov e c ase s,  t h e s a m e t h in g h ap pen s.  t he c o m pile r s e ts  a sid e a n  c o ntig u o us \nb lo ck  o f m em ory  4 0 b yte s l o ng t o  h old  c h ara cte rs  a n d i n itia liz ed  i t s u ch  t h at t h e f ir s t 4  \nc h ara cte rs  a re  t ed \\0 .  \nn ow , c o nsid er t h e f o llo w in g p ro gra m :\n\n1 5 \n  - -----------------program 3.1------------------------------------- \n / * program 3.1 from ptrtut10.htm   6/13/97 */ \n # include <stdio.h> \n  c har stra[80] = "a string to be used for demonstration purposes"; \nc har strb[80]; \n  i nt main(void) \n{  \n      char *pa;     /* a pointer to type character */ \n     char *pb;     /* another pointer to type character */ \n     puts(stra);   /* show string a */ \n     pa = stra;    /* point pa at string a */ \n     puts(pa);     /* show what pa is pointing to */ \n     pb = strb;    /* point pb at string b */ \n     putchar(''\\n'');       /* move down one line on the screen */ \n     while(*pa != ''\\0'')   /* line a (see text) */ \n     { \n         *pb++ = *pa++;   /* line b (see text) */ \n     } \n     *pb = ''\\0'';          /* line c (see text) */ \n     puts(strb);          /* show strb on screen */ \n     return 0; \n}  \n  - -------- end program 3.1 ------------------------------------- \n      \nin  t h e a b ove w e s ta rt o ut b y d efin in g t w o c h ara cte r a rr a y s o f 8 0 c h ara cte rs  e ach . s in ce \nt h ese  a re  g lo ball y  d efin ed , t h ey  a re  i n itia liz ed  t o  a ll '' \\0 ©s  f ir s t. t hen , s tr a  h as t h e f ir s t 4 2 \nc h ara cte rs  i n itia liz ed  t o  t h e s tr in g i n  q uote s.  \nn ow , m ovin g i n to  t h e c o de, w e d ecla re  t w o c h ara cte r p oin te rs  a n d s h o w  t h e s tr in g o n  t h e \ns c re en . w e t h en  " p oin t"  t h e p oin te r p a  a t s tr a . t hat i s , b y m ean s o f t h e a ssig n m en t \ns ta te m en t w e c o p y t h e a d dre ss o f s tr a [0 ] i n to  o ur v aria b le  p a . w e n ow  u se  p uts () t o  \ns h ow  t h at w hic h  i s  p oin te d  t o  b y p a  o n t h e s c re en . c onsid er h ere  t h at t h e f u nctio n \np ro to ty p e f o r p uts () i s :  \n     int puts(const char *s);  \nf or t h e m om en t, i g n ore  t h e c o n st. t he p ara m ete r p asse d  t o  p uts () i s  a  p oin te r, t h at i s  t h e \nv alu e o f a  p oin te r ( s in ce a ll p ara m ete rs  i n  c  a re  p asse d  b y v alu e), a n d t h e v alu e o f a  \np oin te r i s  t h e a d dre ss t o  w hic h  i t p oin ts , o r, s im ply , a n  a d dre ss. t hus w hen  w e w rite  \np uts (s tr a ); a s w e h av e s e en , w e a re  p assin g t h e a d dre ss o f s tr a [0 ].  \ns im ila rly , w hen  w e w rite  p uts (p a ); w e a re  p assin g t h e s a m e a d dre ss, s in ce  w e h av e s e t \np a  =  s tr a ;\n\n1 6 \ng\niv en  t h at, f o llo w  t h e c o de d ow n t o  t h e w hile () s ta te m en t o n l in e a .  l in e a  s ta te s:  \nw hile  t h e c h ara cte r p oin te d  t o  b y p a  ( i.e . * p a ) i s  n ot a  n ul c h ara cte r ( i.e . t h e t e rm in atin g \n'' \\0 ©) , d o t h e f o llo w in g:  \nl in e b  s ta te s: c o p y t h e c h ara cte r p oin te d  t o  b y p a  t o  t h e s p ace p oin te d  t o  b y p b , t h en  \ni n cre m en t p a  s o  i t p oin ts  t o  t h e n ex t c h ara cte r a n d  p b  s o  i t p oin ts  t o  t h e n ex t s p ace.   \nw hen  w e h av e c o pie d  t h e l a st c h ara cte r, p a  n ow  p oin ts  t o  t h e t e rm in atin g n ul c h ara cte r \na n d t h e l o op e n ds. h ow ev er, w e h av e n ot c o pie d  t h e n ul c h ara cte r. a nd, b y d efin itio n  a  \ns tr in g i n  c  m ust b e n ul t e rm in ate d . s o, w e a d d t h e n ul c h ara cte r w ith  l in e c .  \ni t i s  v ery  e d ucatio nal t o  r u n t h is  p ro gra m  w ith  y o u r d eb u gger w hile  w atc h in g s tr a , s tr b , \np a  a n d p b  a n d s in gle  s te p pin g t h ro u gh  t h e p ro gra m .  i t i s  e v en  m ore  e d u catio nal i f  \ni n ste ad  o f s im ply  d efin in g s tr b [] a s h as b een  d on e a b ove, i n itia liz e i t a ls o  w ith  s o m eth in g \nl ik e:  \n     strb[80] = "12345678901234567890123456789012345678901234567890" \nw here  t h e n um ber o f d ig its  u se d  i s  g re ate r t h an  t h e l e n gth  o f s tr a  a n d t h en  r e p eat t h e \ns in gle  s te p pin g p ro ced ure  w hile  w atc h in g t h e a b o ve v aria b le s.  g iv e t h ese  t h in gs a  t r y !  \ng ettin g b ack  t o  t h e p ro to ty p e f o r p uts () f o r a  m om en t, t h e " c o nst"  u se d  a s a  p ara m ete r \nm odif ie r i n fo rm s t h e u se r t h at t h e f u nctio n w ill n ot m odif y  t h e s tr in g p oin te d  t o  b y s , i .e . \ni t w ill t r e at t h at s tr in g a s a  c o nsta n t.  \no f c o urs e , w hat t h e a b ov e p ro gra m  i llu str a te s i s  a  s im ple  w ay  o f c o p yin g a  s tr in g. a fte r \np la y in g w ith  t h e a b ov e u ntil y o u h av e a  g o od u nd ers ta n din g o f w hat i s  h ap pen in g, w e c an  \np ro ceed  t o  c re atin g o u r o w n r e p la c em en t f o r t h e s ta n dard  s tr cp y() t h at c o m es w ith  c .  i t \nm ig h t l o ok l ik e:  \n    char *my_strcpy(char *destination, char *source) \n    { \n        char *p = destination; \n        while (*source != ''\\0'') \n        { \n            *p++ = *source++; \n        } \n        *p = ''\\0''; \n        return destination; \n    }    \nin  t h is  c ase ,  i  h av e f o llo w ed  t h e p ra ctic e u se d  i n  t h e s ta n dard  r o utin e o f r e tu rn in g a  \np oin te r t o  t h e d estin atio n.  \na gain , t h e f u nctio n i s  d esig n ed  t o  a ccep t t h e v alu es o f t w o c h ara cte r p oin te rs , i .e . \na d dre sse s,  a n d t h us i n  t h e p re v io us p ro gra m  w e c o uld  w rite :\n\n1 7 \n       int main(void) \n     { \n         my_strcpy(strb, stra); \n         puts(strb); \n     }     \ni h av e d ev ia te d  s lig h tl y  f ro m  t h e f o rm  u se d  i n  s ta n dard  c  w hic h  w ould  h av e t h e \np ro to ty p e:  \n     char *my_strcpy(char *destination, const char *source);   \nh ere  t h e " c o nst"  m odif ie r i s  u se d  t o  a ssu re  t h e u se r t h at t h e f u nctio n w ill n ot m odif y  t h e \nc o nte n ts  p oin te d  t o  b y t h e s o urc e p oin te r. y ou c an  p ro ve t h is  b y m odif y in g t h e f u n ctio n \na b ove, a n d i ts  p ro to ty p e,  t o  i n clu de t h e " c o nst"  m odif ie r a s s h ow n. t hen , w ith in  t h e \nf u nctio n y o u c an  a d d a  s ta te m en t w hic h  a tte m pts  t o  c h an ge t h e c o nte n ts  o f t h at w hic h  i s  \np oin te d  t o  b y s o urc e, s u ch  a s:  \n     *source = ''x''; \nw hic h  w ould  n orm all y  c h an ge t h e f ir s t c h ara cte r o f t h e s tr in g t o  a n  x . t he c o nst m od if ie r \ns h ould  c au se  y o ur c o m pile r t o  c atc h  t h is  a s a n  e rr o r. t ry  i t a n d s e e.  \nn ow , l e t©s  c o nsid er s o m e o f t h e t h in gs t h e a b ove e x am ple s h av e s h ow n u s. f ir s t o ff, \nc o nsid er t h e f a ct t h at * p tr + + i s  t o  b e i n te rp re te d  a s r e tu rn in g t h e v alu e p oin te d  t o  b y p tr  \na n d t h en  i n cre m en tin g t h e p oin te r v alu e. t his  h as t o  d o w ith  t h e p re ced en ce o f t h e \no pera to rs . w ere  w e t o  w rite  ( * p tr )+ + w e w ould  i n cre m en t, n ot t h e p oin te r,  b ut t h at w hic h  \nt h e p oin te r p oin ts  t o ! i .e . i f  u se d  o n t h e f ir s t c h ara cte r o f t h e a b ov e e x am ple  s tr in g t h e ©t © \nw ould  b e i n cre m en te d  t o  a  ©u ©.  y ou c an  w rite  s o m e s im ple  e x am ple  c o de t o  i llu str a te  t h is .  \nr ecall a g ain  t h at a  s tr in g i s  n oth in g m ore  t h an  a n  a rra y  o f c h ara cte rs , w ith  t h e l a st \nc h ara cte r b ein g a  '' \\0 ''. w hat w e h av e d one a b ov e i s  d eal w ith  c o p yin g a n  a rra y .  i t h ap p en s \nt o  b e a n  a rra y  o f c h ara cte rs  b ut t h e t e ch niq ue c o uld  b e a p plie d  t o  a n  a rra y  o f i n te g ers , \nd ouble s, e tc .  i n  t h ose  c ase s, h ow ev er, w e w ould  n ot b e d ealin g w ith  s tr in gs a n d h en ce t h e \ne n d o f t h e a rra y  w ould  n ot b e m ark ed  w ith  a  s p ec ia l v alu e l ik e t h e n ul c h ara cte r. w e \nc o uld  i m ple m en t a  v ers io n t h at r e lie d  o n a  s p ecia l v alu e t o  i d en tif y  t h e e n d.  f or e x am ple , \nw e c o uld  c o p y a n  a rra y  o f p ositiv e i n te g ers  b y m ark in g t h e e n d w ith  a  n eg ativ e i n te g er. \no n t h e o th er h an d, i t i s  m ore  u su al t h at w hen  w e w rite  a  f u nctio n t o  c o p y a n  a rra y  o f \ni te m s o th er t h an  s tr in gs w e p ass t h e f u n ctio n t h e n um ber o f i te m s t o  b e c o pie d  a s w ell a s \nt h e a d dre ss o f t h e a rra y ,  e .g . s o m eth in g l ik e t h e f o llo w in g p ro to ty p e m ig h t i n dic ate :  \n     void int_copy(int *ptra, int *ptrb, int nbr); \nw here  n br i s  t h e n um ber o f i n te g ers  t o  b e c o pie d .  y ou m ig h t w an t t o  p la y  w ith  t h is  i d ea \na n d c re ate  a n  a rr a y  o f i n te g ers  a n d s e e i f  y o u c an  w rite  t h e f u nctio n i n t_ co p y() a n d m ak e \ni t w ork .\n\n1 8 \nt\nhis  p erm its  u sin g f u ncti o ns t o  m an ip ula te  l a rg e a rra y s.  f or e x am ple , i f  w e h av e a n  a rr a y  \no f 5 000 i n te g ers  t h at w e w an t t o  m an ip ula te  w ith  a  f u nctio n, w e n eed  o nly  p ass t o  t h at \nf u nctio n t h e a d dre ss o f t h e a rr a y  ( a n d a n y a u x ilia ry  i n fo rm atio n s u ch  a s n br a b ove, \nd ep en din g o n w hat w e a re  d oin g).  t he a rra y  i ts e lf  d oes n ot g et p asse d , i .e . t h e w hole  \na rra y  i s  n ot c o pie d  a n d p ut o n t h e s ta ck  b efo re  c allin g t h e f u nctio n, o nly  i ts  a d dre ss i s  \ns e n t.  \nt his  i s  d if fe re n t f ro m  p assin g, s a y  a n  i n te g er, t o  a  f u nctio n. w hen  w e p ass a n  i n te g er w e \nm ak e a  c o p y o f t h e i n te g er, i .e .  g et i ts  v alu e a n d p ut i t o n t h e s ta ck . w ith in  t h e f u ncti o n \na n y m an ip ula tio n o f t h e v alu e p asse d  c an  i n  n o w ay  e ff e ct t h e o rig in al i n te g er. b ut, w ith  \na rra y s a n d p oin te rs  w e c a n  p ass t h e a d dre ss o f t h e v aria b le  a n d h en ce m an ip ula te  t h e \nv alu es o f t h e o rig in al v aria b le s.\n\n1 9 \nc h apt er  4 : m ore o n  s tr in gs \nw ell, w e h av e p ro gre sse d  q uite  a  w ay  i n  a  s h ort t i m e! l et©s  b ack  u p a  l ittle  a n d l o ok a t \nw hat w as d one i n  c hap te r 3  o n c o p yin g o f s tr in gs b ut i n  a  d if fe re n t l i g h t. c onsid er t h e \nf o llo w in g f u n ctio n:  \n       char *my_strcpy(char dest[], char source[]) \n     { \n         int i = 0; \n         while (source[i] != ''\\0'') \n         { \n             dest[i] = source[i]; \n             i++; \n         } \n         dest[i] = ''\\0''; \n         return dest; \n     } \nr ecall t h at s tr in gs a re  a rr a y s o f c h ara cte rs . h ere  w e h av e c h ose n  t o  u se  a rra y  n ota tio n  \ni n ste ad  o f p oin te r n ota tio n t o  d o t h e a ctu al c o p yin g. t he r e su lts  a re  t h e s a m e, i .e . t h e \ns tr in g g ets  c o pie d  u sin g t h is  n ota tio n j u st a s a ccu ra te ly  a s i t d id  b efo re .  t his  r a is e s s o m e \ni n te re stin g p oin ts  w hic h  w e w ill d is c u ss.  \ns in ce p ara m ete rs  a re  p asse d  b y v alu e, i n  b oth  t h e p assin g o f a  c h ara cte r p oin te r o r t h e \nn am e o f t h e a rra y  a s a b o ve, w hat a ctu all y  g ets  p asse d  i s  t h e a d dre ss o f t h e f ir s t e le m en t o f \ne ach  a rr a y . t hus, t h e n u m eric al v alu e o f t h e p ara m ete r p asse d  i s  t h e s a m e w heth er w e u se  \na  c h ara cte r p oin te r o r a n  a rra y  n am e a s a  p ara m ete r. t his  w ould  t e n d t o  i m ply  t h at \ns o m eh ow  s o u rce[i]  i s  t h e s a m e a s * (p + i) .  \ni n  f a ct, t h is  i s  t r u e, i .e  w here v er o ne w rite s a [i]  i t c an  b e r e p la ced  w ith  * (a  +  i )  w ith ou t \na n y p ro ble m s.  i n  f a ct, t h e c o m pile r w ill c re ate  t h e s a m e c o de i n  e ith er c ase .  t hus w e s e e \nt h at p oin te r a rith m etic  i s  t h e s a m e t h in g a s a rra y  i n dex in g. e ith er s y n ta x  p ro duces t h e \ns a m e r e su lt.  \nt his  i s  n ot s a y in g t h at p oin te rs  a n d a rra y s a re  t h e s a m e t h in g, t h ey  a re  n o t. w e a re  o nly  \ns a y in g t h at t o  i d en tif y  a  g iv en  e le m en t o f a n  a rr a y  w e h av e t h e c h oic e o f t w o s y n ta x es, \no ne u sin g a rra y  i n d ex in g a n d t h e o th er u sin g p oin te r a rith m etic , w hic h  y ie ld  i d en tic al \nr e su lts .  \nn ow , l o okin g a t t h is  l a st e x pre ssio n, p art o f i t.. ( a  +  i ) , i s  a  s im ple  a d ditio n u sin g t h e +  \no pera to r a n d t h e r u le s o f c  s ta te  t h at s u ch  a n  e x pre ssio n i s  c o m muta tiv e. t hat i s  ( a  +  i )  i s  \ni d en tic al t o  ( i +  a ). t hus w e c o uld  w rite  * (i +  a ) j u st a s e asil y  a s * (a  +  i ) .\n\n2 0 \nb\nut * (i +  a ) c o uld  h av e c o m e f ro m  i [ a ] !  f ro m  a ll o f t h is  c o m es t h e c u rio us t r u th  t h at i f :  \n     char a[20]; \n     int i; \n \nw ritin g  \n       a[3] = ''x''; \n \ni s  t h e s a m e a s w ritin g  \n \n     3[a] = ''x''; \n \nt ry  i t!  s et u p a n  a rr a y  o f c h ara cte rs , i n te g ers  o r l o ngs, e tc .  a n d a ssig n ed  t h e 3 rd  o r 4 th  \ne le m en t a  v alu e u sin g t h e c o nven tio nal a p pro ach  a n d t h en  p rin t o ut t h at v alu e t o  b e s u re  \ny o u h av e t h at w ork in g. t hen  r e v ers e  t h e a rr a y  n ota tio n a s i  h av e d on e a b ov e. a  g o od  \nc o m pile r w ill n ot b alk  a n d t h e r e su lts  w ill b e i d en tic al. a  c u rio sit y ... n oth in g m ore !  \nn ow , l o okin g a t o u r f u nctio n a b ove, w hen  w e w rit e :  \n     dest[i] = source[i]; \n \nd ue t o  t h e f a ct t h at a rr a y  i n dex in g a n d p oin te r a rit h m etic  y ie ld  i d en tic al r e su lts , w e c a n  \nw rite  t h is  a s:  \n      *(dest + i) = *(source + i); \n \nb ut, t h is  t a k es 2  a d ditio ns f o r e a ch  v alu e t a k en  o n b y i . a dditio ns, g en era ll y  s p eak in g , \nt a k e m ore  t im e t h an  i n cre m en ta tio ns ( s u ch  a s t h ose  d one u sin g t h e + + o pera to r a s i n  i + +). \nt his  m ay  n ot b e t r u e i n  m odern  o ptim iz in g c o m pile rs , b ut o ne c an  n ev er b e s u re . t hu s, \nt h e p oin te r v ers io n m ay  b e a  b it f a ste r t h an  t h e a rra y  v ers io n.  \na noth er w ay  t o  s p eed  u p  t h e p oin te r v ers io n w ould  b e t o  c h an ge:  \n     while (*source != ''\\0'') \n \nt o  s im ply   \n       while (*source) \n \ns in ce t h e v alu e w ith in  t h e p are n th esis  w ill g o  t o  z ero  ( f a lse ) a t t h e s a m e t im e i n  e ith er \nc ase .\n\n2 1 \na\nt t h is  p oin t y o u m ig h t w an t t o  e x perim en t a  b it w ith  w ritin g s o m e o f y o u r o w n p ro gra m s \nu sin g p oin te rs . m an ip ula tin g s tr in gs i s  a  g o od p la ce t o  e x perim en t. y ou m ig h t w an t t o  \nw rite  y o u r o w n v ers io ns o f s u ch  s ta n dard  f u nctio n s a s:  \n       strlen(); \n     strcat(); \n     strchr(); \nan d a n y o th ers  y o u m ig h t h av e o n y o ur s y ste m .  \nw e w ill c o m e b ack  t o  s tr in gs a n d t h eir  m an ip ula tio n t h ro ugh  p oin te rs  i n  a  f u tu re  c h ap te r. \nf or n ow , l e t©s  m ove o n a n d d is c u ss s tr u ctu re s f o r a  b it.\n\n2 2 \nc h apt er  5 : p oin te rs a n d s tr u ctu res  \na s y o u m ay  k no w , w e c a n  d ecla re  t h e f o rm  o f a  b lo ck  o f d ata  c o nta in in g d if fe re n t d ata  \nt y p es b y m ean s o f a  s tr u ctu re  d ecla ra tio n. f or e x am ple , a  p ers o nnel f ile  m ig h t c o nta in  \ns tr u ctu re s w hic h  l o ok s o m eth in g l ik e:  \n     struct tag { \n         char lname[20];        /* last name */ \n         char fname[20];        /* first name */ \n         int age;               /* age */ \n         float rate;            /* e.g. 12.75 per hour */ \n     }; \nl et©s  s a y  w e h av e a  b un ch  o f t h ese  s tr u ctu re s i n  a  d is k  f ile  a n d w e w an t t o  r e ad  e ach  o ne \no ut a n d p rin t o ut t h e f ir s t a n d l a st n am e o f e ach  o n e s o  t h at w e c an  h av e a  l is t o f t h e \np eo ple  i n  o ur f ile s. t he r e m ain in g i n fo rm atio n w ill n ot b e p rin te d  o ut. w e w ill w an t t o  d o \nt h is  p rin tin g w ith  a  f u ncti o n c all a n d p ass t o  t h at f u nctio n a  p oin te r t o  t h e s tr u ctu re  a t \nh an d. f or d em onstr a tio n p urp ose s i  w ill u se  o nly  o ne s tr u ctu re  f o r n ow .  b ut r e aliz e t h e \ng o al i s  t h e w ritin g o f t h e f u nctio n, n ot t h e r e ad in g o f t h e f ile  w hic h , p re su m ab ly , w e \nk now  h ow  t o  d o.  \nf or r e v ie w , r e call t h at w e c an  a cc ess s tr u ctu re  m em bers  w ith  t h e d ot o pera to r a s i n :  \n  - -------------- program 5.1 ------------------ \n / * program 5.1 from ptrtut10.htm     6/13/97 */ \n    # include <stdio.h> \n# include <string.h> \n s truct tag { \n     char lname[20];      /* last name */ \n     char fname[20];      /* first name */ \n     int age;             /* age */ \n     float rate;          /* e.g. 12.75 per hour */ \n} ; \n s truct tag my_struct;       /* declare the structure my_struct */ \n i nt main(void) \n{  \n     strcpy(my_struct.lname,"jensen"); \n     strcpy(my_struct.fname,"ted"); \n     printf("\\n%s ",my_struct.fname); \n     printf("%s\\n",my_struct.lname); \n     return 0; \n}  \n  - ------------- end of program 5.1 --------------\n\n2 3 \nn\now , t h is  p artic u la r s tr u ctu re  i s  r a th er s m all c o m pare d  t o  m an y u se d  i n  c  p ro gra m s.  t o \nt h e a b ove w e m ig h t w an t t o  a d d:  \n       date_of_hire;                  (data types not shown) \n     date_of_last_raise; \n     last_percent_increase; \n     emergency_phone; \n     medical_plan; \n     social_s_nbr; \n     etc..... \nif  w e h av e a  l a rg e n um ber o f e m plo yees,  w hat w e w an t t o  d o i s  m an ip ula te  t h e d ata  i n  \nt h ese  s tr u ctu re s b y m ean s o f f u nctio ns. f or e x am ple  w e m ig h t w an t a  f u n ctio n p rin t o ut \nt h e n am e o f t h e e m plo yee l is te d  i n  a n y s tr u ctu re  p asse d  t o  i t. h ow ev er, i n  t h e o rig in al c  \n( k ern ig h an  &  r itc h ie , 1 st e ditio n) i t w as n ot p ossib le  t o  p ass a  s tr u ctu re , o nly  a  p oin te r \nt o  a  s tr u ctu re  c o uld  b e p asse d .  i n  a nsi c , i t i s  n ow  p erm is sib le  t o  p ass t h e c o m ple te  \ns tr u ctu re .  b ut, s in ce o ur g o al h ere  i s  t o  l e a rn  m ore  a b out p oin te rs , w e w on ©t  p urs u e t h at.  \na nyw ay , i f  w e p ass t h e w hole  s tr u ctu re  i t m ean s t h at w e m ust c o p y t h e c o nte n ts  o f t h e \ns tr u ctu re  f ro m  t h e c allin g f u nctio n t o  t h e c alle d  f u nctio n.  i n  s y ste m s u sin g s ta ck s, t h is  i s  \nd one b y p ush in g t h e c o nte n ts  o f t h e s tr u ctu re  o n t h e s ta ck . w ith  l a rg e s tr u ctu re s t h is  \nc o uld  p ro ve t o  b e a  p ro ble m . h ow ev er, p assin g a  p oin te r u se s a  m in im um  a m ount o f \ns ta ck  s p ac e.  \ni n  a n y c ase , s in ce t h is  i s  a  d is c u ssio n o f p oin te rs ,  w e w ill d is c u ss h ow  w e g o  a b out \np assin g a  p oin te r t o  a  s tr u ctu re  a n d t h en  u sin g i t w ith in  t h e f u nctio n.  \nc onsid er t h e c ase  d esc rib ed , i .e . w e w an t a  f u n ctio n t h at w ill a ccep t a s a  p ara m ete r a  \np oin te r t o  a  s tr u ctu re  a n d  f ro m  w ith in  t h at f u nctio n w e w an t t o  a ccess m em bers  o f t h e \ns tr u ctu re .  f or e x am ple  w e w an t t o  p rin t o ut t h e n am e o f t h e e m plo yee i n  o u r e x am ple  \ns tr u ctu re .  \no kay , s o  w e k now  t h at o ur p oin te r i s  g o in g t o  p oin t t o  a  s tr u ctu re  d ecla re d  u sin g s tr u ct \nt a g . w e d ecla re  s u ch  a  p oin te r w ith  t h e d ecla ra tio n:  \n     struct tag *st_ptr; \nan d w e p oin t i t t o  o ur e x am ple  s tr u ctu re  w ith :  \n     st_ptr = &my_struct; \nn ow , w e c an  a ccess a  g iv en  m em ber b y d e-re fe re n cin g t h e p oin te r. b ut, h o w  d o w e d e-\nr e fe re n ce t h e p oin te r t o  a  s tr u ctu re ?  w ell, c o nsid er t h e f a ct t h at w e m ig h t w an t t o  u se  t h e \np oin te r t o  s e t t h e a g e o f t h e e m plo yee. w e w ould  w rite :  \n     (*st_ptr).age = 63;\n\n2 4 \nl\nook a t t h is  c are fu ll y .  i t s a y s,  r e p la c e t h at w ith in  t h e p are n th esis  w ith  t h at w hic h  s t_ p tr  \np oin ts  t o , w hic h  i s  t h e s tr u ctu re  m y_str u ct. t hus,  t h is  b re ak s d ow n t o  t h e s a m e a s \nm y_str u ct.a g e.  \nh ow ev er, t h is  i s  a  f a ir ly  o fte n  u se d  e x pre ssio n a n d t h e d esig n ers  o f c  h av e c re ate d  a n  \na lte rn ate  s y n ta x  w ith  t h e s a m e m ean in g w hic h  i s :  \n       st_ptr->age = 63; \nw ith  t h at i n  m in d, l o ok a t t h e f o llo w in g p ro gra m :  \n - ----------- program 5.2 --------------------- \n / * program 5.2 from ptrtut10.htm   6/13/97 */ \n  # include <stdio.h> \n# include <string.h> \n  s truct tag{                     /* the structure type */ \n     char lname[20];             /* last name */ \n     char fname[20];             /* first name */ \n     int age;                    /* age */ \n     float rate;                 /* e.g. 12.75 per hour */ \n} ; \n  s truct tag my_struct;           /* define the structure */ \nv oid show_name(struct tag *p);  /* function prototype */ \n  i nt main(void) \n{  \n     struct tag *st_ptr;         /* a pointer to a structure */ \n     st_ptr = &my_struct;        /* point the pointer to my_struct */  \n     strcpy(my_struct.lname,"jensen"); \n     strcpy(my_struct.fname,"ted"); \n     printf("\\n%s ",my_struct.fname); \n     printf("%s\\n",my_struct.lname); \n     my_struct.age = 63; \n     show_name(st_ptr);          /* pass the pointer */ \n     return 0; \n}  \n v oid show_name(struct tag *p) \n{  \n     printf("\\n%s ", p->fname);  /* p points to a structure */ \n     printf("%s ", p->lname); \n     printf("%d\\n", p->age); \n}  \n - ------------------- end of program 5.2 ---------------- \na gain , t h is  i s  a  l o t o f i n fo rm atio n t o  a b so rb  a t o ne t im e. t he r e ad er s h ould  c o m pile  a n d \nr u n t h e v ario us c o d e s n ip pets  a n d u sin g a  d eb u gger m onito r t h in gs l ik e m y_str u ct a n d p\n\n2 5 \nw\nhile  s in gle  s te p pin g t h ro ugh  t h e m ain  a n d f o llo w in g t h e c o de d ow n i n to  t h e f u nctio n  t o  \ns e e w hat i s  h ap p en in g.\n\n2 6 \nc h apt er  6 : s om e m ore  o n  s tr in gs, a n d a rra y s o f \ns tr in gs  \nw ell, l e t©s  g o  b ack  t o  s tr in gs f o r a  b it.  i n  t h e f o llo w in g a ll a ssig n m en ts  a re  t o  b e \nu nders to od a s b ein g g lo b al, i .e . m ad e o uts id e o f a n y f u n ctio n, i n clu din g m ain ().  \nw e p oin te d  o ut i n  a n  e arlie r c h ap te r t h at w e c o uld  w rite :  \n    char my_string[40] = "ted"; \nw hic h  w ould  a llo cate  s p ace f o r a  4 0 b yte  a rra y  a n d  p ut t h e s tr in g i n  t h e f ir s t 4  b yte s ( th re e \nf o r t h e c h ara cte rs  i n  t h e q uote s a n d a  4 th  t o  h an dle  t h e t e rm in atin g '' \\0 '') .  \na ctu all y , i f  a ll w e w an te d  t o  d o w as s to re  t h e n am e " t ed " w e c o uld  w rite :  \n    char my_name[] = "ted"; \nan d t h e c o m pile r w ould  c o unt t h e c h ara cte rs , l e av e r o om  f o r t h e n ul c h ara cte r a n d s to re  \nt h e t o ta l o f t h e f o ur c h ara cte rs  i n  m em ory  t h e l o catio n o f w hic h  w ould  b e r e tu rn ed  b y t h e \na rra y  n am e, i n  t h is  c ase  m y_n am e.  \ni n  s o m e c o de, i n ste ad  o f t h e a b ove,  y o u m ig h t s e e :  \n    char *my_name = "ted"; \nw hic h  i s  a n  a lte rn ate  a p p ro ach .  i s  t h ere  a  d if fe re n ce b etw een  t h ese ?  t he a n sw er i s ..  y es. \nu sin g t h e a rra y  n ota tio n 4  b yte s o f s to ra g e i n  t h e s ta tic  m em ory  b lo ck  a re  t a k en  u p, o ne \nf o r e a ch  c h ara cte r a n d o n e f o r t h e t e rm in atin g n ul c h ara cte r.  b ut, i n  t h e p oin te r n ota tio n \nt h e s a m e 4  b yte s r e q uir e d , p lu s n  b yte s t o  s to re  t h e p oin te r v aria b le  m y_n am e ( w here  n  \nd ep en ds o n t h e s y ste m  b ut i s  u su all y  a  m in im um  o f 2  b yte s a n d c an  b e 4  o r m ore ).  \ni n  t h e a rr a y  n ota tio n,  m y_n am e i s  s h ort f o r & myn am e[0 ] w hic h  i s  t h e a d dre ss o f t h e \nf ir s t e le m en t o f t h e a rr a y . s in ce t h e l o catio n o f t h e a rra y  i s  f ix ed  d urin g r u n t im e, t h is  i s  a  \nc o nsta n t ( n ot a  v aria b le ).  i n  t h e p oin te r n ota tio n m y_n am e i s  a  v aria b le .  a s t o  w hic h  i s  \nt h e b ette r m eth od, t h at d ep en ds o n w hat y o u a re  g oin g t o  d o w ith in  t h e r e st o f t h e \np ro gra m .  \nl et©s  n ow  g o  o n e s te p  f u rth er a n d c o nsid er w hat h ap pen s i f  e ach  o f t h ese  d ecla ra tio ns a re  \nd one w ith in  a  f u nctio n a s o ppose d  t o  g lo ball y  o uts id e t h e b ounds o f a n y f u n ctio n.  \nv oid my_function_a(char *ptr) \n{  \n     char a[] = "abcde" \n     . \n     . \n}\n\n2 7 \n  v oid my_function_b(char *ptr) \n{  \n     char *cp = "fghij" \n     . \n     . \n}  \nin  t h e c ase  o f m y_fu nctio n _a , t h e c o nte n t, o r v alu e(s ), o f t h e a rr a y  a [] i s  c o nsid ere d  t o  \nb e t h e d ata . t he a rra y  i s  s a id  t o  b e i n itia liz ed  t o  t h e v alu es a bc d e.  i n  t h e c ase  o f \nm y_fu nctio n _b , t h e v alu e o f t h e p oin te r c p  i s  c o nsid ere d  t o  b e t h e d ata . t he p oin te r h as \nb een  i n itia liz ed  t o  p oin t t o  t h e s tr in g f g h ij .  i n  b oth  m y_fu nctio n _a  a n d \nm y_fu nctio n _b  t h e d efin itio ns a re  l o cal v aria b le s a n d t h us t h e s tr in g a bc de i s  s to re d  \no n t h e s ta ck , a s i s  t h e v alu e o f t h e p oin te r c p . t he s tr in g f g h ij  c an  b e s to re d  a n yw here . \no n m y s y ste m  i t g ets  s to re d  i n  t h e d ata  s e g m en t.  \nb y t h e w ay , a rra y  i n itia liz atio n o f a u to m atic  v aria b le s a s i  h av e d one i n  m y_fu nctio n _a  \nw as i lle g al i n  t h e o ld er k & r c  a n d o nly  " c am e o f a g e" i n  t h e n ew er a nsi c . a  f a ct t h at \nm ay  b e i m porta n t w hen  o ne i s  c o nsid erin g p orta b il it y  a n d b ack w ard s c o m patib ilit y .  \na s l o ng a s w e a re  d is c u ssin g t h e r e la tio nsh ip /d if fe re n ces b etw een  p oin te rs  a n d a rr a y s, \nl e t©s  m ove o n t o  m ulti- d im en sio nal a rra y s. c onsid er, f o r e x am ple  t h e a rr a y :  \n     char multi[5][10]; \nju st w hat d oes t h is  m ean ? w ell, l e t©s  c o nsid er i t i n  t h e f o llo w in g l i g h t.  \n     char multi[5][10]; \nl et©s  t a k e t h e u nderlin ed  p art t o  b e t h e " n am e" o f a n  a rr a y . t hen  p re p en din g t h e c h ar a n d \na p pen din g t h e [ 1 0] w e h av e a n  a rra y  o f 1 0 c h ara cte rs . b ut, t h e n am e m ult i[ 5 ] i s  i ts e lf  a n  \na rra y  i n dic atin g t h at t h ere  a re  5  e le m en ts  e ach  b ein g a n  a rr a y  o f 1 0 c h ara cte rs . h en ce  w e \nh av e a n  a rr a y  o f 5  a rra y s o f 1 0 c h ara cte rs  e a ch ..  \na ssu m e w e h av e f ille d  t h is  t w o d im en sio nal a rra y  w ith  d ata  o f s o m e k in d.  i n  m em ory , i t \nm ig h t l o ok a s i f  i t h ad  b een  f o rm ed  b y i n itia liz in g 5  s e p ara te  a rra y s u sin g s o m eth in g l ik e:  \n     multi[0] = {''0'',''1'',''2'',''3'',''4'',''5'',''6'',''7'',''8'',''9''} \n     multi[1] = {''a'',''b'',''c'',''d'',''e'',''f'',''g'',''h'',''i'',''j''} \n     multi[2] = {''a'',''b'',''c'',''d'',''e'',''f'',''g'',''h'',''i'',''j''} \n     multi[3] = {''9'',''8'',''7'',''6'',''5'',''4'',''3'',''2'',''1'',''0''} \n     multi[4] = {''j'',''i'',''h'',''g'',''f'',''e'',''d'',''c'',''b'',''a''} \na t t h e s a m e t im e, i n div id ual e le m en ts  m ig h t b e a d dre ssa b le  u sin g s y n ta x  s u ch  a s: \n     multi[0][3] = ''3'' \n     multi[1][7] = ''h'' \n     multi[4][0] = ''j''\n\n2 8 \ns\nin ce a rr a y s a re  c o nti g u o us i n  m em ory , o ur a ctu al m em ory  b lo ck  f o r t h e a b ove s h ould  \nl o ok l ik e:  \n     0123456789abcdefghijabcdefghij9876543210jihgfedcba \n     ^ \n     |_____ starting at the address &multi[0][0] \nn ote  t h at i  d id  n ot w rite  m ult i[ 0 ] =  " 0123456789 " . h ad  i  d on e s o  a  t e rm in atin g '' \\0 '' \nw ould  h av e b een  i m plie d  s in ce w hen ev er d ouble  q uote s a re  u se d  a  '' \\0 ©  c h ara cte r i s  \na p pen ded  t o  t h e c h ara cte rs  c o nta in ed  w ith in  t h ose  q uote s. h ad  t h at b een  t h e c ase  i  w ould  \nh av e h ad  t o  s e t a sid e r o o m  f o r 1 1 c h ara cte rs  p er r o w  i n ste ad  o f 1 0.  \nm y g o al i n  t h e a b ov e i s  t o  i llu str a te  h ow  m em ory  i s  l a id  o ut f o r 2  d im en sio nal a rr a y s. \nt hat i s , t h is  i s  a  2  d im en sio nal a rra y  o f c h ara cte rs ,  n ot a n  a rra y  o f " str in gs".  \nn ow , t h e c o m pile r k now s h ow  m an y c o lu m ns a re  p re se n t i n  t h e a rra y  s o  i t c an  i n te rp re t \nm ult i +  1  a s t h e a d dre ss o f t h e ©a ©  i n  t h e 2 nd r o w  a b ove. t hat i s , i t a d ds 1 0, t h e n um ber o f \nc o lu m ns, t o  g et t h is  l o catio n.  i f  w e w ere  d ealin g w ith  i n te g ers  a n d a n  a rra y  w ith  t h e s a m e \nd im en sio n t h e c o m pile r w ould  a d d 1 0*siz eo f(in t)  w hic h , o n m y m ach in e,  w ould  b e 2 0. \nt hus, t h e a d dre ss o f t h e 9  i n  t h e 4 th  r o w  a b ove w ould  b e & mult i[ 3 ][0 ] o r * (m ult i +  3 ) i n  \np oin te r n ota tio n. t o g et t o  t h e c o nte n t o f t h e 2 nd e le m en t i n  t h e 4 th  r o w  w e a d d 1  t o  t h is  \na d dre ss a n d d ere fe re n ce t h e r e su lt a s i n   \n     *(*(multi + 3) + 1) \nw ith  a  l ittl e  t h ough t w e c an  s e e t h at:  \n     *(*(multi + row) + col)    and \n     multi[row][col]            yield the same results. \nt he f o llo w in g p ro gra m  i l lu str a te s t h is  u sin g i n te g er a rr a y s i n ste ad  o f c h ara c te r a rr a y s.  \n- ------------------ program 6.1 ---------------------- \n  / * program 6.1 from ptrtut10.htm   6/13/97*/ \n  # include <stdio.h> \n# define rows 5 \n# define cols 10 \n  i nt multi[rows][cols]; \n i nt main(void) \n{  \n     int row, col; \n     for (row = 0; row < rows; row++) \n     { \n         for (col = 0; col < cols; col++) \n         { \n             multi[row][col] = row*col; \n         }\n\n2 9 \n     } \n       for (row = 0; row < rows; row++) \n     { \n         for (col = 0; col < cols; col++) \n         { \n             printf("\\n%d  ",multi[row][col]); \n             printf("%d ",*(*(multi + row) + col)); \n         } \n     } \n       return 0; \n}  \n- ---------------- end of program 6.1 ---------------------    \nb ec au se  o f t h e d ouble  d e-re fe re n cin g r e q uir e d  i n  t h e p oin te r v ers io n, t h e n am e o f a  2  \nd im en sio nal a rra y  i s  o fte n  s a id  t o  b e e q uiv ale n t t o  a  p oin te r t o  a  p oin te r. w ith  a  t h re e  \nd im en sio nal a rra y  w e w ould  b e d ealin g w ith  a n  a rra y  o f a rra y s o f a rra y s a n d s o m e m ig h t \ns a y  i ts  n am e w ould  b e e q uiv ale n t t o  a  p oin te r t o  a  p oin te r t o  a  p oin te r. h ow ev er, h ere  w e \nh av e i n itia ll y  s e t a sid e t h e b lo ck  o f m em ory  f o r t h e a rr a y  b y d efin in g i t u sin g a rra y  \nn ota tio n. h en ce, w e a re  d ealin g w ith  a  c o nsta n t, n ot a  v aria b le . t hat i s  w e a re  t a lk in g \na b out a  f ix ed  a d dre ss n ot a  v aria b le  p oin te r. t he d ere fe re n cin g f u nctio n u se d  a b ove \np erm its  u s t o  a ccess a n y e le m en t i n  t h e a rr a y  o f a rra y s w ith out t h e n eed  o f c h an gin g t h e \nv alu e o f t h at a d d re ss ( th e a d dre ss o f m ult i[ 0 ][0 ] a s g iv en  b y t h e s y m bol m ult i) .\n\n3 0 \nc h apt er  7 : m ore o n  m ult i- d im en sio n al a rra y s \nin  t h e p re v io us c h ap te r w e n ote d  t h at g iv en   \n       #define rows 5 \n     #define cols 10 \n      int multi[rows][cols]; \nw e c an  a c cess i n div id ual e le m en ts  o f t h e a rra y  m ult i u sin g e ith er:  \n      multi[row][col] \nor  \n       *(*(multi + row) + col) \n \nt o u nders ta n d m ore  f u ll y  w hat i s  g o in g o n, l e t u s r e p la ce  \n       *(multi + row) \n \nw ith  x  a s i n :  \n      *(x + col) \n \nn ow , f ro m  t h is  w e s e e t h at x  i s  l ik e a  p oin te r s in ce t h e e x pre ssio n i s  d e-re fe re n ced  a n d \nw e k now  t h at c o l i s  a n  i n te g er. h ere  t h e a rith m etic  b ein g u se d  i s  o f a  s p ecia l k in d c alle d  \n" p oin te r a rith m etic " i s  b ein g u se d . t hat m ean s t h at, s in ce w e a re  t a lk in g a b out a n  i n te g er \na rra y , t h e a d dre ss p oin te d  t o  b y ( i.e . v alu e o f) x  +  c o l +  1  m ust b e g re ate r t h an  t h e \na d dre ss x  +  c o l b y a n d a m ount e q ual t o  s iz eo f(in t).  \ns in ce w e k now  t h e m em ory  l a y o ut f o r 2  d im en sio nal a rr a y s,  w e c an  d ete rm in e t h at i n  t h e \ne x pre ssio n m ult i +  r o w  a s u se d  a b ove,  m ult i +  r o w  +  1  m ust i n cre ase  b y v alu e a n  \na m ount e q ual t o  t h at n ee d ed  t o  " p oin t t o " t h e n ex t r o w , w hic h  i n  t h is  c ase  w ould  b e a n  \na m ount e q ual t o  c o ls *  s iz eo f(in t).  \nt hat s a y s t h at i f  t h e e x pre ssio n * (* (m ult i +  r o w ) +  c o l)  i s  t o  b e e v alu ate d  c o rre ctl y  a t r u n \nt im e, t h e c o m pile r m ust g en era te  c o de w hic h  t a k es i n to  c o nsid era tio n t h e v alu e o f c o ls, \ni .e . t h e 2 nd d im en sio n. b ecau se  o f t h e e q uiv ale n ce o f t h e t w o f o rm s o f e x pre ssio n, t h is  i s  \nt r u e w heth er w e a re  u sin g t h e p oin te r e x pre ssio n a s h ere  o r t h e a rra y  e x pre ssio n \nm ult i[ r o w ][ c o l] .  \nt hus, t o  e v alu ate  e ith er e x pre ssio n, a  t o ta l o f 5  v alu es m ust b e k now n:  \n1 .  the a d dre ss o f t h e f ir s t e le m en t o f t h e a rra y , w hic h  i s  r e tu rn ed  b y t h e e x pre ss io n \nm ult i, i .e ., t h e n am e o f t h e a rr a y .  \n2 .  the s iz e o f t h e t y p e o f t h e e le m en ts  o f t h e a rr a y , i n  t h is  c ase  s iz eo f(in t).  \n3 .  the 2 nd d im en sio n o f t h e a rr a y   \n4 .  the s p ecif ic  i n d ex  v alu e f o r t h e f ir s t d im en sio n, r o w  i n  t h is  c ase .  \n5 .  the s p ecif ic  i n d ex  v alu e f o r t h e s e co nd  d im en sio n, c o l i n  t h is  c ase .\n\n3 1 \ng\niv en  a ll o f t h at, c o nsid er t h e p ro ble m  o f d esig n in g a  f u nctio n t o  m an ip ula te  t h e e le m en t \nv alu es o f a  p re v io usly  d ecla re d  a rr a y . f or e x am ple , o ne w hic h  w ould  s e t a ll t h e e le m en ts  \no f t h e a rr a y  m ult i t o  t h e v alu e 1 .  \n       void set_value(int m_array[][cols]) \n     { \n         int row, col; \n         for (row = 0; row < rows; row++) \n         { \n             for (col = 0; col < cols; col++) \n             { \n                 m_array[row][col] = 1; \n             } \n         } \n     } \n \na nd t o  c all t h is  f u nctio n w e w ould  t h en  u se :  \n       set_value(multi); \n \nn ow , w ith in  t h e f u nctio n w e h av e u se d  t h e v alu es # defin ed  b y r o w s a n d c o ls t h at s e t \nt h e l im its  o n t h e f o r l o ops. b ut, t h ese  # defin es a re  j u st c o nsta n ts  a s f a r a s t h e c o m pile r i s  \nc o ncern ed , i .e . t h ere  i s  n oth in g t o  c o nnect t h em  t o  t h e a rr a y  s iz e w ith in  t h e f u nctio n.  r o w  \na n d c o l a re  l o cal v aria b le s, o f c o urs e . t he f o rm al p ara m ete r d efin itio n p erm its  t h e \nc o m pile r t o  d ete rm in e t h e c h ara cte ris tic s a sso cia te d  w ith  t h e p oin te r v alu e t h at w ill b e \np asse d  a t r u n t im e. w e r e all y  d on’t n eed  t h e f ir s t d im en sio n a n d, a s w ill b e s e en  l a te r, \nt h ere  a re  o ccasio ns w here  w e w ould  p re fe r n ot t o  d efin e i t w ith in  t h e p ara m ete r \nd efin itio n, o ut o f h ab it o r c o nsis te n cy ,  i  h av e n ot u se d  i t h ere .  b ut, t h e s e co nd d im en sio n \nm ust b e u se d  a s h as b een  s h ow n i n  t h e e x pre ssio n f o r t h e p ara m ete r. t he r e aso n i s  t h at \nw e n eed  t h is  i n  t h e e v alu atio n o f m _arra y [r o w ][c o l]  a s h as b ee n  d esc rib ed . w hile  t h e \np ara m ete r d efin es t h e d ata  t y p e ( in t i n  t h is  c ase ) a n d t h e a u to m atic  v aria b le s f o r r o w  a n d \nc o lu m n a re  d efin ed  i n  t h e f o r l o ops, o nly  o n e v alu e c an  b e p asse d  u sin g a  s in gle  \np ara m ete r.  i n  t h is  c ase , t h at i s  t h e v alu e o f m ult i a s n ote d  i n  t h e c all s ta te m en t, i .e . t h e \na d dre ss o f t h e f ir s t e le m en t, o fte n  r e fe rr e d  t o  a s a  p oin te r t o  t h e a rr a y . t hus, t h e o nly  w ay  \nw e h av e o f i n fo rm in g t h e c o m pile r o f t h e 2 nd d im en sio n i s  b y e x plic itl y  i n clu din g i t i n  \nt h e p ara m ete r d efin itio n.  \ni n  f a ct, i n  g en era l a ll d im en sio ns o f h ig h er o rd er t h an  o ne a re  n eed ed  w hen  d ealin g w ith  \nm ulti- d im en sio nal a rra y s. t hat i s  i f  w e a re  t a lk in g a b out 3  d im en sio nal a rra y s, t h e 2 n d \na n d 3 rd  d im en sio n m ust b e s p ecif ie d  i n  t h e p ara m ete r d efin itio n.\n\n3 2 \nc h apt er  8 : p oin te rs t o  a rra y s \npoin te rs , o f c o urs e ,  c an  b e " p oin te d  a t"  a n y t y p e o f d ata  o bje ct, i n clu din g a rra y s. w hile  \nt h at w as e v id en t w hen  w e d is c u sse d  p ro gra m  3 .1 ,  i t i s  i m porta n t t o  e x pan d o n h ow  w e d o \nt h is  w hen  i t c o m es t o  m ulti- d im en sio nal a rra y s.  \nt o r e v ie w , i n  c hap te r 2  w e s ta te d  t h at g iv en  a n  a rra y  o f i n te g ers  w e c o uld  p oin t a n  \ni n te g er p oin te r a t t h at a rr a y  u sin g:  \n     int *ptr; \n     ptr = &my_array[0];       /* point our pointer at the first \n                                  integer in our array */ \na s w e s ta te d  t h ere , t h e t y p e o f t h e p oin te r v aria b le  m ust m atc h  t h e t y p e o f t h e f ir s t \ne le m en t o f t h e a rra y .  \ni n  a d ditio n, w e c an  u se  a  p oin te r a s a  f o rm al p ara m ete r o f a  f u nctio n w hic h  i s  d esig n ed  t o  \nm an ip ula te  a n  a rra y . e .g .   \ng iv en :  \n     int array[3] = {''1'', ''5'', ''7''}; \n     void a_func(int *p); \n \ns om e p ro gra m mers  m ig h t p re fe r t o  w rite  t h e f u n ctio n p ro to ty p e a s:  \n      void a_func(int p[]); \n \nw hic h  w ould  t e n d t o  i n fo rm  o th ers  w ho m ig h t u se  t h is  f u nctio n t h at t h e f u nctio n i s  \nd esig n ed  t o  m an ip ula te  t h e e le m en ts  o f a n  a rra y .  o f c o urs e , i n  e ith er c ase ,  w hat a ctu all y  \ng ets  p ass e d  i s  t h e v alu e o f a  p oin te r t o  t h e f ir s t e le m en t o f t h e a rr a y , i n dep en den t o f w hic h  \nn ota tio n i s  u se d  i n  t h e f u nctio n p ro to ty p e o r d efin itio n. n ote  t h at i f  t h e a rra y  n ota tio n  i s  \nu se d , t h ere  i s  n o n eed  t o  p ass t h e a ctu al d im en sio n o f t h e a rr a y  s in ce w e a re  n ot p assin g \nt h e w hole  a rra y , o nly  t h e a d dre ss t o  t h e f ir s t e le m en t.  \nw e n ow  t u rn  t o  t h e p ro ble m  o f t h e 2  d im en sio nal a rra y .  a s s ta te d  i n  t h e l a st c h ap te r, c  \ni n te rp re ts  a  2  d im en sio nal a rra y  a s a n  a rra y  o f o ne d im en sio nal a rra y s. t hat b ein g t h e \nc ase , t h e f ir s t e le m en t o f a  2  d im en sio nal a rr a y  o f i n te g ers  i s  a  o ne d im en sio nal a rr a y  o f \ni n te g ers . a nd a  p oin te r t o  a  t w o d im en sio nal a rr a y  o f i n te g ers  m ust b e a  p oin te r t o  t h at \nd ata  t y p e. o ne w ay  o f a c co m plis h in g t h is  i s  t h ro ugh  t h e u se  o f t h e k ey w ord  " ty p ed ef" . \nt y p ed ef a ssig n s a  n ew  n am e t o  a  s p ecif ie d  d ata  t y p e. f or e x am ple :  \n     typedef unsigned char byte; \n \nc au se s t h e n am e b yte  t o  m ean  t y p e u nsig n ed  c h ar. h en ce  \n       byte b[10];     would be an array of unsigned characters.\n\n3 3 \nn\note  t h at i n  t h e t y p ed ef d ecla ra tio n, t h e w ord  b yte  h as r e p la ced  t h at w hic h  w ould  \nn orm all y  b e t h e n am e o f o ur u nsig n ed  c h ar. t hat i s , t h e r u le  f o r u sin g t y p ed ef i s  t h at t h e \nn ew  n am e f o r t h e d ata  t y p e i s  t h e n am e u se d  i n  t h e d efin itio n o f t h e d ata  t y p e. t hus i n :  \n       typedef int array[10]; \n \na rra y  b eco m es a  d ata  t y p e f o r a n  a rr a y  o f 1 0 i n te g ers . i .e . a rra y m y_a rr; d ecla re s \nm y_a rr a s a n  a rra y  o f 1 0  i n te g ers  a n d a rra y a rr2 d [5 ]; m ak es a rr2 d  a n  a rr a y  o f 5  a rra y s \no f 1 0 i n te g ers  e ach .  \na ls o  n ote  t h at a rra y * p 1d ; m ak es p 1d  a  p oin te r t o  a n  a rr a y  o f 1 0 i n te g ers . b ec au se  \n* p 1d  p oin ts  t o  t h e s a m e t y p e a s a rr2 d ,  a ssig n in g t h e a d dre ss o f t h e t w o d im en sio nal \na rra y  a rr2 d  t o  p 1d , t h e p oin te r t o  a  o ne d im en sio n al a rr a y  o f 1 0 i n te g ers  i s  a cc ep ta b le . \ni .e . p 1d  =  & arr2 d [0 ]; o r p 1d  =  a rr2 d ; a re  b oth  c o rre ct.  \ns in ce t h e d ata  t y p e w e u se  f o r o ur p oin te r i s  a n  a rra y  o f 1 0 i n te g ers  w e w ou ld  e x pect t h at \ni n cre m en tin g p 1d  b y 1  w ould  c h an ge i ts  v alu e b y 1 0*siz eo f(in t), w hic h  i t d oes. t hat i s , \ns iz eo f(* p 1d ) i s  2 0. y ou c an  p ro ve t h is  t o  y o urs e lf  b y w ritin g a n d r u nnin g a  s im ple  s h ort \np ro gra m .  \nn ow , w hile  u sin g t y p ed ef m ak es t h in gs c le a re r f o r t h e r e ad er a n d e asie r o n t h e \np ro gra m mer, i t i s  n ot r e ally  n ecessa ry . w hat w e n eed  i s  a  w ay  o f d ecla rin g a  p oin te r l ik e \np 1d  w ith out t h e n eed  o f t h e t y p ed ef k ey w ord .  i t t u rn s o ut t h at t h is  c an  b e d one a n d t h at  \n     int (*p1d)[10]; \n \ni s  t h e p ro per d ecla ra tio n, i .e . p 1d  h ere  i s  a  p oin te r t o  a n  a rr a y  o f 1 0 i n te g ers  j u st a s i t  w as \nu nder t h e d ecla ra tio n u sin g t h e a rra y  t y p e. n ote  t h at t h is  i s  d if fe re n t f ro m   \n       int *p1d[10]; \n \nw hic h  w ould  m ak e p 1d  t h e n am e o f a n  a rra y  o f 1 0 p oin te rs  t o  t y p e i n t.\n\n3 4 \nc h apt er  9 : p oin te rs a n d d yn am ic  a llo ca tio n  o f \nm em ory  \nthere  a re  t im es w hen  i t i s  c o nven ie n t t o  a llo cate  m em ory  a t r u n t im e u sin g m allo c(), \nc a llo c(), o r o th er a llo catio n f u nctio ns. u sin g t h is  a p pro ach  p erm its  p ostp onin g t h e \nd ecis io n o n t h e s iz e o f t h e m em ory  b lo ck  n eed  t o  s to re  a n  a rra y , f o r e x am ple , u ntil r u n \nt im e. o r i t p erm its  u sin g a  s e ctio n o f m em ory  f o r t h e s to ra g e o f a n  a rra y  o f i n te g ers  a t \no ne p oin t i n  t im e, a n d t h en  w hen  t h at m em ory  i s  n o l o nger n eed ed  i t c an  b e f re ed  u p f o r \no th er u se s, s u ch  a s t h e s to ra g e o f a n  a rra y  o f s tr u ctu re s.  \nw hen  m em ory  i s  a llo cate d , t h e a llo catin g f u n ctio n ( s u ch  a s m allo c(), c a ll o c(), e tc .)  \nr e tu rn s a  p oin te r. t he t y p e o f t h is  p oin te r d ep en ds o n w heth er y o u a re  u sin g a n  o ld er \nk & r c o m pile r o r t h e n ew er a nsi t y p e c o m pile r. w ith  t h e o ld er c o m pile r t h e t y p e o f t h e \nr e tu rn ed  p oin te r i s  c h ar,  w ith  t h e a nsi c o m pile r i t i s  v oid .  \ni f  y o u a re  u sin g a n  o ld er c o m pile r, a n d y o u w an t t o  a llo cate  m em ory  f o r a n  a rra y  o f \ni n te g ers  y o u w ill h av e t o  c ast t h e c h ar p oin te r r e tu rn ed  t o  a n  i n te g er p oin te r. f or e x am ple , \nt o  a llo cate  s p ac e f o r 1 0 i n te g ers  w e m ig h t w rite :  \n     int *iptr; \n     iptr = (int *)malloc(10 * sizeof(int)); \n     if (iptr == null) \n       { .. error routine goes here .. } \n \ni f  y o u a re  u sin g a n  a nsi c o m plia n t c o m pile r,  m allo c() r e tu rn s a  v oid  p oin te r a n d s in ce a  \nv oid  p oin te r c an  b e a ssig ned  t o  a  p oin te r v aria b le  o f a n y o bje ct t y p e, t h e ( in t * ) c ast \ns h ow n a b ove i s  n ot n eed ed . t he a rra y  d im en sio n c an  b e d ete rm in ed  a t r u n t im e a n d i s  n ot \nn eed ed  a t c o m pile  t im e. t hat i s , t h e 1 0 a b ove c o u ld  b e a  v aria b le  r e ad  i n  f r o m  a  d ata  f ile  \no r k ey b oard , o r c alc u la te d  b ase d  o n s o m e n eed , a t r u n t im e.  \nb ec au se  o f t h e e q uiv ale n ce b etw een  a rra y  a n d p oin te r n ota tio n, o nce i p tr  h as b een  \na ssig n ed  a s a b ov e, o ne c an  u se  t h e a rra y  n ota tio n. f or e x am ple , o ne c o uld  w rite :  \n     int k; \n     for (k = 0; k < 10; k++) \n        iptr[k] = 2; \n \nt o  s e t t h e v alu es o f a ll e le m en ts  t o  2 .  \ne ven  w ith  a  r e aso nab ly  g ood u nders ta n din g o f p oin te rs  a n d a rra y s, o n e p la c e t h e \nn ew co m er t o  c  i s  l ik ely  t o  s tu m ble  a t f ir s t i s  i n  t h e d yn am ic  a llo catio n o f m ulti-\nd im en sio nal a rra y s.  i n  g en era l, w e w ould  l ik e t o  b e a b le  t o  a ccess e le m en ts  o f s u ch  a rra y s \nu sin g a rra y  n ota tio n, n ot p oin te r n ota tio n, w here v er p ossib le . d ep en din g o n t h e \na p plic atio n w e m ay  o r m ay  n ot k now  b oth  d im en sio ns a t c o m pile  t im e. t his  l e ad s t o  a  \nv arie ty  o f w ay s t o  g o  a b o ut o ur t a sk .\n\n3 5 \na\ns w e h av e s e en , w hen  d yn am ic all y  a llo catin g a  o ne d im en sio nal a rr a y  i ts  d im en sio n  c an  \nb e d ete rm in ed  a t r u n t im e. n ow , w hen  u sin g d yn am ic  a llo catio n o f h ig h er o rd er a rra y s, \nw e n ev er n eed  t o  k no w  t h e f ir s t d im en sio n a t c o m pile  t im e. w heth er w e n eed  t o  k now  t h e \nh ig h er d im en sio ns d ep en ds o n h ow  w e g o  a b out w ritin g t h e c o d e. h ere  i  w ill d is c u ss  \nv ario us m eth ods o f d yn am ic all y  a llo catin g r o om  f o r 2  d im en sio nal a rr a y s o f i n te g ers .  \nf ir s t w e w ill c o nsid er c ase s w here  t h e 2 nd d im en sio n i s  k now n a t c o m pile  t im e.  \nm eth o d 1 : \no ne w ay  o f d ealin g w ith  t h e p ro ble m  i s  t h ro ugh  t h e u se  o f t h e t y p ed ef k ey w ord . t o \na llo cate  a  2  d im en sio nal a rra y  o f i n te g ers  r e c all t h at t h e f o llo w in g t w o n ota tio ns r e su lt i n  \nt h e s a m e o bje ct c o d e b ein g g en era te d :  \n         multi[row][col] = 1;     *(*(multi + row) + col) = 1; \n \ni t i s  a ls o  t r u e t h at t h e f o llo w in g t w o n ota tio ns g en era te  t h e s a m e c o d e:  \n      multi[row]            *(multi + row) \n \ns in ce t h e o ne o n t h e r ig h t m ust e v alu ate  t o  a  p oin te r, t h e a rra y  n ota tio n o n t h e l e ft m ust \na ls o  e v alu ate  t o  a  p oin te r.  i n  f a ct m ult i[ 0 ] w ill r e tu rn  a  p oin te r t o  t h e f ir s t i n te g er i n  t h e \nf ir s t r o w ,  m ult i[ 1 ] a  p oin te r t o  t h e f ir s t i n te g er o f t h e s e co nd r o w , e tc . a ctu all y ,  m ult i[ n ] \ne v alu ate s t o  a  p oin te r t o  t h at a rr a y  o f i n te g ers  t h at m ak e u p t h e n -th  r o w  o f o ur 2  \nd im en sio nal a rra y . t hat i s , m ult i c an  b e t h ou gh t o f a s a n  a rra y  o f a rra y s a n d m ult i[ n ] a s \na  p oin te r t o  t h e n -th  a rra y  o f t h is  a rra y  o f a rra y s. h ere  t h e w ord  p oin te r i s  b ein g u se d  t o  \nr e p re se n t a n  a d d re ss v alu e. w hile  s u ch  u sa g e i s  c o m mon i n  t h e l ite ra tu re , w hen  r e ad in g \ns u ch  s ta te m en ts  o ne m ust b e c are fu l t o  d is tin gu is h  b etw een  t h e c o nsta n t a d d re ss o f a n  \na rra y  a n d a  v aria b le  p oin te r w hic h  i s  a  d ata  o bje ct i n  i ts e lf .  \nc onsid er n ow :  \n- -------------- program 9.1 -------------------------------- \n / * program 9.1 from ptrtut10.htm  6/13/97 */ \n # include <stdio.h> \n# include <stdlib.h> \n # define cols 5 \n t ypedef int rowarray[cols]; \nr owarray *rptr; \n i nt main(void) \n{  \n     int nrows = 10; \n     int row, col; \n     rptr = malloc(nrows * cols * sizeof(int)); \n     for (row = 0; row < nrows; row++)\n\n3 6 \n     { \n         for (col = 0; col < cols; col++) \n         { \n             rptr[row][col] = 17; \n         } \n     } \n       return 0; \n}  \n- ------------ end of prog. 9.1 -------------------------------- \n \nh ere  i  h av e a ssu m ed  a n  a nsi c o m pile r s o  a  c ast o n t h e v oid  p oin te r r e tu rn ed  b y m allo c() \ni s  n ot r e q uir e d .  i f  y o u a re  u sin g a n  o ld er k & r c o m pile r y o u w ill h av e t o  c ast u sin g:  \n      rptr = (rowarray *)malloc(.... etc. \n \nu sin g t h is  a p pro ach , r p tr  h as a ll t h e c h ara cte ris tic s o f a n  a rra y  n am e n am e, ( e x cep t t h at \nr p tr  i s  m odif ia b le ), a n d a rra y  n ota tio n m ay  b e u se d  t h ro ugh out t h e r e st o f t h e p ro gra m . \nt hat a ls o  m ean s t h at i f  y o u i n te n d t o  w rite  a  f u nctio n t o  m odif y  t h e a rra y  c o nte n ts ,  y o u \nm ust u se  c o ls a s a  p art o f t h e f o rm al p ara m ete r i n  t h at f u nctio n, j u st a s w e d id  w hen  \nd is c u ssin g t h e p assin g o f t w o d im en sio nal a rra y s t o  a  f u nctio n.  \nm eth o d 2 : \nin  t h e m eth od 1  a b ove, r p tr  t u rn ed  o ut t o  b e a  p oin te r t o  t y p e " o ne d im en sio nal a rr a y  \no f c o ls i n te g ers " .  i t t u rn s o ut t h at t h ere  i s  s y n ta x  w hic h  c an  b e u se d  f o r t h is  t y p e \nw ith out t h e n eed  o f t y p ed ef.  i f  w e w rite :  \n      int (*xptr)[cols]; \n \nt h e v aria b le  x p tr  w ill h av e a ll t h e s a m e c h ara cte ris tic s a s t h e v aria b le  r p tr  i n  m eth o d \n1  a b ove, a n d w e n eed  n ot u se  t h e t y p ed ef k ey w ord . h ere  x p tr  i s  a  p oin te r t o  a n  a rr a y  o f \ni n te g ers  a n d t h e s iz e o f t h at a rr a y  i s  g iv en  b y t h e # d efin ed  c o ls. t he p are n th esis  \np la cem en t m ak es t h e p oin te r n ota tio n p re d om in ate , e v en  t h ou gh  t h e a rr a y  n ota tio n h as \nh ig h er p re ced en ce. i .e . h ad  w e w ritte n   \n      int *xptr[cols]; \n \nw e w ould  h av e d efin ed  x p tr  a s a n  a rra y  o f p oin te rs  h old in g t h e n um ber o f p oin te rs  e q ual \nt o  t h at # defin ed  b y c o ls. t hat i s  n ot t h e s a m e t h in g a t a ll. h ow ev er,  a rr a y s o f p oin te rs  \nh av e t h eir  u se  i n  t h e d yn am ic  a llo catio n o f t w o d im en sio nal a rra y s,  a s w ill b e s e en  i n  t h e \nn ex t 2  m eth ods.  \nm eth o d 3 : \nc onsid er t h e c ase  w here  w e d o n ot k now  t h e n um ber o f e le m en ts  i n  e ach  r o w  a t c o m pile  \nt im e, i .e . b oth  t h e n um ber o f r o w s a n d n um ber o f c o lu m ns m ust b e d ete rm in ed  a t r u n  \nt im e. o ne w ay  o f d oin g t h is  w ould  b e t o  c re ate  a n  a rra y  o f p oin te rs  t o  t y p e i n t a n d t h en  \na llo cate  s p ace f o r e a ch  r o w  a n d p oin t t h ese  p oin te rs  a t e ach  r o w . c onsid er:\n\n3 7 \n  - ------------- program 9.2 ------------------------------------ \n / * program 9.2 from ptrtut10.htm   6/13/97 */ \n # include <stdio.h> \n# include <stdlib.h> \n i nt main(void) \n{  \n     int nrows = 5;     /* both nrows and ncols could be evaluated */  \n     int ncols = 10;    /* or read in at run time */ \n     int row; \n     int **rowptr; \n     rowptr = malloc(nrows * sizeof(int *)); \n     if (rowptr == null) \n     { \n         puts("\\nfailure to allocate room for row pointers.\\n"); \n         exit(0); \n     } \n      printf("\\n\\n\\nindex   pointer(hex)   pointer(dec)   diff.(dec)") ; \n      for (row = 0; row < nrows; row++) \n     { \n         rowptr[row] = malloc(ncols * sizeof(int)); \n         if (rowptr[row] == null) \n         { \n             printf("\\nfailure to allocate for row[%d]\\n",row); \n             exit(0); \n         } \n         printf("\\n%d         %p         %d", row, rowptr[row], \nr owptr[row]); \n         if (row > 0) \n         printf("              %d",(int)(rowptr[row] - rowptr[row-1]) ); \n     } \n       return 0; \n}  \n  - -------------- end 9.2 ------------------------------------ \n \ni n  t h e a b ove c o de r o w ptr  i s  a  p oin te r t o  p oin te r t o  t y p e i n t.  i n  t h is  c ase  i t p oin ts  t o  t h e \nf ir s t e le m en t o f a n  a rr a y  o f p oin te rs  t o  t y p e i n t. c onsid er t h e n um ber o f c alls  t o  m all o c():  \n      to get the array of pointers             1     call \n     to get space for the rows                5     calls \n                                           ----- \n                      total                   6     calls \n \ni f  y o u c h oose  t o  u se  t h is  a p pro ach  n ote  t h at w hile  y o u c an  u se  t h e a rr a y  n ota tio n t o  a c cess \ni n div id ual e le m en ts  o f t h e a rr a y , e .g .  r o w ptr [r o w ][c o l]  =  1 7;, i t d oes n ot m ean  t h at t h e \nd ata  i n  t h e " tw o d im en sio nal a rr a y " i s  c o nti g u ous i n  m em ory .\n\n3 8 \ny\nou c an , h ow ev er, u se  t h e a rr a y  n ota tio n j u st a s i f  i t w ere  a  c o ntin uous b lo ck  o f m em ory . \nf or e x am ple ,  y o u c an  w rite :  \n     rowptr[row][col] = 176; \n \nj u st a s i f  r o w ptr  w ere  t h e n am e o f a  t w o d im en sio n al a rr a y  c re ate d  a t c o m pile  t im e. o f \nc o urs e  r o w  a n d c o l m ust b e w ith in  t h e b ounds o f t h e a rr a y  y o u h av e c re ate d , j u st a s w ith  \na n  a rr a y  c re ate d  a t c o m pile  t im e.  \ni f  y o u w an t t o  h av e a  c o n tig u ous b lo ck  o f m em ory  d ed ic ate d  t o  t h e s to ra g e o f t h e \ne le m en ts  i n  t h e a rr a y  y o u  c an  d o i t a s f o llo w s:  \nm eth o d 4 : \nin  t h is  m eth od w e a llo cate  a  b lo ck  o f m em ory  t o  h old  t h e w hole  a rr a y  f ir s t.  w e t h en  \nc re ate  a n  a rra y  o f p oin te rs  t o  p oin t t o  e ach  r o w . t hus e v en  t h ou gh  t h e a rra y  o f p oin te rs  i s  \nb ein g u se d , t h e a ctu al a rr a y  i n  m em ory  i s  c o ntig u o us. t he c o de l o oks l ik e t h is :  \n  - ---------------- program 9.3 ----------------------------------- \n / * program 9.3 from ptrtut10.htm   6/13/97 */ \n  # include <stdio.h> \n# include <stdlib.h> \n  i nt main(void) \n{  \n     int **rptr; \n     int *aptr; \n     int *testptr; \n     int k; \n     int nrows = 5;     /* both nrows and ncols could be evaluated */  \n     int ncols = 8;    /* or read in at run time */ \n     int row, col; \n      /* we now allocate the memory for the array */ \n       aptr = malloc(nrows * ncols * sizeof(int)); \n     if (aptr == null) \n     { \n         puts("\\nfailure to allocate room for the array"); \n         exit(0); \n     } \n      /* next we allocate room for the pointers to the rows */ \n       rptr = malloc(nrows * sizeof(int *)); \n     if (rptr == null) \n     { \n         puts("\\nfailure to allocate room for pointers"); \n         exit(0); \n     }\n\n3 9 \n     /* and now we ''point'' the pointers */ \n       for (k = 0; k < nrows; k++) \n     { \n         rptr[k] = aptr + (k * ncols); \n     } \n      /* now we illustrate how the row pointers are incremented */ \n     printf("\\n\\nillustrating how row pointers are incremented"); \n     printf("\\n\\nindex   pointer(hex)  diff.(dec)"); \n       for (row = 0; row < nrows; row++) \n     { \n         printf("\\n%d         %p", row, rptr[row]); \n         if (row > 0) \n         printf("              %d",(rptr[row] - rptr[row-1])); \n     } \n     printf("\\n\\nand now we print out the array\\n"); \n     for (row = 0; row < nrows; row++) \n     { \n         for (col = 0; col < ncols; col++) \n         { \n             rptr[row][col] = row + col; \n             printf("%d ", rptr[row][col]); \n         } \n         putchar(''\\n''); \n     } \n      puts("\\n"); \n      /* and here we illustrate that we are, in fact, dealing with \n        a 2 dimensional array in a contiguous block of memory. */ \n     printf("and now we demonstrate that they are contiguous in \nm emory\\n"); \n      testptr = aptr; \n     for (row = 0; row < nrows; row++) \n     { \n         for (col = 0; col < ncols; col++) \n         { \n             printf("%d ", *(testptr++)); \n         } \n         putchar(''\\n''); \n     } \n      return 0; \n}  \n - ------------ end program 9.3 ----------------- \n \nc onsid er a g ain , t h e n um ber o f c alls  t o  m allo c()  \n      to get room for the array itself      1      call \n     to get room for the array of ptrs     1      call \n                                         ---- \n                          total            2      calls\n\n4 0 \n \nn ow , e a ch  c all t o  m allo c() c re ate s a d ditio nal s p ac e o verh ead  s in ce m allo c() i s  g en era ll y  \ni m ple m en te d  b y t h e o p era tin g s y ste m  f o rm in g a  l i n ked  l is t w hic h  c o nta in s d ata  \nc o ncern in g t h e s iz e o f t h e b lo ck . b ut, m ore  i m porta n tl y , w ith  l a rg e a rr a y s ( s e v era l \nh undre d  r o w s) k eep in g t r a ck  o f w hat n eed s t o  b e f re ed  w hen  t h e t im e c o m es c an  b e m ore  \nc u m bers o m e. t his , c o m bin ed  w ith  t h e c o ntig u ousn ess o f t h e d ata  b lo ck  t h at p erm its  \ni n itia liz atio n t o  a ll z ero es u sin g m em se t() w ould  s e em  t o  m ak e t h e s e co nd a lte rn ativ e t h e \np re fe rre d  o n e.  \na s a  f in al e x am ple  o n m ultid im en sio nal a rra y s w e w ill i llu str a te  t h e d yn am ic  a llo catio n \no f a  t h re e d im en sio nal a rra y . t his  e x am ple  w ill i llu str a te  o ne m ore  t h in g t o  w atc h  w hen  \nd oin g t h is  k in d o f a llo catio n. f or r e aso ns c ite d  a b ove w e w ill u se  t h e a p p ro ach  o utlin ed  i n  \na lte rn ativ e t w o. c onsid er t h e f o llo w in g c o d e:  \n  - ------------------ program 9.4 ------------------------------------ - \n  / * program 9.4 from ptrtut10.htm   6/13/97 */ \n # include <stdio.h> \n# include <stdlib.h> \n# include <stddef.h> \n  i nt x_dim=16; \ni nt y_dim=5; \ni nt z_dim=3; \n  i nt main(void) \n{  \n     char *space; \n     char ***arr3d; \n     int y, z; \n     ptrdiff_t diff; \n      /* first we set aside space for the array itself */ \n       space = malloc(x_dim * y_dim * z_dim * sizeof(char)); \n      /* next we allocate space of an array of pointers, each \n        to eventually point to the first element of a \n        2 dimensional array of pointers to pointers */ \n       arr3d = malloc(z_dim * sizeof(char **)); \n      /* and for each of these we assign a pointer to a newly \n        allocated array of pointers to a row */ \n      for (z = 0; z < z_dim; z++) \n     { \n         arr3d[z] = malloc(y_dim * sizeof(char *)); \n           /* and for each space in this array we put a pointer to \n            the first element of each row in the array space \n            originally allocated */\n\n4 1 \n           for (y = 0; y < y_dim; y++) \n         { \n             arr3d[z][y] = space + (z*(x_dim * y_dim) + y*x_dim); \n         } \n     } \n       /* and, now we check each address in our 3d array to see if \n        the indexing of the arr3d pointer leads through in a \n        continuous manner */ \n       for (z = 0; z < z_dim; z++) \n     { \n         printf("location of array %d is %p\\n", z, *arr3d[z]); \n         for ( y = 0; y < y_dim; y++) \n         { \n             printf("  array %d and row %d starts at %p", z, y, \na rr3d[z][y]); \n             diff = arr3d[z][y] - space; \n             printf("    diff = %d  ",diff); \n             printf(" z = %d  y = %d\\n", z, y); \n         } \n     } \n     return 0; \n}  \n - ------------------ end of prog. 9.4 ---------------------------- \n \ni f  y o u h av e f o llo w ed  t h is  t u to ria l u p t o  t h is  p oin t y o u s h ould  h av e n o p ro ble m  \nd ecip herin g t h e a b ove o n  t h e b asis  o f t h e c o m men ts  a lo ne. t here  a re  a  c o u ple  o f p oin ts  \nt h at s h ould  b e m ad e h ow ev er.  l et©s  s ta rt w ith  t h e l in e w hic h  r e ad s:  \n       arr3d[z][y] = space + (z*(x_dim * y_dim) + y*x_dim); \nn ote  t h at h ere  s p ace i s  a  c h ara cte r p oin te r, w hic h  i s  t h e s a m e t y p e a s a rr3 d [z ][y ].  i t i s  \ni m porta n t t h at w hen  a d din g a n  i n te g er, s u ch  a s t h at o bta in ed  b y e v alu atio n o f t h e \ne x pre ssio n ( z * (x _d im  *  y _d im ) +  y *x _d im ),  t o  a  p oin te r, t h e r e su lt i s  a  n ew  p oin te r \nv alu e. a nd w hen  a ssig n in g p oin te r v alu es t o  p oin te r v aria b le s t h e d ata  t y p es o f t h e v alu e \na n d v aria b le  m ust m atc h .\n\n4 2 \nc h apt er  1 0: p oin te rs t o  f unctio n s \nu p t o  t h is  p oin t w e h av e b een  d is c u ssin g p oin te rs  t o  d ata  o bje cts . c  a ls o  p erm its  t h e \nd ecla ra tio n o f p oin te rs  t o  f u nctio ns. p oin te rs  t o  f u nctio ns h av e a  v arie ty  o f u se s a n d s o m e \no f t h em  w ill b e d is c u sse d  h ere .  \nc onsid er t h e f o llo w in g r e al p ro ble m . y ou w an t t o  w rite  a  f u n ctio n t h at i s  c ap ab le  o f \ns o rtin g v ir tu all y  a n y c o ll e ctio n o f d ata  t h at c an  b e s to re d  i n  a n  a rra y . t his  m ig h t b e a n  \na rra y  o f s tr in gs, o r i n te g ers , o r f lo ats , o r e v en  s tr u ctu re s. t he s o rtin g a lg o rit h m  c an  b e t h e \ns a m e f o r a ll.  f or e x am ple , i t c o uld  b e a  s im ple  b u bble  s o rt a lg o rith m , o r t h e m ore  \nc o m ple x  s h ell o r q uic k  s o rt a lg o rith m . w e©l l u se  a  s im ple  b ubble  s o rt f o r d em onstr a ti o n \np urp ose s.  \ns ed gew ic k  [ 1 ] h as d esc rib ed  t h e b ubble  s o rt u sin g c  c o de b y s e ttin g u p a  f u nctio n w hic h  \nw hen  p asse d  a  p oin te r t o  t h e a rr a y  w ould  s o rt i t.  i f  w e c all t h at f u n ctio n b ub ble (), a  s o rt \np ro gra m  i s  d esc rib ed  b y b ubble _ 1.c , w hic h  f o llo w s:  \n/ *-------------------- bubble_1.c --------------------*/ \n  / * program bubble_1.c from ptrtut10.htm   6/13/97 */ \n  # include <stdio.h> \n i nt arr[10] = { 3,6,1,2,3,8,4,1,7,2}; \n v oid bubble(int a[], int n); \n  i nt main(void) \n{  \n     int i; \n     putchar(''\\n''); \n     for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     bubble(arr,10); \n     putchar(''\\n''); \n       for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     return 0; \n}  \n v oid bubble(int a[], int n) \n{  \n     int i, j, t; \n     for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++)\n\n4 3 \n         { \n             if (a[j-1] > a[j]) \n             { \n                 t = a[j-1]; \n                 a[j-1] = a[j]; \n                 a[j] = t; \n             } \n         } \n     } \n}  \n      / *---------------------- end bubble_1.c -----------------------*/ \n \nt he b ubble  s o rt i s  o ne o f t h e s im ple r s o rts . t he a lg orith m  s c an s t h e a rr a y  f r o m  t h e s e co nd \nt o  t h e l a st e le m en t c o m parin g e ach  e le m en t w ith  t h e o ne w hic h  p re c ed es i t.  i f t h e o ne t h at \np re ced es i t i s  l a rg er t h an  t h e c u rr e n t e le m en t, t h e t w o a re  s w ap ped  s o  t h e l a rg er o ne i s  \nc lo se r t o  t h e e n d o f t h e a rra y . o n t h e f ir s t p ass, t h is  r e su lts  i n  t h e l a rg est e le m en t e n din g \nu p a t t h e e n d o f t h e a rr a y . t he a rr a y  i s  n ow  l im ite d  t o  a ll e le m en ts  e x cep t t h e l a st a n d  t h e \np ro cess r e p eate d . t his  p uts  t h e n ex t l a rg est e le m en t a t a  p oin t p re ced in g t h e l a rg est \ne le m en t. t he p ro cess i s  r e p eate d  f o r a  n um ber o f t im es e q ual t o  t h e n um ber o f e le m en ts  \nm in us 1 . t he e n d r e su lt i s  a  s o rte d  a rra y .  \nh ere  o u r f u nctio n i s  d esig n ed  t o  s o rt a n  a rra y  o f i n te g ers . t hus i n  l in e 1  w e a re  \nc o m parin g i n te g ers  a n d i n  l in es 2  t h ro ugh  4  w e a re  u sin g t e m pora ry  i n te g er s to ra g e t o  \ns to re  i n te g ers . w hat w e w an t t o  d o n ow  i s  s e e i f  w e c an  c o nvert t h is  c o d e s o  w e c an  u se  \na n y d ata  t y p e, i .e . n ot b e r e str ic te d  t o  i n te g ers .  \na t t h e s a m e t im e w e d on ©t  w an t t o  h av e t o  a n aly ze o ur a lg o rith m  a n d t h e c o de a sso cia te d  \nw ith  i t e ach  t im e w e u se  i t. w e s ta rt b y r e m ovin g t h e c o m paris o n f ro m  w ith in  t h e \nf u nctio n b ubble () s o  a s t o  m ak e i t r e la tiv ely  e asy  t o  m odif y  t h e c o m paris o n f u nctio n \nw ith out h av in g t o  r e -w rit e  p ortio ns r e la te d  t o  t h e a ctu al a lg o rith m . t his  r e su lts  i n  \nb ubble _ 2.c :  \n/ *---------------------- bubble_2.c -------------------------*/ \n  / * program bubble_2.c from ptrtut10.htm   6/13/97 */ \n      /* separating the comparison function */ \n # include <stdio.h> \n i nt arr[10] = { 3,6,1,2,3,8,4,1,7,2}; \n  v oid bubble(int a[], int n); \ni nt compare(int m, int n); \n  i nt main(void) \n{  \n     int i; \n     putchar(''\\n'');\n\n4 4 \n     for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     bubble(arr,10); \n     putchar(''\\n''); \n       for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     return 0; \n}  \n v oid bubble(int a[], int n) \n  {  \n     int i, j, t; \n     for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++) \n         { \n             if (compare(a[j-1], a[j])) \n             { \n                 t = a[j-1]; \n                 a[j-1] = a[j]; \n                 a[j] = t; \n             } \n         } \n     } \n}  \n  i nt compare(int m, int n) \n{  \n     return (m > n); \n}  \n/ *--------------------- end of bubble_2.c -----------------------*/ \nif  o ur g o al i s  t o  m ak e o ur s o rt r o utin e d ata  t y p e i n dep en den t, o ne w ay  o f d oin g t h is  i s  t o  \nu se  p oin te rs  t o  t y p e v oid  t o  p oin t t o  t h e d ata  i n ste ad  o f u sin g t h e i n te g er d ata  t y p e. a s a  \ns ta rt i n  t h at d ir e ctio n l e t©s  m odif y  a  f e w  t h in gs i n  t h e a b ove s o  t h at p oin te rs  c an  b e u se d . \nt o b eg in  w ith , w e©l l s tic k  w ith  p oin te rs  t o  t y p e i n te g er.  \n    / *----------------------- bubble_3.c -------------------------*/ \n  / * program bubble_3.c from ptrtut10.htm    6/13/97 */ \n # include <stdio.h> \n i nt arr[10] = { 3,6,1,2,3,8,4,1,7,2}; \n  v oid bubble(int *p, int n); \ni nt compare(int *m, int *n); \n  i nt main(void) \n{\n\n4 5 \n     int i; \n     putchar(''\\n''); \n       for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     bubble(arr,10); \n     putchar(''\\n''); \n      for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     return 0; \n}  \n  v oid bubble(int *p, int n) \n{  \n     int i, j, t; \n     for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++) \n         { \n             if (compare(&p[j-1], &p[j])) \n             { \n                 t = p[j-1]; \n                 p[j-1] = p[j]; \n                 p[j] = t; \n             } \n         } \n     } \n}  \n i nt compare(int *m, int *n) \n{  \n     return (*m > *n); \n}  \n / *------------------ end of bubble3.c -------------------------*/ \n \nn ote  t h e c h an ges. w e a re  n ow  p assin g a  p oin te r t o  a n  i n te g er ( o r a rra y  o f i n te g ers ) t o  \nb ubb le (). a nd f ro m  w ith in  b ubble  w e a re  p assin g p oin te rs  t o  t h e e le m en ts  o f t h e a rr a y  \nt h at w e w an t t o  c o m pare  t o  o ur c o m paris o n f u ncti o n. a nd, o f c o urs e  w e a re  d ere fe re n cin g \nt h ese  p oin te r i n  o ur c o m pare() f u n ctio n i n  o rd er t o  m ak e t h e a ctu al c o m paris o n. o ur n ex t \ns te p  w ill b e t o  c o nvert t h e p oin te rs  i n  b ubble () t o  p oin te rs  t o  t y p e v oid  s o  t h at t h at \nf u nctio n w ill b eco m e m ore  t y p e i n se n sitiv e. t his  i s  s h ow n i n  b ubble _ 4.  \n   / *------------------ bubble_4.c ----------------------------*/ \n / * program bubble_4.c from ptrtut10,htm   6/13/97 */ \n  # include <stdio.h>\n\n4 6 \ni nt arr[10] = { 3,6,1,2,3,8,4,1,7,2}; \n  v oid bubble(int *p, int n); \ni nt compare(void *m, void *n); \n  i nt main(void) \n{  \n     int i; \n     putchar(''\\n''); \n      for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     bubble(arr,10); \n     putchar(''\\n''); \n       for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     return 0; \n}  \n v oid bubble(int *p, int n) \n{  \n     int i, j, t; \n     for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++) \n         { \n             if (compare((void *)&p[j-1], (void *)&p[j])) \n             { \n                 t = p[j-1]; \n                 p[j-1] = p[j]; \n                 p[j] = t; \n             } \n         } \n     } \n}  \n  i nt compare(void *m, void *n) \n{  \n     int *m1, *n1; \n     m1 = (int *)m; \n     n1 = (int *)n; \n     return (*m1 > *n1); \n}  \n  / *------------------ end of bubble_4.c ---------------------*/ \n \nn ote  t h at, i n  d oin g t h is , i n  c o m pare() w e h ad  t o  i n tr o duce t h e c astin g o f t h e v oid  p oin te r \nt y p es p ass e d  t o  t h e a ctu al t y p e b ein g s o rte d . b ut,  a s w e©l l s e e l a te r t h at©s  o k ay . a nd s in ce \nw hat i s  b ein g p asse d  t o  b ubble () i s  s till  a  p oin te r t o  a n  a rr a y  o f i n te g ers , w e h ad  t o  c a st \nt h ese  p oin te rs  t o  v oid  p oin te rs  w hen  w e p asse d  t h em  a s p ara m ete rs  i n  o ur c all t o  \nc o m pare().\n\n4 7 \nw\ne n ow  a d dre ss t h e p ro b le m  o f w hat w e p ass t o  b ubble (). w e w an t t o  m ak e t h e f ir s t \np ara m ete r o f t h at f u n ctio n a  v oid  p oin te r a ls o . b ut, t h at m ean s t h at w ith in  b ubble () w e \nn eed  t o  d o s o m eth in g a b out t h e v aria b le  t ,  w hic h  i s  c u rre n tl y  a n  i n te g er. a ls o , w here  w e \nu se  t  =  p [j-1 ]; t h e t y p e o f p [j-1 ] n eed s t o  b e k now n i n  o rd er t o  k now  h ow  m an y b yte s t o  \nc o p y t o  t h e v aria b le  t  ( o r w hate v er w e r e p la c e t  w ith ).  \nc urre n tl y , i n  b ubble _ 4.c , k now le d ge w ith in  b ubble () a s t o  t h e t y p e o f t h e d ata  b ein g \ns o rte d  ( a n d h en ce t h e s iz e o f e a ch  i n div id ual e le m en t)  i s  o bta in ed  f ro m  t h e f a ct t h at t h e \nf ir s t p ara m ete r i s  a  p oin te r t o  t y p e i n te g er.  i f  w e a re  g o in g t o  b e a b le  t o  u se  b ubb le () t o  \ns o rt a n y t y p e o f d ata ,  w e n eed  t o  m ak e t h at p oin te r a  p oin te r t o  t y p e v oid . b ut, i n  d oin g s o  \nw e a re  g o in g t o  l o se  i n fo rm atio n c o nce rn in g t h e s iz e o f i n div id ual e le m en ts  w ith in  t h e \na rra y . s o, i n  b ubble _ 5.c  w e w ill a d d a  s e p ara te  p ara m ete r t o  h an dle  t h is  s iz e i n fo rm atio n.  \nt hese  c h an ges, f r o m  b ubble 4 .c  t o  b ubble 5 .c  a re , p erh ap s, a  b it m ore  e x te n siv e t h an  t h ose  \nw e h av e m ad e i n  t h e p ast. s o, c o m pare  t h e t w o m odule s c are fu ll y  f o r d if f e re n ces.  \n/ *---------------------- bubble5.c ---------------------------*/ \n  / * program bubble_5.c from ptrtut10.htm    6/13/97 */ \n  # include <stdio.h> \n# include <string.h> \n  l ong arr[10] = { 3,6,1,2,3,8,4,1,7,2}; \n  v oid bubble(void *p, size_t width, int n); \ni nt compare(void *m, void *n); \n  i nt main(void) \n{  \n     int i; \n     putchar(''\\n''); \n      for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     bubble(arr, sizeof(long), 10); \n     putchar(''\\n''); \n       for (i = 0; i < 10; i++) \n     { \n         printf("%ld ", arr[i]); \n     } \n       return 0; \n}  \n v oid bubble(void *p, size_t width, int n) \n{  \n     int i, j; \n     unsigned char buf[4]; \n     unsigned char *bp = p;\n\n4 8 \n       for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++) \n         { \n             if (compare((void *)(bp + width*(j-1)), \n                         (void *)(bp + j*width)))  /* 1 */ \n             { \n/ *              t = p[j-1];   */ \n                 memcpy(buf, bp + width*(j-1), width); \n/ *              p[j-1] = p[j];   */ \n                 memcpy(bp + width*(j-1), bp + j*width , width); \n/ *              p[j] = t;   */ \n                 memcpy(bp + j*width, buf, width); \n             } \n         } \n     } \n}  \n  i nt compare(void *m, void *n) \n{  \n     long *m1, *n1; \n     m1 = (long *)m; \n     n1 = (long *)n; \n     return (*m1 > *n1); \n}  \n / *--------------------- end of bubble5.c ---------------------*/ \n \nn ote  t h at i  h av e c h an ged  t h e d ata  t y p e o f t h e a rr a y  f ro m  i n t t o  l o n g t o  i ll u str a te  t h e \nc h an ges n eed ed  i n  t h e c o m pare() f u nctio n. w ith in  b ubb le () i ©v e d one a w ay  w ith  t h e \nv aria b le  t  ( w hic h  w e w ou ld  h av e h ad  t o  c h an ge f ro m  t y p e i n t t o  t y p e l o n g). i  h av e a d d ed  \na  b uffe r o f s iz e 4  u nsig n ed  c h ara cte rs , w hic h  i s  t h e s iz e n eed ed  t o  h old  a  l o ng ( th is  w ill \nc h an ge a g ain  i n  f u tu re  m odif ic atio ns t o  t h is  c o de). t he u nsig n ed  c h ara cte r p oin te r * b p i s  \nu se d  t o  p oin t t o  t h e b ase  o f t h e a rr a y  t o  b e s o rte d ,  i .e . t o  t h e f ir s t e le m en t o f t h at a rra y .  \nw e a ls o  h ad  t o  m odif y  w hat w e p asse d  t o  c o m pare(), a n d h o w  w e d o t h e s w ap pin g o f \ne le m en ts  t h at t h e c o m paris o n i n dic ate s n eed  s w ap pin g. u se  o f m em cp y() a n d p oin te r \nn ota tio n i n ste ad  o f a rr a y  n ota tio n w ork  t o w ard s t h is  r e d uctio n i n  t y p e s e n sitiv it y .  \na gain , m ak in g a  c are fu l c o m paris o n o f b ubble 5 .c  w ith  b ubble 4 .c  c an  r e su lt i n  i m pro v ed  \nu nders ta n din g o f w hat i s  h ap pen in g a n d w hy.  \nw e m ove n ow  t o  b ubble 6 .c  w here  w e u se  t h e s a m e f u nctio n b ubble () t h at w e u se d  i n  \nb ubble 5 .c  t o  s o rt s tr in gs i n ste ad  o f l o n g i n te g ers .  o f c o urs e  w e h av e t o  c h an ge t h e \nc o m paris o n f u nctio n s in ce t h e m ean s b y w hic h  s tr in gs a re  c o m pare d  i s  d if f e re n t f ro m  t h at \nb y w hic h  l o n g i n te g ers  a re  c o m pare d . a nd,i n  b ubb le 6 .c  w e h av e d ele te d  t h e l in es w ith in  \nb ubb le () t h at w ere  c o m men te d  o ut i n  b ubble 5 .c .   \n / *--------------------- bubble6.c ---------------------*/ \n/ * program bubble_6.c from ptrtut10.htm   6/13/97 */\n\n4 9 \n  # include <stdio.h> \n# include <string.h> \n  # define max_buf 256 \n  c har arr2[5][20] = {  "mickey mouse", \n                       "donald duck", \n                       "minnie mouse", \n                       "goofy", \n                       "ted jensen" }; \n  v oid bubble(void *p, int width, int n); \ni nt compare(void *m, void *n); \n  i nt main(void) \n{  \n     int i; \n     putchar(''\\n''); \n      for (i = 0; i < 5; i++) \n     { \n         printf("%s\\n", arr2[i]); \n     } \n     bubble(arr2, 20, 5); \n     putchar(''\\n\\n''); \n       for (i = 0; i < 5; i++) \n     { \n         printf("%s\\n", arr2[i]); \n     } \n     return 0; \n}  \n v oid bubble(void *p, int width, int n) \n{  \n     int i, j, k; \n     unsigned char buf[max_buf]; \n     unsigned char *bp = p; \n       for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++) \n         { \n           k = compare((void *)(bp + width*(j-1)), (void *)(bp + \nj *width)); \n           if (k > 0) \n             { \n              memcpy(buf, bp + width*(j-1), width); \n              memcpy(bp + width*(j-1), bp + j*width , width); \n              memcpy(bp + j*width, buf, width); \n             } \n         } \n     } \n}  \n i nt compare(void *m, void *n)\n\n5 0 \n{  \n     char *m1 = m; \n     char *n1 = n; \n     return (strcmp(m1,n1)); \n}  \n  / *------------------- end of bubble6.c ---------------------*/ \n \nb ut, t h e f a ct t h at b ubble ()  w as u nch an ged  f ro m  t h at u se d  i n  b ubble 5 .c  i n dic ate s t h at t h at \nf u nctio n i s  c ap ab le  o f s o rtin g a  w id e v arie ty  o f d ata  t y p es. w hat i s  l e ft t o  d o i s  t o  p ass t o  \nb ubb le () t h e n am e o f t h e c o m paris o n f u nctio n w e w an t t o  u se  s o  t h at i t c an  b e t r u ly  \nu niv ers a l. j u st a s t h e n am e o f a n  a rra y  i s  t h e a d dre ss o f t h e f ir s t e le m en t o f t h e a rr a y  i n  \nt h e d ata  s e g m en t, t h e n am e o f a  f u n ctio n d eca y s i n to  t h e a d dre ss o f t h at f u nctio n i n  t h e \nc o de s e g m en t. t hus w e n eed  t o  u se  a  p oin te r t o  a  f u nctio n.  i n  t h is  c ase  t h e c o m paris o n \nf u nctio n.  \np oin te rs  t o  f u nctio ns m ust m atc h  t h e f u nctio ns p oin te d  t o  i n  t h e n um ber a n d t y p es o f t h e \np ara m ete rs  a n d t h e t y p e o f t h e r e tu rn  v alu e.  i n  o u r c ase ,  w e d ecla re  o ur f u nctio n p oin te r \na s:  \n    int (*fptr)(const void *p1, const void *p2); \n \nn ote  t h at w ere  w e t o  w rite :  \n       int *fptr(const void *p1, const void *p2); \n \nw e w ould  h av e a  f u n ctio n p ro to ty p e f o r a  f u nctio n w hic h  r e tu rn ed  a  p oin te r t o  t y p e i n t. \nt hat i s  b ecau se  i n  c  t h e p are n th esis  ( ) o pera to r h av e a  h ig h er p re c ed en ce t h an  t h e p oin te r \n*  o pera to r.  b y p uttin g t h e p are n th esis  a ro und t h e s tr in g ( * fp tr ) w e i n dic ate  t h at w e a re  \nd ecla rin g a  f u nctio n p oin te r.  \nw e n ow  m odif y  o ur d ecla ra tio n o f b ubble () b y a d din g, a s i ts  4 th  p ara m ete r, a  f u ncti o n \np oin te r o f t h e p ro per t y p e.  i t©s  f u n ctio n p ro to ty p e b eco m es:  \n     void bubble(void *p, int width, int n, \n                 int(*fptr)(const void *, const void *)); \n \nw hen  w e c all t h e b ubble (), w e i n se rt t h e n am e o f t h e c o m paris o n f u nctio n t h at w e w an t \nt o  u se . b ubble 7 .c  i llu str a te  h ow  t h is  a p pro ach  p erm its  t h e u se  o f t h e s a m e b ubb le () \nf u nctio n f o r s o rtin g d if fe re n t t y p es o f d ata .  \n    / *------------------- bubble7.c ------------------*/ \n  / * program bubble_7.c from ptrtut10.htm  6/10/97 */ \n # include <stdio.h> \n# include <string.h> \n # define max_buf 256\n\n5 1 \nl ong arr[10] = { 3,6,1,2,3,8,4,1,7,2}; \nc har arr2[5][20] = {  "mickey mouse", \n                       "donald duck", \n                       "minnie mouse", \n                       "goofy", \n                       "ted jensen" }; \n  v oid bubble(void *p, int width, int n, \n             int(*fptr)(const void *, const void *)); \ni nt compare_string(const void *m, const void *n); \ni nt compare_long(const void *m, const void *n); \n i nt main(void) \n{  \n     int i; \n     puts("\\nbefore sorting:\\n"); \n      for (i = 0; i < 10; i++)               /* show the long ints */ \n     { \n         printf("%ld ",arr[i]); \n     } \n     puts("\\n"); \n       for (i = 0; i < 5; i++)                  /* show the strings */ \n     { \n         printf("%s\\n", arr2[i]); \n     } \n     bubble(arr, 4, 10, compare_long);          /* sort the longs */ \n     bubble(arr2, 20, 5, compare_string);     /* sort the strings */ \n     puts("\\n\\nafter sorting:\\n"); \n      for (i = 0; i < 10; i++)             /* show the sorted longs */  \n     { \n         printf("%d ",arr[i]); \n     } \n     puts("\\n"); \n       for (i = 0; i < 5; i++)            /* show the sorted strings */  \n     { \n         printf("%s\\n", arr2[i]); \n     } \n     return 0; \n}  \n v oid bubble(void *p, int width, int n, \n             int(*fptr)(const void *, const void *)) \n{  \n     int i, j, k; \n     unsigned char buf[max_buf]; \n     unsigned char *bp = p; \n       for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++) \n         { \n             k = fptr((void *)(bp + width*(j-1)), (void *)(bp + \nj *width));\n\n5 2 \n             if (k > 0) \n             { \n                 memcpy(buf, bp + width*(j-1), width); \n                 memcpy(bp + width*(j-1), bp + j*width , width); \n                 memcpy(bp + j*width, buf, width); \n             } \n         } \n     } \n}  \n  i nt compare_string(const void *m, const void *n) \n{  \n     char *m1 = (char *)m; \n     char *n1 = (char *)n; \n     return (strcmp(m1,n1)); \n}  \n  i nt compare_long(const void *m, const void *n) \n{  \n     long *m1, *n1; \n     m1 = (long *)m; \n     n1 = (long *)n; \n     return (*m1 > *n1); \n}  \n  / *----------------- end of bubble7.c -----------------*/ \n \nr efe re n ces f o r c hap te r 1 0: \n1 .  "a lg o rith m s i n  c " \nr obert s ed gew ic k  \na ddis o n-w esle y  \ni s b n  0 -2 01-5 1425 -7\n\n5 3 \ne pil o g  \ni h av e w ritte n  t h e p re ced in g m ate ria l t o  p ro vid e a n  i n tr o ductio n t o  p oin te rs  f o r \nn ew co m ers  t o  c .  i n  c , t h e m ore  o ne u nd ers ta n ds a b out p oin te rs  t h e g re ate r f le x ib ilit y  o n e \nh as i n  t h e w ritin g o f c o de. t he a b ove e x pan ds o n m y f ir s t e ffo rt a t t h is  w hic h  w as e n title d  \np tr _ help .t x t a n d f o und i n  a n  e arly  v ers io n o f b ob s to ut©s  c o lle ctio n o f c  c o d e s n ip pe ts. \nt he c o nte n t i n  t h is  v ers io n h as b een  u pd ate d  f ro m  t h at i n  p t r tu to t.z ip  i n clu ded  i n  \ns n ip 9510.z ip .  \ni  a m  a lw ay s r e ad y t o  a cc ep t c o nstr u ctiv e c ritic is m  o n t h is  m ate ria l, o r r e v ie w  r e q uests  f o r \nt h e a d ditio n o f o th er r e le v an t m ate ria l. t here fo re ,  i f  y o u h av e q uestio ns, c o m men ts , \nc ritic is m s, e tc . c o ncern in g t h at w hic h  h as b een  p re se n te d ,  i  w ould  g re atl y  a p pre cia te  y o u r \nc o nta ctin g m e v ia  e m ail m e a t t je n se n @ ix .n etc o m .c o m .', 7, 'sunita williams', 9, '2017-02-08', 'letter', 'L', 'M', 55, 13, 0);
INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(3, 1, '324', '2017-02-06', 2, 1, 0, 53, 0, '1486540780.pdf', 7, '1  \na  t u to ria l o n p o in ter s a nd a rr ays i n  c   \nby  t ed  j e n se n   \nv ers io n 1 .2  ( p d f v ers io n)\n \ns ep t. 2 003 \nt his  m ate ria l i s  h ere b y p la ced  i n  t h e p ublic  d om ain   \na vaila b le  i n  v ario us f o rm ats  v ia   \nh ttp ://p w eb .n etc o m .c o m /~ tje n se n /p tr /c p oin t.h tm  \n \nt a ble o f c o n ten ts \npr efa ce  2 \ni n tr o ductio n  4 \nc h apt er  1 : w hat i s  a  p oin te r?   5 \nc h apt er  2 : p oin te r t y p es a n d a rra ys  9 \nc h apt er  3 : p oin te rs a n d s tr in gs  14 \nc h apt er  4 : m ore o n  s tr in gs  19 \nc h apt er  5 : p oin te rs a n d s tr u ctu res  22 \nc h apt er  6 : s om e m ore o n  s tr in gs, a n d  a rra ys o f s tr in gs  26 \nc h apt er  7 : m ore o n  m ult i- d im en sio n al a rra y s  30 \nc h apt er  8 : p oin te rs t o  a rra ys  32 \nc h apt er  9 : p oin te rs a n d d yn am ic  a llo ca tio n  o f m em ory   34 \nc h apt er  1 0: p oin te rs t o  f unctio n s  42 \ne pil o g  53\n\n2  \np r efa ce  \nt his  d ocu m en t i s  i n te n ded  t o  i n tr o duce p oin te rs  t o  b eg in nin g p ro gra m mers  i n  t h e c  \np ro gra m min g l a n gu ag e.  o ver s e v era l y ears  o f r e a d in g a n d c o ntr ib utin g t o  v ario us \nc o nfe re n ces o n c  i n clu din g t h ose  o n t h e f id on et a n d u se n et,  i  h av e n ote d  a  l a rg e \nn um ber o f n ew co m ers  t o  c  a p pear t o  h av e a  d if fic u lt t im e i n  g ra sp in g t h e f u ndam en ta ls  \no f p oin te rs .  i  t h ere fo re  u nderto ok t h e t a sk  o f t r y in g t o  e x pla in  t h em  i n  p la in  l a n gu ag e w ith  \nl o ts  o f e x am ple s. \nt he f ir s t v ers io n o f t h is  d ocu m en t w as p la c ed  i n  t h e p ublic  d om ain , a s i s  t h is  o ne.  i t w as \np ic k ed  u p b y b ob s to ut w ho i n clu ded  i t a s a  f ile  c alle d  p t r -h elp.t x t i n  h is  w id ely  \nd is tr ib ute d  c o lle ctio n o f s n ip pe ts. s in ce t h at o rig in al 1 995 r e le ase ,  i  h av e a d ded  a  \ns ig n if ic an t a m ount o f m ate ria l a n d m ad e s o m e m in or c o rr e ctio ns i n  t h e o rig in al w ork . \ni  s u bse q uen tl y  p oste d  a n  h tm l v ers io n a ro und 1 998 o n m y w eb site  a t: \n \nh ttp ://p w eb .n etc o m .c o m /~ tje n se n /p tr /c p oin t.h tm  \na fte r n um ero us r e q u ests ,  i ’ v e f in all y  c o m e o ut w ith  t h is  p d f v ers io n w hic h  i s  i d en ti c al \nt o  t h at h tm l v ers io n c ite d  a b ove,  a n d w hic h  c an  b e o bta in ed  f ro m  t h at s a m e w eb  s ite .  \na ck n ow le d gem en ts :  \nt here  a re  s o  m an y p eo ple  w ho h av e u nkno w in gly  c o ntr ib ute d  t o  t h is  w ork  b ecau se  o f t h e \nq uestio ns t h ey  h av e p ose d  i n  t h e f id on et c  e ch o, o r t h e u se n et n ew sg ro u p \nc o m p.l a n g.c , o r s e v era l o th er c o nfe re n ces i n  o th er n etw ork s, t h at i t w ould  b e i m possib le  \nt o  l is t t h em  a ll. s pecia l t h an ks g o  t o  b ob s to ut w ho w as k in d e n ou gh  t o  i n clu de t h e f ir s t \nv ers io n o f t h is  m ate ria l i n  h is  s n ip pe ts f ile .  \na bou t t h e a uth or:  \nt ed  j e n se n  i s  a  r e tir e d  e le ctr o nic s e ngin eer w ho w ork ed  a s a  h ard w are  d esig n er o r \nm an ag er o f h ard w are  d esig n ers  i n  t h e f ie ld  o f m ag netic  r e co rd in g. p ro gra m min g h as b een  \na  h obb y o f h is  o ff a n d o n  s in ce 1 968 w hen  h e l e arn ed  h ow  t o  k ey p unch  c ard s f o r \ns u bm is sio n t o  b e r u n o n a  m ain fra m e. ( t he m ain fra m e h ad  6 4k  o f m ag n eti c  c o re  \nm em ory !).  \nu se  o f t h is  m ate ria l:  \ne very th in g c o nta in ed  h ere in  i s  h ere b y r e le ase d  t o  t h e p ublic  d om ain . a ny p ers o n m ay  \nc o p y o r d is tr ib ute  t h is  m ate ria l i n  a n y m an ner t h ey  w is h . t he o nly  t h in g i  a sk  i s  t h at i f  \nt h is  m ate ria l i s  u se d  a s a  t e ach in g a id  i n  a  c la ss,  i  w ould  a p pre cia te  i t i f  i t w ere  d is tr ib ute d  \ni n  i ts  e n tir e ty , i .e . i n clu din g a ll c h ap te rs , t h e p re fa ce a n d t h e i n tr o du ctio n.  i  w ould  a ls o  \na p pre cia te  i t i f , u nder s u ch  c ir c u m sta n ces, t h e i n str u cto r o f s u ch  a  c la ss w ou ld  d ro p m e a\n\n3  \nn\note  a t o ne o f t h e a d dre ss e s b elo w  i n fo rm in g m e o f t h is .  i  h av e w ritte n  t h is  w ith  t h e h ope \nt h at i t w ill b e u se fu l t o  o th ers  a n d s in ce  i ©m  n ot a sk in g a n y f in an cia l r e m un era tio n, t h e \no nly  w ay  i  k now  t h at i  h av e a t l e ast p artia ll y  r e ac h ed  t h at g o al i s  v ia  f e ed b ack  f ro m  t h ose  \nw ho f in d t h is  m ate ria l u se fu l. \nb y t h e w ay ,  y o u n eed n ©t  b e a n  i n str u cto r o r t e ach er t o  c o nta ct m e.  i  w ould  a p pre cia te  a  \nn ote  f ro m  a n yo ne\n w ho f in ds t h e m ate ria l u se fu l, o r w ho h as c o nstr u ctiv e c ritic is m  t o  \no ffe r.  i ©m  a ls o  w illin g t o  a n sw er q u estio ns s u bm itte d  b y e m ail a t t h e a d d re sse s s h ow n \nb elo w . \nt ed  j e n se n   \nr ed w ood c it y , c alif o rn ia  \nt je n se n @ ix .n etc o m .c o m   \nj u ly  1 998\n\n4  \ni n tr o du ctio n \nif  y o u w an t t o  b e p ro fic ie n t i n  t h e w ritin g o f c o d e i n  t h e c  p ro gra m min g l a n gu ag e,  y o u \nm ust h av e a  t h oro u gh  w ork in g k now le d ge o f h ow  t o  u se  p oin te rs . u nfo rtu n ate ly , c  \np oin te rs  a p pea r t o  r e p re se n t a  s tu m blin g b lo ck  t o  n ew co m ers , p artic u la rly  t h ose  c o m in g \nf ro m  o th er c o m pute r l a n gu ag es s u ch  a s f ortr a n , p asc al o r b asic .  \nt o a id  t h ose  n ew co m ers  i n  t h e u nders ta n din g o f p oin te rs  i  h av e w ritte n  t h e f o llo w in g \nm ate ria l. t o g et t h e m ax im um  b en efit f ro m  t h is  m ate ria l,  i  f e el i t i s  i m porta n t t h at t h e \nu se r b e a b le  t o  r u n t h e c o de i n  t h e v ario us l is tin gs c o nta in ed  i n  t h e a rtic le .  i  h av e \na tte m pte d , t h ere fo re , t o  k eep  a ll c o d e a nsi c o m plia n t s o  t h at i t w ill w ork  w ith  a n y a nsi \nc o m plia n t c o m pile r.  i  h av e a ls o  t r ie d  t o  c a re fu ll y  b lo ck  t h e c o de w ith in  t h e t e x t. t hat \nw ay , w ith  t h e h elp  o f a n  a sc ii t e x t e d ito r,  y o u c a n  c o p y a  g iv en  b lo ck  o f c o de t o  a  n ew  \nf ile  a n d c o m pile  i t o n y o ur s y ste m .  i  r e co m men d t h at r e ad ers  d o t h is  a s i t w ill h elp  i n  \nu nders ta n din g t h e m ate ria l.\n\n5  \nc h apt er  1 : w hat i s  a  p oin te r?   \no ne o f t h ose  t h in gs b eg in ners  i n  c  f in d d if fic u lt i s  t h e c o ncep t o f p oin te rs . t he p urp o se  \no f t h is  t u to ria l i s  t o  p ro vid e a n  i n tr o ductio n t o  p oin te rs  a n d t h eir  u se  t o  t h ese  b eg in ners .  \ni  h av e f o und t h at o fte n  t h e m ain  r e aso n b eg in ners  h av e a  p ro ble m  w ith  p oin te rs  i s  t h at \nt h ey  h av e a  w eak  o r m in im al f e elin g f o r v aria b le s, ( a s t h ey  a re  u se d  i n  c ).  t hus w e s ta rt \nw ith  a  d is c u ssio n o f c  v aria b le s i n  g en era l.  \na  v aria b le  i n  a  p ro gra m  i s  s o m eth in g w ith  a  n am e, t h e v alu e o f w hic h  c an  v ary . t he w ay  \nt h e c o m pile r a n d l in ker h an dle s t h is  i s  t h at i t a ssig n s a  s p ecif ic  b lo ck  o f m em ory  w ith in  \nt h e c o m pute r t o  h old  t h e v alu e o f t h at v aria b le . t he s iz e o f t h at b lo ck  d ep en ds o n t h e \nr a n ge o ver w hic h  t h e v aria b le  i s  a llo w ed  t o  v ary .  f or e x am ple , o n p c ©s  t h e s iz e o f a n  \ni n te g er v aria b le  i s  2  b yte s, a n d t h at o f a  l o n g i n te g er i s  4  b yte s.  i n  c  t h e s iz e o f a  v aria b le  \nt y p e s u ch  a s a n  i n te g er n eed  n ot b e t h e s a m e o n a ll t y p es o f m ach in es.  \nw hen  w e d ecla re  a  v aria b le  w e i n fo rm  t h e c o m pile r o f t w o t h in gs, t h e n am e o f t h e \nv aria b le  a n d t h e t y p e o f t h e v aria b le .  f or e x am ple , w e d ecla re  a  v aria b le  o f t y p e i n te g er \nw ith  t h e n am e k  b y w ritin g:  \n     int k;  \no n s e ein g t h e " in t"  p art o f t h is  s ta te m en t t h e c o m pile r s e ts  a sid e 2  b yte s o f m em ory  ( o n a  \np c ) t o  h old  t h e v alu e o f t h e i n te g er.  i t a ls o  s e ts  u p a  s y m bol t a b le .  i n  t h at t a b le  i t a d ds t h e \ns y m bol k  a n d t h e r e la tiv e a d dre ss i n  m em ory  w here  t h ose  2  b yte s w ere  s e t a sid e.  \nt hus, l a te r i f  w e w rite :  \n     k = 2;  \nw e e x pect t h at, a t r u n t im e w hen  t h is  s ta te m en t i s  e x ecu te d , t h e v alu e 2  w il l b e p la ced  i n  \nt h at m em ory  l o catio n r e se rv ed  f o r t h e s to ra g e o f t h e v alu e o f k .  i n  c  w e r e fe r t o  a  \nv aria b le  s u ch  a s t h e i n te g er k  a s a n  " o bje ct" .  \ni n  a  s e n se  t h ere  a re  t w o " v alu es"  a sso cia te d  w ith  t h e o bje ct k . o ne i s  t h e v alu e o f t h e \ni n te g er s to re d  t h ere  ( 2  i n  t h e a b ove e x am ple ) a n d t h e o th er t h e " v alu e" o f t h e m em ory  \nl o catio n, i .e ., t h e a d dre ss o f k . s om e t e x ts  r e fe r t o  t h ese  t w o v alu es w ith  t h e n om en cla tu re  \nr v a lu e ( rig h t v alu e, p ro n ounced  " a re  v alu e") a n d l v a lu e ( le ft v alu e, p ro nou nced  " e l \nv alu e") r e sp ectiv ely .  \ni n  s o m e l a n gu ag es, t h e l v alu e i s  t h e v alu e p erm itte d  o n t h e l e ft s id e o f t h e a ssig n m en t \no pera to r ©= ©  ( i.e . t h e a d dre ss w here  t h e r e su lt o f e v alu atio n o f t h e r ig h t s id e e n ds u p).  t he \nr v alu e i s  t h at w hic h  i s  o n  t h e r ig h t s id e o f t h e a ssig n m en t s ta te m en t, t h e 2  a b ove. r valu es \nc an not b e u se d  o n t h e l e ft s id e o f t h e a ssig n m en t s ta te m en t. t hus: 2  =  k ; i s  i lle g al.\n\n6  \na\nctu all y , t h e a b ove d efin itio n o f " lv alu e" i s  s o m ew hat m odif ie d  f o r c . a cco rd in g t o  \nk & r i i ( p ag e 1 97 ): [ 1 ]  \n" a n o bje ct i s  a  n am ed  r e g io n o f s to ra g e; a n  l v a lu e i s  a n  e x pre ssio n \nr e fe rrin g t o  a n  o bje ct."   \nh ow ev er, a t t h is  p oin t, t h e d efin itio n o rig in all y  c it e d  a b ove i s  s u ffic ie n t. a s w e b eco m e \nm ore  f a m ilia r w ith  p oin te rs  w e w ill g o  i n to  m ore  d eta il o n t h is .  \no kay , n ow  c o nsid er:  \n    int j, k;  \n       k = 2;  \n     j = 7;    <-- line 1  \n     k = j;    <-- line 2  \nin  t h e a b ove, t h e c o m pile r i n te rp re ts  t h e j  i n  l in e 1  a s t h e a d dre ss o f t h e v aria b le  j  ( its  \nl v alu e) a n d c re ate s c o de t o  c o p y t h e v alu e 7  t o  t h at a d dre ss.  i n  l in e 2 , h ow ev er, t h e j  i s  \ni n te rp re te d  a s i ts  r v alu e ( s in ce i t i s  o n t h e r ig h t h an d s id e o f t h e a ssig n m en t o pera to r ©= ©) . \nt hat i s , h ere  t h e j  r e fe rs  t o  t h e v alu e s to re d  a t t h e m em ory  l o catio n s e t a sid e f o r j , i n  t h is  \nc ase  7 . s o, t h e 7  i s  c o pie d  t o  t h e a d dre ss d esig n ate d  b y t h e l v alu e o f k .  \ni n  a ll o f t h ese  e x am ple s,  w e a re  u sin g 2  b yte  i n te g ers  s o  a ll c o p yin g o f r v alu es f ro m  o ne \ns to ra g e l o catio n t o  t h e o th er i s  d one b y c o p yin g 2  b yte s. h ad  w e b een  u sin g l o n g i n te g ers , \nw e w ould  b e c o p yin g 4  b yte s.  \nn ow , l e t©s  s a y  t h at w e h av e a  r e aso n f o r w an tin g a  v aria b le  d esig n ed  t o  h old  a n  l v alu e ( a n  \na d dre ss). t he s iz e r e q uir e d  t o  h old  s u ch  a  v alu e d ep en ds o n t h e s y ste m . o n o ld er d esk  t o p \nc o m pute rs  w ith  6 4k  o f m em ory  t o ta l, t h e a d dre ss o f a n y p oin t i n  m em ory  c an  b e \nc o nta in ed  i n  2  b yte s. c om pute rs  w ith  m ore  m em ory  w ould  r e q uir e  m ore  b yte s t o  h old  a n  \na d dre ss. s om e c o m pute rs , s u ch  a s t h e i b m  p c  m ig h t r e q uir e  s p ecia l h an dli n g t o  h old  a  \ns e g m en t a n d o ffs e t u nder c erta in  c ir c u m sta n ces. t he a ctu al s iz e r e q uir e d  i s  n ot t o o \ni m porta n t s o  l o ng a s w e h av e a  w ay  o f i n fo rm in g t h e c o m pile r t h at w hat w e w an t t o  s to re  \ni s  a n  a d dre ss.  \ns uch  a  v aria b le  i s  c alle d  a  p oin te r v a ria ble  ( fo r r e aso ns w hic h  h opefu ll y  w ill b eco m e \nc le are r a  l ittle  l a te r).  i n  c  w hen  w e d efin e a  p oin te r v aria b le  w e d o s o  b y p re ced in g i t s  \nn am e w ith  a n  a ste ris k .  i n  c  w e a ls o  g iv e o ur p oin te r a  t y p e w hic h , i n  t h is  c ase , r e fe rs  t o  \nt h e t y p e o f d ata  s to re d  a t t h e a d dre ss w e w ill b e s to rin g i n  o ur p oin te r.  f or e x am ple , \nc o nsid er t h e v aria b le  d ecla ra tio n:  \n    int *ptr; \np tr  i s  t h e n am e o f o ur v aria b le  ( ju st a s k  w as t h e n am e o f o ur i n te g er v aria b le ). t he ©* © \ni n fo rm s t h e c o m pile r t h at w e w an t a  p oin te r v aria b le , i .e . t o  s e t a sid e h ow ev er m an y b yte s \ni s  r e q uir e d  t o  s to re  a n  a d dre ss i n  m em ory . t he i n t s a y s t h at w e i n te n d t o  u se  o ur p oin te r\n\n7  \nv\naria b le  t o  s to re  t h e a d dre ss o f a n  i n te g er. s uch  a  p oin te r i s  s a id  t o  " p oin t t o " a n  i n te g er. \nh ow ev er, n ote  t h at w hen  w e w ro te  i n t k ; w e d id  n ot g iv e k  a  v alu e.  i f  t h is  d efin itio n i s  \nm ad e o uts id e o f a n y f u n ctio n a nsi c o m plia n t c o m pile rs  w ill i n itia liz e i t t o  z ero . \ns im ila rly , p tr  h as n o v alu e, t h at i s  w e h av en ©t  s to re d  a n  a d dre ss i n  i t i n  t h e a b ove \nd ecla ra tio n.  i n  t h is  c ase ,  a g ain  i f  t h e d ecla ra tio n i s  o uts id e o f a n y f u nctio n,  i t i s  i n iti a liz ed  \nt o  a  v alu e g u ara n te ed  i n  s u ch  a  w ay  t h at i t i s  g u ara n te ed  t o  n ot p oin t t o  a n y c  o bje ct o r \nf u nctio n. a  p oin te r i n itia liz ed  i n  t h is  m an ner i s  c alle d  a  " n ull "  p oin te r.  \nt he a ctu al b it p atte rn  u se d  f o r a  n ull p oin te r m ay  o r m ay  n ot e v alu ate  t o  z ero  s in ce i t  \nd ep en ds o n t h e s p ecif ic  s y ste m  o n w hic h  t h e c o de i s  d ev elo ped . t o m ak e t h e s o urc e c o de \nc o m patib le  b etw een  v ario us c o m pile rs  o n v ario us s y ste m s, a  m acro  i s  u se d  t o  r e p re se n t a  \nn ull p oin te r. t hat m acro  g o es u nd er t h e n am e n u ll. t hus, s e ttin g t h e v alu e o f a  p oin te r \nu sin g t h e n u ll m acro ,  a s w ith  a n  a ssig n m en t s ta te m en t s u ch  a s p tr  =  n ull,  g u ara n te es \nt h at t h e p oin te r h as b eco m e a  n ull p oin te r. s im ila rly , j u st a s o ne c an  t e st f o r a n  i n te g er \nv alu e o f z ero , a s i n  i f (k  = = 0 ), w e c an  t e st f o r a  n ull p oin te r u sin g i f  ( p tr  = = n ull).  \nb ut, b ack  t o  u sin g o ur n ew  v aria b le  p tr . s uppose  n ow  t h at w e w an t t o  s to re  i n  p tr  t h e \na d dre ss o f o u r i n te g er v aria b le  k . t o d o t h is  w e u se  t h e u nary  &  o pera to r a n d w rite : \n     ptr = &k;  \nw hat t h e &  o pera to r d o es i s  r e tr ie v e t h e l v alu e ( a d dre ss) o f k , e v en  t h ough  k  i s  o n t h e \nr ig h t h an d s id e o f t h e a ss ig n m en t o pera to r ©= ©,   a n d c o pie s t h at t o  t h e c o nte n ts  o f o ur \np oin te r p tr . n ow , p tr  i s  s a id  t o  " p oin t t o " k . b ear w ith  u s n ow , t h ere  i s  o nly  o ne m ore  \no pera to r w e n eed  t o  d is c u ss.  \nt he " d ere fe re n cin g o pera to r"  i s  t h e a ste ris k  a n d i t i s  u se d  a s f o llo w s:  \n     *ptr = 7;  \nw ill c o p y 7  t o  t h e a d d re ss p oin te d  t o  b y p tr . t hus i f  p tr  " p oin ts  t o " ( c o nta in s t h e a d dre ss \no f) k , t h e a b ove s ta te m en t w ill s e t t h e v alu e o f k  t o  7 . t hat i s , w hen  w e u se  t h e ©* ©  t h is  \nw ay  w e a re  r e fe rrin g t o  t h e v alu e o f t h at w hic h  p tr  i s  p oin tin g t o , n ot t h e v alu e o f t h e \np oin te r i ts e lf .  \ns im ila rly , w e c o uld  w rite :  \n  printf("%d\\n",*ptr);  \nto  p rin t t o  t h e s c re en  t h e i n te g er v alu e s to re d  a t t h e a d dre ss p oin te d  t o  b y p tr ;.  \no ne w ay  t o  s e e h ow  a ll t h is  s tu ff f its  t o geth er w ould  b e t o  r u n t h e f o llo w in g p ro gra m  a n d \nt h en  r e v ie w  t h e c o de a n d  t h e o utp ut c are fu ll y .  \n- ----------- program 1.1 ---------------------------------  \n  / * program 1.1 from ptrtut10.txt   6/10/97 */\n\n8  \n# include <stdio.h> \n  i nt j, k; \ni nt *ptr; \n  i nt main(void) \n{  \n     j = 1; \n     k = 2; \n     ptr = &k; \n     printf("\\n"); \n     printf("j has the value %d and is stored at %p\\n", j, (void *)&j ); \n     printf("k has the value %d and is stored at %p\\n", k, (void *)&k ); \n     printf("ptr has the value %p and is stored at %p\\n", ptr, (void \n* )&ptr); \n     printf("the value of the integer pointed to by ptr is %d\\n", *pt r); \n       return 0; \n}  \nn ote : w e h av e y et t o  d is c u ss t h ose  a sp ects  o f c  w hic h  r e q uir e  t h e u se  o f t h e ( v oid  * ) \ne x pre ssio n u se d  h ere .  f or n ow , i n clu de i t i n  y o ur t e st c o de. w e©l l e x pla in  t h e r e aso n \nb eh in d t h is  e x pre ssio n l a te r.  \nt o r e v ie w :  \n·  a  v aria b le  i s  d ecla re d  b y g iv in g i t a  t y p e a n d a  n am e ( e .g . i n t k ;)  \n·  a  p oin te r v aria b le  i s  d ecla re d  b y g iv in g i t a  t y p e a n d a  n am e ( e .g . i n t * p tr ) w here  \nt h e a ste ris k  t e lls  t h e c o m pile r t h at t h e v aria b le  n am ed  p tr  i s  a  p oin te r v aria b le  a n d \nt h e t y p e t e lls  t h e c o m pile r w hat t y p e t h e p oin te r i s  t o  p oin t t o  ( in te g er i n  t h is  \nc ase ).  \n·  o nce a  v aria b le  i s  d ecla re d , w e c an  g et i ts  a d dre ss b y p re ced in g i ts  n am e w ith  t h e \nu nary  &  o pera to r,  a s i n  & k.  \n·  w e c an  " d ere fe re n ce" a  p oin te r, i .e . r e fe r t o  t h e v alu e o f t h at w hic h  i t p oin ts  t o , b y \nu sin g t h e u nary  ©* ©  o pera to r a s i n  * p tr .  \n·  a n " lv alu e" o f a  v aria b le  i s  t h e v alu e o f i ts  a d dre ss , i .e . w here  i t i s  s to re d  i n  \nm em ory . t he " rv alu e" o f a  v aria b le  i s  t h e v alu e s to re d  i n  t h at v aria b le  ( a t t h at \na d dre ss).  \nr efe re n ces f o r c hap te r 1 :  \n1 .  "t he c  p ro gra m min g l an gu ag e" 2 nd e ditio n \nb . k ern ig h an  a n d d . r itc h ie   \np re n tic e h all  \ni s b n  0 -1 3-1 10362 -8\n\n9  \nc h apt er  2 : p oin te r t y p es a n d a rra y s  \no kay , l e t©s  m ove o n.  l et u s c o nsid er w hy w e n eed  t o  i d en tif y  t h e t y p e o f v aria b le  t h at a  \np oin te r p oin ts  t o , a s i n :  \n      int *ptr; \no ne r e aso n f o r d oin g t h is  i s  s o  t h at l a te r, o nce p tr  " p oin ts  t o " s o m eth in g, i f  w e w rite :  \n     *ptr = 2; \nth e c o m pile r w ill k now  h ow  m an y b yte s t o  c o p y i n to  t h at m em ory  l o catio n p oin te d  t o  b y \np tr .  i f  p tr  w as d ecla re d  a s p oin tin g t o  a n  i n te g er, 2  b yte s w ould  b e c o pie d , i f  a  l o ng,  4  \nb yte s w ould  b e c o pie d . s im ila rly  f o r f lo ats  a n d d o uble s t h e a p pro pria te  n u m ber w ill b e \nc o pie d . b ut, d efin in g t h e t y p e t h at t h e p oin te r p oin ts  t o  p erm its  a  n um ber o f o th er \ni n te re stin g w ay s a  c o m pile r c an  i n te rp re t c o d e. f or e x am ple , c o nsid er a  b lo ck  i n  m em ory  \nc o nsis tin g i f  t e n  i n te g ers  i n  a  r o w . t hat i s , 2 0 b yte s o f m em ory  a re  s e t a sid e t o  h old  1 0 \ni n te g ers .  \nn ow , l e t©s  s a y  w e p oin t o ur i n te g er p oin te r p tr  a t t h e f ir s t o f t h ese  i n te g ers .  f urth erm ore  \nl e ts  s a y  t h at i n te g er i s  l o cate d  a t m em ory  l o catio n 1 00 ( d ecim al) . w hat h ap pen s w hen  w e \nw rite :  \n     ptr + 1;  \nb ec au se  t h e c o m pile r " k now s"  t h is  i s  a  p oin te r ( i.e . i ts  v alu e i s  a n  a d dre ss) a n d t h at i t \np oin ts  t o  a n  i n te g er ( its  c u rre n t a d dre ss, 1 00, i s  t h e a d dre ss o f a n  i n te g er), i t a d ds 2  t o  p tr  \ni n ste ad  o f 1 , s o  t h e p oin te r " p oin ts  t o " t h e n ex t i n te g er,  a t m em ory  l o catio n 1 02. \ns im ila rly , w ere  t h e p tr  d ecla re d  a s a  p oin te r t o  a  l o ng, i t w ould  a d d 4  t o  i t i n ste ad  o f 1 . \nt he s a m e g o es f o r o th er d ata  t y p es s u ch  a s f lo ats , d ouble s, o r e v en  u se r d efin ed  d ata  \nt y p es s u ch  a s s tr u ctu re s.  t his  i s  o bvio usly  n ot t h e s a m e k in d o f " a d ditio n" t h at w e \nn orm all y  t h in k o f.  i n  c  i t  i s  r e fe rre d  t o  a s a d ditio n u sin g " p oin te r a rith m etic ", a  t e rm  \nw hic h  w e w ill c o m e b ack  t o  l a te r.  \ns im ila rly , s in ce + +ptr  a n d p tr + + a re  b oth  e q uiv ale n t t o  p tr  +  1  ( th ough  t h e p oin t i n  t h e \np ro gra m  w hen  p tr  i s  i n cre m en te d  m ay  b e d if fe re n t) , i n cre m en tin g a  p oin te r u sin g t h e \nu nary  + + o pera to r, e ith er p re - o r p ost- , i n cre m en ts  t h e a d dre ss i t s to re s b y t h e a m ount \ns iz eo f(ty p e) w here  " ty p e" i s  t h e t y p e o f t h e o bje ct p oin te d  t o . ( i.e . 2  f o r a n  i n te g er, 4  f o r a  \nl o ng, e tc .) .  \ns in ce a  b lo ck  o f 1 0 i n te g ers  l o cate d  c o ntig u ously  i n  m em ory  i s , b y d efin iti o n, a n  a rr a y  o f \ni n te g ers , t h is  b rin gs u p a n  i n te re stin g r e la tio nsh ip  b etw een  a rr a y s a n d p oin te rs .\n\n1 0 \n \n \nc onsid er t h e f o llo w in g:  \n     int my_array[] = {1,23,17,4,-5,100};  \nh ere  w e h av e a n  a rra y  c o nta in in g 6  i n te g ers . w e r e fe r t o  e ach  o f t h ese  i n te g ers  b y m ean s \no f a  s u bsc rip t t o  m y_arra y, i .e . u sin g m y_a rra y[0 ] t h ro ugh  m y_arra y[5 ]. b ut, w e c o uld  \na lte rn ativ ely  a ccess t h em  v ia  a  p oin te r a s f o llo w s:  \n     int *ptr; \n     ptr = &my_array[0];       /* point our pointer at the first \n                                  integer in our array */  \na nd t h en  w e c o uld  p rin t o ut o ur a rra y  e ith er u sin g t h e a rr a y  n ota tio n o r b y d ere fe re n cin g \no ur p oin te r. t he f o llo w in g c o d e i llu str a te s t h is :  \n- ----------  program 2.1  ----------------------------------- \n  / * program 2.1 from ptrtut10.htm   6/13/97 */ \n # include <stdio.h> \n i nt my_array[] = {1,23,17,4,-5,100}; \ni nt *ptr; \n i nt main(void) \n{  \n     int i; \n     ptr = &my_array[0];     /* point our pointer to the first \n                                       element of the array */ \n     printf("\\n\\n"); \n     for (i = 0; i < 6; i++) \n     { \n       printf("my_array[%d] = %d   ",i,my_array[i]);   /*<-- a */ \n       printf("ptr + %d = %d\\n",i, *(ptr + i));        /*<-- b */ \n     } \n     return 0; \n}  \nc om pile  a n d r u n t h e a b o ve p ro gra m  a n d c a re fu ll y  n ote  l in es a  a n d b  a n d t h at t h e \np ro gra m  p rin ts  o ut t h e s a m e v alu es i n  e ith er c ase .  a ls o  o bse rv e h ow  w e d ere fe re n ced  o ur \np oin te r i n  l in e b , i .e . w e f ir s t a d ded  i  t o  i t a n d t h en  d ere fe re n ced  t h e n ew  p oin te r. c han ge \nl in e b  t o  r e ad :  \n     printf("ptr + %d = %d\\n",i, *ptr++); \nan d r u n i t a g ain ... t h en  c h an ge i t t o :  \n     printf("ptr + %d = %d\\n",i, *(++ptr));\n\n1 1 \na\nn d t r y  o nce m ore . e ach  t im e t r y  a n d p re d ic t t h e o utc o m e a n d c are fu ll y  l o o k a t t h e a c tu al \no utc o m e.  \ni n  c , t h e s ta n d ard  s ta te s t h at w here v er w e m ig h t u se  & var_ n am e[0 ] w e c a n  r e p la c e t h at \nw ith  v ar_ n am e, t h us i n  o ur c o de w here  w e w ro te :  \n     ptr = &my_array[0]; \nw e c an  w rite :  \n     ptr = my_array; \nto  a ch ie v e t h e s a m e r e su lt.  \nt his  l e ad s m an y t e x ts  t o  s ta te  t h at t h e n am e o f a n  a rra y  i s  a  p oin te r.  i  p re fe r t o  m en ta ll y  \nt h in k " th e n am e o f t h e a rra y  i s  t h e a d dre ss o f f ir s t e le m en t i n  t h e a rr a y ". m an y b eg in n ers  \n( in clu din g m yse lf  w hen  i  w as l e arn in g) h av e a  t e n den cy  t o  b eco m e c o nfu se d  b y t h in k in g \no f i t a s a  p oin te r. f or e x am ple , w hile  w e c an  w rite   \n     ptr = my_array; \nw e c an not w rite   \n     my_array = ptr; \nt he r e aso n i s  t h at w hile  p tr  i s  a  v aria b le ,  m y_arra y i s  a  c o nsta n t. t hat i s , t h e l o catio n a t \nw hic h  t h e f ir s t e le m en t o f m y_arra y w ill b e s to re d  c an not b e c h an ged  o n ce m y_arra y [] \nh as b een  d ecla re d .  \ne arlie r w hen  d is c u ssin g t h e t e rm  " lv alu e" i  c ite d  k & r-2  w here  i t s ta te d :  \n" a n o b je ct i s  a  n am ed  r e g io n o f s to ra g e; a n  l v alu e i s  a n  e x pre ssio n \nr e fe rrin g t o  a n  o bje ct" .  \nt his  r a is e s a n  i n te re stin g p ro ble m . s in ce m y_arra y i s  a  n am ed  r e g io n o f s to ra g e, w hy i s  \nm y_a rra y i n  t h e a b ov e a ssig n m en t s ta te m en t n ot a n  l v alu e?  t o r e so lv e t h is  p ro ble m , \ns o m e r e fe r t o  m y_arra y a s a n  " u nm odif ia b le  l v alu e".  \nm odif y  t h e e x am ple  p ro gra m  a b ove b y c h an gin g  \n     ptr = &my_array[0]; \nto   \n     ptr = my_array; \nan d r u n i t a g ain  t o  v erif y  t h e r e su lts  a re  i d en tic al.\n\n1 2 \nn\now , l e t©s  d elv e a  l ittle  f u rth er i n to  t h e d if fe re n ce b etw een  t h e n am es p tr  a n d m y_a rra y \na s u se d  a b ove. s om e w rite rs  w ill r e fe r t o  a n  a rra y ©s  n am e a s a  c o n sta n t p oin te r. w hat d o \nw e m ean  b y t h at?  w ell, t o  u nders ta n d t h e t e rm  " c o nsta n t"  i n  t h is  s e n se , l e t©s  g o  b ack  t o  \no ur d efin itio n o f t h e t e rm  " v aria b le ". w hen  w e d ecla re  a  v aria b le  w e s e t a sid e a  s p ot i n  \nm em ory  t o  h old  t h e v alu e o f t h e a p p ro pria te  t y p e. o nce t h at i s  d one t h e n am e o f t h e \nv aria b le  c an  b e i n te rp re te d  i n  o ne o f t w o w ay s. w hen  u se d  o n t h e l e ft s id e o f t h e \na ssig n m en t o pera to r, t h e c o m pile r i n te rp re ts  i t a s t h e m em ory  l o catio n t o  w hic h  t o  m ove \nt h at v alu e r e su ltin g f ro m  e v alu atio n o f t h e r ig h t s id e o f t h e a ssig n m en t o pera to r. b ut, \nw hen  u se d  o n t h e r ig h t s id e o f t h e a ssig n m en t o pera to r, t h e n am e o f a  v aria b le  i s  \ni n te rp re te d  t o  m ea n  t h e c o nte n ts  s to re d  a t t h at m em ory  a d d re ss s e t a sid e t o  h old  t h e v alu e \no f t h at v aria b le .  \nw ith  t h at i n  m in d, l e t©s  n ow  c o nsid er t h e s im ple st o f c o nsta n ts , a s i n :  \n     int i, k; \n     i = 2; \nh ere ,  w hile  i  i s  a  v aria b le  a n d t h en  o ccu pie s s p ace i n  t h e d ata  p ortio n o f m em ory , 2  i s  a  \nc o nsta n t a n d, a s s u ch , i n ste ad  o f s e ttin g a sid e m em ory  i n  t h e d ata  s e g m en t, i t i s  i m bed ded  \nd ir e ctl y  i n  t h e c o de s e g m en t o f m em ory . t hat i s ,  w hile  w ritin g s o m eth in g l ik e k  =  i ;  t e lls  \nt h e c o m pile r t o  c re ate  c o de w hic h  a t r u n t im e w ill  l o ok a t m em ory  l o catio n & i t o  \nd ete rm in e t h e v alu e t o  b e m oved  t o  k , c o de c re ate d  b y i  =  2 ; s im ply  p uts  t h e 2  i n  t h e c o de \na n d t h ere  i s  n o r e fe re n cin g o f t h e d ata  s e g m en t. t hat i s , b oth  k  a n d i  a re  o bje cts , b ut 2  i s  \nn ot a n  o bje ct.  \ns im ila rly , i n  t h e a b ove, s in ce m y_arra y i s  a  c o nsta n t, o nce t h e c o m pile r e sta b lis h es \nw here  t h e a rr a y  i ts e lf  i s  t o  b e s to re d , i t " k now s" t h e a d dre ss o f m y_arra y[0 ] a n d o n \ns e ein g:  \n     ptr = my_array; \nit s im ply  u se s t h is  a d dre ss a s a  c o nsta n t i n  t h e c o d e s e g m en t a n d t h ere  i s  n o  r e fe re n cin g \no f t h e d ata  s e g m en t b ey o nd t h at.  \nt his  m ig h t b e a  g o od p la ce e x pla in  f u rth er t h e u se  o f t h e ( v oid  * ) e x pre ssio n u se d  i n  \np ro gra m  1 .1  o f c hap te r 1 . a s w e h av e s e en  w e c an  h av e p oin te rs  o f v ario u s t y p es. s o f a r \nw e h av e d is c u ss e d  p oin te rs  t o  i n te g ers  a n d p oin te rs  t o  c h ara cte rs .  i n  c o m in g c h ap te rs  w e \nw ill b e l e arn in g a b out p o in te rs  t o  s tr u ctu re s a n d e v en  p oin te r t o  p oin te rs .  \na ls o  w e h av e l e arn ed  t h at o n d if fe re n t s y ste m s t h e s iz e o f a  p oin te r c an  v ary . a s i t t u rn s \no ut i t i s  a ls o  p ossib le  t h at t h e s iz e o f a  p oin te r c an  v ary  d ep en din g o n t h e d ata  t y p e o f t h e \no bje ct t o  w hic h  i t p oin ts . t hus, a s w ith  i n te g ers  w here  y o u c an  r u n i n to  t r o uble  \na tte m ptin g t o  a ssig n  a  l o ng i n te g er t o  a  v aria b le  o f t y p e s h o rt i n te g er,  y o u c an  r u n i n to  \nt r o uble  a tte m ptin g t o  a ssig n  t h e v alu es o f p oin te rs  o f v ario us t y p es t o  p oin te r v aria b le s o f \no th er t y p es.\n\n1 3 \nt\no m in im iz e t h is  p ro ble m , c  p ro vid es f o r a  p oin te r o f t y p e v oid . w e c an  d ecla re  s u ch  a  \np oin te r b y w ritin g:  \nv oid *vptr; \na  v oid  p oin te r i s  s o rt o f a  g en eric  p oin te r.  f or e x am ple , w hile  c  w ill n ot p erm it t h e \nc o m paris o n o f a  p oin te r t o  t y p e i n te g er w ith  a  p oin te r t o  t y p e c h ara cte r, f o r e x am ple , \ne ith er o f t h ese  c an  b e c o m pare d  t o  a  v oid  p oin te r. o f c o urs e , a s w ith  o th er v aria b le s,  c asts  \nc an  b e u se d  t o  c o nvert f ro m  o ne t y p e o f p oin te r t o  a n oth er u nder t h e p ro per \nc ir c u m sta n ces.  i n  p ro gra m  1 .1 . o f c hap te r 1  i  c ast t h e p oin te rs  t o  i n te g ers  i n to  v oid  \np oin te rs  t o  m ak e t h em  c o m patib le  w ith  t h e % p c o nvers io n s p ecif ic atio n.  i n  l a te r c h ap te rs  \no th er c asts  w ill b e m ad e f o r r e aso ns d efin ed  t h ere in .  \nw ell, t h at©s  a  l o t o f t e ch n ic al s tu ff t o  d ig est a n d i  d on©t  e x pect a  b eg in ner t o  u nders ta n d a ll \no f i t o n f ir s t r e ad in g. w ith  t im e a n d e x perim en ta tio n y o u w ill w an t t o  c o m e b ack  a n d  r e -\nr e ad  t h e f ir s t 2  c h ap te rs .  b ut f o r n ow , l e t©s  m ove o n t o  t h e r e la tio nsh ip  b etw een  p oin te rs , \nc h ara cte r a rr a y s, a n d s tr in gs.\n\n1 4 \nc h apt er  3 : p oin te rs a n d s tr in gs  \nt he s tu d y o f s tr in gs i s  u se fu l t o  f u rth er t ie  i n  t h e r e la tio nsh ip  b etw een  p oin te rs  a n d a rra y s. \ni t a ls o  m ak es i t e asy  t o  i llu str a te  h ow  s o m e o f t h e s ta n dard  c  s tr in g f u nctio n s c an  b e \ni m ple m en te d . f in all y  i t i l lu str a te s h ow  a n d w hen  p oin te rs  c an  a n d s h ould  b e p asse d  t o  \nf u nctio ns.  \ni n  c , s tr in gs a re  a rra y s o f c h ara cte rs . t his  i s  n ot n ecessa ril y  t r u e i n  o th er l a n gu ag es.  i n  \nb a sic , p asc al,  f ortr a n  a n d v ario us o th er l a n gu ag es, a  s tr in g h as i ts  o w n d ata  t y p e. b ut i n  \nc  i t d oes n ot.  i n  c  a  s tr in g i s  a n  a rra y  o f c h ara cte rs  t e rm in ate d  w ith  a  b in ary  z ero  \nc h ara cte r ( w ritte n  a s '' \\0 '') . t o s ta rt o ff o ur d is c u ssio n w e w ill w rite  s o m e c o de w hic h , \nw hile  p re fe rr e d  f o r i llu str a tiv e p urp ose s,  y o u w ould  p ro bab ly  n ev er w rite  i n  a n  a ctu al \np ro gra m . c onsid er, f o r e x am ple :  \n     char my_string[40]; \n       my_string[0] = ''t''; \n     my_string[1] = ''e''; \n     my_string[2] = ''d'': \n     my_string[3] = ''\\0''; \nw hile  o ne w ould  n ev er b uild  a  s tr in g l ik e t h is , t h e e n d r e su lt i s  a  s tr in g i n  t h at i t i s  a n  \na rra y  o f c h ara cte rs  t e r m in ate d  w it h  a  n ul c h ara cte r.  b y d efin itio n, i n  c , a  s tr in g i s  a n  \na rra y  o f c h ara cte rs  t e rm in ate d  w ith  t h e n ul c h ara c te r. b e a w are  t h at " n ul"  i s  n ot t h e s a m e \na s " n ull". t he n ul r e fe rs  t o  a  z ero  a s d efin ed  b y t h e e sc ap e s e q uen ce '' \\0 ''. t hat i s  i t  \no ccu pie s o ne b yte  o f m em ory . n ull, o n t h e o th er h an d, i s  t h e n am e o f t h e m acro  u se d  t o  \ni n itia liz e n ull p oin te rs . n u ll i s  # d efin ed  i n  a  h ea d er f ile  i n  y o ur c  c o m pil e r, n ul m ay  n ot \nb e # defin ed  a t a ll.  \ns in ce w ritin g t h e a b ove c o de w ould  b e v ery  t im e c o nsu m in g, c  p erm its  t w o a lte rn ate  \nw ay s o f a ch ie v in g t h e s a m e t h in g. f ir s t, o n e m ig h t w rite :  \n     char my_string[40] = {''t'', ''e'', ''d'', ''\\0'',};     \nb ut t h is  a ls o  t a k es m ore  t y p in g t h an  i s  c o nven ie n t. s o, c  p erm its :  \n     char my_string[40] = "ted"; \nw hen  t h e d ouble  q uote s a re  u se d , i n ste ad  o f t h e s in gle  q uote s a s w as d on e i n  t h e p re v io us \ne x am ple s, t h e n ul c h ara cte r (  '' \\0 ©  )  i s  a u to m atic all y  a p pen ded  t o  t h e e n d o f t h e s tr in g.  \ni n  a ll o f t h e a b ov e c ase s,  t h e s a m e t h in g h ap pen s.  t he c o m pile r s e ts  a sid e a n  c o ntig u o us \nb lo ck  o f m em ory  4 0 b yte s l o ng t o  h old  c h ara cte rs  a n d i n itia liz ed  i t s u ch  t h at t h e f ir s t 4  \nc h ara cte rs  a re  t ed \\0 .  \nn ow , c o nsid er t h e f o llo w in g p ro gra m :\n\n1 5 \n  - -----------------program 3.1------------------------------------- \n / * program 3.1 from ptrtut10.htm   6/13/97 */ \n # include <stdio.h> \n  c har stra[80] = "a string to be used for demonstration purposes"; \nc har strb[80]; \n  i nt main(void) \n{  \n      char *pa;     /* a pointer to type character */ \n     char *pb;     /* another pointer to type character */ \n     puts(stra);   /* show string a */ \n     pa = stra;    /* point pa at string a */ \n     puts(pa);     /* show what pa is pointing to */ \n     pb = strb;    /* point pb at string b */ \n     putchar(''\\n'');       /* move down one line on the screen */ \n     while(*pa != ''\\0'')   /* line a (see text) */ \n     { \n         *pb++ = *pa++;   /* line b (see text) */ \n     } \n     *pb = ''\\0'';          /* line c (see text) */ \n     puts(strb);          /* show strb on screen */ \n     return 0; \n}  \n  - -------- end program 3.1 ------------------------------------- \n      \nin  t h e a b ove w e s ta rt o ut b y d efin in g t w o c h ara cte r a rr a y s o f 8 0 c h ara cte rs  e ach . s in ce \nt h ese  a re  g lo ball y  d efin ed , t h ey  a re  i n itia liz ed  t o  a ll '' \\0 ©s  f ir s t. t hen , s tr a  h as t h e f ir s t 4 2 \nc h ara cte rs  i n itia liz ed  t o  t h e s tr in g i n  q uote s.  \nn ow , m ovin g i n to  t h e c o de, w e d ecla re  t w o c h ara cte r p oin te rs  a n d s h o w  t h e s tr in g o n  t h e \ns c re en . w e t h en  " p oin t"  t h e p oin te r p a  a t s tr a . t hat i s , b y m ean s o f t h e a ssig n m en t \ns ta te m en t w e c o p y t h e a d dre ss o f s tr a [0 ] i n to  o ur v aria b le  p a . w e n ow  u se  p uts () t o  \ns h ow  t h at w hic h  i s  p oin te d  t o  b y p a  o n t h e s c re en . c onsid er h ere  t h at t h e f u nctio n \np ro to ty p e f o r p uts () i s :  \n     int puts(const char *s);  \nf or t h e m om en t, i g n ore  t h e c o n st. t he p ara m ete r p asse d  t o  p uts () i s  a  p oin te r, t h at i s  t h e \nv alu e o f a  p oin te r ( s in ce a ll p ara m ete rs  i n  c  a re  p asse d  b y v alu e), a n d t h e v alu e o f a  \np oin te r i s  t h e a d dre ss t o  w hic h  i t p oin ts , o r, s im ply , a n  a d dre ss. t hus w hen  w e w rite  \np uts (s tr a ); a s w e h av e s e en , w e a re  p assin g t h e a d dre ss o f s tr a [0 ].  \ns im ila rly , w hen  w e w rite  p uts (p a ); w e a re  p assin g t h e s a m e a d dre ss, s in ce  w e h av e s e t \np a  =  s tr a ;\n\n1 6 \ng\niv en  t h at, f o llo w  t h e c o de d ow n t o  t h e w hile () s ta te m en t o n l in e a .  l in e a  s ta te s:  \nw hile  t h e c h ara cte r p oin te d  t o  b y p a  ( i.e . * p a ) i s  n ot a  n ul c h ara cte r ( i.e . t h e t e rm in atin g \n'' \\0 ©) , d o t h e f o llo w in g:  \nl in e b  s ta te s: c o p y t h e c h ara cte r p oin te d  t o  b y p a  t o  t h e s p ace p oin te d  t o  b y p b , t h en  \ni n cre m en t p a  s o  i t p oin ts  t o  t h e n ex t c h ara cte r a n d  p b  s o  i t p oin ts  t o  t h e n ex t s p ace.   \nw hen  w e h av e c o pie d  t h e l a st c h ara cte r, p a  n ow  p oin ts  t o  t h e t e rm in atin g n ul c h ara cte r \na n d t h e l o op e n ds. h ow ev er, w e h av e n ot c o pie d  t h e n ul c h ara cte r. a nd, b y d efin itio n  a  \ns tr in g i n  c  m ust b e n ul t e rm in ate d . s o, w e a d d t h e n ul c h ara cte r w ith  l in e c .  \ni t i s  v ery  e d ucatio nal t o  r u n t h is  p ro gra m  w ith  y o u r d eb u gger w hile  w atc h in g s tr a , s tr b , \np a  a n d p b  a n d s in gle  s te p pin g t h ro u gh  t h e p ro gra m .  i t i s  e v en  m ore  e d u catio nal i f  \ni n ste ad  o f s im ply  d efin in g s tr b [] a s h as b een  d on e a b ove, i n itia liz e i t a ls o  w ith  s o m eth in g \nl ik e:  \n     strb[80] = "12345678901234567890123456789012345678901234567890" \nw here  t h e n um ber o f d ig its  u se d  i s  g re ate r t h an  t h e l e n gth  o f s tr a  a n d t h en  r e p eat t h e \ns in gle  s te p pin g p ro ced ure  w hile  w atc h in g t h e a b o ve v aria b le s.  g iv e t h ese  t h in gs a  t r y !  \ng ettin g b ack  t o  t h e p ro to ty p e f o r p uts () f o r a  m om en t, t h e " c o nst"  u se d  a s a  p ara m ete r \nm odif ie r i n fo rm s t h e u se r t h at t h e f u nctio n w ill n ot m odif y  t h e s tr in g p oin te d  t o  b y s , i .e . \ni t w ill t r e at t h at s tr in g a s a  c o nsta n t.  \no f c o urs e , w hat t h e a b ov e p ro gra m  i llu str a te s i s  a  s im ple  w ay  o f c o p yin g a  s tr in g. a fte r \np la y in g w ith  t h e a b ov e u ntil y o u h av e a  g o od u nd ers ta n din g o f w hat i s  h ap pen in g, w e c an  \np ro ceed  t o  c re atin g o u r o w n r e p la c em en t f o r t h e s ta n dard  s tr cp y() t h at c o m es w ith  c .  i t \nm ig h t l o ok l ik e:  \n    char *my_strcpy(char *destination, char *source) \n    { \n        char *p = destination; \n        while (*source != ''\\0'') \n        { \n            *p++ = *source++; \n        } \n        *p = ''\\0''; \n        return destination; \n    }    \nin  t h is  c ase ,  i  h av e f o llo w ed  t h e p ra ctic e u se d  i n  t h e s ta n dard  r o utin e o f r e tu rn in g a  \np oin te r t o  t h e d estin atio n.  \na gain , t h e f u nctio n i s  d esig n ed  t o  a ccep t t h e v alu es o f t w o c h ara cte r p oin te rs , i .e . \na d dre sse s,  a n d t h us i n  t h e p re v io us p ro gra m  w e c o uld  w rite :\n\n1 7 \n       int main(void) \n     { \n         my_strcpy(strb, stra); \n         puts(strb); \n     }     \ni h av e d ev ia te d  s lig h tl y  f ro m  t h e f o rm  u se d  i n  s ta n dard  c  w hic h  w ould  h av e t h e \np ro to ty p e:  \n     char *my_strcpy(char *destination, const char *source);   \nh ere  t h e " c o nst"  m odif ie r i s  u se d  t o  a ssu re  t h e u se r t h at t h e f u nctio n w ill n ot m odif y  t h e \nc o nte n ts  p oin te d  t o  b y t h e s o urc e p oin te r. y ou c an  p ro ve t h is  b y m odif y in g t h e f u n ctio n \na b ove, a n d i ts  p ro to ty p e,  t o  i n clu de t h e " c o nst"  m odif ie r a s s h ow n. t hen , w ith in  t h e \nf u nctio n y o u c an  a d d a  s ta te m en t w hic h  a tte m pts  t o  c h an ge t h e c o nte n ts  o f t h at w hic h  i s  \np oin te d  t o  b y s o urc e, s u ch  a s:  \n     *source = ''x''; \nw hic h  w ould  n orm all y  c h an ge t h e f ir s t c h ara cte r o f t h e s tr in g t o  a n  x . t he c o nst m od if ie r \ns h ould  c au se  y o ur c o m pile r t o  c atc h  t h is  a s a n  e rr o r. t ry  i t a n d s e e.  \nn ow , l e t©s  c o nsid er s o m e o f t h e t h in gs t h e a b ove e x am ple s h av e s h ow n u s. f ir s t o ff, \nc o nsid er t h e f a ct t h at * p tr + + i s  t o  b e i n te rp re te d  a s r e tu rn in g t h e v alu e p oin te d  t o  b y p tr  \na n d t h en  i n cre m en tin g t h e p oin te r v alu e. t his  h as t o  d o w ith  t h e p re ced en ce o f t h e \no pera to rs . w ere  w e t o  w rite  ( * p tr )+ + w e w ould  i n cre m en t, n ot t h e p oin te r,  b ut t h at w hic h  \nt h e p oin te r p oin ts  t o ! i .e . i f  u se d  o n t h e f ir s t c h ara cte r o f t h e a b ov e e x am ple  s tr in g t h e ©t © \nw ould  b e i n cre m en te d  t o  a  ©u ©.  y ou c an  w rite  s o m e s im ple  e x am ple  c o de t o  i llu str a te  t h is .  \nr ecall a g ain  t h at a  s tr in g i s  n oth in g m ore  t h an  a n  a rra y  o f c h ara cte rs , w ith  t h e l a st \nc h ara cte r b ein g a  '' \\0 ''. w hat w e h av e d one a b ov e i s  d eal w ith  c o p yin g a n  a rra y .  i t h ap p en s \nt o  b e a n  a rra y  o f c h ara cte rs  b ut t h e t e ch niq ue c o uld  b e a p plie d  t o  a n  a rra y  o f i n te g ers , \nd ouble s, e tc .  i n  t h ose  c ase s, h ow ev er, w e w ould  n ot b e d ealin g w ith  s tr in gs a n d h en ce t h e \ne n d o f t h e a rra y  w ould  n ot b e m ark ed  w ith  a  s p ec ia l v alu e l ik e t h e n ul c h ara cte r. w e \nc o uld  i m ple m en t a  v ers io n t h at r e lie d  o n a  s p ecia l v alu e t o  i d en tif y  t h e e n d.  f or e x am ple , \nw e c o uld  c o p y a n  a rra y  o f p ositiv e i n te g ers  b y m ark in g t h e e n d w ith  a  n eg ativ e i n te g er. \no n t h e o th er h an d, i t i s  m ore  u su al t h at w hen  w e w rite  a  f u nctio n t o  c o p y a n  a rra y  o f \ni te m s o th er t h an  s tr in gs w e p ass t h e f u n ctio n t h e n um ber o f i te m s t o  b e c o pie d  a s w ell a s \nt h e a d dre ss o f t h e a rra y ,  e .g . s o m eth in g l ik e t h e f o llo w in g p ro to ty p e m ig h t i n dic ate :  \n     void int_copy(int *ptra, int *ptrb, int nbr); \nw here  n br i s  t h e n um ber o f i n te g ers  t o  b e c o pie d .  y ou m ig h t w an t t o  p la y  w ith  t h is  i d ea \na n d c re ate  a n  a rr a y  o f i n te g ers  a n d s e e i f  y o u c an  w rite  t h e f u nctio n i n t_ co p y() a n d m ak e \ni t w ork .\n\n1 8 \nt\nhis  p erm its  u sin g f u ncti o ns t o  m an ip ula te  l a rg e a rra y s.  f or e x am ple , i f  w e h av e a n  a rr a y  \no f 5 000 i n te g ers  t h at w e w an t t o  m an ip ula te  w ith  a  f u nctio n, w e n eed  o nly  p ass t o  t h at \nf u nctio n t h e a d dre ss o f t h e a rr a y  ( a n d a n y a u x ilia ry  i n fo rm atio n s u ch  a s n br a b ove, \nd ep en din g o n w hat w e a re  d oin g).  t he a rra y  i ts e lf  d oes n ot g et p asse d , i .e . t h e w hole  \na rra y  i s  n ot c o pie d  a n d p ut o n t h e s ta ck  b efo re  c allin g t h e f u nctio n, o nly  i ts  a d dre ss i s  \ns e n t.  \nt his  i s  d if fe re n t f ro m  p assin g, s a y  a n  i n te g er, t o  a  f u nctio n. w hen  w e p ass a n  i n te g er w e \nm ak e a  c o p y o f t h e i n te g er, i .e .  g et i ts  v alu e a n d p ut i t o n t h e s ta ck . w ith in  t h e f u ncti o n \na n y m an ip ula tio n o f t h e v alu e p asse d  c an  i n  n o w ay  e ff e ct t h e o rig in al i n te g er. b ut, w ith  \na rra y s a n d p oin te rs  w e c a n  p ass t h e a d dre ss o f t h e v aria b le  a n d h en ce m an ip ula te  t h e \nv alu es o f t h e o rig in al v aria b le s.\n\n1 9 \nc h apt er  4 : m ore o n  s tr in gs \nw ell, w e h av e p ro gre sse d  q uite  a  w ay  i n  a  s h ort t i m e! l et©s  b ack  u p a  l ittle  a n d l o ok a t \nw hat w as d one i n  c hap te r 3  o n c o p yin g o f s tr in gs b ut i n  a  d if fe re n t l i g h t. c onsid er t h e \nf o llo w in g f u n ctio n:  \n       char *my_strcpy(char dest[], char source[]) \n     { \n         int i = 0; \n         while (source[i] != ''\\0'') \n         { \n             dest[i] = source[i]; \n             i++; \n         } \n         dest[i] = ''\\0''; \n         return dest; \n     } \nr ecall t h at s tr in gs a re  a rr a y s o f c h ara cte rs . h ere  w e h av e c h ose n  t o  u se  a rra y  n ota tio n  \ni n ste ad  o f p oin te r n ota tio n t o  d o t h e a ctu al c o p yin g. t he r e su lts  a re  t h e s a m e, i .e . t h e \ns tr in g g ets  c o pie d  u sin g t h is  n ota tio n j u st a s a ccu ra te ly  a s i t d id  b efo re .  t his  r a is e s s o m e \ni n te re stin g p oin ts  w hic h  w e w ill d is c u ss.  \ns in ce p ara m ete rs  a re  p asse d  b y v alu e, i n  b oth  t h e p assin g o f a  c h ara cte r p oin te r o r t h e \nn am e o f t h e a rra y  a s a b o ve, w hat a ctu all y  g ets  p asse d  i s  t h e a d dre ss o f t h e f ir s t e le m en t o f \ne ach  a rr a y . t hus, t h e n u m eric al v alu e o f t h e p ara m ete r p asse d  i s  t h e s a m e w heth er w e u se  \na  c h ara cte r p oin te r o r a n  a rra y  n am e a s a  p ara m ete r. t his  w ould  t e n d t o  i m ply  t h at \ns o m eh ow  s o u rce[i]  i s  t h e s a m e a s * (p + i) .  \ni n  f a ct, t h is  i s  t r u e, i .e  w here v er o ne w rite s a [i]  i t c an  b e r e p la ced  w ith  * (a  +  i )  w ith ou t \na n y p ro ble m s.  i n  f a ct, t h e c o m pile r w ill c re ate  t h e s a m e c o de i n  e ith er c ase .  t hus w e s e e \nt h at p oin te r a rith m etic  i s  t h e s a m e t h in g a s a rra y  i n dex in g. e ith er s y n ta x  p ro duces t h e \ns a m e r e su lt.  \nt his  i s  n ot s a y in g t h at p oin te rs  a n d a rra y s a re  t h e s a m e t h in g, t h ey  a re  n o t. w e a re  o nly  \ns a y in g t h at t o  i d en tif y  a  g iv en  e le m en t o f a n  a rr a y  w e h av e t h e c h oic e o f t w o s y n ta x es, \no ne u sin g a rra y  i n d ex in g a n d t h e o th er u sin g p oin te r a rith m etic , w hic h  y ie ld  i d en tic al \nr e su lts .  \nn ow , l o okin g a t t h is  l a st e x pre ssio n, p art o f i t.. ( a  +  i ) , i s  a  s im ple  a d ditio n u sin g t h e +  \no pera to r a n d t h e r u le s o f c  s ta te  t h at s u ch  a n  e x pre ssio n i s  c o m muta tiv e. t hat i s  ( a  +  i )  i s  \ni d en tic al t o  ( i +  a ). t hus w e c o uld  w rite  * (i +  a ) j u st a s e asil y  a s * (a  +  i ) .\n\n2 0 \nb\nut * (i +  a ) c o uld  h av e c o m e f ro m  i [ a ] !  f ro m  a ll o f t h is  c o m es t h e c u rio us t r u th  t h at i f :  \n     char a[20]; \n     int i; \n \nw ritin g  \n       a[3] = ''x''; \n \ni s  t h e s a m e a s w ritin g  \n \n     3[a] = ''x''; \n \nt ry  i t!  s et u p a n  a rr a y  o f c h ara cte rs , i n te g ers  o r l o ngs, e tc .  a n d a ssig n ed  t h e 3 rd  o r 4 th  \ne le m en t a  v alu e u sin g t h e c o nven tio nal a p pro ach  a n d t h en  p rin t o ut t h at v alu e t o  b e s u re  \ny o u h av e t h at w ork in g. t hen  r e v ers e  t h e a rr a y  n ota tio n a s i  h av e d on e a b ov e. a  g o od  \nc o m pile r w ill n ot b alk  a n d t h e r e su lts  w ill b e i d en tic al. a  c u rio sit y ... n oth in g m ore !  \nn ow , l o okin g a t o u r f u nctio n a b ove, w hen  w e w rit e :  \n     dest[i] = source[i]; \n \nd ue t o  t h e f a ct t h at a rr a y  i n dex in g a n d p oin te r a rit h m etic  y ie ld  i d en tic al r e su lts , w e c a n  \nw rite  t h is  a s:  \n      *(dest + i) = *(source + i); \n \nb ut, t h is  t a k es 2  a d ditio ns f o r e a ch  v alu e t a k en  o n b y i . a dditio ns, g en era ll y  s p eak in g , \nt a k e m ore  t im e t h an  i n cre m en ta tio ns ( s u ch  a s t h ose  d one u sin g t h e + + o pera to r a s i n  i + +). \nt his  m ay  n ot b e t r u e i n  m odern  o ptim iz in g c o m pile rs , b ut o ne c an  n ev er b e s u re . t hu s, \nt h e p oin te r v ers io n m ay  b e a  b it f a ste r t h an  t h e a rra y  v ers io n.  \na noth er w ay  t o  s p eed  u p  t h e p oin te r v ers io n w ould  b e t o  c h an ge:  \n     while (*source != ''\\0'') \n \nt o  s im ply   \n       while (*source) \n \ns in ce t h e v alu e w ith in  t h e p are n th esis  w ill g o  t o  z ero  ( f a lse ) a t t h e s a m e t im e i n  e ith er \nc ase .\n\n2 1 \na\nt t h is  p oin t y o u m ig h t w an t t o  e x perim en t a  b it w ith  w ritin g s o m e o f y o u r o w n p ro gra m s \nu sin g p oin te rs . m an ip ula tin g s tr in gs i s  a  g o od p la ce t o  e x perim en t. y ou m ig h t w an t t o  \nw rite  y o u r o w n v ers io ns o f s u ch  s ta n dard  f u nctio n s a s:  \n       strlen(); \n     strcat(); \n     strchr(); \nan d a n y o th ers  y o u m ig h t h av e o n y o ur s y ste m .  \nw e w ill c o m e b ack  t o  s tr in gs a n d t h eir  m an ip ula tio n t h ro ugh  p oin te rs  i n  a  f u tu re  c h ap te r. \nf or n ow , l e t©s  m ove o n a n d d is c u ss s tr u ctu re s f o r a  b it.\n\n2 2 \nc h apt er  5 : p oin te rs a n d s tr u ctu res  \na s y o u m ay  k no w , w e c a n  d ecla re  t h e f o rm  o f a  b lo ck  o f d ata  c o nta in in g d if fe re n t d ata  \nt y p es b y m ean s o f a  s tr u ctu re  d ecla ra tio n. f or e x am ple , a  p ers o nnel f ile  m ig h t c o nta in  \ns tr u ctu re s w hic h  l o ok s o m eth in g l ik e:  \n     struct tag { \n         char lname[20];        /* last name */ \n         char fname[20];        /* first name */ \n         int age;               /* age */ \n         float rate;            /* e.g. 12.75 per hour */ \n     }; \nl et©s  s a y  w e h av e a  b un ch  o f t h ese  s tr u ctu re s i n  a  d is k  f ile  a n d w e w an t t o  r e ad  e ach  o ne \no ut a n d p rin t o ut t h e f ir s t a n d l a st n am e o f e ach  o n e s o  t h at w e c an  h av e a  l is t o f t h e \np eo ple  i n  o ur f ile s. t he r e m ain in g i n fo rm atio n w ill n ot b e p rin te d  o ut. w e w ill w an t t o  d o \nt h is  p rin tin g w ith  a  f u ncti o n c all a n d p ass t o  t h at f u nctio n a  p oin te r t o  t h e s tr u ctu re  a t \nh an d. f or d em onstr a tio n p urp ose s i  w ill u se  o nly  o ne s tr u ctu re  f o r n ow .  b ut r e aliz e t h e \ng o al i s  t h e w ritin g o f t h e f u nctio n, n ot t h e r e ad in g o f t h e f ile  w hic h , p re su m ab ly , w e \nk now  h ow  t o  d o.  \nf or r e v ie w , r e call t h at w e c an  a cc ess s tr u ctu re  m em bers  w ith  t h e d ot o pera to r a s i n :  \n  - -------------- program 5.1 ------------------ \n / * program 5.1 from ptrtut10.htm     6/13/97 */ \n    # include <stdio.h> \n# include <string.h> \n s truct tag { \n     char lname[20];      /* last name */ \n     char fname[20];      /* first name */ \n     int age;             /* age */ \n     float rate;          /* e.g. 12.75 per hour */ \n} ; \n s truct tag my_struct;       /* declare the structure my_struct */ \n i nt main(void) \n{  \n     strcpy(my_struct.lname,"jensen"); \n     strcpy(my_struct.fname,"ted"); \n     printf("\\n%s ",my_struct.fname); \n     printf("%s\\n",my_struct.lname); \n     return 0; \n}  \n  - ------------- end of program 5.1 --------------\n\n2 3 \nn\now , t h is  p artic u la r s tr u ctu re  i s  r a th er s m all c o m pare d  t o  m an y u se d  i n  c  p ro gra m s.  t o \nt h e a b ove w e m ig h t w an t t o  a d d:  \n       date_of_hire;                  (data types not shown) \n     date_of_last_raise; \n     last_percent_increase; \n     emergency_phone; \n     medical_plan; \n     social_s_nbr; \n     etc..... \nif  w e h av e a  l a rg e n um ber o f e m plo yees,  w hat w e w an t t o  d o i s  m an ip ula te  t h e d ata  i n  \nt h ese  s tr u ctu re s b y m ean s o f f u nctio ns. f or e x am ple  w e m ig h t w an t a  f u n ctio n p rin t o ut \nt h e n am e o f t h e e m plo yee l is te d  i n  a n y s tr u ctu re  p asse d  t o  i t. h ow ev er, i n  t h e o rig in al c  \n( k ern ig h an  &  r itc h ie , 1 st e ditio n) i t w as n ot p ossib le  t o  p ass a  s tr u ctu re , o nly  a  p oin te r \nt o  a  s tr u ctu re  c o uld  b e p asse d .  i n  a nsi c , i t i s  n ow  p erm is sib le  t o  p ass t h e c o m ple te  \ns tr u ctu re .  b ut, s in ce o ur g o al h ere  i s  t o  l e a rn  m ore  a b out p oin te rs , w e w on ©t  p urs u e t h at.  \na nyw ay , i f  w e p ass t h e w hole  s tr u ctu re  i t m ean s t h at w e m ust c o p y t h e c o nte n ts  o f t h e \ns tr u ctu re  f ro m  t h e c allin g f u nctio n t o  t h e c alle d  f u nctio n.  i n  s y ste m s u sin g s ta ck s, t h is  i s  \nd one b y p ush in g t h e c o nte n ts  o f t h e s tr u ctu re  o n t h e s ta ck . w ith  l a rg e s tr u ctu re s t h is  \nc o uld  p ro ve t o  b e a  p ro ble m . h ow ev er, p assin g a  p oin te r u se s a  m in im um  a m ount o f \ns ta ck  s p ac e.  \ni n  a n y c ase , s in ce t h is  i s  a  d is c u ssio n o f p oin te rs ,  w e w ill d is c u ss h ow  w e g o  a b out \np assin g a  p oin te r t o  a  s tr u ctu re  a n d t h en  u sin g i t w ith in  t h e f u nctio n.  \nc onsid er t h e c ase  d esc rib ed , i .e . w e w an t a  f u n ctio n t h at w ill a ccep t a s a  p ara m ete r a  \np oin te r t o  a  s tr u ctu re  a n d  f ro m  w ith in  t h at f u nctio n w e w an t t o  a ccess m em bers  o f t h e \ns tr u ctu re .  f or e x am ple  w e w an t t o  p rin t o ut t h e n am e o f t h e e m plo yee i n  o u r e x am ple  \ns tr u ctu re .  \no kay , s o  w e k now  t h at o ur p oin te r i s  g o in g t o  p oin t t o  a  s tr u ctu re  d ecla re d  u sin g s tr u ct \nt a g . w e d ecla re  s u ch  a  p oin te r w ith  t h e d ecla ra tio n:  \n     struct tag *st_ptr; \nan d w e p oin t i t t o  o ur e x am ple  s tr u ctu re  w ith :  \n     st_ptr = &my_struct; \nn ow , w e c an  a ccess a  g iv en  m em ber b y d e-re fe re n cin g t h e p oin te r. b ut, h o w  d o w e d e-\nr e fe re n ce t h e p oin te r t o  a  s tr u ctu re ?  w ell, c o nsid er t h e f a ct t h at w e m ig h t w an t t o  u se  t h e \np oin te r t o  s e t t h e a g e o f t h e e m plo yee. w e w ould  w rite :  \n     (*st_ptr).age = 63;\n\n2 4 \nl\nook a t t h is  c are fu ll y .  i t s a y s,  r e p la c e t h at w ith in  t h e p are n th esis  w ith  t h at w hic h  s t_ p tr  \np oin ts  t o , w hic h  i s  t h e s tr u ctu re  m y_str u ct. t hus,  t h is  b re ak s d ow n t o  t h e s a m e a s \nm y_str u ct.a g e.  \nh ow ev er, t h is  i s  a  f a ir ly  o fte n  u se d  e x pre ssio n a n d t h e d esig n ers  o f c  h av e c re ate d  a n  \na lte rn ate  s y n ta x  w ith  t h e s a m e m ean in g w hic h  i s :  \n       st_ptr->age = 63; \nw ith  t h at i n  m in d, l o ok a t t h e f o llo w in g p ro gra m :  \n - ----------- program 5.2 --------------------- \n / * program 5.2 from ptrtut10.htm   6/13/97 */ \n  # include <stdio.h> \n# include <string.h> \n  s truct tag{                     /* the structure type */ \n     char lname[20];             /* last name */ \n     char fname[20];             /* first name */ \n     int age;                    /* age */ \n     float rate;                 /* e.g. 12.75 per hour */ \n} ; \n  s truct tag my_struct;           /* define the structure */ \nv oid show_name(struct tag *p);  /* function prototype */ \n  i nt main(void) \n{  \n     struct tag *st_ptr;         /* a pointer to a structure */ \n     st_ptr = &my_struct;        /* point the pointer to my_struct */  \n     strcpy(my_struct.lname,"jensen"); \n     strcpy(my_struct.fname,"ted"); \n     printf("\\n%s ",my_struct.fname); \n     printf("%s\\n",my_struct.lname); \n     my_struct.age = 63; \n     show_name(st_ptr);          /* pass the pointer */ \n     return 0; \n}  \n v oid show_name(struct tag *p) \n{  \n     printf("\\n%s ", p->fname);  /* p points to a structure */ \n     printf("%s ", p->lname); \n     printf("%d\\n", p->age); \n}  \n - ------------------- end of program 5.2 ---------------- \na gain , t h is  i s  a  l o t o f i n fo rm atio n t o  a b so rb  a t o ne t im e. t he r e ad er s h ould  c o m pile  a n d \nr u n t h e v ario us c o d e s n ip pets  a n d u sin g a  d eb u gger m onito r t h in gs l ik e m y_str u ct a n d p\n\n2 5 \nw\nhile  s in gle  s te p pin g t h ro ugh  t h e m ain  a n d f o llo w in g t h e c o de d ow n i n to  t h e f u nctio n  t o  \ns e e w hat i s  h ap p en in g.\n\n2 6 \nc h apt er  6 : s om e m ore  o n  s tr in gs, a n d a rra y s o f \ns tr in gs  \nw ell, l e t©s  g o  b ack  t o  s tr in gs f o r a  b it.  i n  t h e f o llo w in g a ll a ssig n m en ts  a re  t o  b e \nu nders to od a s b ein g g lo b al, i .e . m ad e o uts id e o f a n y f u n ctio n, i n clu din g m ain ().  \nw e p oin te d  o ut i n  a n  e arlie r c h ap te r t h at w e c o uld  w rite :  \n    char my_string[40] = "ted"; \nw hic h  w ould  a llo cate  s p ace f o r a  4 0 b yte  a rra y  a n d  p ut t h e s tr in g i n  t h e f ir s t 4  b yte s ( th re e \nf o r t h e c h ara cte rs  i n  t h e q uote s a n d a  4 th  t o  h an dle  t h e t e rm in atin g '' \\0 '') .  \na ctu all y , i f  a ll w e w an te d  t o  d o w as s to re  t h e n am e " t ed " w e c o uld  w rite :  \n    char my_name[] = "ted"; \nan d t h e c o m pile r w ould  c o unt t h e c h ara cte rs , l e av e r o om  f o r t h e n ul c h ara cte r a n d s to re  \nt h e t o ta l o f t h e f o ur c h ara cte rs  i n  m em ory  t h e l o catio n o f w hic h  w ould  b e r e tu rn ed  b y t h e \na rra y  n am e, i n  t h is  c ase  m y_n am e.  \ni n  s o m e c o de, i n ste ad  o f t h e a b ove,  y o u m ig h t s e e :  \n    char *my_name = "ted"; \nw hic h  i s  a n  a lte rn ate  a p p ro ach .  i s  t h ere  a  d if fe re n ce b etw een  t h ese ?  t he a n sw er i s ..  y es. \nu sin g t h e a rra y  n ota tio n 4  b yte s o f s to ra g e i n  t h e s ta tic  m em ory  b lo ck  a re  t a k en  u p, o ne \nf o r e a ch  c h ara cte r a n d o n e f o r t h e t e rm in atin g n ul c h ara cte r.  b ut, i n  t h e p oin te r n ota tio n \nt h e s a m e 4  b yte s r e q uir e d , p lu s n  b yte s t o  s to re  t h e p oin te r v aria b le  m y_n am e ( w here  n  \nd ep en ds o n t h e s y ste m  b ut i s  u su all y  a  m in im um  o f 2  b yte s a n d c an  b e 4  o r m ore ).  \ni n  t h e a rr a y  n ota tio n,  m y_n am e i s  s h ort f o r & myn am e[0 ] w hic h  i s  t h e a d dre ss o f t h e \nf ir s t e le m en t o f t h e a rr a y . s in ce t h e l o catio n o f t h e a rra y  i s  f ix ed  d urin g r u n t im e, t h is  i s  a  \nc o nsta n t ( n ot a  v aria b le ).  i n  t h e p oin te r n ota tio n m y_n am e i s  a  v aria b le .  a s t o  w hic h  i s  \nt h e b ette r m eth od, t h at d ep en ds o n w hat y o u a re  g oin g t o  d o w ith in  t h e r e st o f t h e \np ro gra m .  \nl et©s  n ow  g o  o n e s te p  f u rth er a n d c o nsid er w hat h ap pen s i f  e ach  o f t h ese  d ecla ra tio ns a re  \nd one w ith in  a  f u nctio n a s o ppose d  t o  g lo ball y  o uts id e t h e b ounds o f a n y f u n ctio n.  \nv oid my_function_a(char *ptr) \n{  \n     char a[] = "abcde" \n     . \n     . \n}\n\n2 7 \n  v oid my_function_b(char *ptr) \n{  \n     char *cp = "fghij" \n     . \n     . \n}  \nin  t h e c ase  o f m y_fu nctio n _a , t h e c o nte n t, o r v alu e(s ), o f t h e a rr a y  a [] i s  c o nsid ere d  t o  \nb e t h e d ata . t he a rra y  i s  s a id  t o  b e i n itia liz ed  t o  t h e v alu es a bc d e.  i n  t h e c ase  o f \nm y_fu nctio n _b , t h e v alu e o f t h e p oin te r c p  i s  c o nsid ere d  t o  b e t h e d ata . t he p oin te r h as \nb een  i n itia liz ed  t o  p oin t t o  t h e s tr in g f g h ij .  i n  b oth  m y_fu nctio n _a  a n d \nm y_fu nctio n _b  t h e d efin itio ns a re  l o cal v aria b le s a n d t h us t h e s tr in g a bc de i s  s to re d  \no n t h e s ta ck , a s i s  t h e v alu e o f t h e p oin te r c p . t he s tr in g f g h ij  c an  b e s to re d  a n yw here . \no n m y s y ste m  i t g ets  s to re d  i n  t h e d ata  s e g m en t.  \nb y t h e w ay , a rra y  i n itia liz atio n o f a u to m atic  v aria b le s a s i  h av e d one i n  m y_fu nctio n _a  \nw as i lle g al i n  t h e o ld er k & r c  a n d o nly  " c am e o f a g e" i n  t h e n ew er a nsi c . a  f a ct t h at \nm ay  b e i m porta n t w hen  o ne i s  c o nsid erin g p orta b il it y  a n d b ack w ard s c o m patib ilit y .  \na s l o ng a s w e a re  d is c u ssin g t h e r e la tio nsh ip /d if fe re n ces b etw een  p oin te rs  a n d a rr a y s, \nl e t©s  m ove o n t o  m ulti- d im en sio nal a rra y s. c onsid er, f o r e x am ple  t h e a rr a y :  \n     char multi[5][10]; \nju st w hat d oes t h is  m ean ? w ell, l e t©s  c o nsid er i t i n  t h e f o llo w in g l i g h t.  \n     char multi[5][10]; \nl et©s  t a k e t h e u nderlin ed  p art t o  b e t h e " n am e" o f a n  a rr a y . t hen  p re p en din g t h e c h ar a n d \na p pen din g t h e [ 1 0] w e h av e a n  a rra y  o f 1 0 c h ara cte rs . b ut, t h e n am e m ult i[ 5 ] i s  i ts e lf  a n  \na rra y  i n dic atin g t h at t h ere  a re  5  e le m en ts  e ach  b ein g a n  a rr a y  o f 1 0 c h ara cte rs . h en ce  w e \nh av e a n  a rr a y  o f 5  a rra y s o f 1 0 c h ara cte rs  e a ch ..  \na ssu m e w e h av e f ille d  t h is  t w o d im en sio nal a rra y  w ith  d ata  o f s o m e k in d.  i n  m em ory , i t \nm ig h t l o ok a s i f  i t h ad  b een  f o rm ed  b y i n itia liz in g 5  s e p ara te  a rra y s u sin g s o m eth in g l ik e:  \n     multi[0] = {''0'',''1'',''2'',''3'',''4'',''5'',''6'',''7'',''8'',''9''} \n     multi[1] = {''a'',''b'',''c'',''d'',''e'',''f'',''g'',''h'',''i'',''j''} \n     multi[2] = {''a'',''b'',''c'',''d'',''e'',''f'',''g'',''h'',''i'',''j''} \n     multi[3] = {''9'',''8'',''7'',''6'',''5'',''4'',''3'',''2'',''1'',''0''} \n     multi[4] = {''j'',''i'',''h'',''g'',''f'',''e'',''d'',''c'',''b'',''a''} \na t t h e s a m e t im e, i n div id ual e le m en ts  m ig h t b e a d dre ssa b le  u sin g s y n ta x  s u ch  a s: \n     multi[0][3] = ''3'' \n     multi[1][7] = ''h'' \n     multi[4][0] = ''j''\n\n2 8 \ns\nin ce a rr a y s a re  c o nti g u o us i n  m em ory , o ur a ctu al m em ory  b lo ck  f o r t h e a b ove s h ould  \nl o ok l ik e:  \n     0123456789abcdefghijabcdefghij9876543210jihgfedcba \n     ^ \n     |_____ starting at the address &multi[0][0] \nn ote  t h at i  d id  n ot w rite  m ult i[ 0 ] =  " 0123456789 " . h ad  i  d on e s o  a  t e rm in atin g '' \\0 '' \nw ould  h av e b een  i m plie d  s in ce w hen ev er d ouble  q uote s a re  u se d  a  '' \\0 ©  c h ara cte r i s  \na p pen ded  t o  t h e c h ara cte rs  c o nta in ed  w ith in  t h ose  q uote s. h ad  t h at b een  t h e c ase  i  w ould  \nh av e h ad  t o  s e t a sid e r o o m  f o r 1 1 c h ara cte rs  p er r o w  i n ste ad  o f 1 0.  \nm y g o al i n  t h e a b ov e i s  t o  i llu str a te  h ow  m em ory  i s  l a id  o ut f o r 2  d im en sio nal a rr a y s. \nt hat i s , t h is  i s  a  2  d im en sio nal a rra y  o f c h ara cte rs ,  n ot a n  a rra y  o f " str in gs".  \nn ow , t h e c o m pile r k now s h ow  m an y c o lu m ns a re  p re se n t i n  t h e a rra y  s o  i t c an  i n te rp re t \nm ult i +  1  a s t h e a d dre ss o f t h e ©a ©  i n  t h e 2 nd r o w  a b ove. t hat i s , i t a d ds 1 0, t h e n um ber o f \nc o lu m ns, t o  g et t h is  l o catio n.  i f  w e w ere  d ealin g w ith  i n te g ers  a n d a n  a rra y  w ith  t h e s a m e \nd im en sio n t h e c o m pile r w ould  a d d 1 0*siz eo f(in t)  w hic h , o n m y m ach in e,  w ould  b e 2 0. \nt hus, t h e a d dre ss o f t h e 9  i n  t h e 4 th  r o w  a b ove w ould  b e & mult i[ 3 ][0 ] o r * (m ult i +  3 ) i n  \np oin te r n ota tio n. t o g et t o  t h e c o nte n t o f t h e 2 nd e le m en t i n  t h e 4 th  r o w  w e a d d 1  t o  t h is  \na d dre ss a n d d ere fe re n ce t h e r e su lt a s i n   \n     *(*(multi + 3) + 1) \nw ith  a  l ittl e  t h ough t w e c an  s e e t h at:  \n     *(*(multi + row) + col)    and \n     multi[row][col]            yield the same results. \nt he f o llo w in g p ro gra m  i l lu str a te s t h is  u sin g i n te g er a rr a y s i n ste ad  o f c h ara c te r a rr a y s.  \n- ------------------ program 6.1 ---------------------- \n  / * program 6.1 from ptrtut10.htm   6/13/97*/ \n  # include <stdio.h> \n# define rows 5 \n# define cols 10 \n  i nt multi[rows][cols]; \n i nt main(void) \n{  \n     int row, col; \n     for (row = 0; row < rows; row++) \n     { \n         for (col = 0; col < cols; col++) \n         { \n             multi[row][col] = row*col; \n         }\n\n2 9 \n     } \n       for (row = 0; row < rows; row++) \n     { \n         for (col = 0; col < cols; col++) \n         { \n             printf("\\n%d  ",multi[row][col]); \n             printf("%d ",*(*(multi + row) + col)); \n         } \n     } \n       return 0; \n}  \n- ---------------- end of program 6.1 ---------------------    \nb ec au se  o f t h e d ouble  d e-re fe re n cin g r e q uir e d  i n  t h e p oin te r v ers io n, t h e n am e o f a  2  \nd im en sio nal a rra y  i s  o fte n  s a id  t o  b e e q uiv ale n t t o  a  p oin te r t o  a  p oin te r. w ith  a  t h re e  \nd im en sio nal a rra y  w e w ould  b e d ealin g w ith  a n  a rra y  o f a rra y s o f a rra y s a n d s o m e m ig h t \ns a y  i ts  n am e w ould  b e e q uiv ale n t t o  a  p oin te r t o  a  p oin te r t o  a  p oin te r. h ow ev er, h ere  w e \nh av e i n itia ll y  s e t a sid e t h e b lo ck  o f m em ory  f o r t h e a rr a y  b y d efin in g i t u sin g a rra y  \nn ota tio n. h en ce, w e a re  d ealin g w ith  a  c o nsta n t, n ot a  v aria b le . t hat i s  w e a re  t a lk in g \na b out a  f ix ed  a d dre ss n ot a  v aria b le  p oin te r. t he d ere fe re n cin g f u nctio n u se d  a b ove \np erm its  u s t o  a ccess a n y e le m en t i n  t h e a rr a y  o f a rra y s w ith out t h e n eed  o f c h an gin g t h e \nv alu e o f t h at a d d re ss ( th e a d dre ss o f m ult i[ 0 ][0 ] a s g iv en  b y t h e s y m bol m ult i) .\n\n3 0 \nc h apt er  7 : m ore o n  m ult i- d im en sio n al a rra y s \nin  t h e p re v io us c h ap te r w e n ote d  t h at g iv en   \n       #define rows 5 \n     #define cols 10 \n      int multi[rows][cols]; \nw e c an  a c cess i n div id ual e le m en ts  o f t h e a rra y  m ult i u sin g e ith er:  \n      multi[row][col] \nor  \n       *(*(multi + row) + col) \n \nt o u nders ta n d m ore  f u ll y  w hat i s  g o in g o n, l e t u s r e p la ce  \n       *(multi + row) \n \nw ith  x  a s i n :  \n      *(x + col) \n \nn ow , f ro m  t h is  w e s e e t h at x  i s  l ik e a  p oin te r s in ce t h e e x pre ssio n i s  d e-re fe re n ced  a n d \nw e k now  t h at c o l i s  a n  i n te g er. h ere  t h e a rith m etic  b ein g u se d  i s  o f a  s p ecia l k in d c alle d  \n" p oin te r a rith m etic " i s  b ein g u se d . t hat m ean s t h at, s in ce w e a re  t a lk in g a b out a n  i n te g er \na rra y , t h e a d dre ss p oin te d  t o  b y ( i.e . v alu e o f) x  +  c o l +  1  m ust b e g re ate r t h an  t h e \na d dre ss x  +  c o l b y a n d a m ount e q ual t o  s iz eo f(in t).  \ns in ce w e k now  t h e m em ory  l a y o ut f o r 2  d im en sio nal a rr a y s,  w e c an  d ete rm in e t h at i n  t h e \ne x pre ssio n m ult i +  r o w  a s u se d  a b ove,  m ult i +  r o w  +  1  m ust i n cre ase  b y v alu e a n  \na m ount e q ual t o  t h at n ee d ed  t o  " p oin t t o " t h e n ex t r o w , w hic h  i n  t h is  c ase  w ould  b e a n  \na m ount e q ual t o  c o ls *  s iz eo f(in t).  \nt hat s a y s t h at i f  t h e e x pre ssio n * (* (m ult i +  r o w ) +  c o l)  i s  t o  b e e v alu ate d  c o rre ctl y  a t r u n \nt im e, t h e c o m pile r m ust g en era te  c o de w hic h  t a k es i n to  c o nsid era tio n t h e v alu e o f c o ls, \ni .e . t h e 2 nd d im en sio n. b ecau se  o f t h e e q uiv ale n ce o f t h e t w o f o rm s o f e x pre ssio n, t h is  i s  \nt r u e w heth er w e a re  u sin g t h e p oin te r e x pre ssio n a s h ere  o r t h e a rra y  e x pre ssio n \nm ult i[ r o w ][ c o l] .  \nt hus, t o  e v alu ate  e ith er e x pre ssio n, a  t o ta l o f 5  v alu es m ust b e k now n:  \n1 .  the a d dre ss o f t h e f ir s t e le m en t o f t h e a rra y , w hic h  i s  r e tu rn ed  b y t h e e x pre ss io n \nm ult i, i .e ., t h e n am e o f t h e a rr a y .  \n2 .  the s iz e o f t h e t y p e o f t h e e le m en ts  o f t h e a rr a y , i n  t h is  c ase  s iz eo f(in t).  \n3 .  the 2 nd d im en sio n o f t h e a rr a y   \n4 .  the s p ecif ic  i n d ex  v alu e f o r t h e f ir s t d im en sio n, r o w  i n  t h is  c ase .  \n5 .  the s p ecif ic  i n d ex  v alu e f o r t h e s e co nd  d im en sio n, c o l i n  t h is  c ase .\n\n3 1 \ng\niv en  a ll o f t h at, c o nsid er t h e p ro ble m  o f d esig n in g a  f u nctio n t o  m an ip ula te  t h e e le m en t \nv alu es o f a  p re v io usly  d ecla re d  a rr a y . f or e x am ple , o ne w hic h  w ould  s e t a ll t h e e le m en ts  \no f t h e a rr a y  m ult i t o  t h e v alu e 1 .  \n       void set_value(int m_array[][cols]) \n     { \n         int row, col; \n         for (row = 0; row < rows; row++) \n         { \n             for (col = 0; col < cols; col++) \n             { \n                 m_array[row][col] = 1; \n             } \n         } \n     } \n \na nd t o  c all t h is  f u nctio n w e w ould  t h en  u se :  \n       set_value(multi); \n \nn ow , w ith in  t h e f u nctio n w e h av e u se d  t h e v alu es # defin ed  b y r o w s a n d c o ls t h at s e t \nt h e l im its  o n t h e f o r l o ops. b ut, t h ese  # defin es a re  j u st c o nsta n ts  a s f a r a s t h e c o m pile r i s  \nc o ncern ed , i .e . t h ere  i s  n oth in g t o  c o nnect t h em  t o  t h e a rr a y  s iz e w ith in  t h e f u nctio n.  r o w  \na n d c o l a re  l o cal v aria b le s, o f c o urs e . t he f o rm al p ara m ete r d efin itio n p erm its  t h e \nc o m pile r t o  d ete rm in e t h e c h ara cte ris tic s a sso cia te d  w ith  t h e p oin te r v alu e t h at w ill b e \np asse d  a t r u n t im e. w e r e all y  d on’t n eed  t h e f ir s t d im en sio n a n d, a s w ill b e s e en  l a te r, \nt h ere  a re  o ccasio ns w here  w e w ould  p re fe r n ot t o  d efin e i t w ith in  t h e p ara m ete r \nd efin itio n, o ut o f h ab it o r c o nsis te n cy ,  i  h av e n ot u se d  i t h ere .  b ut, t h e s e co nd d im en sio n \nm ust b e u se d  a s h as b een  s h ow n i n  t h e e x pre ssio n f o r t h e p ara m ete r. t he r e aso n i s  t h at \nw e n eed  t h is  i n  t h e e v alu atio n o f m _arra y [r o w ][c o l]  a s h as b ee n  d esc rib ed . w hile  t h e \np ara m ete r d efin es t h e d ata  t y p e ( in t i n  t h is  c ase ) a n d t h e a u to m atic  v aria b le s f o r r o w  a n d \nc o lu m n a re  d efin ed  i n  t h e f o r l o ops, o nly  o n e v alu e c an  b e p asse d  u sin g a  s in gle  \np ara m ete r.  i n  t h is  c ase , t h at i s  t h e v alu e o f m ult i a s n ote d  i n  t h e c all s ta te m en t, i .e . t h e \na d dre ss o f t h e f ir s t e le m en t, o fte n  r e fe rr e d  t o  a s a  p oin te r t o  t h e a rr a y . t hus, t h e o nly  w ay  \nw e h av e o f i n fo rm in g t h e c o m pile r o f t h e 2 nd d im en sio n i s  b y e x plic itl y  i n clu din g i t i n  \nt h e p ara m ete r d efin itio n.  \ni n  f a ct, i n  g en era l a ll d im en sio ns o f h ig h er o rd er t h an  o ne a re  n eed ed  w hen  d ealin g w ith  \nm ulti- d im en sio nal a rra y s. t hat i s  i f  w e a re  t a lk in g a b out 3  d im en sio nal a rra y s, t h e 2 n d \na n d 3 rd  d im en sio n m ust b e s p ecif ie d  i n  t h e p ara m ete r d efin itio n.\n\n3 2 \nc h apt er  8 : p oin te rs t o  a rra y s \npoin te rs , o f c o urs e ,  c an  b e " p oin te d  a t"  a n y t y p e o f d ata  o bje ct, i n clu din g a rra y s. w hile  \nt h at w as e v id en t w hen  w e d is c u sse d  p ro gra m  3 .1 ,  i t i s  i m porta n t t o  e x pan d o n h ow  w e d o \nt h is  w hen  i t c o m es t o  m ulti- d im en sio nal a rra y s.  \nt o r e v ie w , i n  c hap te r 2  w e s ta te d  t h at g iv en  a n  a rra y  o f i n te g ers  w e c o uld  p oin t a n  \ni n te g er p oin te r a t t h at a rr a y  u sin g:  \n     int *ptr; \n     ptr = &my_array[0];       /* point our pointer at the first \n                                  integer in our array */ \na s w e s ta te d  t h ere , t h e t y p e o f t h e p oin te r v aria b le  m ust m atc h  t h e t y p e o f t h e f ir s t \ne le m en t o f t h e a rra y .  \ni n  a d ditio n, w e c an  u se  a  p oin te r a s a  f o rm al p ara m ete r o f a  f u nctio n w hic h  i s  d esig n ed  t o  \nm an ip ula te  a n  a rra y . e .g .   \ng iv en :  \n     int array[3] = {''1'', ''5'', ''7''}; \n     void a_func(int *p); \n \ns om e p ro gra m mers  m ig h t p re fe r t o  w rite  t h e f u n ctio n p ro to ty p e a s:  \n      void a_func(int p[]); \n \nw hic h  w ould  t e n d t o  i n fo rm  o th ers  w ho m ig h t u se  t h is  f u nctio n t h at t h e f u nctio n i s  \nd esig n ed  t o  m an ip ula te  t h e e le m en ts  o f a n  a rra y .  o f c o urs e , i n  e ith er c ase ,  w hat a ctu all y  \ng ets  p ass e d  i s  t h e v alu e o f a  p oin te r t o  t h e f ir s t e le m en t o f t h e a rr a y , i n dep en den t o f w hic h  \nn ota tio n i s  u se d  i n  t h e f u nctio n p ro to ty p e o r d efin itio n. n ote  t h at i f  t h e a rra y  n ota tio n  i s  \nu se d , t h ere  i s  n o n eed  t o  p ass t h e a ctu al d im en sio n o f t h e a rr a y  s in ce w e a re  n ot p assin g \nt h e w hole  a rra y , o nly  t h e a d dre ss t o  t h e f ir s t e le m en t.  \nw e n ow  t u rn  t o  t h e p ro ble m  o f t h e 2  d im en sio nal a rra y .  a s s ta te d  i n  t h e l a st c h ap te r, c  \ni n te rp re ts  a  2  d im en sio nal a rra y  a s a n  a rra y  o f o ne d im en sio nal a rra y s. t hat b ein g t h e \nc ase , t h e f ir s t e le m en t o f a  2  d im en sio nal a rr a y  o f i n te g ers  i s  a  o ne d im en sio nal a rr a y  o f \ni n te g ers . a nd a  p oin te r t o  a  t w o d im en sio nal a rr a y  o f i n te g ers  m ust b e a  p oin te r t o  t h at \nd ata  t y p e. o ne w ay  o f a c co m plis h in g t h is  i s  t h ro ugh  t h e u se  o f t h e k ey w ord  " ty p ed ef" . \nt y p ed ef a ssig n s a  n ew  n am e t o  a  s p ecif ie d  d ata  t y p e. f or e x am ple :  \n     typedef unsigned char byte; \n \nc au se s t h e n am e b yte  t o  m ean  t y p e u nsig n ed  c h ar. h en ce  \n       byte b[10];     would be an array of unsigned characters.\n\n3 3 \nn\note  t h at i n  t h e t y p ed ef d ecla ra tio n, t h e w ord  b yte  h as r e p la ced  t h at w hic h  w ould  \nn orm all y  b e t h e n am e o f o ur u nsig n ed  c h ar. t hat i s , t h e r u le  f o r u sin g t y p ed ef i s  t h at t h e \nn ew  n am e f o r t h e d ata  t y p e i s  t h e n am e u se d  i n  t h e d efin itio n o f t h e d ata  t y p e. t hus i n :  \n       typedef int array[10]; \n \na rra y  b eco m es a  d ata  t y p e f o r a n  a rr a y  o f 1 0 i n te g ers . i .e . a rra y m y_a rr; d ecla re s \nm y_a rr a s a n  a rra y  o f 1 0  i n te g ers  a n d a rra y a rr2 d [5 ]; m ak es a rr2 d  a n  a rr a y  o f 5  a rra y s \no f 1 0 i n te g ers  e ach .  \na ls o  n ote  t h at a rra y * p 1d ; m ak es p 1d  a  p oin te r t o  a n  a rr a y  o f 1 0 i n te g ers . b ec au se  \n* p 1d  p oin ts  t o  t h e s a m e t y p e a s a rr2 d ,  a ssig n in g t h e a d dre ss o f t h e t w o d im en sio nal \na rra y  a rr2 d  t o  p 1d , t h e p oin te r t o  a  o ne d im en sio n al a rr a y  o f 1 0 i n te g ers  i s  a cc ep ta b le . \ni .e . p 1d  =  & arr2 d [0 ]; o r p 1d  =  a rr2 d ; a re  b oth  c o rre ct.  \ns in ce t h e d ata  t y p e w e u se  f o r o ur p oin te r i s  a n  a rra y  o f 1 0 i n te g ers  w e w ou ld  e x pect t h at \ni n cre m en tin g p 1d  b y 1  w ould  c h an ge i ts  v alu e b y 1 0*siz eo f(in t), w hic h  i t d oes. t hat i s , \ns iz eo f(* p 1d ) i s  2 0. y ou c an  p ro ve t h is  t o  y o urs e lf  b y w ritin g a n d r u nnin g a  s im ple  s h ort \np ro gra m .  \nn ow , w hile  u sin g t y p ed ef m ak es t h in gs c le a re r f o r t h e r e ad er a n d e asie r o n t h e \np ro gra m mer, i t i s  n ot r e ally  n ecessa ry . w hat w e n eed  i s  a  w ay  o f d ecla rin g a  p oin te r l ik e \np 1d  w ith out t h e n eed  o f t h e t y p ed ef k ey w ord .  i t t u rn s o ut t h at t h is  c an  b e d one a n d t h at  \n     int (*p1d)[10]; \n \ni s  t h e p ro per d ecla ra tio n, i .e . p 1d  h ere  i s  a  p oin te r t o  a n  a rr a y  o f 1 0 i n te g ers  j u st a s i t  w as \nu nder t h e d ecla ra tio n u sin g t h e a rra y  t y p e. n ote  t h at t h is  i s  d if fe re n t f ro m   \n       int *p1d[10]; \n \nw hic h  w ould  m ak e p 1d  t h e n am e o f a n  a rra y  o f 1 0 p oin te rs  t o  t y p e i n t.\n\n3 4 \nc h apt er  9 : p oin te rs a n d d yn am ic  a llo ca tio n  o f \nm em ory  \nthere  a re  t im es w hen  i t i s  c o nven ie n t t o  a llo cate  m em ory  a t r u n t im e u sin g m allo c(), \nc a llo c(), o r o th er a llo catio n f u nctio ns. u sin g t h is  a p pro ach  p erm its  p ostp onin g t h e \nd ecis io n o n t h e s iz e o f t h e m em ory  b lo ck  n eed  t o  s to re  a n  a rra y , f o r e x am ple , u ntil r u n \nt im e. o r i t p erm its  u sin g a  s e ctio n o f m em ory  f o r t h e s to ra g e o f a n  a rra y  o f i n te g ers  a t \no ne p oin t i n  t im e, a n d t h en  w hen  t h at m em ory  i s  n o l o nger n eed ed  i t c an  b e f re ed  u p f o r \no th er u se s, s u ch  a s t h e s to ra g e o f a n  a rra y  o f s tr u ctu re s.  \nw hen  m em ory  i s  a llo cate d , t h e a llo catin g f u n ctio n ( s u ch  a s m allo c(), c a ll o c(), e tc .)  \nr e tu rn s a  p oin te r. t he t y p e o f t h is  p oin te r d ep en ds o n w heth er y o u a re  u sin g a n  o ld er \nk & r c o m pile r o r t h e n ew er a nsi t y p e c o m pile r. w ith  t h e o ld er c o m pile r t h e t y p e o f t h e \nr e tu rn ed  p oin te r i s  c h ar,  w ith  t h e a nsi c o m pile r i t i s  v oid .  \ni f  y o u a re  u sin g a n  o ld er c o m pile r, a n d y o u w an t t o  a llo cate  m em ory  f o r a n  a rra y  o f \ni n te g ers  y o u w ill h av e t o  c ast t h e c h ar p oin te r r e tu rn ed  t o  a n  i n te g er p oin te r. f or e x am ple , \nt o  a llo cate  s p ac e f o r 1 0 i n te g ers  w e m ig h t w rite :  \n     int *iptr; \n     iptr = (int *)malloc(10 * sizeof(int)); \n     if (iptr == null) \n       { .. error routine goes here .. } \n \ni f  y o u a re  u sin g a n  a nsi c o m plia n t c o m pile r,  m allo c() r e tu rn s a  v oid  p oin te r a n d s in ce a  \nv oid  p oin te r c an  b e a ssig ned  t o  a  p oin te r v aria b le  o f a n y o bje ct t y p e, t h e ( in t * ) c ast \ns h ow n a b ove i s  n ot n eed ed . t he a rra y  d im en sio n c an  b e d ete rm in ed  a t r u n t im e a n d i s  n ot \nn eed ed  a t c o m pile  t im e. t hat i s , t h e 1 0 a b ove c o u ld  b e a  v aria b le  r e ad  i n  f r o m  a  d ata  f ile  \no r k ey b oard , o r c alc u la te d  b ase d  o n s o m e n eed , a t r u n t im e.  \nb ec au se  o f t h e e q uiv ale n ce b etw een  a rra y  a n d p oin te r n ota tio n, o nce i p tr  h as b een  \na ssig n ed  a s a b ov e, o ne c an  u se  t h e a rra y  n ota tio n. f or e x am ple , o ne c o uld  w rite :  \n     int k; \n     for (k = 0; k < 10; k++) \n        iptr[k] = 2; \n \nt o  s e t t h e v alu es o f a ll e le m en ts  t o  2 .  \ne ven  w ith  a  r e aso nab ly  g ood u nders ta n din g o f p oin te rs  a n d a rra y s, o n e p la c e t h e \nn ew co m er t o  c  i s  l ik ely  t o  s tu m ble  a t f ir s t i s  i n  t h e d yn am ic  a llo catio n o f m ulti-\nd im en sio nal a rra y s.  i n  g en era l, w e w ould  l ik e t o  b e a b le  t o  a ccess e le m en ts  o f s u ch  a rra y s \nu sin g a rra y  n ota tio n, n ot p oin te r n ota tio n, w here v er p ossib le . d ep en din g o n t h e \na p plic atio n w e m ay  o r m ay  n ot k now  b oth  d im en sio ns a t c o m pile  t im e. t his  l e ad s t o  a  \nv arie ty  o f w ay s t o  g o  a b o ut o ur t a sk .\n\n3 5 \na\ns w e h av e s e en , w hen  d yn am ic all y  a llo catin g a  o ne d im en sio nal a rr a y  i ts  d im en sio n  c an  \nb e d ete rm in ed  a t r u n t im e. n ow , w hen  u sin g d yn am ic  a llo catio n o f h ig h er o rd er a rra y s, \nw e n ev er n eed  t o  k no w  t h e f ir s t d im en sio n a t c o m pile  t im e. w heth er w e n eed  t o  k now  t h e \nh ig h er d im en sio ns d ep en ds o n h ow  w e g o  a b out w ritin g t h e c o d e. h ere  i  w ill d is c u ss  \nv ario us m eth ods o f d yn am ic all y  a llo catin g r o om  f o r 2  d im en sio nal a rr a y s o f i n te g ers .  \nf ir s t w e w ill c o nsid er c ase s w here  t h e 2 nd d im en sio n i s  k now n a t c o m pile  t im e.  \nm eth o d 1 : \no ne w ay  o f d ealin g w ith  t h e p ro ble m  i s  t h ro ugh  t h e u se  o f t h e t y p ed ef k ey w ord . t o \na llo cate  a  2  d im en sio nal a rra y  o f i n te g ers  r e c all t h at t h e f o llo w in g t w o n ota tio ns r e su lt i n  \nt h e s a m e o bje ct c o d e b ein g g en era te d :  \n         multi[row][col] = 1;     *(*(multi + row) + col) = 1; \n \ni t i s  a ls o  t r u e t h at t h e f o llo w in g t w o n ota tio ns g en era te  t h e s a m e c o d e:  \n      multi[row]            *(multi + row) \n \ns in ce t h e o ne o n t h e r ig h t m ust e v alu ate  t o  a  p oin te r, t h e a rra y  n ota tio n o n t h e l e ft m ust \na ls o  e v alu ate  t o  a  p oin te r.  i n  f a ct m ult i[ 0 ] w ill r e tu rn  a  p oin te r t o  t h e f ir s t i n te g er i n  t h e \nf ir s t r o w ,  m ult i[ 1 ] a  p oin te r t o  t h e f ir s t i n te g er o f t h e s e co nd r o w , e tc . a ctu all y ,  m ult i[ n ] \ne v alu ate s t o  a  p oin te r t o  t h at a rr a y  o f i n te g ers  t h at m ak e u p t h e n -th  r o w  o f o ur 2  \nd im en sio nal a rra y . t hat i s , m ult i c an  b e t h ou gh t o f a s a n  a rra y  o f a rra y s a n d m ult i[ n ] a s \na  p oin te r t o  t h e n -th  a rra y  o f t h is  a rra y  o f a rra y s. h ere  t h e w ord  p oin te r i s  b ein g u se d  t o  \nr e p re se n t a n  a d d re ss v alu e. w hile  s u ch  u sa g e i s  c o m mon i n  t h e l ite ra tu re , w hen  r e ad in g \ns u ch  s ta te m en ts  o ne m ust b e c are fu l t o  d is tin gu is h  b etw een  t h e c o nsta n t a d d re ss o f a n  \na rra y  a n d a  v aria b le  p oin te r w hic h  i s  a  d ata  o bje ct i n  i ts e lf .  \nc onsid er n ow :  \n- -------------- program 9.1 -------------------------------- \n / * program 9.1 from ptrtut10.htm  6/13/97 */ \n # include <stdio.h> \n# include <stdlib.h> \n # define cols 5 \n t ypedef int rowarray[cols]; \nr owarray *rptr; \n i nt main(void) \n{  \n     int nrows = 10; \n     int row, col; \n     rptr = malloc(nrows * cols * sizeof(int)); \n     for (row = 0; row < nrows; row++)\n\n3 6 \n     { \n         for (col = 0; col < cols; col++) \n         { \n             rptr[row][col] = 17; \n         } \n     } \n       return 0; \n}  \n- ------------ end of prog. 9.1 -------------------------------- \n \nh ere  i  h av e a ssu m ed  a n  a nsi c o m pile r s o  a  c ast o n t h e v oid  p oin te r r e tu rn ed  b y m allo c() \ni s  n ot r e q uir e d .  i f  y o u a re  u sin g a n  o ld er k & r c o m pile r y o u w ill h av e t o  c ast u sin g:  \n      rptr = (rowarray *)malloc(.... etc. \n \nu sin g t h is  a p pro ach , r p tr  h as a ll t h e c h ara cte ris tic s o f a n  a rra y  n am e n am e, ( e x cep t t h at \nr p tr  i s  m odif ia b le ), a n d a rra y  n ota tio n m ay  b e u se d  t h ro ugh out t h e r e st o f t h e p ro gra m . \nt hat a ls o  m ean s t h at i f  y o u i n te n d t o  w rite  a  f u nctio n t o  m odif y  t h e a rra y  c o nte n ts ,  y o u \nm ust u se  c o ls a s a  p art o f t h e f o rm al p ara m ete r i n  t h at f u nctio n, j u st a s w e d id  w hen  \nd is c u ssin g t h e p assin g o f t w o d im en sio nal a rra y s t o  a  f u nctio n.  \nm eth o d 2 : \nin  t h e m eth od 1  a b ove, r p tr  t u rn ed  o ut t o  b e a  p oin te r t o  t y p e " o ne d im en sio nal a rr a y  \no f c o ls i n te g ers " .  i t t u rn s o ut t h at t h ere  i s  s y n ta x  w hic h  c an  b e u se d  f o r t h is  t y p e \nw ith out t h e n eed  o f t y p ed ef.  i f  w e w rite :  \n      int (*xptr)[cols]; \n \nt h e v aria b le  x p tr  w ill h av e a ll t h e s a m e c h ara cte ris tic s a s t h e v aria b le  r p tr  i n  m eth o d \n1  a b ove, a n d w e n eed  n ot u se  t h e t y p ed ef k ey w ord . h ere  x p tr  i s  a  p oin te r t o  a n  a rr a y  o f \ni n te g ers  a n d t h e s iz e o f t h at a rr a y  i s  g iv en  b y t h e # d efin ed  c o ls. t he p are n th esis  \np la cem en t m ak es t h e p oin te r n ota tio n p re d om in ate , e v en  t h ou gh  t h e a rr a y  n ota tio n h as \nh ig h er p re ced en ce. i .e . h ad  w e w ritte n   \n      int *xptr[cols]; \n \nw e w ould  h av e d efin ed  x p tr  a s a n  a rra y  o f p oin te rs  h old in g t h e n um ber o f p oin te rs  e q ual \nt o  t h at # defin ed  b y c o ls. t hat i s  n ot t h e s a m e t h in g a t a ll. h ow ev er,  a rr a y s o f p oin te rs  \nh av e t h eir  u se  i n  t h e d yn am ic  a llo catio n o f t w o d im en sio nal a rra y s,  a s w ill b e s e en  i n  t h e \nn ex t 2  m eth ods.  \nm eth o d 3 : \nc onsid er t h e c ase  w here  w e d o n ot k now  t h e n um ber o f e le m en ts  i n  e ach  r o w  a t c o m pile  \nt im e, i .e . b oth  t h e n um ber o f r o w s a n d n um ber o f c o lu m ns m ust b e d ete rm in ed  a t r u n  \nt im e. o ne w ay  o f d oin g t h is  w ould  b e t o  c re ate  a n  a rra y  o f p oin te rs  t o  t y p e i n t a n d t h en  \na llo cate  s p ace f o r e a ch  r o w  a n d p oin t t h ese  p oin te rs  a t e ach  r o w . c onsid er:\n\n3 7 \n  - ------------- program 9.2 ------------------------------------ \n / * program 9.2 from ptrtut10.htm   6/13/97 */ \n # include <stdio.h> \n# include <stdlib.h> \n i nt main(void) \n{  \n     int nrows = 5;     /* both nrows and ncols could be evaluated */  \n     int ncols = 10;    /* or read in at run time */ \n     int row; \n     int **rowptr; \n     rowptr = malloc(nrows * sizeof(int *)); \n     if (rowptr == null) \n     { \n         puts("\\nfailure to allocate room for row pointers.\\n"); \n         exit(0); \n     } \n      printf("\\n\\n\\nindex   pointer(hex)   pointer(dec)   diff.(dec)") ; \n      for (row = 0; row < nrows; row++) \n     { \n         rowptr[row] = malloc(ncols * sizeof(int)); \n         if (rowptr[row] == null) \n         { \n             printf("\\nfailure to allocate for row[%d]\\n",row); \n             exit(0); \n         } \n         printf("\\n%d         %p         %d", row, rowptr[row], \nr owptr[row]); \n         if (row > 0) \n         printf("              %d",(int)(rowptr[row] - rowptr[row-1]) ); \n     } \n       return 0; \n}  \n  - -------------- end 9.2 ------------------------------------ \n \ni n  t h e a b ove c o de r o w ptr  i s  a  p oin te r t o  p oin te r t o  t y p e i n t.  i n  t h is  c ase  i t p oin ts  t o  t h e \nf ir s t e le m en t o f a n  a rr a y  o f p oin te rs  t o  t y p e i n t. c onsid er t h e n um ber o f c alls  t o  m all o c():  \n      to get the array of pointers             1     call \n     to get space for the rows                5     calls \n                                           ----- \n                      total                   6     calls \n \ni f  y o u c h oose  t o  u se  t h is  a p pro ach  n ote  t h at w hile  y o u c an  u se  t h e a rr a y  n ota tio n t o  a c cess \ni n div id ual e le m en ts  o f t h e a rr a y , e .g .  r o w ptr [r o w ][c o l]  =  1 7;, i t d oes n ot m ean  t h at t h e \nd ata  i n  t h e " tw o d im en sio nal a rr a y " i s  c o nti g u ous i n  m em ory .\n\n3 8 \ny\nou c an , h ow ev er, u se  t h e a rr a y  n ota tio n j u st a s i f  i t w ere  a  c o ntin uous b lo ck  o f m em ory . \nf or e x am ple ,  y o u c an  w rite :  \n     rowptr[row][col] = 176; \n \nj u st a s i f  r o w ptr  w ere  t h e n am e o f a  t w o d im en sio n al a rr a y  c re ate d  a t c o m pile  t im e. o f \nc o urs e  r o w  a n d c o l m ust b e w ith in  t h e b ounds o f t h e a rr a y  y o u h av e c re ate d , j u st a s w ith  \na n  a rr a y  c re ate d  a t c o m pile  t im e.  \ni f  y o u w an t t o  h av e a  c o n tig u ous b lo ck  o f m em ory  d ed ic ate d  t o  t h e s to ra g e o f t h e \ne le m en ts  i n  t h e a rr a y  y o u  c an  d o i t a s f o llo w s:  \nm eth o d 4 : \nin  t h is  m eth od w e a llo cate  a  b lo ck  o f m em ory  t o  h old  t h e w hole  a rr a y  f ir s t.  w e t h en  \nc re ate  a n  a rra y  o f p oin te rs  t o  p oin t t o  e ach  r o w . t hus e v en  t h ou gh  t h e a rra y  o f p oin te rs  i s  \nb ein g u se d , t h e a ctu al a rr a y  i n  m em ory  i s  c o ntig u o us. t he c o de l o oks l ik e t h is :  \n  - ---------------- program 9.3 ----------------------------------- \n / * program 9.3 from ptrtut10.htm   6/13/97 */ \n  # include <stdio.h> \n# include <stdlib.h> \n  i nt main(void) \n{  \n     int **rptr; \n     int *aptr; \n     int *testptr; \n     int k; \n     int nrows = 5;     /* both nrows and ncols could be evaluated */  \n     int ncols = 8;    /* or read in at run time */ \n     int row, col; \n      /* we now allocate the memory for the array */ \n       aptr = malloc(nrows * ncols * sizeof(int)); \n     if (aptr == null) \n     { \n         puts("\\nfailure to allocate room for the array"); \n         exit(0); \n     } \n      /* next we allocate room for the pointers to the rows */ \n       rptr = malloc(nrows * sizeof(int *)); \n     if (rptr == null) \n     { \n         puts("\\nfailure to allocate room for pointers"); \n         exit(0); \n     }\n\n3 9 \n     /* and now we ''point'' the pointers */ \n       for (k = 0; k < nrows; k++) \n     { \n         rptr[k] = aptr + (k * ncols); \n     } \n      /* now we illustrate how the row pointers are incremented */ \n     printf("\\n\\nillustrating how row pointers are incremented"); \n     printf("\\n\\nindex   pointer(hex)  diff.(dec)"); \n       for (row = 0; row < nrows; row++) \n     { \n         printf("\\n%d         %p", row, rptr[row]); \n         if (row > 0) \n         printf("              %d",(rptr[row] - rptr[row-1])); \n     } \n     printf("\\n\\nand now we print out the array\\n"); \n     for (row = 0; row < nrows; row++) \n     { \n         for (col = 0; col < ncols; col++) \n         { \n             rptr[row][col] = row + col; \n             printf("%d ", rptr[row][col]); \n         } \n         putchar(''\\n''); \n     } \n      puts("\\n"); \n      /* and here we illustrate that we are, in fact, dealing with \n        a 2 dimensional array in a contiguous block of memory. */ \n     printf("and now we demonstrate that they are contiguous in \nm emory\\n"); \n      testptr = aptr; \n     for (row = 0; row < nrows; row++) \n     { \n         for (col = 0; col < ncols; col++) \n         { \n             printf("%d ", *(testptr++)); \n         } \n         putchar(''\\n''); \n     } \n      return 0; \n}  \n - ------------ end program 9.3 ----------------- \n \nc onsid er a g ain , t h e n um ber o f c alls  t o  m allo c()  \n      to get room for the array itself      1      call \n     to get room for the array of ptrs     1      call \n                                         ---- \n                          total            2      calls\n\n4 0 \n \nn ow , e a ch  c all t o  m allo c() c re ate s a d ditio nal s p ac e o verh ead  s in ce m allo c() i s  g en era ll y  \ni m ple m en te d  b y t h e o p era tin g s y ste m  f o rm in g a  l i n ked  l is t w hic h  c o nta in s d ata  \nc o ncern in g t h e s iz e o f t h e b lo ck . b ut, m ore  i m porta n tl y , w ith  l a rg e a rr a y s ( s e v era l \nh undre d  r o w s) k eep in g t r a ck  o f w hat n eed s t o  b e f re ed  w hen  t h e t im e c o m es c an  b e m ore  \nc u m bers o m e. t his , c o m bin ed  w ith  t h e c o ntig u ousn ess o f t h e d ata  b lo ck  t h at p erm its  \ni n itia liz atio n t o  a ll z ero es u sin g m em se t() w ould  s e em  t o  m ak e t h e s e co nd a lte rn ativ e t h e \np re fe rre d  o n e.  \na s a  f in al e x am ple  o n m ultid im en sio nal a rra y s w e w ill i llu str a te  t h e d yn am ic  a llo catio n \no f a  t h re e d im en sio nal a rra y . t his  e x am ple  w ill i llu str a te  o ne m ore  t h in g t o  w atc h  w hen  \nd oin g t h is  k in d o f a llo catio n. f or r e aso ns c ite d  a b ove w e w ill u se  t h e a p p ro ach  o utlin ed  i n  \na lte rn ativ e t w o. c onsid er t h e f o llo w in g c o d e:  \n  - ------------------ program 9.4 ------------------------------------ - \n  / * program 9.4 from ptrtut10.htm   6/13/97 */ \n # include <stdio.h> \n# include <stdlib.h> \n# include <stddef.h> \n  i nt x_dim=16; \ni nt y_dim=5; \ni nt z_dim=3; \n  i nt main(void) \n{  \n     char *space; \n     char ***arr3d; \n     int y, z; \n     ptrdiff_t diff; \n      /* first we set aside space for the array itself */ \n       space = malloc(x_dim * y_dim * z_dim * sizeof(char)); \n      /* next we allocate space of an array of pointers, each \n        to eventually point to the first element of a \n        2 dimensional array of pointers to pointers */ \n       arr3d = malloc(z_dim * sizeof(char **)); \n      /* and for each of these we assign a pointer to a newly \n        allocated array of pointers to a row */ \n      for (z = 0; z < z_dim; z++) \n     { \n         arr3d[z] = malloc(y_dim * sizeof(char *)); \n           /* and for each space in this array we put a pointer to \n            the first element of each row in the array space \n            originally allocated */\n\n4 1 \n           for (y = 0; y < y_dim; y++) \n         { \n             arr3d[z][y] = space + (z*(x_dim * y_dim) + y*x_dim); \n         } \n     } \n       /* and, now we check each address in our 3d array to see if \n        the indexing of the arr3d pointer leads through in a \n        continuous manner */ \n       for (z = 0; z < z_dim; z++) \n     { \n         printf("location of array %d is %p\\n", z, *arr3d[z]); \n         for ( y = 0; y < y_dim; y++) \n         { \n             printf("  array %d and row %d starts at %p", z, y, \na rr3d[z][y]); \n             diff = arr3d[z][y] - space; \n             printf("    diff = %d  ",diff); \n             printf(" z = %d  y = %d\\n", z, y); \n         } \n     } \n     return 0; \n}  \n - ------------------ end of prog. 9.4 ---------------------------- \n \ni f  y o u h av e f o llo w ed  t h is  t u to ria l u p t o  t h is  p oin t y o u s h ould  h av e n o p ro ble m  \nd ecip herin g t h e a b ove o n  t h e b asis  o f t h e c o m men ts  a lo ne. t here  a re  a  c o u ple  o f p oin ts  \nt h at s h ould  b e m ad e h ow ev er.  l et©s  s ta rt w ith  t h e l in e w hic h  r e ad s:  \n       arr3d[z][y] = space + (z*(x_dim * y_dim) + y*x_dim); \nn ote  t h at h ere  s p ace i s  a  c h ara cte r p oin te r, w hic h  i s  t h e s a m e t y p e a s a rr3 d [z ][y ].  i t i s  \ni m porta n t t h at w hen  a d din g a n  i n te g er, s u ch  a s t h at o bta in ed  b y e v alu atio n o f t h e \ne x pre ssio n ( z * (x _d im  *  y _d im ) +  y *x _d im ),  t o  a  p oin te r, t h e r e su lt i s  a  n ew  p oin te r \nv alu e. a nd w hen  a ssig n in g p oin te r v alu es t o  p oin te r v aria b le s t h e d ata  t y p es o f t h e v alu e \na n d v aria b le  m ust m atc h .\n\n4 2 \nc h apt er  1 0: p oin te rs t o  f unctio n s \nu p t o  t h is  p oin t w e h av e b een  d is c u ssin g p oin te rs  t o  d ata  o bje cts . c  a ls o  p erm its  t h e \nd ecla ra tio n o f p oin te rs  t o  f u nctio ns. p oin te rs  t o  f u nctio ns h av e a  v arie ty  o f u se s a n d s o m e \no f t h em  w ill b e d is c u sse d  h ere .  \nc onsid er t h e f o llo w in g r e al p ro ble m . y ou w an t t o  w rite  a  f u n ctio n t h at i s  c ap ab le  o f \ns o rtin g v ir tu all y  a n y c o ll e ctio n o f d ata  t h at c an  b e s to re d  i n  a n  a rra y . t his  m ig h t b e a n  \na rra y  o f s tr in gs, o r i n te g ers , o r f lo ats , o r e v en  s tr u ctu re s. t he s o rtin g a lg o rit h m  c an  b e t h e \ns a m e f o r a ll.  f or e x am ple , i t c o uld  b e a  s im ple  b u bble  s o rt a lg o rith m , o r t h e m ore  \nc o m ple x  s h ell o r q uic k  s o rt a lg o rith m . w e©l l u se  a  s im ple  b ubble  s o rt f o r d em onstr a ti o n \np urp ose s.  \ns ed gew ic k  [ 1 ] h as d esc rib ed  t h e b ubble  s o rt u sin g c  c o de b y s e ttin g u p a  f u nctio n w hic h  \nw hen  p asse d  a  p oin te r t o  t h e a rr a y  w ould  s o rt i t.  i f  w e c all t h at f u n ctio n b ub ble (), a  s o rt \np ro gra m  i s  d esc rib ed  b y b ubble _ 1.c , w hic h  f o llo w s:  \n/ *-------------------- bubble_1.c --------------------*/ \n  / * program bubble_1.c from ptrtut10.htm   6/13/97 */ \n  # include <stdio.h> \n i nt arr[10] = { 3,6,1,2,3,8,4,1,7,2}; \n v oid bubble(int a[], int n); \n  i nt main(void) \n{  \n     int i; \n     putchar(''\\n''); \n     for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     bubble(arr,10); \n     putchar(''\\n''); \n       for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     return 0; \n}  \n v oid bubble(int a[], int n) \n{  \n     int i, j, t; \n     for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++)\n\n4 3 \n         { \n             if (a[j-1] > a[j]) \n             { \n                 t = a[j-1]; \n                 a[j-1] = a[j]; \n                 a[j] = t; \n             } \n         } \n     } \n}  \n      / *---------------------- end bubble_1.c -----------------------*/ \n \nt he b ubble  s o rt i s  o ne o f t h e s im ple r s o rts . t he a lg orith m  s c an s t h e a rr a y  f r o m  t h e s e co nd \nt o  t h e l a st e le m en t c o m parin g e ach  e le m en t w ith  t h e o ne w hic h  p re c ed es i t.  i f t h e o ne t h at \np re ced es i t i s  l a rg er t h an  t h e c u rr e n t e le m en t, t h e t w o a re  s w ap ped  s o  t h e l a rg er o ne i s  \nc lo se r t o  t h e e n d o f t h e a rra y . o n t h e f ir s t p ass, t h is  r e su lts  i n  t h e l a rg est e le m en t e n din g \nu p a t t h e e n d o f t h e a rr a y . t he a rr a y  i s  n ow  l im ite d  t o  a ll e le m en ts  e x cep t t h e l a st a n d  t h e \np ro cess r e p eate d . t his  p uts  t h e n ex t l a rg est e le m en t a t a  p oin t p re ced in g t h e l a rg est \ne le m en t. t he p ro cess i s  r e p eate d  f o r a  n um ber o f t im es e q ual t o  t h e n um ber o f e le m en ts  \nm in us 1 . t he e n d r e su lt i s  a  s o rte d  a rra y .  \nh ere  o u r f u nctio n i s  d esig n ed  t o  s o rt a n  a rra y  o f i n te g ers . t hus i n  l in e 1  w e a re  \nc o m parin g i n te g ers  a n d i n  l in es 2  t h ro ugh  4  w e a re  u sin g t e m pora ry  i n te g er s to ra g e t o  \ns to re  i n te g ers . w hat w e w an t t o  d o n ow  i s  s e e i f  w e c an  c o nvert t h is  c o d e s o  w e c an  u se  \na n y d ata  t y p e, i .e . n ot b e r e str ic te d  t o  i n te g ers .  \na t t h e s a m e t im e w e d on ©t  w an t t o  h av e t o  a n aly ze o ur a lg o rith m  a n d t h e c o de a sso cia te d  \nw ith  i t e ach  t im e w e u se  i t. w e s ta rt b y r e m ovin g t h e c o m paris o n f ro m  w ith in  t h e \nf u nctio n b ubble () s o  a s t o  m ak e i t r e la tiv ely  e asy  t o  m odif y  t h e c o m paris o n f u nctio n \nw ith out h av in g t o  r e -w rit e  p ortio ns r e la te d  t o  t h e a ctu al a lg o rith m . t his  r e su lts  i n  \nb ubble _ 2.c :  \n/ *---------------------- bubble_2.c -------------------------*/ \n  / * program bubble_2.c from ptrtut10.htm   6/13/97 */ \n      /* separating the comparison function */ \n # include <stdio.h> \n i nt arr[10] = { 3,6,1,2,3,8,4,1,7,2}; \n  v oid bubble(int a[], int n); \ni nt compare(int m, int n); \n  i nt main(void) \n{  \n     int i; \n     putchar(''\\n'');\n\n4 4 \n     for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     bubble(arr,10); \n     putchar(''\\n''); \n       for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     return 0; \n}  \n v oid bubble(int a[], int n) \n  {  \n     int i, j, t; \n     for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++) \n         { \n             if (compare(a[j-1], a[j])) \n             { \n                 t = a[j-1]; \n                 a[j-1] = a[j]; \n                 a[j] = t; \n             } \n         } \n     } \n}  \n  i nt compare(int m, int n) \n{  \n     return (m > n); \n}  \n/ *--------------------- end of bubble_2.c -----------------------*/ \nif  o ur g o al i s  t o  m ak e o ur s o rt r o utin e d ata  t y p e i n dep en den t, o ne w ay  o f d oin g t h is  i s  t o  \nu se  p oin te rs  t o  t y p e v oid  t o  p oin t t o  t h e d ata  i n ste ad  o f u sin g t h e i n te g er d ata  t y p e. a s a  \ns ta rt i n  t h at d ir e ctio n l e t©s  m odif y  a  f e w  t h in gs i n  t h e a b ove s o  t h at p oin te rs  c an  b e u se d . \nt o b eg in  w ith , w e©l l s tic k  w ith  p oin te rs  t o  t y p e i n te g er.  \n    / *----------------------- bubble_3.c -------------------------*/ \n  / * program bubble_3.c from ptrtut10.htm    6/13/97 */ \n # include <stdio.h> \n i nt arr[10] = { 3,6,1,2,3,8,4,1,7,2}; \n  v oid bubble(int *p, int n); \ni nt compare(int *m, int *n); \n  i nt main(void) \n{\n\n4 5 \n     int i; \n     putchar(''\\n''); \n       for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     bubble(arr,10); \n     putchar(''\\n''); \n      for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     return 0; \n}  \n  v oid bubble(int *p, int n) \n{  \n     int i, j, t; \n     for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++) \n         { \n             if (compare(&p[j-1], &p[j])) \n             { \n                 t = p[j-1]; \n                 p[j-1] = p[j]; \n                 p[j] = t; \n             } \n         } \n     } \n}  \n i nt compare(int *m, int *n) \n{  \n     return (*m > *n); \n}  \n / *------------------ end of bubble3.c -------------------------*/ \n \nn ote  t h e c h an ges. w e a re  n ow  p assin g a  p oin te r t o  a n  i n te g er ( o r a rra y  o f i n te g ers ) t o  \nb ubb le (). a nd f ro m  w ith in  b ubble  w e a re  p assin g p oin te rs  t o  t h e e le m en ts  o f t h e a rr a y  \nt h at w e w an t t o  c o m pare  t o  o ur c o m paris o n f u ncti o n. a nd, o f c o urs e  w e a re  d ere fe re n cin g \nt h ese  p oin te r i n  o ur c o m pare() f u n ctio n i n  o rd er t o  m ak e t h e a ctu al c o m paris o n. o ur n ex t \ns te p  w ill b e t o  c o nvert t h e p oin te rs  i n  b ubble () t o  p oin te rs  t o  t y p e v oid  s o  t h at t h at \nf u nctio n w ill b eco m e m ore  t y p e i n se n sitiv e. t his  i s  s h ow n i n  b ubble _ 4.  \n   / *------------------ bubble_4.c ----------------------------*/ \n / * program bubble_4.c from ptrtut10,htm   6/13/97 */ \n  # include <stdio.h>\n\n4 6 \ni nt arr[10] = { 3,6,1,2,3,8,4,1,7,2}; \n  v oid bubble(int *p, int n); \ni nt compare(void *m, void *n); \n  i nt main(void) \n{  \n     int i; \n     putchar(''\\n''); \n      for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     bubble(arr,10); \n     putchar(''\\n''); \n       for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     return 0; \n}  \n v oid bubble(int *p, int n) \n{  \n     int i, j, t; \n     for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++) \n         { \n             if (compare((void *)&p[j-1], (void *)&p[j])) \n             { \n                 t = p[j-1]; \n                 p[j-1] = p[j]; \n                 p[j] = t; \n             } \n         } \n     } \n}  \n  i nt compare(void *m, void *n) \n{  \n     int *m1, *n1; \n     m1 = (int *)m; \n     n1 = (int *)n; \n     return (*m1 > *n1); \n}  \n  / *------------------ end of bubble_4.c ---------------------*/ \n \nn ote  t h at, i n  d oin g t h is , i n  c o m pare() w e h ad  t o  i n tr o duce t h e c astin g o f t h e v oid  p oin te r \nt y p es p ass e d  t o  t h e a ctu al t y p e b ein g s o rte d . b ut,  a s w e©l l s e e l a te r t h at©s  o k ay . a nd s in ce \nw hat i s  b ein g p asse d  t o  b ubble () i s  s till  a  p oin te r t o  a n  a rr a y  o f i n te g ers , w e h ad  t o  c a st \nt h ese  p oin te rs  t o  v oid  p oin te rs  w hen  w e p asse d  t h em  a s p ara m ete rs  i n  o ur c all t o  \nc o m pare().\n\n4 7 \nw\ne n ow  a d dre ss t h e p ro b le m  o f w hat w e p ass t o  b ubble (). w e w an t t o  m ak e t h e f ir s t \np ara m ete r o f t h at f u n ctio n a  v oid  p oin te r a ls o . b ut, t h at m ean s t h at w ith in  b ubble () w e \nn eed  t o  d o s o m eth in g a b out t h e v aria b le  t ,  w hic h  i s  c u rre n tl y  a n  i n te g er. a ls o , w here  w e \nu se  t  =  p [j-1 ]; t h e t y p e o f p [j-1 ] n eed s t o  b e k now n i n  o rd er t o  k now  h ow  m an y b yte s t o  \nc o p y t o  t h e v aria b le  t  ( o r w hate v er w e r e p la c e t  w ith ).  \nc urre n tl y , i n  b ubble _ 4.c , k now le d ge w ith in  b ubble () a s t o  t h e t y p e o f t h e d ata  b ein g \ns o rte d  ( a n d h en ce t h e s iz e o f e a ch  i n div id ual e le m en t)  i s  o bta in ed  f ro m  t h e f a ct t h at t h e \nf ir s t p ara m ete r i s  a  p oin te r t o  t y p e i n te g er.  i f  w e a re  g o in g t o  b e a b le  t o  u se  b ubb le () t o  \ns o rt a n y t y p e o f d ata ,  w e n eed  t o  m ak e t h at p oin te r a  p oin te r t o  t y p e v oid . b ut, i n  d oin g s o  \nw e a re  g o in g t o  l o se  i n fo rm atio n c o nce rn in g t h e s iz e o f i n div id ual e le m en ts  w ith in  t h e \na rra y . s o, i n  b ubble _ 5.c  w e w ill a d d a  s e p ara te  p ara m ete r t o  h an dle  t h is  s iz e i n fo rm atio n.  \nt hese  c h an ges, f r o m  b ubble 4 .c  t o  b ubble 5 .c  a re , p erh ap s, a  b it m ore  e x te n siv e t h an  t h ose  \nw e h av e m ad e i n  t h e p ast. s o, c o m pare  t h e t w o m odule s c are fu ll y  f o r d if f e re n ces.  \n/ *---------------------- bubble5.c ---------------------------*/ \n  / * program bubble_5.c from ptrtut10.htm    6/13/97 */ \n  # include <stdio.h> \n# include <string.h> \n  l ong arr[10] = { 3,6,1,2,3,8,4,1,7,2}; \n  v oid bubble(void *p, size_t width, int n); \ni nt compare(void *m, void *n); \n  i nt main(void) \n{  \n     int i; \n     putchar(''\\n''); \n      for (i = 0; i < 10; i++) \n     { \n         printf("%d ", arr[i]); \n     } \n     bubble(arr, sizeof(long), 10); \n     putchar(''\\n''); \n       for (i = 0; i < 10; i++) \n     { \n         printf("%ld ", arr[i]); \n     } \n       return 0; \n}  \n v oid bubble(void *p, size_t width, int n) \n{  \n     int i, j; \n     unsigned char buf[4]; \n     unsigned char *bp = p;\n\n4 8 \n       for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++) \n         { \n             if (compare((void *)(bp + width*(j-1)), \n                         (void *)(bp + j*width)))  /* 1 */ \n             { \n/ *              t = p[j-1];   */ \n                 memcpy(buf, bp + width*(j-1), width); \n/ *              p[j-1] = p[j];   */ \n                 memcpy(bp + width*(j-1), bp + j*width , width); \n/ *              p[j] = t;   */ \n                 memcpy(bp + j*width, buf, width); \n             } \n         } \n     } \n}  \n  i nt compare(void *m, void *n) \n{  \n     long *m1, *n1; \n     m1 = (long *)m; \n     n1 = (long *)n; \n     return (*m1 > *n1); \n}  \n / *--------------------- end of bubble5.c ---------------------*/ \n \nn ote  t h at i  h av e c h an ged  t h e d ata  t y p e o f t h e a rr a y  f ro m  i n t t o  l o n g t o  i ll u str a te  t h e \nc h an ges n eed ed  i n  t h e c o m pare() f u nctio n. w ith in  b ubb le () i ©v e d one a w ay  w ith  t h e \nv aria b le  t  ( w hic h  w e w ou ld  h av e h ad  t o  c h an ge f ro m  t y p e i n t t o  t y p e l o n g). i  h av e a d d ed  \na  b uffe r o f s iz e 4  u nsig n ed  c h ara cte rs , w hic h  i s  t h e s iz e n eed ed  t o  h old  a  l o ng ( th is  w ill \nc h an ge a g ain  i n  f u tu re  m odif ic atio ns t o  t h is  c o de). t he u nsig n ed  c h ara cte r p oin te r * b p i s  \nu se d  t o  p oin t t o  t h e b ase  o f t h e a rr a y  t o  b e s o rte d ,  i .e . t o  t h e f ir s t e le m en t o f t h at a rra y .  \nw e a ls o  h ad  t o  m odif y  w hat w e p asse d  t o  c o m pare(), a n d h o w  w e d o t h e s w ap pin g o f \ne le m en ts  t h at t h e c o m paris o n i n dic ate s n eed  s w ap pin g. u se  o f m em cp y() a n d p oin te r \nn ota tio n i n ste ad  o f a rr a y  n ota tio n w ork  t o w ard s t h is  r e d uctio n i n  t y p e s e n sitiv it y .  \na gain , m ak in g a  c are fu l c o m paris o n o f b ubble 5 .c  w ith  b ubble 4 .c  c an  r e su lt i n  i m pro v ed  \nu nders ta n din g o f w hat i s  h ap pen in g a n d w hy.  \nw e m ove n ow  t o  b ubble 6 .c  w here  w e u se  t h e s a m e f u nctio n b ubble () t h at w e u se d  i n  \nb ubble 5 .c  t o  s o rt s tr in gs i n ste ad  o f l o n g i n te g ers .  o f c o urs e  w e h av e t o  c h an ge t h e \nc o m paris o n f u nctio n s in ce t h e m ean s b y w hic h  s tr in gs a re  c o m pare d  i s  d if f e re n t f ro m  t h at \nb y w hic h  l o n g i n te g ers  a re  c o m pare d . a nd,i n  b ubb le 6 .c  w e h av e d ele te d  t h e l in es w ith in  \nb ubb le () t h at w ere  c o m men te d  o ut i n  b ubble 5 .c .   \n / *--------------------- bubble6.c ---------------------*/ \n/ * program bubble_6.c from ptrtut10.htm   6/13/97 */\n\n4 9 \n  # include <stdio.h> \n# include <string.h> \n  # define max_buf 256 \n  c har arr2[5][20] = {  "mickey mouse", \n                       "donald duck", \n                       "minnie mouse", \n                       "goofy", \n                       "ted jensen" }; \n  v oid bubble(void *p, int width, int n); \ni nt compare(void *m, void *n); \n  i nt main(void) \n{  \n     int i; \n     putchar(''\\n''); \n      for (i = 0; i < 5; i++) \n     { \n         printf("%s\\n", arr2[i]); \n     } \n     bubble(arr2, 20, 5); \n     putchar(''\\n\\n''); \n       for (i = 0; i < 5; i++) \n     { \n         printf("%s\\n", arr2[i]); \n     } \n     return 0; \n}  \n v oid bubble(void *p, int width, int n) \n{  \n     int i, j, k; \n     unsigned char buf[max_buf]; \n     unsigned char *bp = p; \n       for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++) \n         { \n           k = compare((void *)(bp + width*(j-1)), (void *)(bp + \nj *width)); \n           if (k > 0) \n             { \n              memcpy(buf, bp + width*(j-1), width); \n              memcpy(bp + width*(j-1), bp + j*width , width); \n              memcpy(bp + j*width, buf, width); \n             } \n         } \n     } \n}  \n i nt compare(void *m, void *n)\n\n5 0 \n{  \n     char *m1 = m; \n     char *n1 = n; \n     return (strcmp(m1,n1)); \n}  \n  / *------------------- end of bubble6.c ---------------------*/ \n \nb ut, t h e f a ct t h at b ubble ()  w as u nch an ged  f ro m  t h at u se d  i n  b ubble 5 .c  i n dic ate s t h at t h at \nf u nctio n i s  c ap ab le  o f s o rtin g a  w id e v arie ty  o f d ata  t y p es. w hat i s  l e ft t o  d o i s  t o  p ass t o  \nb ubb le () t h e n am e o f t h e c o m paris o n f u nctio n w e w an t t o  u se  s o  t h at i t c an  b e t r u ly  \nu niv ers a l. j u st a s t h e n am e o f a n  a rra y  i s  t h e a d dre ss o f t h e f ir s t e le m en t o f t h e a rr a y  i n  \nt h e d ata  s e g m en t, t h e n am e o f a  f u n ctio n d eca y s i n to  t h e a d dre ss o f t h at f u nctio n i n  t h e \nc o de s e g m en t. t hus w e n eed  t o  u se  a  p oin te r t o  a  f u nctio n.  i n  t h is  c ase  t h e c o m paris o n \nf u nctio n.  \np oin te rs  t o  f u nctio ns m ust m atc h  t h e f u nctio ns p oin te d  t o  i n  t h e n um ber a n d t y p es o f t h e \np ara m ete rs  a n d t h e t y p e o f t h e r e tu rn  v alu e.  i n  o u r c ase ,  w e d ecla re  o ur f u nctio n p oin te r \na s:  \n    int (*fptr)(const void *p1, const void *p2); \n \nn ote  t h at w ere  w e t o  w rite :  \n       int *fptr(const void *p1, const void *p2); \n \nw e w ould  h av e a  f u n ctio n p ro to ty p e f o r a  f u nctio n w hic h  r e tu rn ed  a  p oin te r t o  t y p e i n t. \nt hat i s  b ecau se  i n  c  t h e p are n th esis  ( ) o pera to r h av e a  h ig h er p re c ed en ce t h an  t h e p oin te r \n*  o pera to r.  b y p uttin g t h e p are n th esis  a ro und t h e s tr in g ( * fp tr ) w e i n dic ate  t h at w e a re  \nd ecla rin g a  f u nctio n p oin te r.  \nw e n ow  m odif y  o ur d ecla ra tio n o f b ubble () b y a d din g, a s i ts  4 th  p ara m ete r, a  f u ncti o n \np oin te r o f t h e p ro per t y p e.  i t©s  f u n ctio n p ro to ty p e b eco m es:  \n     void bubble(void *p, int width, int n, \n                 int(*fptr)(const void *, const void *)); \n \nw hen  w e c all t h e b ubble (), w e i n se rt t h e n am e o f t h e c o m paris o n f u nctio n t h at w e w an t \nt o  u se . b ubble 7 .c  i llu str a te  h ow  t h is  a p pro ach  p erm its  t h e u se  o f t h e s a m e b ubb le () \nf u nctio n f o r s o rtin g d if fe re n t t y p es o f d ata .  \n    / *------------------- bubble7.c ------------------*/ \n  / * program bubble_7.c from ptrtut10.htm  6/10/97 */ \n # include <stdio.h> \n# include <string.h> \n # define max_buf 256\n\n5 1 \nl ong arr[10] = { 3,6,1,2,3,8,4,1,7,2}; \nc har arr2[5][20] = {  "mickey mouse", \n                       "donald duck", \n                       "minnie mouse", \n                       "goofy", \n                       "ted jensen" }; \n  v oid bubble(void *p, int width, int n, \n             int(*fptr)(const void *, const void *)); \ni nt compare_string(const void *m, const void *n); \ni nt compare_long(const void *m, const void *n); \n i nt main(void) \n{  \n     int i; \n     puts("\\nbefore sorting:\\n"); \n      for (i = 0; i < 10; i++)               /* show the long ints */ \n     { \n         printf("%ld ",arr[i]); \n     } \n     puts("\\n"); \n       for (i = 0; i < 5; i++)                  /* show the strings */ \n     { \n         printf("%s\\n", arr2[i]); \n     } \n     bubble(arr, 4, 10, compare_long);          /* sort the longs */ \n     bubble(arr2, 20, 5, compare_string);     /* sort the strings */ \n     puts("\\n\\nafter sorting:\\n"); \n      for (i = 0; i < 10; i++)             /* show the sorted longs */  \n     { \n         printf("%d ",arr[i]); \n     } \n     puts("\\n"); \n       for (i = 0; i < 5; i++)            /* show the sorted strings */  \n     { \n         printf("%s\\n", arr2[i]); \n     } \n     return 0; \n}  \n v oid bubble(void *p, int width, int n, \n             int(*fptr)(const void *, const void *)) \n{  \n     int i, j, k; \n     unsigned char buf[max_buf]; \n     unsigned char *bp = p; \n       for (i = n-1; i >= 0; i--) \n     { \n         for (j = 1; j <= i; j++) \n         { \n             k = fptr((void *)(bp + width*(j-1)), (void *)(bp + \nj *width));\n\n5 2 \n             if (k > 0) \n             { \n                 memcpy(buf, bp + width*(j-1), width); \n                 memcpy(bp + width*(j-1), bp + j*width , width); \n                 memcpy(bp + j*width, buf, width); \n             } \n         } \n     } \n}  \n  i nt compare_string(const void *m, const void *n) \n{  \n     char *m1 = (char *)m; \n     char *n1 = (char *)n; \n     return (strcmp(m1,n1)); \n}  \n  i nt compare_long(const void *m, const void *n) \n{  \n     long *m1, *n1; \n     m1 = (long *)m; \n     n1 = (long *)n; \n     return (*m1 > *n1); \n}  \n  / *----------------- end of bubble7.c -----------------*/ \n \nr efe re n ces f o r c hap te r 1 0: \n1 .  "a lg o rith m s i n  c " \nr obert s ed gew ic k  \na ddis o n-w esle y  \ni s b n  0 -2 01-5 1425 -7\n\n5 3 \ne pil o g  \ni h av e w ritte n  t h e p re ced in g m ate ria l t o  p ro vid e a n  i n tr o ductio n t o  p oin te rs  f o r \nn ew co m ers  t o  c .  i n  c , t h e m ore  o ne u nd ers ta n ds a b out p oin te rs  t h e g re ate r f le x ib ilit y  o n e \nh as i n  t h e w ritin g o f c o de. t he a b ove e x pan ds o n m y f ir s t e ffo rt a t t h is  w hic h  w as e n title d  \np tr _ help .t x t a n d f o und i n  a n  e arly  v ers io n o f b ob s to ut©s  c o lle ctio n o f c  c o d e s n ip pe ts. \nt he c o nte n t i n  t h is  v ers io n h as b een  u pd ate d  f ro m  t h at i n  p t r tu to t.z ip  i n clu ded  i n  \ns n ip 9510.z ip .  \ni  a m  a lw ay s r e ad y t o  a cc ep t c o nstr u ctiv e c ritic is m  o n t h is  m ate ria l, o r r e v ie w  r e q uests  f o r \nt h e a d ditio n o f o th er r e le v an t m ate ria l. t here fo re ,  i f  y o u h av e q uestio ns, c o m men ts , \nc ritic is m s, e tc . c o ncern in g t h at w hic h  h as b een  p re se n te d ,  i  w ould  g re atl y  a p pre cia te  y o u r \nc o nta ctin g m e v ia  e m ail m e a t t je n se n @ ix .n etc o m .c o m .', 7, 'pointers', 10, '2017-02-08', 'letter', 'L', 'M', 6, 9, 0);
INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(4, 1, 'abc12', '2017-02-01', 2, 2, 0, 10, 0, '1486540868.pdf', 91, 'replacethislewith prentcsmacro.sty foryour meeting,\nor with entcsmacro.sty foryour meeting. bothcanbe\nfound atthe entcs macrohomepage .\nan example pap er\nmy name 1\n;2\nmy department\nmy university\nmy city, mycountry\nmy co-author 3\nmy co-author''s department\nmy co-author''s university\nmy co-author''s city,myco-author''s country\nabstract thisisashort example tosho wthe basics ofusing theentcs style macro les.\nample examples ofhowles should look ma ybe found among thepublished volumes\nof the series atthe entcs homepage http://www.elsevier.nl/ locate/ entcs.\nkey words: please listkeyw ords from your paperhere, separated\nb y commas.\n1 intro duction\nthis short noteprovides aguide tousing theentcs macropackage for\npreparing papers forpublication inyour conference proce edings .the pro-\nc eedings maybe prin ted and hard copies distributed toparticipan tsat the\nmeeting; thisisan option toconference organizersmaycho ose toexercise.\nthe proceedings alsowillbe par ofavolume inthe series electronic notes\nin the oretic alcomputer science(entcs), whichis published undertheaus-\npices ofelsevier scienceb.v., the publishers ofthe oretic alcomputer science.\nit''s home pageishttp://www.elsevier.nl/loc ate/entcs\nthe entcs macropackage consists oftw o les:\nentcs.cls ,the basic style le, and\n1\nthanks toevery one who should be thank ed\n2 email: myuserid@mydept. myins t.mye du\n3 email: couserid@codept. coins t.coe du\nc\n\r 2003 published by elsevier scienceb.v.\n\npleaselistyour lastname here\nentcsmacro.sty ,amacro lecontaining thedenitions ofsome ofthe theorem-\nlik een vironmen tsand afew other tidbits.\nthe formatting thesestyle les imposeshould notbe altered {the reason for\nusing themisto attain auniform formatforallpap ersinthe proceedings of\nwhic hyour paperisapart.\nadditional macrolescanbe added using\\usepackage{...} .the le\nentcsmacro.sty mustbe included inthe list, asisdone atthe start ofthe\nsource leforthis paper.\nthe entcs package requires arelativ elyup-to-date la\nt ex\nsystem inorder\nto be successfully used.thisisre\rected intw o other packages thatarecalled\nb y en tcs.cls, whichmust be available onyour machine. these are:\n the hyperref package. this package allowsthe use ofhyp erlinks inles\nprepared usingla\nt e x2e,\noneofthe main features ofadob e''sacrobat c\n\r\nreader software. besure that you have at least version 6.69dofthis pack-\nage.\n the ifpdf package. this isused by hyp erref todieren tiatebet ween the\nuse ofpdfl a\nt ex\nand la\nt e x2e,\nfollowed by dvips andthen ps2pdf.\nthe leinstraut.dvi contains information about theuse ofla\nt e xto\npre-\npare lesforonline publication by elsevier. thislerefers tothe older version\nof la\nt e x\nthat isno longer suppported, andthat isinadequate forpreparing\n.pdf lesforonline publication. readingthisleshould answermost ofthe\nbasic questions about la\nt ex\nthat mightarise.\n2 fron tmatter\nthe biggest dierence bet ween a\\usual" la\nt ex\nstyle suchas article.sty\nand theentcs package isthat theentcs macropackage requires thetitle,\nauthor''s nameornames, abstract, keyw ords and	hanks" alltobe included\nwithin thefrontmatter environmen t.at the beginning ofthe source lefor\nthis paper,you''ll notice this.also, you''ll notice thattheusual \\maketitle\nis absen t;itno longer isneeded. theentcs style package automatically\ngenerates thetitle, author''s nameandaddress, andrelated material atthe\nb eginning ofthe paper.note alsothat hyp erref hasbeen disabled inthis part\nof the entcs.cls le,soreferences tofootnotes aren''tlinkedtothe appropriate\nfo otenotes oraddresses. thisisan old problem withla\nt e x,\ninvolving thefact\nthat thereferences withinthefron tmatter aren''tpassed cleanly tothe linking\nsoft ware.\nf or those whohave used theentcs package before, theone new thing\nto note isthe inclusion ofkeywor ds;these arenow required by elsevier {\nthey''re alsorequired by acm''s computing reviews whichreviews entcs\npublications.\nthe entcs macropackage provides tw o alternativ esto listing authors\nnames andaddresses. thesearedescrib edindetail inthe leinstraut.dvi .\n2\n\npleaselistyour lastname here\nbasically ,listing eachauthor andhisorher address inturn, isthe simplest\nmetho d.but, ifthere areseveral authors andtw o or more share thesame\naddress (butnotallauthors areatthis address), thenthemetho dof listing\nauthors rst,andthen theaddresses, andofreferencing addressestoauthors\nshould be used.\nalso, notice thatackno wledgmen tof supp ort(the contentsof 	hanks )\nshould be done by aseparate listingof	hanks[nsf]{to thensf} withthe\noptional argument{ [nsf] {being used for	hanksref whichis attac hedto\nthose authors ackno wledging suchsupp ort.itisimp ortan tthat the	hanks\nnot be included withinthescop eof \\author{} orof	itle{} ,but itmust\nb e within thescop eof the environmen tfrontmatter .\nmore details about added termssuchas \\collab canbe found ininst.dvi ,\nif they areneeded.\nalso, notice thatthecommand \\lastname{my lastname}hasbeen in-\ncluded befor ethe frontmatter begins. thiscommand shouldcontain the\nlast names ofthe authors ofthe paper. ifthere arenomore thanthree au-\nthors, thentheyshould be listed withtheword \\and" bet ween thelast tw o;\nif more thanthree authors collaborated onthe paper,then therst author\nonly should be listed, together with\\emph{et al}.this command creates\nthe headline foreachpage after page1.\nfinally ,please be sure toinclude anabstract foryour paper.\n3 sectioning andenvironmen ts\nsince entcs ispublished throughtheauspices ofelsevier scienceb.v., their\nst yle les have been used tocreate theentcs macropackage. here''s apro of\nthat thispackage isnot muc hdieren tthan most ofthe ones oneencoun ters:\ndenition 3.1ale isderive dfrom another ifit isobtained withonlyafew\nmo dications fromtheoriginal le.\ntheorem 3.2the leentcs.cls isderive dfrom elsart.sty .\npro of.this isclear fromthesimilarit yof the output tothe output from\nelsevier''s style les. 2\nif one wan ts to start apro ofwith adescriptiv eword, suchas \\sk etch",\nthen onecanusethe\\begin{proof*}...\\end{pro of*}environmen t,as in\npro of(sk etch) this canbe deriv edfrom simple observations. 2\nthe main dierences bet ween theleentcs.cls andtheelsartr.cls le\nused by elsevier arethe more precise formatwe use {elsevier''s genericlesare\nmean tfor preliminary editing,andmore precise formatting isimp osed using\na macro ledesigned forthe specic elsevier journalinwhic hthe paperwill\nev en tually appear. theentcs.cls andentcsmacro.sty lesformat papers\n3\n\npleaselistyour lastname here\nuniformly sothat they allare easily recognizable asbeing from theseries\nele ctronic notes inthe oretic alcomputer science.\nall ofthe usual features ofla\nt e x\nare available withthese style les {\nit is only theformatting thathasbeen rigorously dened.thus, one has\na vailable thesectioning commands \\section,\\subsection, \\paragraphand\n\\subparagraph. thenum bering scheme usedisone under whichtheorem\n1.2.3 isthe third num bered item insecond subsection ofthe rst section of\nthe pap er.inorder tofacilitate cross-references, allofthe named environmen ts\ngiv en belo ware num bered, andalluse thesame num ber scheme.\nthe leentcsmacro.sty contains additional information thatisneeded to\nt yp eset apap er.italso hasthedenitions ofthe ams eulerandblackboard\nbold fontsbuiltin. ifyou wan tto use symbols forthe natural num bers, the\nreals, etc.,then we prefer thatyou use the blackboard bold fonts, and not\nplain bold fonts. this isaccomplished by using the\\mathbb font,as innor\nr .\nthe names oftheorem-lik een vironmen tsare provided inentcsmacro.sty .\nwith theexception ofthe environmen talgorithm, thenames ofall ofthese\nare full name, rather thanashortened version. theenvironmen tspro vided\nand their names are\n \\begin{theorem} ...\\end{theorem} fortheorems,\n \\begin{lemma} ...\\end{lemma} forlemmas,\n \\begin{corollary} ...\\end{corollary} forcorollaries,\n \\begin{proposition} ...\\end{proposition} forprop ositions,\n \\begin{criterion} ...\\end{criterion} forcriteria,\n \\begin{alg} ...\\end{alg} foralgorithms,\n \\begin{definition} ...\\end{definition} fordenitions,\n \\begin{conjecture} ...\\end{conjecture} forconjectures,\n \\begin{example} ...\\end{example} forexamples,\n \\begin{problem} ...\\end{problem} forproblems,\n \\begin{remark} ...\\end{remark} forremarks,\n \\begin{note} ...\\end{note} fornotes,\n \\begin{claim} ...\\end{claim} forclaims,\n \\begin{summary} ...\\end{summary} forsummary ,\n \\begin{case} ...\\end{case} forcases, and\n \\begin{ack} ...\\end{ack} forackno wledgemen ts.\nf or example,\n4\n\npleaselistyour lastname here\nalgorithm 1step 1:write thepap er\nstep 2:format itwith theentcs macropackage\nstep 3:ship thewhole thingtothe guest editors\n4 references andcross-references\nall the cross-referencing facilitiesofla\nt e x\nare supp orted, soone can use\n\ref{} and\\cite{} forcross-references withinthepaperand forreferences\nto bibliographic items.asisdone inthis note, thereferences section6can\nb e comp osed with \\begin{thebibliography}... \\end{thebibliograph y}.\nalternativ ely,bibt\nex\ncan be used tocompile thebibliograph y. whic hever\none isused, thereferences aretobe num bered consecutiv ely,rather thanby\nauthor-dened acronyms. ofcourse you can useyour own acron ymsforeasy\nreference toeac hof the items inthe bibliograph y, as has been done withthe\nlisting forthis short note.\nho wev er, note thatthereferences shouldnotbe started withanew \\section\ncommand.\nthe package hyperref isautomatically loadedby en tcs.cls, andthis makes\nall the cross-references withinthedocumen t\\activ e"when thepdf le ofthe\npap erisview edwith adobe''sacrobat c\n\r\nreader. theformat forincluding\na link issimple: simplyinsert\\href{url} {text}whereurlisthe url\nto whic hyou wan tthe link topoin t,and text isthe text you wan tto be\nhighligh ted,whichwhen clicked upon will bring upthe desired web page.\n4.1 particulars about .pdf les\nw eno w require that.pdf lesbe pro vided forpublication online.a.pdf\nle isview able by adob e''sacrobat c\n\r\nview er,whic hcan be congured toload\nautomatically withinabro wser. viewing aprop erlyformatted .pdflewith\nacrobat c\n\r\nallo wsthe cross-references andlinks tourls tobe activ e.in fact,\nelsevier utilizes.pdflesinorder totak ebetter advantage ofthe web''s ca-\npabilities.\nbut onepoin tw e wan tto emphasize isthat you should be sure touse typ e\n1 fon tswhen you typ eset your la\nt ex\nsource le.these fontsare scalable,\nmeaning thatthey carry information thatallowsthe devise viewing thenal\noutput toscale thefontsto suit theview erbeing used {from anonscreen\nview ersuc has adob e''sacrobat c\n\r\nreader, toprin ting theleonaprin ter.\ny ou can tellifyou have used therightfon tsby viewing thenal output on\ny our machine. itthe fontslook grain y, then you have not used typ e1 fon ts.\nthey canbe lo cated atthe ctan archiv ehttp://www.ctan.org {they are\npublic domain fonts, and don''t costanything toadd them toyour system.\nassuming you have typ e1 fon tsavailable, thenthere arethere metho ds\nfor producing .pdfles.\n5\n\npleaselistyour lastname here\nusing dvipsandps2pdf\nw elist this option rstsince itapp ears tobe the most reliable andthe\neasiest touse, especially ifyou include embedded postscript graphics(.eps\nles) inyour source le.simply runla\nt e x2e\nonyour source le,then apply\ndvips topro duce apostscript le,and nally applyps2pdf toobtain a.pdf\nle. the dvipdfm utility\nanother easymetho dfor producing acceptable .pdflesisvia the utilit y\ndvipdfm .this utilityis included indistributions ofmikt\nex,\nwhic hruns\non windo wsmac hines, butitprobably needstobe added toyour tet\nex\ndistribution, ifyou are running la\nt e x\non aunix machine. theutilit yand\nprecise information about installing iton your system canbe found atthe\nw eb page http://gaspra.kettering. edu/dvi pdfm/. in essence, thisutilit y\ncon verts a.dvi leinto a.pdf le.so,one canrst prepare the.dvi le\nusing la\nt e x,\nand then apply theutilit ydvipdfm topro duce theneeded .pdf\nle. 4\nthis utilitymak esinclusion ofgraphics particularly simple{those that\nare included inthe la\nt ex\nsource leare simply converted tothe .pdf format.\nas we note belo w, things arenot sosimple withthesecond alternativ e,whic h\nis to use pdfl a\nt e x.\np dfl a\nt e x\nan alternativ eto the rst possibilities topro duce .pdf lesisto pro cess\nthe source lewith pdfl a\nt ex.\nthis format isavailable fromthestandard\nct an sites http://www.ctan.org .it app ears that pdfl a\nt ex\nand hyperref\nha ve some problems whenusedtogether. itisnecessary touse pdfl a\nt ex\nv ersion 14dorlater inorder tominimize theseissues. ifyour system has\nan earlier version (mosttet\nex\ndistributions have version 13d),thenyou\ncan update your system by retrieving thelatest version ofpdfl a\nt e x\nfrom\nftp://ftp.cstug.cz/pub/tex/ local/c stug/thanh/pdft ex/.even ifthe\nrecen tversions areused, pdfl a\nt e x\nhas thesame dealing withreferences em-\nb edded withthefrontmatter sectiondescribedabov e for la\nt\ne x.\nbut there isone aspect ofpdfl a\nt ex\nthat creates problems. manyauthors\ninclude eps5\nles within theirpapers. while thisisfairly straigh tforward\nwith la\nt e x,\nthere areacouple ofpoin tsto note when attempting thiswith\np dfl a\nt e x.\nt o include apostscript imageina.pdf leproduced withpdfl a\nt ex,\ny ou rst have to con vert the image toa.pdf le,and then itcan be in-\ncluded usingthesame command sequenceasabov e. the conversion canbe\n4\nbewar e! the utilit ydvipdf does not produce acceptable .pdfles,andshould notbe\nused. onlydvipdfm shouldbe used topro duce .pdf les.\n5 eps stands forembedde dpostscript ,whic haords amec hanism forincluding pre-\nprepared postscript leswithin ala\nt\nex\ndocumen t.\n6\n\npleaselistyour lastname here\naccomplished mosteasily usingghostscript; you can simply viewthelein\nghostview andthen printthe image toa.pdf leusing thepdfwriter option\nwithin ghostview. theresult forastandard chess board thatispart ofthe\nghostview distribution isthe follo wing image:\nhereaswell isacop yof acolor image. whilepdfl a\nt ex\ncan handle imageles\nin other formats, la\nt ex\ncan only handle .epsimages reliably.\nitalso should be noted thatwe ha ve included tw o separate sourcelesfor\nthis example le{one forla\nt e x\nand oneforpdfl a\nt ex\n{because we wan t\n7\n\npleaselistyour lastname here\nto illustrate how to insert graphics imagesinto the le. ifyour paperdoes\nnot include suchimages, thenthesame source lecan be formatted by either\nl a\nt ex\norf by pdfl a\nt e x.\nusing entcs macroswithmacosx\nof course, ifyour ledoesn''t require .epsorother postscript les,then\ny ou can create therequired .pdfleusing anyof the standard t\nex\nimple-\nmen tations forthe macin tosh. ifyou need toinclude postscript les,andif\ny ou are using t\ne xshop,\nthenyou can specify touse dvips andghostview in\npro cessing your le, and then you can apply ps2pdf tocreate theneeded .pdf\nle. alternatib ely,the mac osxoperating systemisbased onunix, soit\nsupp ortstheuse oftet\nex\nas describ edabov e.\n5 summary\nthe entcs macropackage isrelativ elyeasy touse and provides auniform\nla yout forallthe papersthat appear inentcs.\nproblem 5.1finish yourpap er and getitto your progr am chairman on\ntime!\nwhen you have nished preparing your paper,send acop yof the sour ce le ,\ntogether withanymacro lesthat areneeded toyour program chairman. if\nthe les areextensiv e,you can place copies inthe pub/incoming sub-directory\nof the ftpdirectory onthe mac hine indicated by your program chairman using\nanon ymous ftp.ifyou dothis, please sendmeemail toalert methat thele(s)\nare here.\nassigning volume /issue numbers\none additional poin tworth mentioning isthat entcs ismo ving tosci-\nencedirect, elsevier''smainplatform forpublishing electronicseries,because\nsciencedirect must publish entire volumes atthe same time, we ha ve changed\nthe procedure forpreparing nalversions sothat volume num bers will not\nb e assigned until the nal versions areready .guest editors willnow have\nto receiv ethe nal version ofall pap ersintheir proceedings before avolume\nand issue num ber will be assigned forthe proceedings .ev en with themove to\nsciencedirect, thereference scheme already usedforpublications inentcs {\nhttp://www.elsevier/nl/loca te/entc s/nnnn.html remainsthevalid way\nto cite paperspublished inentcs, wherenndenotes thenum ber ofthe vol-\nume, andnndenotes theissue num ber. publications consistingofan entire\nv olume should use1as the issue num ber.\ncop yrigh ttransfer forms\none result ofthe move to sciencedirect isthat thecorresp onding author\nof eac hpap erpublished inentcs must submit asigned copyrigh ttransfer\n8\n\npleaselistyour lastname here\nf orm toelsevier inorder fortheir paperto be published. acop yof this form\nwill be sen tto eac hauthor by the guest editors ofeac hvolume. detailsabout\nthis agreemen tsp ecifying therightsof the authors andtherightsof elsevier\nare available atelsevier''s authorgateway .\npublication offinal versions\nbecause sciencedirect cannoteasilyaccommo datechanges topublished\nmaterial, theproceedings inits entiret ymust be ready before itcan be pub-\nlished. thisisone reason whythe volume andissue num ber isnot assigned\nun til the nal versions ofall pap ershave been sentto the guest editors for\nnal processing.\n6 bibliographical references\nentcs employsthe plain style ofbibliographic referencesinwhic hreferences\nare listed inalphab eticalorder, according thetherst author''s lastname, and\nare sequen tiallynum bered. please utilizethisstyle. weha ve a bibt\nex\nstyle\nle, forthose whowish touse it.itisthe leentcs.bst whichis included in\nthis package. thebasic ruleswe ha ve emplo yed are the follo wing:\n authors'' namesshould be listed inalphab eticalorder, withtherst author''s\nlast name being therst listing, followed by the author''s initialsorrst\nname, andwith theother authors nameslistedasrst name, lastname .\n titles ofarticles injournals shouldbe in emphasize dtyp e.\n titles ofbooks, monographs, etc.should be in quotations.\n journal namesshould be in plain roman typ e.\n journal volume num bers should be in boldface typ e,with theyear ofpub-\nlication immediately following inroman typ e,and enclosed inparen theses.\n references tourls onthe netshould be \\activ e"and theurl itselfshould\nb e in typ ewriter font.\n articles shouldinclude pagenum bers.\nthe criteria areillustrated inthe follo wing.\nreferences [1] civin, p., and b.yood, involutions onbanach algebras,pacic j.math. 9\n(1959), 415{436.\n[2] cliord, a.h., and g.b.preston, \\thealgebraic theoryofsemigroups,"\nmath. surveys7, amer. math.soc., pro vidence, r.i.,1961.\n[3] freyd, peter, peter o''hearn, johnpow er, rob ert tennen tand makoto\nt ak eyama, bire\re ctivity ,electronic notesintheoretical computerscience1\n(1995), url:http://www.elsevier.nl/loc ate/entcs/v olume1.html .\n9\n\npleaselistyour lastname here\n[4] easdo wn,d.,and w.d.munn, trac efunctions oninverse semigroupalgebr as,\nu. ofglasgo w,dept. ofmath., preprint93/52.\n[5] rosco e,a. w., \\the theory andpractice ofconcurrency ,"pren ticehall series\nin computer science,prentice hall publishers, london,newyork (1198),\n565pp. withassociated web site\nhttp://www.comlab.ox.ac. uk/oucl/pub lications/b ooks/concur rency/.\n[6] shehadah, a.a., \\em bedding theorems forsemigroups withinvolution, \\ph.d.\nthesis, purdue university, indiana, 1982.\n[7] weyl, h.,\\the classical groups," 2nded., princeton u.press, princeton, n.j.,\n1946.\n10', 12, 'author', 10, '2017-02-08', 'letter', 'L', 'M', 7, 8, 0);
INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(5, 1, '121', '2017-02-08', 1, 3, 0, 486, 0, '1486541355.pdf', 6, 'preface   \npreface to the first edition  \nchapter 1 - a tutorial introduction   \n1.1 getting started   \n1.2 variables and arithmetic expressions   \n1.3 the for statement   \n1.4 symbolic  constants   \n1.5 character input and output    \n1.5.1 file copying    \n1.5.2 character counting    \n1.5.3 line counting   \n1.5.4 word counting      \n1.6 arrays    \n1.7 functions    \n1.8 arguments - call by value  \n1.9 character arrays    \n1.10 external variables and scope  \nchapter 2 - types, operators and expressions   \n2.1 variable names    \n2.2 data types and sizes\n\n2.3 constants    \n2.4 declarations    \n2.5 \narithmeticoperators......................................................................................................40    \n2.6 relational and logical operators................................................................................... 40    \n2.7 type conversions........................................................................................................... 41    \n2.8 increment and decrement operators.............................................................................. 44    \n2.9 bitwise \noperators...........................................................................................................46      \n2.10 assignment operators and \nexpressions.......................................................................47    \n2.11 conditional expressions............................................................................................... 49    \n2.12 precedence and order of \nevaluation............................................................................49  \nchapter 3 - control flow ......................................................................................................... 52    \n3.1 statements and blocks ................................................................................................... 52\n\n3.2 if- \nelse............................................................................................................................52    \n3.3 else-if ............................................................................................................................. 53    \n3.4 \nswitch............................................................................................................................54    \n3.5 loops - while and for ................................................................................................... 56    \n3.6 loops - do-while........................................................................................................... 58    \n3.7 break and \ncontinue........................................................................................................59    \n3.8 goto and labels............................................................................................................... 60   \nchapter 4 - functions and  \nprogramstructure..........................................................................62    \n4.1 basics of functions ........................................................................................................ 62    \n4.2 functions returning non-integers ................................................................................. 65    \n4.3 external variables .......................................................................................................... 67    \n4.4 scope rules .................................................................................................................... 72\n\n4.5 header files....................................................................................................................  73    \n4.6 static variables .............................................................................................................. 75    \n4.7 register variables .......................................................................................................... 75    \n4.8 block structure............................................................................................................... 76    \n4.9 initialization ................................................................................................................... 76    \n4.10 recursion...................................................................................................................... 78    \n4.11 the c preprocessor ...................................................................................................... 79\n\n4.11.1 file inclusion.........................................................................................................79    \n4.11.2 macro substitution ................................................................................................ 80    \n4.11.3 conditional inclusion ............................................................................................ 82  \nchapter 5 - pointers and arrays ............................................................................................... 83    \n5.1 pointers and addresses................................................................................................... 83   \n5.2 pointers and \nfunctionarguments..................................................................................84    \n5.3 pointers and arrays ........................................................................................................ 87    \n5.4 address arithmetic ........................................................................................................ 90      \n5.5 character pointers and functions................................................................................... 93    \n5.6 pointer arrays; pointers to \npointers...............................................................................96    \n5.7 multi-dimensional arrays .............................................................................................. 99    \n5.8 initialization of pointer arrays..................................................................................... 101    \n5.9 pointers vs. multi-dimensional arrays......................................................................... 101\n\n5.10 command-line arguments ......................................................................................... 102    \n5.11 pointers to \nfunctions..................................................................................................106   \n5.12 complicated declarations .......................................................................................... 108  \nchapter 6 - \nstructures............................................................................................................. 114    \n6.1 basics of \nstructures......................................................................................................114    \n6.2 structures and functions .............................................................................................. 116    \n6.3 arrays of structures ..................................................................................................... 118      \n6.4 pointers to structures ................................................................................................... 122    \n6.5 self-referential structures ............................................................................................ 124    \n6.6 table lookup ............................................................................................................... 127    \n6.7 typedef........................................................................................................................ 129    \n6.8 unions .......................................................................................................................... 131\n\n6.9 bit-\nfields.......................................................................................................................132  \nchapter 7 - input and \noutput.................................................................................................. 135    \n7.1 standard input and output ........................................................................................... 135    \n7.2 formatted output - printf ............................................................................................. 137    \n7.3 variable-length argument \nlists...................................................................................138    \n7.4 formatted input - scanf................................................................................................ 140    \n7.5 file access ................................................................................................................... 142      \n7.6 error handling - stderr and exit .................................................................................. 145    \n7.7 line input and output .................................................................................................. 146    \n7.8 miscellaneous functions .............................................................................................. 147    \n7.8.1 string operations................................................................................................... 147    \n7.8.2 character class testing and conversion .............................................................. 148\n\n7.8.3 ungetc ................................................................................................................... 148     \n7.8.4 command execution.............................................................................................148    \n7.8.5 storage management.............................................................................................148    \n7.8.6 mathematical functions ........................................................................................ 149    \n7.8.7 random number generation ................................................................................. 149  \nchapter 8 - the unix system \ninterface................................................................................ 150    \n8.1 file descriptors ............................................................................................................ 150    \n8.2 low level i/o - read and write.................................................................................. 151    \n8.3 open, creat, close, unlink ..........................................................................................  152     \n8.4 random access - lseek ............................................................................................... 154    \n8.5 example - an implementation of fopen and getc....................................................... 155    \n8.6 example - listing directories ...................................................................................... 158    \n8.7 example - a storage allocator .................................................................................... 162  \nappendix a - reference manual ........................................................................................... 167\n\na.1 introduction ................................................................................................................. 167\n\na.2 lexical \nconventions....................................................................................................167    \na.2.1 tokens .................................................................................................................. 167    \na.2.2 comments............................................................................................................. 167    \na.2.3 identifiers.............................................................................................................. 167    \na.2.4 keywords.............................................................................................................. 168   \na.2.5 constants .............................................................................................................. 168    \na.2.6 string literals ....................................................................................................... 170   \na.3 syntax \nnotation...........................................................................................................170      \na.4 meaning of identifiers ................................................................................................. 170    \na.4.1 storage class ........................................................................................................ 170    \na.4.2 basic types .......................................................................................................... 171    \na.4.3 derived types........................................................................................................ 172    \na.4.4 type qualifiers.....................................................................................................172    \na.5 objects and lvalues .................................................................................................... 172\n\na.6 \nconversions.................................................................................................................172    \na.6.1 integral promotion................................................................................................ 173    \na.6.2 integral conversions............................................................................................. 173    \na.6.3 integer and floating.............................................................................................. 173    \na.6.4 floating types......................................................................................................173    \na.6.5 arithmetic conversions........................................................................................ 173    \na.6.6 pointers and integers ............................................................................................ 174    \na.6.7 void......................................................................................................................175     \na.6.8 pointers to void....................................................................................................175     \na.7 expressions.................................................................................................................. 175    \na.7.1 pointer conversion...............................................................................................176    \na.7.2 primary expressions.............................................................................................176    \na.7.3 postfix expressions .............................................................................................. 176    \na.7.4 unary operators ................................................................................................... 178    \na.7.5 casts ..................................................................................................................... 180\n\na.7.6 multiplicative operators....................................................................................... 180    \na.7.7 additive operators ............................................................................................... 181    \na.7.8 shift operators ..................................................................................................... 181    \na.7.9 relational operators.............................................................................................182    \na.7.10 equality operators.............................................................................................. 182    \na.7.11 bitwise and operator.......................................................................................182    \na.7.12 bitwise exclusive or operator ......................................................................... 183    \na.7.13 bitwise inclusive or operator .......................................................................... 183     \na.7.14 logical and operator.......................................................................................183     \na.7.15 logical or operator .......................................................................................... 183    \na.7.16 conditional operator..........................................................................................183    \na.7.17 assignment expressions..................................................................................... 184    \na.7.18 comma operator ................................................................................................ 184    \na.7.19 constant expressions ......................................................................................... 185    \na.8 \ndeclarations.................................................................................................................185\n\na.8.1 storage class specifiers ....................................................................................... 186    \na.8.2 type specifiers.....................................................................................................187    \na.8.3 structure and union declarations ........................................................................ 187    \na.8.4 enumerations........................................................................................................190    \na.8.5 declarators............................................................................................................ 191    \na.8.6 meaning of declarators ........................................................................................ 192    \na.8.7 initialization.......................................................................................................... 195    \na.8.8 type names........................................................................................................... 197\n\na.8.9 typedef................................................................................................................. 198    \na.8.10 type equivalence...............................................................................................198    \na.9 statements ................................................................................................................... 198    \na.9.1 labeled statements............................................................................................... 199    \na.9.2 expression statement ........................................................................................... 199    \na.9.3 compound statement ........................................................................................... 199    \na.9.4 selection statements............................................................................................. 200    \na.9.5 iteration statements..............................................................................................200     \na.9.6 jump statements ................................................................................................... 201     \na.10 external declarations ................................................................................................ 202    \na.10.1 function definitions...........................................................................................202    \na.10.2 external declarations ......................................................................................... 203    \na.11 scope and linkage .................................................................................................... 204    \na.11.1 lexical scope ..................................................................................................... 204\n\na.11.2 linkage...............................................................................................................205     \na.12 preprocessing............................................................................................................. 205    \na.12.1 trigraph sequences ............................................................................................ 206    \na.12.2 line splicing ...................................................................................................... 206    \na.12.3 macro definition and expansion ....................................................................... 206    \na.12.4 file inclusion......................................................................................................208    \na.12.5 conditional compilation .................................................................................... 209    \na.12.6 line control ....................................................................................................... 210    \na.12.7 error generation.................................................................................................210      \na.12.8 pragmas .............................................................................................................. 211   \na.12.9 null directive......................................................................................................211    \na.12.10 predefined names ............................................................................................. 211    \na.13 grammar.................................................................................................................... 211  \nappendix b - standard library.............................................................................................. 219    \nb.1 input and output: <stdio.h> ........................................................................................ 219\n\nb.1.1 file operations ..................................................................................................... 219    \nb.1.2 formatted output.................................................................................................. 221    \nb.1.3 formatted input .................................................................................................... 222    \nb.1.4 character input and output functions.................................................................. 224    \nb.1.5 direct input and output functions ....................................................................... 224    \nb.1.6 file positioning functions .................................................................................... 225    \nb.1.7 error functions ..................................................................................................... 225    \nb.2 character class tests: <ctype.h> ................................................................................ 225     \nb.3 string functions:  \n<string.h>........................................................................................226    \nb.4 mathematical functions: \n<math.h>.............................................................................227    \nb.5 utility functions: <stdlib.h> ....................................................................................... 228    \nb.6 diagnostics: <assert.h>................................................................................................ 230    \nb.7 variable argument lists: <stdarg.h> .......................................................................... 230\n\nb.8 non-local jumps: <setjmp.h>......................................................................................  231    \nb.9 signals: <signal.h> ...................................................................................................... 231    \nb.10 date and time functions: \n<time.h>..........................................................................232    \nb.11 implementation-defined limits: <limits.h> and <float.h>  \n...........................................................................................................................................234  \nappendix c - summary of changes ...................................................................................... 235\n\npreface   \nthe computing world has undergone a revolution since the publication of the c  \nprogramming language in 1978. big computers are much bigger, and personal \ncomputers  \nhave capabilities that rival mainframes of a decade ago. during this time, c has changed \ntoo,  \nalthough only modestly, and it has spread far beyond its origins as the language of the \nunix  \noperating system.   \nthe growing popularity of c, the changes in the language over the years, and the creation \nof  \ncompilers by groups not involved in its design, combined to demonstrate a need for a \nmore  \nprecise and more contemporary definition of the language than the first edition of this  \nbook  \nprovided. in 1983, the american national standards institute (ansi) established a  \ncommittee  \nwhose goal was to produce ``an unambiguous and machine-independent definition of the  \nlanguage c'''', while still retaining its spirit. the result is the ansi standard f or c.  \n \nthe standard formalizes constructions that were hinted but not described in the f irst \nedition,  \nparticularly structure assignment and enumerations. it provides a new form of f unction  \ndeclaration that permits cross-checking of definition with use. it specifies  a standard \nlibrary,  \nwith an extensive set of functions for performing input and output, memory management,  \nstring manipulation, and similar tasks. it makes precise the behavior of featur es that were \nnot  \nspelled out in the original definition, and at the same time states explicitly whi ch aspects \nof  \nthe language remain machine-dependent.   \nthis second edition of the c programming language describes c as defined by the \nansi  \nstandard. although we have noted the places where the language has evolved, we have \nchosen  \nto write exclusively in the new form. for the most part, this makes no significant  \ndifference;  \nthe most visible change is the new form of function declaration and definition. modern  \ncompilers already support most features of the standard.   \nwe have tried to retain the brevity of the first edition. c is not a big language, and it i s \nnot\n\nwell served by a big book. we have improved the exposition of critical features, such as  \npointers, that are central to c programming. we have refined the original exampl es, and \nhave   \nadded new examples in several chapters. for instance, the treatment of complica ted  \ndeclarations is augmented by programs that convert declarations into words and vice \nversa.  \nas before, all examples have been tested directly from the text, which is in mac hine-\nreadable  \nform.   \nappendix a, the reference manual, is not the standard, but our attempt to convey the  \nessentials of the standard in a smaller space. it is meant for easy comprehens ion by  \nprogrammers, but not as a definition for compiler writers -- that role proper ly belongs to \nthe  \nstandard itself. appendix b is a summary of the facilities of the standard librar y. it too is  \nmeant for reference by programmers, not implementers. appendix c is a concise \nsummary of  \nthe changes from the original version.   \nas we said in the preface to the first edition, c ``wears well as one''s experi ence with it  \ngrows''''. with a decade more experience, we still feel that way. we hope that this  book \nwill  \nhelp you learn c and use it well.\n\nwe are deeply indebted to friends who helped us to produce this second edition. jon \nbently,  \ndoug gwyn, doug mcilroy, peter nelson, and rob pike gave us perceptive comments on  \nalmost every page of draft manuscripts. we are grateful for careful reading by al aho, \ndennis  \nallison, joe campbell, g.r. emlin, karen fortgang, allen holub, andrew hume, dave  \nkristol, john linderman, dave prosser, gene spafford, and chris van wyk. we also \nreceived  \nhelpful suggestions from bill cheswick, mark kernighan, andy koenig, robin lake, \ntom  \nlondon, jim reeds, clovis tondo, and peter weinberger. dave prosser answered many  \ndetailed questions about the ansi standard. we used bjarne stroustrup''s c++ translator  \nextensively for local testing of our programs, and dave kristol provided us with an an si \nc  \ncompiler for final testing. rich drechsler helped greatly with typesetting.   \n \nour sincere thanks to all.   \nbrian w. kernighan  \ndennis m. ritchie\n\npreface to the first edition   \nc is a general-purpose programming language with features economy of expression, \nmodern  \nflow control and data structures, and a rich set of operators. c is not a ``very high level''''  \nlanguage, nor a ``big'''' one, and is not specialized to any particular area of applica tion. but \nits  \nabsence of restrictions and its generality make it more convenient and effecti ve for many  \ntasks than supposedly more powerful languages.   \nc was originally designed for and implemented on the unix operating system on the \ndec  \npdp-11, by dennis ritchie. the operating system, the c compiler, and essentially all \nunix  \napplications programs (including all of the software used to prepare this book) ar e written \nin   \nc. production compilers also exist for several other machines, including the i bm \nsystem/370,  \nthe honeywell 6000, and the interdata 8/32. c is not tied to any particular hardware or  \nsystem, however, and it is easy to write programs that will run without change on any  \nmachine that supports c.  \nthis book is meant to help the reader learn how to program in c. it contains a tutorial  \nintroduction to get new users started as soon as possible, separate chapters  on each major  \nfeature, and a reference manual. most of the treatment is based on reading, writ ing and  \nrevising examples, rather than on mere statements of rules. for the most part, the \nexamples  \nare complete, real programs rather than isolated fragments. all examples have  been tested  \ndirectly from the text, which is in machine-readable form. besides showing how t o make  \neffective use of the language, we have also tried where possible to illustra te useful \nalgorithms  \nand principles of good style and sound design.   \nthe book is not an introductory programming manual; it assumes some familiar ity with \nbasic  \nprogramming concepts like variables, assignment statements, loops, and functions.  \nnonetheless, a novice programmer should be able to read along and pick up the language,  \nalthough access to more knowledgeable colleague will help.   \nin our experience, c has proven to be a pleasant, expressive and versatile language for a \nwide  \nvariety of programs. it is easy to learn, and it wears well as on''s experience wit h it grows. \nwe  \nhope that this book will help you to use it well.\n\nthe thoughtful criticisms and suggestions of many friends and colleagues have added  \ngreatly  \nto this book and to our pleasure in writing it. in particular, mike bianchi, jim blue, stu  \nfeldman, doug mcilroy bill roome, bob rosin and larry rosler all read multiple \nvolumes  \nwith care. we are also indebted to al aho, steve bourne, dan dvorak, chuck haley, \ndebbie  \nhaley, marion harris, rick holt, steve johnson, john mashey, bob mitze, ralph muha,  \npeter nelson, elliot pinson, bill plauger, jerry spivack, ken thompson, and peter   \nweinberger for helpful comments at various stages, and to mile lesk and joe ossa nna \nfor  \ninvaluable assistance with typesetting.   \nbrian w. kernighan  \ndennis m. ritchie\n\nchapter 1 - a tutorial introduction   \nlet us begin with a quick introduction in c. our aim is to show the essential elements of \nthe  \nlanguage in real programs, but without getting bogged down in details, rules, and \nexceptions.  \nat this point, we are not trying to be complete or even precise (save that the exam ples are  \nmeant to be correct). we want to get you as quickly as possible to the point where you \ncan  \nwrite useful programs, and to do that we have to concentrate on the basics: variables  and  \nconstants, arithmetic, control flow, functions, and the rudiments of input and output. we  \nare  \nintentionally leaving out of this chapter features of c that are important for w riting bigger  \nprograms. these include pointers, structures, most of c''s rich set of operators, sever al \ncontrol- \nflow statements, and the standard library.   \nthis approach and its drawbacks. most notable is that the complete story on any \nparticular  \nfeature is not found here, and the tutorial, by being brief, may also be misleading. and  \nbecause the examples do not use the full power of c, they are not as concise and elegant \nas  \nthey might be. we have tried to minimize these effects, but be warned. another drawback \nis  \nthat later chapters will necessarily repeat some of this chapter. we  hope that the \nrepetition  \nwill help you more than it annoys.   \nin any case, experienced programmers should be able to extrapolate from the materi al in \nthis  \nchapter to their own programming needs. beginners should supplement it by writing \nsmall,  \nsimilar programs of their own. both groups can use it as a framework on which to hang \nthe  \nmore detailed descriptions that begin in chapter 2.   \n1.1 getting started  \nthe only way to learn a new programming language is by writing programs in it. the \nfirst  \nprogram to write is the same for all languages:   \nprint the words   \nhello, world\n\nthis is a big hurdle; to leap over it you have to be able to create the program text  \nsomewhere,  \ncompile it successfully, load it, run it, and find out where your output went. with these  \nmechanical details mastered, everything else is comparatively easy.   \nin c, the program to print ``hello, world'''' is  \n #include <stdio.h>   \n main( \n)  {  \nprintf("hello, world\\n") \n;  }    \njust how to run this program depends on the system you are using. as a specific example, on  \nthe unix operating system you must create the program in a file whose name ends in \n``.c'''',  \nsuch as hello.c, then compile it with the command   \n cc hello.c\n\nif you haven''t botched anything, such as omitting a character or misspelling something, \nthe  \ncompilation will proceed silently, and make an executable file called a.out. if you run \na.out  \nby typing the command   \n a.out   \nit will print   \n hello, world   \non other systems, the rules will be different; check with a local expert.   \nnow, for some explanations about the program itself. a c program, whatever its size, \nconsists  \nof functions and variables. a function contains statements that specify the computing  \noperations to be done, and variables store values used during the computation. c \nfunctions are  \nlike the subroutines and functions in fortran or the procedures and functions of pasc al. \nour  \nexample is a function named main. normally you are at liberty to give functions \nwhatever  \nnames you like, but ``main'''' is special - your program begins executing at the beginning \nof   \nmain. this means that every program must have a main somewhere.    \nmain will usually call other functions to help perform its job, some that you wrote, an d \nothers  \nfrom libraries that are provided for you. the first line of the program,  \n #include <stdio.h>  \ntells the compiler to include information about the standard input/output library;  the line  \nappears at the beginning of many c source files. the standard library is describ ed in \nchapter  \n7 and appendix b.   \none method of communicating data between functions is for the calling function to \nprovide a  \nlist of values, called arguments, to the function it calls. the parentheses after  the function  \nname surround the argument list. in this example, main is defined to be a function that  \nexpects  \nno arguments, which is indicated by the empty list ( ).   \n#include <stdio.h> include information about standard\n\nlibrary   \nmain() define a function called main   \nthat received no argument values  \n{ statements of main are enclosed in braces  \nprintf("hello, world\\n"); main calls library function printf  \nto print this sequence of characters  \n} \\n represents the newline character   \nthe first c program   \nthe statements of a function are enclosed in braces { }. the function main contains only \none  \nstatement,   \n printf("hello, world\\n");\n\na function is called by naming it, followed by a parenthesized list of arguments, so this \ncalls  \nthe function printf with the argument "hello, world\\n". printf is a library function that  \nprints output, in this case the string of characters between the quotes.   \na sequence of characters in double quotes, like "hello, world\\n", is called a charac ter  \nstring or string constant. for the moment our only use of character strings will be  as  \narguments for printf and other functions.   \nthe sequence \\n in the string is c notation for the newline character, which when printe d  \nadvances the output to the left margin on the next line. if you leave out the \\n (a \nworthwhile  \nexperiment), you will find that there is no line advance after the output is p rinted. you \nmust  \nuse \\n to include a newline character in the printf argument; if you try something li ke  \n \n printf("hello, world  \n") \n;    \nthe c compiler will produce an error message.   \nprintf never supplies a newline character automatically, so several cal ls may be used to  \nbuild up an output line in stages. our first program could just as well have been written   \n \n #include <stdio.h>   \n main()   {   \nprintf("hello, ");   \nprintf("world");   \nprintf("\\n");   }  \nto produce identical output.   \nnotice that \\n represents only a single character. an escape sequence like \\n pr ovides a  \ngeneral and extensible mechanism for representing hard-to-type or invisibl e characters.  \namong the others that c provides are \\t for tab, \\b for backspace, \\" for the double quote\n\nand \\\\ for the backslash itself. there is a complete list in section 2.3.    \nexercise 1-1. run the ``hello, world'''' program on your system. experiment with leaving  \nout parts of the program, to see what error messages you get.   \nexercise 1-2. experiment to find out what happens when prints''s argument string contai ns  \n\\c, where c is some character not listed above.   \n1.2 variables and arithmetic expressions  \nthe next program uses the formula oc=(5/9)(of-32) to print the following table of \nfahrenheit  \ntemperatures and their centigrade or celsius equivalents:\n\n1 -17  \n20 - 6  40  4  60 15  80 26  100 37  120 48  140 60  160 71  180 82  200 93  220 104  240 115  260 126  280 137  300 148    \nthe program itself still consists of the definition of a single function named main. it is \nlonger  \nthan the one that printed ``hello, world'''', but not complicated. it introduces several  new  \nideas, including comments, declarations, variables, arithmetic expressions , loops , and  \nformatted output.     \n #include <stdio.h>   \n /* print fahrenheit-celsius table   \n for fahr = 0, 20, ..., 300 * \n/  \nmain( \n)  {    \nint fahr, celsius;  \nint lower, upper, step;    \nlower = 0; /* lower limit of temperature scale * \n/  \nupper = 300; /* upper limit * \n/\n\nstep = 20; /* step size *  \n/    \nfahr = lower;   \nwhile (fahr <= upper)  {  \ncelsius = 5 * (fahr-32) / 9;  \nprintf("%d\\t%d\\n", fahr, celsius) \n;  \nfahr = fahr + step;    } }   \nthe two lines   \n /* print fahrenheit-celsius table  \nfor fahr = 0, 20, ..., 300 * \n/    \nare a comment, which in this case explains briefly what the program does. any characters  \nbetween /* and */ are ignored by the compiler; they may be used freely to make a \nprogram  \neasier to understand. comments may appear anywhere where a blank, tab or newline ca n.  \n \nin c, all variables must be declared before they are used, usually at the beginning of the  \nfunction before any executable statements. a declaration announces the properties  of  \nvariables; it consists of a name and a list of variables, such as  \n int fahr, celsius;  \nint lower, upper, step;  \nthe type int means that the variables listed are integers; by contrast wit h float, which  \nmeans floating point, i.e., numbers that may have a fractional part. the range of bot h int \nand  \nfloat depends on the machine you are using; 16-bits ints, which lie between -32768 and\n\n+32767, are common, as are 32-bit ints. a float number is typically a 32-bit quantity, \nwith  \nat least six significant digits and magnitude generally between about 10-38 and 1038.   \nc provides several other data types besides int and float, including:   \nchar character - a single byte  \nshort short integer  \nlong long integer  \ndouble double-precision floating point  \nthe size of these objects is also machine-dependent. there are also arrays, st ructures and  \nunions of these basic types, pointers to them, and functions that return them, all of whic h \nwe  \nwill meet in due course.   \ncomputation in the temperature conversion program begins with the assignment \nstatements  \n lower = 0;  \nupper = 300;  \nstep = 20;    \nwhich set the variables to their initial values. individual statements are  terminated by  \nsemicolons.     \neach line of the table is computed the same way, so we use a loop that repeats once pe r \noutput  \nline; this is the purpose of the while loop  \n while (fahr <= upper) {  ...  } \nthe while loop operates as follows: the condition in parentheses is tested. i f it is true \n(fahr  \nis less than or equal to upper), the body of the loop (the three statements enclose d in \nbraces)  \nis executed. then the condition is re-tested, and if true, the body is executed again. whe n \nthe  \ntest becomes false (fahr exceeds upper) the loop ends, and execution continues at  the  \nstatement that follows the loop. there are no further statements in this progra m, so it  \nterminates.   \nthe body of a while can be one or more statements enclosed in braces, as in the \ntemperature\n\nconverter, or a single statement without braces, as in    \n while (i < j)  \ni = 2 * i;  \nin either case, we will always indent the statements controlled by the while by one tab \nstop  \n(which we have shown as four spaces) so you can see at a glance which statements are \ninside  \nthe loop. the indentation emphasizes the logical structure of the program. although c  \ncompilers do not care about how a program looks, proper indentation and spacing are \ncritical  \nin making programs easy for people to read. we recommend writing only one statement \nper  \nline, and using blanks around operators to clarify grouping. the position of braces is less  \nimportant, although people hold passionate beliefs. we have chosen one of several \npopular  \nstyles. pick a style that suits you, then use it consistently.\n\nmost of the work gets done in the body of the loop. the celsius temperature is computed \nand  \nassigned to the variable celsius by the statement   \n celsius = 5 * (fahr-32) / 9;  \nthe reason for multiplying by 5 and dividing by 9 instead of just multiplying by 5/9 is \nthat in  \nc, as in many other languages, integer division truncates: any fractional part is discarded.  \nsince 5 and 9 are integers. 5/9 would be truncated to zero and so all the celsius \ntemperatures  \nwould be reported as zero.   \nthis example also shows a bit more of how printf works. printf is a general-purpose  \noutput formatting function, which we will describe in detail in chapter 7. its first \nargument is  \na string of characters to be printed, with each % indicating where one of the othe r \n(second,  \nthird, ...) arguments is to be substituted, and in what form it is to be printed. for instan ce, \n%d  \nspecifies an integer argument, so the statement  \n printf("%d\\t%d\\n", fahr, celsius);  \ncauses the values of the two integers fahr and celsius to be printed, with a tab (\\t ) between  \nthem.    \neach % construction in the first argument of printf is paired with the corres ponding \nsecond   \nargument, third argument, etc.; they must match up properly by number and type, or you \nwill  \nget wrong answers.   \nby the way, printf is not part of the c language; there is no input or output defined in c  \nitself. printf is just a useful function from the standard library of functions that a re \nnormally  \naccessible to c programs. the behaviour of printf is defined in the ansi standard, \nhowever,  \nso its properties should be the same with any compiler and library that conforms  to the  \nstandard.   \nin order to concentrate on c itself, we don''t talk much about input and output until \nchapter 7.  \nin particular, we will defer formatted input until then. if you have to input numbers, re ad \nthe  \ndiscussion of the function scanf in section 7.4. scanf is like printf, except that it  reads  \ninput instead of writing output.\n\nthere are a couple of problems with the temperature conversion program. the simpler \none is  \nthat the output isn''t very pretty because the numbers are not right-justified. that''s easy to \nfix;  \nif we augment each %d in the printf statement with a width, the numbers printed wil l be  \nright-justified in their fields. for instance, we might say  \n printf("%3d %6d\\n", fahr, celsius);   \nto print the first number of each line in a field three digits wide, and the second in a  field \nsix  \ndigits wide, like this:   \n0 -17  \n20 -6  40 4  60 15  80 26  100 37  ...\n\nthe more serious problem is that because we have used integer arithmetic, the celsius  \ntemperatures are not very accurate; for instance, 0of is actually about -17.8oc, not  -17. \nto get  \nmore accurate answers, we should use floating-point arithmetic instead of i nteger. this  \nrequires some changes in the program. here is the second version:  \n #include <stdio.h>   \n /* print fahrenheit-celsius table   \n for fahr = 0, 20, ..., 300; floating-point version */   \n main()   {   \nfloat fahr, celsius;   \nfloat lower, upper, step;   \nlower = 0; /* lower limit of temperatuire scale * \n/  \nupper = 300; /* upper limit * \n/  \nstep = 20; /* step size *  \n/     \nfahr = lower;   \nwhile (fahr <= upper) {   \n celsius = (5.0/9.0) * (fahr-32.0);   \n printf("%3.0f %6.1f\\n", fahr, celsius);   \n fahr = fahr + step;   } } \nthis is much the same as before, except that fahr and celsius are declared to be fl oat and  \nthe formula for conversion is written in a more natural way. we were unable to use 5/ 9 in \nthe  \nprevious version because integer division would truncate it to zero. a decimal point in a\n\nconstant indicates that it is floating point, however, so 5.0/9.0 is not truncated because it \nis   \nthe ratio of two floating-point values.   \nif an arithmetic operator has integer operands, an integer operation is performe d. if an  \narithmetic operator has one floating-point operand and one integer operand, however, the  \ninteger will be converted to floating point before the operation is done. if we had writt en  \n(fahr-32), the 32 would be automatically converted to floating point. nevertheless, \nwriting  \nfloating-point constants with explicit decimal points even when they have integral va lues  \nemphasizes their floating-point nature for human readers.   \nthe detailed rules for when integers are converted to floating point are in chapt er 2. for \nnow,  \nnotice that the assignment   \n fahr = lower;   \nand the test  \n while (fahr <= upper)  \nalso work in the natural way - the int is converted to float before the operation i s done.  \n \nthe printf conversion specification %3.0f says that a floating-point number (here fah r) is  \nto be printed at least three characters wide, with no decimal point and no fracti on digits.  \n%6.1f describes another number (celsius) that is to be printed at least six c haracters wide,  \nwith 1 digit after the decimal point. the output looks like this:   \n0 -17.8  \n20 -6.7     40 4.4  .. .\n\nwidth and precision may be omitted from a specification: %6f says that the number is to \nbe at  \nleast six characters wide; %.2f specifies two characters after the de cimal point, but the \nwidth  \nis not constrained; and %f merely says to print the number as floating point.   \n%d%6d%f%6f%.2f%6.2f  \nprint as decimal integer  \nprint as decimal integer, at least 6 characters wide  \nprint as floating point  \nprint as floating point, at least 6 characters wide  \nprint as floating point, 2 characters after decimal point  \nprint as floating point, at least 6 wide and 2 after decimal point   \namong others, printf also recognizes %o for octal, %x for hexadecimal, %c for character , \n%s  \nfor character string and %% for itself.   \nexercise 1-3. modify the temperature conversion program to print a heading above the \ntable.   \nexercise 1-4. write a program to print the corresponding celsius to fahrenheit  table.  \n \n1.3 the for statement  \nthere are plenty of different ways to write a program for a particular task.  let''s try a \nvariation  \non the temperature converter.   \n #include <stdio.h>   \n /* print fahrenheit-celsius table */   \n main()   {   \nint fahr;   \n for (fahr = 0; fahr <= 300; fahr = fahr + 20)  \nprintf("%3d %6.1f\\n", fahr, (5.0/9.0)*(fahr-32)) \n;  }   \nthis produces the same answers, but it certainly looks different. one major change is  the\n\nelimination of most of the variables; only fahr remains, and we have made it an int. the  \nlower and upper limits and the step size appear only as constants in the for stateme nt, \nitself a   \nnew construction, and the expression that computes the celsius temperature now appe ars \nas  \nthe third argument of printf instead of a separate assignment statement.   \nthis last change is an instance of a general rule - in any context where it is per missible to \nuse  \nthe value of some type, you can use a more complicated expression of that type. since the  \nthird argument of printf must be a floating-point value to match the %6.1f, any floating- \npoint expression can occur here.   \nthe for statement is a loop, a generalization of the while. if you compare it to the ea rlier  \nwhile, its operation should be clear. within the parentheses, there are three  parts, \nseparated  \nby semicolons. the first part, the initialization   \n fahr = 0\n\nis done once, before the loop proper is entered. the second part is the  \ntest or condition that controls the loop:  \n fahr <= 300  \nthis condition is evaluated; if it is true, the body of the loop (here a single ptintf) is  \nexecuted. then the increment step   \n fahr = fahr + 20  \nis executed, and the condition re-evaluated. the loop terminates if the condition has  \nbecome  \nfalse. as with the while, the body of the loop can be a single statement or a group of  \nstatements enclosed in braces. the initialization, condition and increment ca n be any  \nexpressions.   \nthe choice between while and for is arbitrary, based on which seems clearer. the for  is  \nusually appropriate for loops in which the initialization and increment are single \nstatements  \nand logically related, since it is more compact than while and it keeps the loop contr ol  \nstatements together in one place.   \nexercise 1-5. modify the temperature conversion program to print the table in revers e \norder,  \nthat is, from 300 degrees to 0.   \n1.4 symbolic constants   \na final observation before we leave temperature conversion forever. it''s bad prac tice to \nbury   \n``magic numbers'''' like 300 and 20 in a program; they convey little information to \nsomeone  \nwho might have to read the program later, and they are hard to change in a systematic \nway.  \none way to deal with magic numbers is to give them meaningful names. a #define line  \ndefines a symbolic name or symbolic constant to be a particular string of charact ers:  \n \n#define name replacement list   \nthereafter, any occurrence of name (not in quotes and not part of another name) will be  \nreplaced by the corresponding replacement text. the name has the same form as a \nvariable  \nname: a sequence of letters and digits that begins with a letter. the replaceme nt text can \nbe  \nany sequence of characters; it is not limited to numbers.   \n #include <stdio.h>\n\n#define lower 0 /* lower limit of table */    \n #define upper 300 /* upper limit */  \n #define step 20 /* step size */   \n /* print fahrenheit-celsius table */   \n main()   {   \nint fahr;   \n for (fahr = lower; fahr <= upper; fahr = fahr + step)  \nprintf("%3d %6.1f\\n", fahr, (5.0/9.0)*(fahr-32));  } \nthe quantities lower, upper and step are symbolic constants, not variables, so they \ndo not  \nappear in declarations. symbolic constant names are conventionally writte n in upper case \nso  \nthey can ber readily distinguished from lower case variable names. notice that  there is no  \nsemicolon at the end of a #define line.\n\n1.5 character input and output  \nwe are going to consider a family of related programs for processing character data. you \nwill  \nfind that many programs are just expanded versions of the prototypes that we discuss \nhere.   \nthe model of input and output supported by the standard library is very simple. text \ninput or  \noutput, regardless of where it originates or where it goes to, is dealt with as st reams of  \ncharacters. a text stream is a sequence of characters divided into lines;  each line consists \nof  \nzero or more characters followed by a newline character. it is the responsi bility of the \nlibrary  \nto make each input or output stream confirm this model; the c programmer using the \nlibrary  \nneed not worry about how lines are represented outside the program.   \nthe standard library provides several functions for reading or writing one characte r at a \ntime,  \nof which getchar and putchar are the simplest. each time it is called, getchar  reads the  \nnext input character from a text stream and returns that as its value. that is , after  \n \n c = getchar(); \nthe variable c contains the next character of input. the characters normally com e from \nthe   \nkeyboard; input from files is discussed in chapter 7.    \nthe function putchar prints a character each time it is called:   \n putchar(c);  \nprints the contents of the integer variable c as a character, usually on the scre en. calls to  \nputchar and printf may be interleaved; the output will appear in the order in which t he \ncalls  \nare made.   \n1.5.1 file copying  \ngiven getchar and putchar, you can write a surprising amount of useful code without  \nknowing anything more about input and output. the simplest example is a program that  \ncopies its input to its output one character at a time:   \nread a character  \n while (charater is not end-of-file indicator) \noutput the character just read  \nread a character\n\nconverting this into c gives:  \n #include <stdio.h>   \n /* copy input to output; 1st version * \n/  \nmain( \n)  {    \nint c;   \n c = getchar();   \n while (c != eof)  {  \nputchar(c) \n;  \nc = getchar() \n;    }  }  \nthe relational operator != means ``not equal to''''.\n\nwhat appears to be a character on the keyboard or screen is of course, like everything \nelse,  \nstored internally just as a bit pattern. the type char is specifically meant for storing such  \ncharacter data, but any integer type can be used. we used int for a subtle but importa nt  \nreason.   \nthe problem is distinguishing the end of input from valid data. the solution is that \ngetcharreturns a distinctive value when there is no more input, a value that cannot be \nconfused with  \nany real character. this value is called eof, for ``end of file''''. we must de clare c to be a \ntype  \nbig enough to hold any value that getchar returns. we can''t use char since c must be big  \nenough to hold eof in addition to any possible char. therefore we use int.   \neof is an integer defined in <stdio.h>, but the specific numeric value doesn''t m atter as \nlong as  \nit is not the same as any char value. by using the symbolic constant, we are assured th at  \nnothing in the program depends on the specific numeric value.   \nthe program for copying would be written more concisely by experienced c \nprogrammers. in  \nc, any assignment, such as  \n c = getchar(); \nis an expression and has a value, which is the value of the left hand side after the  \nassignment.   \nthis means that a assignment can appear as part of a larger expression. if the  assignment \nof a  \ncharacter to c is put inside the test part of a while loop, the copy program can be wri tten \nthis  \nway:  \n #include <stdio.h>   \n /* copy input to output; 2nd version */  \n main()   {   \nint c;   \n while ((c = getchar()) != eof)  \nputchar(c);  }\n\nthe while gets a character, assigns it to c, and then tests whether the character was the \nend-  \nof-file signal. if it was not, the body of the while is executed, printing the charac ter. the  \nwhile then repeats. when the end of the input is finally reached, the while terminate s and \nso  \ndoes main.   \nthis version centralizes the input - there is now only one reference to getchar - a nd \nshrinks  \nthe program. the resulting program is more compact, and, once the idiom is mastered, \neasier  \nto read. you''ll see this style often. (it''s possible to get carried away and creat e \nimpenetrable  \ncode, however, a tendency that we will try to curb.)   \nthe parentheses around the assignment, within the condition are necessary. the \nprecedence  \nof != is higher than that of =, which means that in the absence of parentheses the \nrelational  \ntest != would be done before the assignment =. so the statement   \n c = getchar() != eof   \nis equivalent to   \n c = (getchar() != eof)\n\nthis has the undesired effect of setting c to 0 or 1, depending on whether or not the call \nof  \ngetchar returned end of file. (more on this in chapter 2.)   \nexercsise 1-6. verify that the expression getchar() != eof is 0 or 1.   \nexercise 1-7. write a program to print the value of eof.   \n1.5.2 character counting  \nthe next program counts characters; it is similar to the copy program.   \n #include <stdio.h>   \n /* count characters in input; 1st version * \n/  \nmain( \n)  {    \nlong nc;   \nnc = 0;  \nwhile (getchar() != eof)  \n++nc;   \nprintf("%ld\\n", nc)  \n;  }   \nthe statement  \n ++nc;  \npresents a new operator, ++, which means increment by one. you could instead write nc \n= nc   \n+ 1 but ++nc is more concise and often more efficient. there is a corresponding operator  \n- \nto decrement by 1. the operators ++ and -- can be either prefix operators (++nc)  or \npostfix  \noperators (nc++); these two forms have different values in expressions, a s will be shown \nin  \nchapter 2, but ++nc and nc++ both increment nc. for the moment we will will stick to \nthe  \nprefix form.\n\nthe character counting program accumulates its count in a long variable instead of an int.  \nlong integers are at least 32 bits. although on some machines, int and long are the same   \nsize, on others an int is 16 bits, with a maximum value of 32767, and it would take \nrelatively  \nlittle input to overflow an int counter. the conversion specification %ld tells pri ntf that \nthe  \ncorresponding argument is a long integer.   \nit may be possible to cope with even bigger numbers by using a double (double precision  \nfloat). we will also use a for statement instead of a while, to illustrate a nother way to \nwrite  \nthe loop.   \n #include <stdio.h>   \n /* count characters in input; 2nd version * \n/  \nmain( \n)  {    \ndouble nc;  \n for (nc = 0; gechar() != eof; ++nc)  \n;   \nprintf("%.0f\\n", nc)  \n;  }\n\nprintf uses %f for both float and double; %.0f suppresses the printing of the decimal point  \nand the fraction part, which is zero.   \nthe body of this for loop is empty, because all the work is done in the test and increment  \nparts. but the grammatical rules of c require that a for statement have a b ody. the \nisolated  \nsemicolon, called a null statement, is there to satisfy that requirement . we put it on a \nseparate  \nline to make it visible.   \nbefore we leave the character counting program, observe that if the input contains  no  \ncharacters, the while or for test fails on the very first call to getchar, and t he program  \nproduces zero, the right answer. this is important. one of the nice things about while and  \nfor is that they test at the top of the loop, before proceeding with the body. if there is  \nnothing  \nto do, nothing is done, even if that means never going through the loop body. programs  \nshould act intelligently when given zero-length input. the while and for statements hel p  \nensure that programs do reasonable things with boundary conditions.   \n1.5.3 line counting  \nthe next program counts input lines. as we mentioned above, the standard library \nensures  \nthat an input text stream appears as a sequence of lines, each terminated by a  newline. \nhence,  \ncounting lines is just counting newlines:     \n #include <stdio.h>   \n /* count lines in input */  \n main()   {   \nint c, nl;  \n nl = 0;  \nwhile ((c = getchar()) != eof)  \nif (c == ''\\n'')  \n++nl;  \nprintf("%d\\n", nl);  } \nthe body of the while now consists of an if, which in turn controls the increment ++nl.  \nthe  \nif statement tests the parenthesized condition, and if the condition is true, e xecutes the\n\nstatement (or group of statements in braces) that follows. we have again indented to \nshow   \nwhat is controlled by what.   \nthe double equals sign == is the c notation for ``is equal to'''' (like pascal''s s ingle = or  \nfortran''s .eq.). this symbol is used to distinguish the equality test from the single  = that \nc  \nuses for assignment. a word of caution: newcomers to c occasionally write = when they   \nmean ==. as we will see in chapter 2, the result is usually a legal expression, so you  will \nget  \nno warning.   \na character written between single quotes represents an integer value  equal to the \nnumerical  \nvalue of the character in the machine''s character set. this is called a c haracter constant,  \nalthough it is just another way to write a small integer. so, for example, ''a'' is a cha racter  \nconstant; in the ascii character set its value is 65, the internal repr esentation of the \ncharacter   \na. of course, ''a'' is to be preferred over 65: its meaning is obvious, and it is independent \nof a  \nparticular character set.\n\nthe escape sequences used in string constants are also legal in character constants, so ''\\n''  \nstands for the value of the newline character, which is 10 in ascii. you should note \ncarefully  \nthat ''\\n'' is a single character, and in expressions is just an integer; on the  other hand, ''\\n'' is  \na string constant that happens to contain only one character. the topic of strings versus   \ncharacters is discussed further in chapter 2.   \nexercise 1-8. write a program to count blanks, tabs, and newlines.   \nexercise 1-9. write a program to copy its input to its output, replacing each string of  one \nor  \nmore blanks by a single blank.   \nexercise 1-10. write a program to copy its input to its output, replacing each tab by \\t, \neach  \nbackspace by \\b, and each backslash by \\\\. this makes tabs and backspaces visible in an   \nunambiguous way.   \n1.5.4 word counting  \nthe fourth in our series of useful programs counts lines, words, and characters, with the \nloose  \ndefinition that a word is any sequence of characters that does not contain a blank, tab  or  \nnewline. this is a bare-bones version of the unix program wc.   \n #include <stdio.h>     \n #define in 1 /* inside a word * \n/  \n#define out 0 /* outside a word * \n/    \n /* count lines, words, and characters in input */   \n main()   {   \n int c, nl, nw, nc, state;   \n state = out;   \n nl = nw = nc = 0;   \n while ((c = getchar()) != eof) {\n\n++nc;  \n if (c == ''\\n'')   \n ++nl;   \n if (c == '' '' || c == ''\\n'' || c = ''\\t'')   \n state = out;   \n else if (state == out) {   \n state = in;   \n ++nw;   }  }  \n printf("%d %d %d\\n", nl, nw, nc);   } \nevery time the program encounters the first character of a word, it counts one more word. \nthe   \nvariable state records whether the program is currently in a word or not; initi ally it is \n``not in   \na word'''', which is assigned the value out. we prefer the symbolic constants in and \nout to the  \nliteral values 1 and 0 because they make the program more readable. in a program a s tiny \nas  \nthis, it makes little difference, but in larger programs, the increase in cl arity is well worth \nthe  \nmodest extra effort to write it this way from the beginning. you''ll also find that it ''s easier \nto  \nmake extensive changes in programs where magic numbers appear only as symbolic  \nconstants.\n\nthe line   \n nl = nw = nc = 0;  \nsets all three variables to zero. this is not a special case, but a consequence of the fact \nthat an  \nassignment is an expression with the value and assignments associated from right to  left. \nit''s  \nas if we had written   \n nl = (nw = (nc = 0));  \nthe operator || means or, so the line  \n if (c == '' '' || c == ''\\n'' || c = ''\\t'') \nsays ``if c is a blank or c is a newline or c is a tab''''. (recall that the esc ape sequence \\t is a  \nvisible representation of the tab character.) there is a corresponding operat or && for \nand; its  \nprecedence is just higher than ||. expressions connected by && or || are evaluated le ft to  \nright, and it is guaranteed that evaluation will stop as soon as the truth or false hood is \nknown.  \nif c is a blank, there is no need to test whether it is a newline or tab, so thes e tests are not  \nmade. this isn''t particularly important here, but is significant in more compl icated \nsituations,  \nas we will soon see.   \nthe example also shows an else, which specifies an alternative action if the c ondition \npart of  \nan if statement is false. the general form is  \n if (expression) \nstatement1   \n else   \nstatement2  \none and only one of the two statements associated with an if-else is performed. if t he  \nexpression is true, statement1 is executed; if not, statement2 is executed. eac h statement \ncan  \nbe a single statement or several in braces. in the word count program, the one afte r the \nelse is  \nan if that controls two statements in braces.   \nexercise 1-11. how would you test the word count program? what kinds of input are \nmost  \nlikely to uncover bugs if there are any?\n\nexercise 1-12. write a program that prints its input one word per line.   \n1.6 arrays  \nlet is write a program to count the number of occurrences of each digit, of white space  \ncharacters (blank, tab, newline), and of all other characters. this is arti ficial, but it \npermits us  \nto illustrate several aspects of c in one program.   \nthere are twelve categories of input, so it is convenient to use an array to hold the \nnumber of  \noccurrences of each digit, rather than ten individual variables. here is one ver sion of the  \nprogram:\n\n#include <stdio.h>   \n /* count digits, white space, others * \n/  \nmain( \n)  {    \n int c, i, nwhite, nother;  \nint ndigit[10] \n;    \n nwhite = nother = 0;  \nfor (i = 0; i < 10; ++i)  \nndigit[i] = 0;    \n while ((c = getchar()) != eof)  \nif (c >= ''0'' && c <= ''9'' \n)  \n++ndigit[c-''0''] \n;  \nelse if (c == '' '' || c == ''\\n'' || c == ''\\t''  \n)   \n++nwhite;  \nelse  \n++nother;    \n printf("digits =") \n;  \nfor (i = 0; i < 10; ++i)  \nprintf(" %d", ndigit[i]) \n;  \nprintf(", white space = %d, other = %d\\n" ,  \nnwhite, nother) \n;  }   \nthe output of this program on itself is\n\ndigits = 9 3 0 0 0 0 0 0 0 1, white space = 123, other = 345    \nthe declaration   \n int ndigit[10];  \ndeclares ndigit to be an array of 10 integers. array subscripts always start at zero in c, so  \nthe elements are ndigit[0], ndigit[1], ..., ndigit[9]. this is reflected in the for  \nloops that initialize and print the array.   \na subscript can be any integer expression, which includes integer variables like i , and \ninteger  \nconstants.   \nthis particular program relies on the properties of the character represent ation of the \ndigits.  \nfor example, the test   \n if (c >= ''0'' && c <= ''9'')  \ndetermines whether the character in c is a digit. if it is, the numer ic value of that digit is  \n \n c - ''0''  \nthis works only if ''0'', ''1'', ..., ''9'' have consecutive increasing values. fortunately,   \nthis is true for all character sets.   \nby definition, chars are just small integers, so char variables and constants a re identical to  \nints in arithmetic expressions. this is natural and convenient; for example c- ''0'' is an  \ninteger expression with a value between 0 and 9 corresponding to the character ''0'' to ''9''   \nstored in c, and thus a valid subscript for the array ndigit.   \nthe decision as to whether a character is a digit, white space, or something els e is made \nwith  \nthe sequence\n\nif (c >= ''0'' && c <= ''9'')   \n ++ndigit[c-''0''];   \n else if (c == '' '' || c == ''\\n'' || c == ''\\t'')   \n++nwhite;  \n else   \n++nother;   \nthe pattern   \n if (condition1)  \nstatement1  \n else if (condition2)  \nstatement2   ...   ...     \n else   \nstatementn  \noccurs frequently in programs as a way to express a multi-way decision. the conditions \nare  \nevaluated in order from the top until some condition is satisfied; at that point the   \ncorresponding statement part is executed, and the entire construction is finished. (a ny  \nstatement can be several statements enclosed in braces.) if none of the condi tions is \nsatisfied,  \nthe statement after the final else is executed if it is present. if the  final else and statement  \nare omitted, as in the word count program, no action takes place. there can be any \nnumber of   \nelse if(condition)  \nstatement   \ngroups between the initial if and the final else.\n\nas a matter of style, it is advisable to format this construction as we have shown; if each \nif   \nwere indented past the previous else, a long sequence of decisions would march off the  \nright  \nside of the page.   \nthe switch statement, to be discussed in chapter 4, provides another way to write a  \nmulti- \nway branch that is particulary suitable when the condition is whether some int eger or  \ncharacter expression matches one of a set of constants. for contrast, we will  present a \nswitch  \nversion of this program in section 3.4.   \nexercise 1-13. write a program to print a histogram of the lengths of words in its input. it  \nis  \neasy to draw the histogram with the bars horizontal; a vertical orientation is m ore \nchallenging.   \nexercise 1-14. write a program to print a histogram of the frequencies of different  \ncharacters  \nin its input.   \n1.7 functions  \nin c, a function is equivalent to a subroutine or function in fortran, or a procedure or \nfunction  \nin pascal. a function provides a convenient way to encapsulate some computation, which  \ncan   \nthen be used without worrying about its implementation. with properly designed \nfunctions, it  \nis possible to ignore how a job is done; knowing what is done is sufficient. c makes the  \nsue of  \nfunctions easy, convinient and efficient; you will often see a short function defined and \ncalled  \nonly once, just because it clarifies some piece of code.\n\nso far we have used only functions like printf, getchar and putchar that have been  \nprovided for us; now it''s time to write a few of our own. since c has no exponentiation  \noperator like the ** of fortran, let us illustrate the mechanics of function definition by \nwriting  \na function power(m,n) to raise an integer m to a positive integer power n. that is,  the \nvalue of  \npower(2,5) is 32. this function is not a practical exponentiation routine, since it handles   \nonly positive powers of small integers, but it''s good enough for illustration.(the standard  \nlibrary contains a function pow(x,y) that computes xy.)   \nhere is the function power and a main program to exercise it, so you can see the whole  \nstructure at once.   \n #include <stdio.h>   \n int power(int m, int n);   \n /* test power function * \n/  \nmain( \n)  {   \n int i;     \n for (i = 0; i < 10; ++i)  \nprintf("%d %d %d\\n", i, power(2,i), power(-3,i)) \n;  \nreturn 0; }   \n /* power: raise base to n-th power; n >= 0 * \n/  \nint power(int base, int n) {   \n int i, p;  \n p = 1;  \nfor (i = 1; i <= n; ++i)  \np = p * base;  \nreturn p;\n\n}    \na function definition has this form:   \nreturn-type function-name(parameter declarations, if any)   {  \ndeclarations  \nstatements   }  \nfunction definitions can appear in any order, and in one source file or several, although no  \nfunction can be split between files. if the source program appears in several files, you \nmay  \nhave to say more to compile and load it than if it all appears in one, but that is an \noperating  \nsystem matter, not a language attribute. for the moment, we will assume t hat both \nfunctions  \nare in the same file, so whatever you have learned about running c programs will sti ll \nwork.   \nthe function power is called twice by main, in the line   \n printf("%d %d %d\\n", i, power(2,i), power(-3,i));   \neach call passes two arguments to power, which each time returns an integer to b e \nformatted  \nand printed. in an expression, power(2,i) is an integer just as 2 and i are. (not all \nfunctions  \nproduce an integer value; we will take this up in chapter 4.)   \nthe first line of power itself,\n\nint power(int base, int n) \ndeclares the parameter types and names, and the type of the result that the function \nreturns.  \nthe names used by power for its parameters are local to power, and are not visible t o any  \nother function: other routines can use the same names without conflict. this is al so true \nof the  \nvariables i and p: the i in power is unrelated to the i in main.   \nwe will generally use parameter for a variable named in the parenthesized li st in a \nfunction.  \nthe terms formal argument and actual argument are sometimes used for the same \ndistinction.   \nthe value that power computes is returned to main by the return: statement. any \nexpression  \nmay follow return:   \n return expression;  \na function need not return a value; a return statement with no expression causes contr ol, \nbut  \nno useful value, to be returned to the caller, as does ``falling off the end'''' of a funct ion by  \nreaching the terminating right brace. and the calling function can ignore a value ret urned \nby a  \nfunction.    \nyou may have noticed that there is a return statement at the end of main. since main i s a  \nfunction like any other, it may return a value to its caller, which is in effect t he \nenvironment in   \nwhich the program was executed. typically, a return value of zero implies normal  \ntermination; non-zero values signal unusual or erroneous termination conditions. in th e  \ninterests of simplicity, we have omitted return statements from our main funct ions up to \nthis  \npoint, but we will include them hereafter, as a reminder that programs should retur n \nstatus to  \ntheir environment.   \nthe declaration   \n int power(int base, int n);  \njust before main says that power is a function that expects two int arguments and retur ns \nan  \nint. this declaration, which is called a function prototype, has to agree with the defini tion  \nand uses of power. it is an error if the definition of a function or any uses of it do not \nagree  \nwith its prototype.\n\nparameter names need not agree. indeed, parameter names are optional in a function  \nprototype, so for the prototype we could have written   \n int power(int, int);   \nwell-chosen names are good documentation however, so we will often use them.   \na note of history: the biggest change between ansi c and earlier versions is how \nfunctions  \nare declared and defined. in the original definition of c, the power function would have \nbeen  \nwritten like this:\n\n/* power: raise base to n-th power; n >= 0 * \n/  \n/* (old-style version) * \n/  \npower(base, n)  \nint base, n;  {    \nint i, p;   \np = 1;  \nfor (i = 1; i <= n; ++i)  \np = p * base;  \nreturn p; }   \nthe parameters are named between the parentheses, and their types are declared before  \nopening the left brace; undeclared parameters are taken as int. (the body of the funct ion \nis  \nthe same as before.)   \nthe declaration of power at the beginning of the program would have looked like this:   \n int power();   \nno parameter list was permitted, so the compiler could not readily check that pow er was  \nbeing called correctly. indeed, since by default power would have been assumed to return \nan  \nint, the entire declaration might well have been omitted.   \nthe new syntax of function prototypes makes it much easier for a compiler to detect \nerrors in  \nthe number of arguments or their types. the old style of declaration and definition sti ll \nworks  \nin ansi c, at least for a transition period, but we strongly recommend that you use th e \nnew  \nform when you have a compiler that supports it.   \nexercise 1.15. rewrite the temperature conversion program of section 1.2 to use a \nfunction  \nfor conversion.   \n1.8 arguments - call by value  \none aspect of c functions may be unfamiliar to programmers who are used to some othe r\n\nlanguages, particulary fortran. in c, all function arguments are passed ``by value.'''' this  \nmeans that the called function is given the values of its arguments in temporary vari ables  \nrather than the originals. this leads to some different properties than are s een with ``call \nby   \nreference'''' languages like fortran or with var parameters in pascal, in whi ch the called \nroutine  \nhas access to the original argument, not a local copy.   \ncall by value is an asset, however, not a liability. it usually leads to more compact  \nprograms  \nwith fewer extraneous variables, because parameters can be treated as con veniently \ninitialized  \nlocal variables in the called routine. for example, here is a version of power that m akes \nuse of  \nthis property.  \n /* power: raise base to n-th power; n >= 0; version 2 * \n/  \nint power(int base, int n) {    \nint p;   \n for (p = 1; n > 0; --n)  \np = p * base;   \nreturn p;  }\n\nthe parameter n is used as a temporary variable, and is counted down (a for loop that \nruns  \nbackwards) until it becomes zero; there is no longer a need for the variable i. whatever is  \ndone to n inside power has no effect on the argument that power was originally called \nwith.   \nwhen necessary, it is possible to arrange for a function to modify a variable in a c alling  \nroutine. the caller must provide the address of the variable to be set (techni cally a pointer \nto  \nthe variable), and the called function must declare the parameter to be a pointer a nd \naccess the  \nvariable indirectly through it. we will cover pointers in chapter 5.   \nthe story is different for arrays. when the name of an array is used as an argument, the  \nvalue  \npassed to the function is the location or address of the beginning of the array - there is  no  \ncopying of array elements. by subscripting this value, the function can access and alter  \nany  \nargument of the array. this is the topic of the next section.   \n1.9 character arrays  \nthe most common type of array in c is the array of characters. to illustrate the u se of  \ncharacter arrays and functions to manipulate them, let''s write a program that r eads a set of \ntext  \nlines and prints the longest. the outline is simple enough:     \n while (there''s another line)  \nif (it''s longer than the previous longest)  \n(save it)  \n(save its length)  \nprint longest line  \nthis outline makes it clear that the program divides naturally into pieces. one pi ece gets \na  \nnew line, another saves it, and the rest controls the process.   \nsince things divide so nicely, it would be well to write them that way too. accordingly, \nlet us  \nfirst write a separate function getline to fetch the next line of input. we will  try to make \nthe  \nfunction useful in other contexts. at the minimum, getline has to return a signal about\n\npossible end of file; a more useful design would be to return the length of the line, or zero \nif   \nend of file is encountered. zero is an acceptable end-of-file return because it i s never a \nvalid  \nline length. every text line has at least one character; even a line contain ing only a \nnewline  \nhas length 1.   \nwhen we find a line that is longer than the previous longest line, it must be saved \nsomewhere.  \nthis suggests a second function, copy, to copy the new line to a safe place.   \nfinally, we need a main program to control getline and copy. here is the result.\n\n#include <stdio.h>  \n#define maxline 1000 /* maximum input line length * \n/    \n int getline(char line[], int maxline) \n;  \nvoid copy(char to[], char from[]) \n;    \n /* print the longest input line * \n/  \nmain( \n)  {    \nint len; /* current line length * \n/  \nint max; /* maximum length seen so far * \n/  \nchar line[maxline]; /* current input line * \n/  \nchar longest[maxline]; /* longest line saved here *  \n/     \nmax = 0;  \nwhile ((len = getline(line, maxline)) > 0)    \n if (len > max)  {  \nmax = len;  \ncopy(longest, line) \n;    }  \nif (max > 0) /* there was a line * \n/  \nprintf("%s", longest) \n;  \nreturn 0;\n\n}     \n /* getline: read a line into s, return length * \n/  \nint getline(char s[],int lim)  {    \nint c, i;   \n for (i=0; i < lim-1 && (c=getchar())!=eof && c!=''\\n''; ++i)  \ns[i] = c;   \n if (c == ''\\n'')  {  \ns[i] = c;  \n++i;   }  \ns[i] = ''\\0'' \n;  \nreturn i;    }    \n /* copy: copy ''from'' into ''to''; assume to is big enough * \n/  \nvoid copy(char to[], char from[] \n)  {    \nint i;   \ni = 0;  \nwhile ((to[i] = from[i]) != ''\\0'')  \n++i; } \nthe functions getline and copy are declared at the beginning of the program, which we  \nassume is contained in one file.   \nmain and getline communicate through a pair of arguments and a returned value. in  \ngetline, the arguments are declared by the line\n\nint getline(char s[], int lim);  \nwhich specifies that the first argument, s, is an array, and the second, lim, is an integer. \nthe  \npurpose of supplying the size of an array in a declaration is to set aside storage. the  \nlength of  \nan array s is not necessary in getline since its size is set in main. getline  uses return to\n\nsend a value back to the caller, just as the function power did. this line also declares that  \ngetline returns an int; since int is the default return type, it could be omitted.   \n \nsome functions return a useful value; others, like copy, are used only for their effect a nd  \nreturn no value. the return type of copy is void, which states explicitly that no value is   \nreturned.   \ngetline puts the character ''\\0'' (the null character, whose value is zero) at t he end of the  \narray it is creating, to mark the end of the string of characters. this conver sion is also \nused by  \nthe c language: when a string constant like   \n "hello\\n"  \nappears in a c program, it is stored as an array of characters containing the cha racters in \nthe  \nstring and terminated with a ''\\0'' to mark the end.    \nthe %s format specification in printf expects the corresponding argument to be a  string  \nrepresented in this form. copy also relies on the fact that its input argument is te rminated \nwith  \na ''\\0'', and copies this character into the output.   \nit is worth mentioning in passing that even a program as small as this one presents  some  \nsticky design problems. for example, what should main do if it encounters a line which is   \nbigger than its limit? getline works safely, in that it stops collecting when the ar ray is full,  \neven if no newline has been seen. by testing the length and the last character retur ned, \nmain  \ncan determine whether the line was too long, and then cope as it wishes. in the interes ts \nof  \nbrevity, we have ignored this issue.   \nthere is no way for a user of getline to know in advance how long an input line might be, \nso  \ngetline checks for overflow. on the other hand, the user of copy already knows (or can \nfind  \nout) how big the strings are, so we have chosen not to add error checking to it.   \nexercise 1-16. revise the main routine of the longest-line program so it will c orrectly \nprint  \nthe length of arbitrary long input lines, and as much as possible of the text.   \nexercise 1-17. write a program to print all input lines that are longer than 80 ch aracters.\n\nexercise 1-18. write a program to remove trailing blanks and tabs from each line of \ninput,   \nand to delete entirely blank lines.   \nexercise 1-19. write a function reverse(s) that reverses the charact er string s. use it to  \nwrite a program that reverses its input a line at a time.   \n1.10 external variables and scope  \nthe variables in main, such as line, longest, etc., are private or local to main. be cause \nthey  \nare declared within main, no other function can have direct access to them. the same  is \ntrue  \nof the variables in other functions; for example, the variable i in getline is unrel ated to the \ni\n\nin copy. each local variable in a function comes into existence only when the function is  \ncalled, and disappears when the function is exited. this is why such variables are usually  \nknown as automatic variables, following terminology in other languages. we will use the   \nterm automatic henceforth to refer to these local variables. (chapte r 4 discusses the static  \nstorage class, in which local variables do retain their values between call s.)  \n \nbecause automatic variables come and go with function invocation, they do not retain \ntheir  \nvalues from one call to the next, and must be explicitly set upon each entry. if they are \nnot set,  \nthey will contain garbage.   \nas an alternative to automatic variables, it is possible to define vari ables that are external \nto  \nall functions, that is, variables that can be accessed by name by any function. (this  \nmechanism is rather like fortran common or pascal variables declared  in the outermost  \nblock.) because external variables are globally accessible, they can be used ins tead of  \nargument lists to communicate data between functions. furthermore, because exter nal  \nvariables remain in existence permanently, rather than appearing and disappear ing as  \nfunctions are called and exited, they retain their values even after the functi ons that set \nthem  \nhave returned.   \nan external variable must be defined, exactly once, outside of any function; this se ts \naside   \nstorage for it. the variable must also be declared in each function that wants to acc ess it; \nthis   \nstates the type of the variable. the declaration may be an explicit extern sta tement or may \nbe  \nimplicit from context. to make the discussion concrete, let us rewrite the l ongest-line  \nprogram with line, longest, and max as external variables. this requires changing the \ncalls,  \ndeclarations, and bodies of all three functions.   \n #include <stdio.h>  \n#define maxline 1000 /* maximum input line size */  \nint max;  \nchar line[maxline];  \n/* maximum length seen so far */  \n/* current input line */   \n char longest[maxline]; /* longest line saved here */   \n int getline(void) \n;\n\nvoid copy(void)  \n;    \n /* print longest input line; specialized version * \n/  \nmain( \n)  {    \nint len;  \nextern int max;  \nextern char longest[] \n;   \n max = 0;  \nwhile ((len = getline()) > 0)    \n if (len > max)  {  \nmax = len;  \ncopy() \n;      }  \nif (max > 0) /* there was a line */  \nprintf("%s", longest);  \nreturn 0; }\n\n/* getline: specialized version */   \n int getline(void)   {   \nint c, i;  \n extern char line[];   \n for (i = 0; i < maxline - 1   \n && (c=getchar)) != eof && c != ''\\n''; ++i)  \n line[i] = c;   \n if (c == ''\\n'') {   \n line[i] = c;   \n++i;  }  \n line[i] = ''\\0'';     \nreturn i;  }   \n /* copy: specialized version */   \n void copy(void)   {   \nint i;  \n extern char line[], longest[];   \ni = 0;  \nwhile ((longest[i] = line[i]) != ''\\0'')  \n++i; }\n\nthe external variables in main, getline and copy are defined by the first lines of the \nexample   \nabove, which state their type and cause storage to be allocated for them. syntacti cally,  \nexternal definitions are just like definitions of local variables, but sinc e they occur outside \nof  \nfunctions, the variables are external. before a function can use an external varia ble, the \nname  \nof the variable must be made known to the function; the declaration is the same as be fore  \nexcept for the added keyword extern.   \nin certain circumstances, the extern declaration can be omitted. if the defini tion of the  \nexternal variable occurs in the source file before its use in a particular func tion, then there \nis  \nno need for an extern declaration in the function. the extern declarations in main, getli ne  \nand copy are thus redundant. in fact, common practice is to place definitions of all \nexternal  \nvariables at the beginning of the source file, and then omit all extern declarati ons.  \n \nif the program is in several source files, and a variable is defined in file1 and used i n file2 \nand  \nfile3, then extern declarations are needed in file2 and file3 to connect the occurr ences of \nthe  \nvariable. the usual practice is to collect extern declarations of variab les and functions in \na  \nseparate file, historically called a header, that is included by #include at t he front of each  \nsource file. the suffix .h is conventional for header names. the functions of the standar d  \nlibrary, for example, are declared in headers like <stdio.h>. this topic is discus sed at \nlength  \nin chapter 4, and the library itself in chapter 7 and appendix b.   \nsince the specialized versions of getline and copy have no arguments, logic would \nsuggest  \nthat their prototypes at the beginning of the file should be getline() and copy(). but for   \ncompatibility with older c programs the standard takes an empty list as an old -style  \ndeclaration, and turns off all argument list checking; the word void must be used for an  \nexplicitly empty list. we will discuss this further in chapter 4.   \nyou should note that we are using the words definition and declaration carefully when we   \nrefer to external variables in this section.``definition'''' refers to the pla ce where the \nvariable is\n\ncreated or assigned storage; ``declaration'''' refers to places where the nature of the \nvariable is  \nstated but no storage is allocated.   \nby the way, there is a tendency to make everything in sight an extern variable beca use it  \nappears to simplify communications - argument lists are short and variables are  always \nthere  \nwhen you want them. but external variables are always there even when you don''t want \nthem.  \nrelying too heavily on external variables is fraught with peril since it leads t o programs  \nwhose data connections are not all obvious - variables can be changed in unexpected and \neven  \ninadvertent ways, and the program is hard to modify. the second version of the longest-\nline  \nprogram is inferior to the first, partly for these reasons, and partly because it  destroys the  \ngenerality of two useful functions by writing into them the names of the variables  they  \nmanipulate.   \nat this point we have covered what might be called the conventional core of c. with t his  \nhandful of building blocks, it''s possible to write useful programs of considerable size , and \nit  \nwould probably be a good idea if you paused long enough to do so. these exercises \nsuggest  \nprograms of somewhat greater complexity than the ones earlier in this chapter.   \n  \nexercise 1-20. write a program detab that replaces tabs in the input with the  proper \nnumber   \nof blanks to space to the next tab stop. assume a fixed set of tab stops, say every n \ncolumns.  \nshould n be a variable or a symbolic parameter?   \nexercise 1-21. write a program entab that replaces strings of blanks by the minimu m  \nnumber of tabs and blanks to achieve the same spacing. use the same tab stops as for \ndetab.  \nwhen either a tab or a single blank would suffice to reach a tab stop, which should be \ngiven  \npreference?   \nexercise 1-22. write a program to ``fold'''' long input lines into two or more shorter l ines \nafter  \nthe last non-blank character that occurs before the n-th column of input. make sure your   \nprogram does something intelligent with very long lines, and if there are no blanks or ta bs  \nbefore the specified column.\n\nexercise 1-23. write a program to remove all comments from a c program. don''t forget \nto   \nhandle quoted strings and character constants properly. c comments don''t nest.   \nexercise 1-24. write a program to check a c program for rudimentary syntax errors l ike  \nunmatched parentheses, brackets and braces. don''t forget about quotes, both single and   \ndouble, escape sequences, and comments. (this program is hard if you do it in full  \ngenerality.)\n\nchapter 2 - types, operators and  \nexpressions   \nvariables and constants are the basic data objects manipulated in a program. declarations \nlist  \nthe variables to be used, and state what type they have and perhaps what their initial  \nvalues  \nare. operators specify what is to be done to them. expressions combine variables and   \nconstants to produce new values. the type of an object determines the set of values it c an  \nhave and what operations can be performed on it. these building blocks are the topics of \nthis  \nchapter.   \nthe ansi standard has made many small changes and additions to basic types and  \nexpressions. there are now signed and unsigned forms of all integer types, and notations \nfor  \nunsigned constants and hexadecimal character constants. floating-point operat ions may \nbe  \ndone in single precision; there is also a long double type for extended precision. string  \nconstants may be concatenated at compile time. enumerations have become part of  the  \nlanguage, formalizing a feature of long standing. objects may be declared const, which   \nprevents them from being changed. the rules for automatic coercions among arithm etic \ntypes  \nhave been augmented to handle the richer set of types.    \n2.1 variable names   \nalthough we didn''t say so in chapter 1, there are some restrictions on the names of \nvariables  \nand symbolic constants. names are made up of letters and digits; the first c haracter must \nbe a  \nletter. the underscore ``_'''' counts as a letter; it is sometimes useful for i mproving the  \nreadability of long variable names. don''t begin variable names with underscore, howeve r,  \nsince library routines often use such names. upper and lower case letters a re distinct, so x \nand  \nx are two different names. traditional c practice is to use lower case for  variable names, \nand  \nall upper case for symbolic constants.   \nat least the first 31 characters of an internal name are significant. for funct ion names and  \nexternal variables, the number may be less than 31, because external names may be  used \nby  \nassemblers and loaders over which the language has no control. for external names, the   \nstandard guarantees uniqueness only for 6 characters and a single case. keywords like  if,  \nelse, int, float, etc., are reserved: you can''t use them as variable names. t hey must be in  \nlower case.\n\nit''s wise to choose variable names that are related to the purpose of the variable, and that \nare  \nunlikely to get mixed up typographically. we tend to use short names for local variables,  \nespecially loop indices, and longer names for external variables.   \n2.2 data types and sizes  \nthere are only a few basic data types in c:   \nchar a single byte, capable of holding one character in the local character set   \nint an integer, typically reflecting the natural size of integers on the host mac hine  \n \nfloat single-precision floating point\n\ndouble double-precision floating point   \nin addition, there are a number of qualifiers that can be applied to these basic types. short  \nand long apply to integers:   \n short int sh;   \n long int counter;  \nthe word int can be omitted in such declarations, and typically it is.   \nthe intent is that short and long should provide different lengths of integers where \npractical;  \nint will normally be the natural size for a particular machine. short is often 16 bi ts long, \nand  \nint either 16 or 32 bits. each compiler is free to choose appropriate sizes for its ow n  \nhardware, subject only to the the restriction that shorts and ints are at leas t 16 bits, longs \nare  \nat least 32 bits, and short is no longer than int, which is no longer than long.   \nthe qualifier signed or unsigned may be applied to char or any integer. unsigned numbers  \nare always positive or zero, and obey the laws of arithmetic modulo 2n, where n is the \nnumber  \nof bits in the type. so, for instance, if chars are 8 bits, unsigned char variables have \nvalues  \nbetween 0 and 255, while signed chars have values between -128 and 127 (in a two''s   \ncomplement machine.) whether plain chars are signed or unsigned is machine-depe ndent,  \nbut printable characters are always positive.    \nthe type long double specifies extended-precision floating point. as with integers, the  \nsizes  \nof floating-point objects are implementation-defined; float, double and long double could  \nrepresent one, two or three distinct sizes.   \nthe standard headers <limits.h> and <float.h> contain symbolic constants for all of  these  \nsizes, along with other properties of the machine and compiler. these are discusse d in  \nappendix b.   \nexercise 2-1. write a program to determine the ranges of char, short, int, and \nlongvariables, both signed and unsigned, by printing appropriate values from standard \nheaders  \nand by direct computation. harder if you compute them: determine the ranges of the \nvarious  \nfloating-point types.   \n2.3 constants\n\nan integer constant like 1234 is an int. a long constant is written with a terminal l (ell) or  \nl, as in 123456789l; an integer constant too big to fit into an int will also be taken as a  \nlong.  \nunsigned constants are written with a terminal u or u, and the suffix ul or ul indi cates  \nunsigned long.   \nfloating-point constants contain a decimal point (123.4) or an exponent (1e-2) or both; \ntheir  \ntype is double, unless suffixed. the suffixes f or f indicate a float constant; l or l  \nindicate  \na long double.   \nthe value of an integer can be specified in octal or hexadecimal instead of decimal. a  \nleading  \n0 (zero) on an integer constant means octal; a leading 0x or 0x means hexadecimal. for   \nexample, decimal 31 can be written as 037 in octal and 0x1f or 0x1f in hex. octal and\n\nhexadecimal constants may also be followed by l to make them long and u to make \nthem  \nunsigned: 0xful is an unsigned long constant with value 15 decimal.   \na character constant is an integer, written as one character within single quotes, such as  \n''x''. the value of a character constant is the numeric value of the character i n the \nmachine''s  \ncharacter set. for example, in the ascii character set the character cons tant ''0'' has the \nvalue  \n48, which is unrelated to the numeric value 0. if we write ''0'' instead of a numeric value  \nlike  \n48 that depends on the character set, the program is independent of the particular value  \nand  \neasier to read. character constants participate in numeric operations  just as any other \nintegers,  \nalthough they are most often used in comparisons with other characters.   \ncertain characters can be represented in character and string constants by  escape \nsequences  \nlike \\n (newline); these sequences look like two characters, but represent  only one. in  \naddition, an arbitrary byte-sized bit pattern can be specified by  \n ''\\ooo''   \nwhere ooo is one to three octal digits (0...7) or by    \n ''\\xhh''  \nwhere hh is one or more hexadecimal digits (0...9, a...f, a...f). so we might write   \n #define vtab ''\\013'' /* ascii vertical tab * \n/  \n#define bell ''\\007'' /* ascii bell character * \n/    \nor, in hexadecimal,   \n #define vtab ''\\xb'' /* ascii vertical tab * \n/  \n#define bell ''\\x7'' /* ascii bell character * \n/    \nthe complete set of escape sequences is\n\n\\a alert (bell) character \\\\ backslash   \n\\b backspace \\? question mark  \n\\f formfeed \\'' single quote  \n\\n newline \\" double quote  \n\\r carriage return \\ooo octal number  \n\\t horizontal tab \\xhh hexadecimal number  \n\\v vertical tab  \nthe character constant ''\\0'' represents the character with value zero, the null character. ''\\0''  \nis often written instead of 0 to emphasize the character nature of some expres sion, but the  \nnumeric value is just 0.   \na constant expression is an expression that involves only constants. such expressions  \nmay be  \nevaluated at during compilation rather than run-time, and accordingly may be used in any  \nplace that a constant can occur, as in   \n #define maxline 1000  \nchar line[maxline+1] \n;    \nor   \n #define leap 1 /* in leap years * \n/  \nint days[31+28+leap+31+30+31+30+31+31+30+31+30+31]  \n;\n\na string constant, or string literal, is a sequence of zero or more characters surrounded by  \ndouble quotes, as in   \n "i am a string"   \nor   \n "" /* the empty string */  \nthe quotes are not part of the string, but serve only to delimit it. the same escape \nsequences  \nused in character constants apply in strings; \\" represents the double-quote char acter. \nstring  \nconstants can be concatenated at compile time:  \n "hello, " "world"   \nis equivalent to   \n "hello, world"   \nthis is useful for splitting up long strings across several source lines.   \ntechnically, a string constant is an array of characters. the internal rep resentation of a \nstring  \nhas a null character ''\\0'' at the end, so the physical storage required is one mor e than the  \nnumber of characters written between the quotes. this representation means that  there is \nno  \nlimit to how long a string can be, but programs must scan a string completely to \ndetermine its  \nlength. the standard library function strlen(s) returns the length of its chara cter string  \nargument s, excluding the terminal ''\\0''. here is our version:   \n /* strlen: return length of s */   \n int strlen(char s[])   {   \nint i;   \n while (s[i] != ''\\0'')  \n++i; \nreturn i; } \nstrlen and other string functions are declared in the standard header <string.h> .\n\nbe careful to distinguish between a character constant and a string that contains a single  \ncharacter: ''x'' is not the same as "x". the former is an integer, used to produce the  numeric  \nvalue of the letter x in the machine''s character set. the latter is an a rray of characters that  \ncontains one character (the letter x) and a ''\\0''.   \nthere is one other kind of constant, the enumeration constant. an enumeration is a lis t of  \nconstant integer values, as in   \n enum boolean { no, yes };  \nthe first name in an enum has value 0, the next 1, and so on, unless explicit values are  \nspecified. if not all values are specified, unspecified values continue the progre ssion from \nthe  \nlast specified value, as the second of these examples:  \n enum escapes { bell = ''\\a'', backspace = ''\\b'', tab = ''\\t'' ,  \nnewline = ''\\n'', vtab = ''\\v'', return = ''\\r'' } \n;    \n enum months { jan = 1, feb, mar, apr, may, jun,  \njul, aug, sep, oct, nov, dec } \n;  \n/* feb = 2, mar = 3, etc. * \n/\n\nnames in different enumerations must be distinct. values need not be distinct in the same  \nenumeration.   \nenumerations provide a convenient way to associate constant values with names , an  \nalternative to #define with the advantage that the values can be generated for  you. \nalthough  \nvariables of enum types may be declared, compilers need not check that what you store i n  \nsuch a variable is a valid value for the enumeration. nevertheless, enumeration va riables \noffer  \nthe chance of checking and so are often better than #defines. in addition, a debugger may \nbe  \nable to print values of enumeration variables in their symbolic form.   \n2.4 declarations  \nall variables must be declared before use, although certain declarations can be ma de  \nimplicitly by content. a declaration specifies a type, and contains a list of one  or more  \nvariables of that type, as in   \n int lower, upper, step;  \nchar c, line[1000] \n;    \nvariables can be distributed among declarations in any fashion; the lists above could  well \nbe   \nwritten as   \n int lower;  \nint upper;  \nint step;  \nchar c;  \nchar line[1000] \n;    \nthe latter form takes more space, but is convenient for adding a comment to each \ndeclaration  \nfor subsequent modifications.   \na variable may also be initialized in its declaration. if the name is followe d by an equals \nsign  \nand an expression, the expression serves as an initializer, as in  \n char esc = ''\\\\'' \n;\n\nint i = 0;   \nint limit = maxline+1;  \nfloat eps = 1.0e-5;    \nif the variable in question is not automatic, the initialization is done once only, \nconceptionally  \nbefore the program starts executing, and the initializer must be a constant expression. an  \nexplicitly initialized automatic variable is initialized each tim e the function or block it is \nin is  \nentered; the initializer may be any expression. external and static variabl es are initialized \nto  \nzero by default. automatic variables for which is no explicit initializer have  undefined \n(i.e.,  \ngarbage) values.   \nthe qualifier const can be applied to the declaration of any variable to specify that  its \nvalue  \nwill not be changed. for an array, the const qualifier says that the elements will  not be  \naltered.   \n const double e = 2.71828182845905;   \n const char msg[] = "warning: ";  \nthe const declaration can also be used with array arguments, to indicate that the func tion  \ndoes not change that array:    \n int strlen(const char[]);\n\nthe result is implementation-defined if an attempt is made to change a const.   \n2.5 arithmetic operators  \nthe binary arithmetic operators are +, -, *, /, and the modulus operator %. integer \ndivision  \ntruncates any fractional part. the expression   \n x % y  \nproduces the remainder when x is divided by y, and thus is zero when y divides x exactly. \nfor  \nexample, a year is a leap year if it is divisible by 4 but not by 100, except that years \ndivisible  \nby 400 are leap years. therefore   \n if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)  \nprintf("%d is a leap year\\n", year);  \nelse  \nprintf("%d is not a leap year\\n", year);  \nthe % operator cannot be applied to a float or double. the direction of truncation for / \nand  \nthe sign of the result for % are machine-dependent for negative operands, as is the action \ntaken  \non overflow or underflow.   \nthe binary + and - operators have the same precedence, which is lower than the  \nprecedence   \nof *, / and %, which is in turn lower than unary + and -. arithmetic operators associate \nleft to  \nright.   \ntable 2.1 at the end of this chapter summarizes precedence and associativi ty for all \noperators.   \n2.6 relational and logical operators  \nthe relational operators are   \n> >= < <=   \nthey all have the same precedence. just below them in precedence are the equalit y \noperators:  \n == !=  \nrelational operators have lower precedence than arithmetic operators , so an expression \nlike i  \n< lim-1 is taken as i < (lim-1), as would be expected.\n\nmore interesting are the logical operators && and ||. expressions connected by && or || \nare  \nevaluated left to right, and evaluation stops as soon as the truth or falsehood of the re sult \nis  \nknown. most c programs rely on these properties. for example, here is a loop from the \ninput  \nfunction getline that we wrote in chapter 1:   \n for (i=0; i < lim-1 && (c=getchar()) != ''\\n'' && c != eof; ++i) \ns[i] = c;   \nbefore reading a new character it is necessary to check that there is room t o store it in the  \narray s, so the test i < lim-1 must be made first. moreover, if this test f ails, we must not \ngo  \non and read another character.   \nsimilarly, it would be unfortunate if c were tested against eof before getchar i s called;  \ntherefore the call and assignment must occur before the character in c i s tested.\n\nthe precedence of && is higher than that of ||, and both are lower than relational and \nequality  \noperators, so expressions like  \n i < lim-1 && (c=getchar()) != ''\\n'' && c != eof  \nneed no extra parentheses. but since the precedence of != is higher than assignment,  \nparentheses are needed in  \n (c=getchar()) != ''\\n''  \nto achieve the desired result of assignment to c and then comparison with ''\\n''.   \nby definition, the numeric value of a relational or logical expression is 1 if the rela tion is \ntrue,  \nand 0 if the relation is false.   \nthe unary negation operator ! converts a non-zero operand into 0, and a zero operand in \n1. a  \ncommon use of ! is in constructions like   \n if (!valid)   \nrather than   \n if (valid == 0) \nit''s hard to generalize about which form is better. constructions like !vali d read nicely \n(``if  \nnot valid''''), but more complicated ones can be hard to understand.   \nexercise 2-2. write a loop equivalent to the for loop above without using && or ||.   \n2.7 type conversions  \nwhen an operator has operands of different types, they are converted to a common type  \naccording to a small number of rules. in general, the only automatic conversions are t hose \nthat  \nconvert a ``narrower'''' operand into a ``wider'''' one without losing information, s uch as  \nconverting an integer into floating point in an expression like f + i. expressions that  don''t  \nmake sense, like using a float as a subscript, are disallowed. expressions tha t might lose  \ninformation, like assigning a longer integer type to a shorter, or a floating-point type  to an  \ninteger, may draw a warning, but they are not illegal.   \na char is just a small integer, so chars may be freely used in arithmetic ex pressions. this  \npermits considerable flexibility in certain kinds of character transfor mations. one is  \nexemplified by this naive implementation of the function atoi, which converts a string of   \ndigits into its numeric equivalent.\n\n/* atoi: convert s to integer */    \n int atoi(char s[])   {   \nint i, n;   \nn = 0;  \nfor (i = 0; s[i] >= ''0'' && s[i] <= ''9''; ++i)  \nn = 10 * n + (s[i] - ''0'') \n;  \nreturn n; }   \nas we discussed in chapter 1, the expression\n\ns[i] - ''0''  \ngives the numeric value of the character stored in s[i], because the values of ''0'', ''1'', etc.,  \nform a contiguous increasing sequence.   \nanother example of char to int conversion is the function lower, which maps a single  \ncharacter to lower case for the ascii character set. if the characte r is not an upper case \nletter,  \nlower returns it unchanged.   \n /* lower: convert c to lower case; ascii only */   \n int lower(int c)   {   \n if (c >= ''a'' && c <= ''z'')   \n return c + ''a'' - ''a'';   \nelse   \n return c;   } \nthis works for ascii because corresponding upper case and lower case letters are  a fixed  \ndistance apart as numeric values and each alphabet is contiguous -- there  is nothing but \nletters  \nbetween a and z. this latter observation is not true of the ebcdic character se t, \nhowever, so  \nthis code would convert more than just letters in ebcdic.   \nthe standard header <ctype.h>, described in appendix b, defines a family of functions \nthat  \nprovide tests and conversions that are independent of character set. for example, the  \nfunction  \ntolower is a portable replacement for the function lower shown above. similarl y, the test \n \n c >= ''0'' && c <= ''9''   \ncan be replaced by  \n isdigit(c)  \nwe will use the <ctype.h> functions from now on.\n\nthere is one subtle point about the conversion of characters to integers. the language  \ndoes  \nnot specify whether variables of type char are signed or unsigned quantities. when a char \nis  \nconverted to an int, can it ever produce a negative integer? the answer varies from \nmachine  \nto machine, reflecting differences in architecture. on some machines a c har whose \nleftmost  \nbit is 1 will be converted to a negative integer (``sign extension''''). on others, a cha r is  \npromoted to an int by adding zeros at the left end, and thus is always positive.   \nthe definition of c guarantees that any character in the machine''s standard printing \ncharacter  \nset will never be negative, so these characters will always be positive quant ities in  \nexpressions. but arbitrary bit patterns stored in character variables may appe ar to be \nnegative  \non some machines, yet positive on others. for portability, specify signed or unsigned if \nnon- \ncharacter data is to be stored in char variables.   \nrelational expressions like i > j and logical expressions connected by && and || are  \ndefined  \nto have value 1 if true, and 0 if false. thus the assignment   \n d = c >= ''0'' && c <= ''9''  \nsets d to 1 if c is a digit, and 0 if not. however, functions like isdigit may return any  \nnonzero value for true. in the test part of if, while, for, etc., ``true'''' just means ``non -\nzero'''', so   \nthis makes no difference.\n\nimplicit arithmetic conversions work much as expected. in general, if an operator like + \nor *  \nthat takes two operands (a binary operator) has operands of different types, the ``l ower'''' \ntype  \nis promoted to the ``higher'''' type before the operation proceeds. the result is of th e \ninteger  \ntype. section 6 of appendix a states the conversion rules precisely. if there are no \nunsigned  \noperands, however, the following informal set of rules will suffice:   \n•  \nif either operand is long double, convert the other to long double.  \n•  \notherwise, if either operand is double, convert the other to double.  \n•  \notherwise, if either operand is float, convert the other to float.  \n•  \notherwise, convert char and short to int.  \n•  \nthen, if either operand is long, convert the other to long.  \nnotice that floats in an expression are not automatically converted to double;  this is a  \nchange from the original definition. in general, mathematical functions like those  in \n<math.h>  \nwill use double precision. the main reason for using float is to save storage in la rge \narrays,   \nor, less often, to save time on machines where double-precision arithmetic is pa rticularly  \nexpensive.    \nconversion rules are more complicated when unsigned operands are involved. the \nproblem  \nis that comparisons between signed and unsigned values are machine-dependent, because  \nthey  \ndepend on the sizes of the various integer types. for example, suppose that int is 16 bits \nand  \nlong is 32 bits. then -1l < 1u, because 1u, which is an unsigned int, is promoted to a  \nsigned long. but -1l > 1ul because -1l is promoted to unsigned long and thus appears  \nto be a large positive number.   \nconversions take place across assignments; the value of the right side is converted  to the \ntype  \nof the left, which is the type of the result.   \na character is converted to an integer, either by sign extension or not, as describe d above.\n\nlonger integers are converted to shorter ones or to chars by dropping the excess high- \norder  \nbits. thus in  \n int i;  \nchar c;    \n i = c;   \n c = i;  \nthe value of c is unchanged. this is true whether or not sign extension is involved. \nreversing  \nthe order of assignments might lose information, however.   \nif x is float and i is int, then x =i and i =x both cause conversions; float to int  \ncauses truncation of any fractional part. when a double is converted to float, whether the  \nvalue is rounded or truncated is implementation dependent.   \nsince an argument of a function call is an expression, type conversion also takes plac e \nwhen  \narguments are passed to functions. in the absence of a function prototype, char and short   \nbecome int, and float becomes double. this is why we have declared function arguments \nto  \nbe int and double even when the function is called with char and float.    \nfinally, explicit type conversions can be forced (``coerced'''') in any expression, wi th a \nunary   \noperator called a cast. in the construction\n\n(type name) expression   \nthe expression is converted to the named type by the conversion rules above. the precise  \nmeaning of a cast is as if the expression were assigned to a variable of the specified type,  \nwhich is then used in place of the whole construction. for example, the library routine \nsqrtexpects a double argument, and will produce nonsense if inadvertently handled \nsomething  \nelse. (sqrt is declared in <math.h>.) so if n is an integer, we can use   \n sqrt((double) n)  \nto convert the value of n to double before passing it to sqrt. note that the cast produces \nthe  \nvalue of n in the proper type; n itself is not altered. the cast operator has the sam e high  \nprecedence as other unary operators, as summarized in the table at the end of t his chapter.  \n \nif arguments are declared by a function prototype, as the normally should be, the \ndeclaration  \ncauses automatic coercion of any arguments when the function is called. thus, given a   \nfunction prototype for sqrt:   \n double sqrt(double)   \nthe call   \n root2 = sqrt(2)   \ncoerces the integer 2 into the double value 2.0 without any need for a cast.    \nthe standard library includes a portable implementation of a pseudo-random number  \ngenerator and a function for initializing the seed; the former illustrates a  cast:  \n \n unsigned long int next = 1;  \n /* rand: return pseudo-random integer on 0..32767 */   \n int rand(void)  {   \n next = next * 1103515245 + 12345;   \n return (unsigned int)(next/65536) % 32768;   }   \n /* srand: set seed for rand() *\n\n/   \nvoid srand(unsigned int seed)  {    \n next = seed;  } \nexercise 2-3. write a function htoi(s), which converts a string of hexadecimal digits  \n(including an optional 0x or 0x) into its equivalent integer value. the allowable digits ar e \n0  \nthrough 9, a through f, and a through f.   \n2.8 increment and decrement operators  \nc provides two unusual operators for incrementing and decrementing variables. the  \nincrement operator ++ adds 1 to its operand, while the decrement operator -- subtrac ts 1. \nwe  \nhave frequently used ++ to increment variables, as in   \n if (c == ''\\n'' \n) \n++nl;\n\nthe unusual aspect is that ++ and -- may be used either as prefix operators (before the  \nvariable, as in ++n), or postfix operators (after the variable: n++). in both ca ses, the effect \nis to  \nincrement n. but the expression ++n increments n before its value is used, while n+ +  \nincrements n after its value has been used. this means that in a context where t he value is  \nbeing used, not just the effect, ++n and n++ are different. if n is 5, then  \n x = n++;  \nsets x to 5, but   \n x = ++n;  \nsets x to 6. in both cases, n becomes 6. the increment and decrement operators can only \nbe  \napplied to variables; an expression like (i+j)++ is illegal.   \nin a context where no value is wanted, just the incrementing effect, as in   \n if (c == ''\\n'' \n) \nnl++ \n;    \nprefix and postfix are the same. but there are situations where one or the other  is \nspecifically   \ncalled for. for instance, consider the function squeeze(s,c), which removes all  \noccurrences  \nof the character c from the string s.   \n /* squeeze: delete all c from s * \n/  \nvoid squeeze(char s[], int c)  {    \nint i, j;   \n for (i = j = 0; s[i] != ''\\0''; i++)  \nif (s[i] != c)  \ns[j++] = s[i];  \ns[j] = ''\\0'';  } \neach time a non-c occurs, it is copied into the current j position, and only then is \njincremented to be ready for the next character. this is exactly equivalent to\n\nif (s[i] != c)   {  \ns[j] = s[i] \n;  \nj++ \n;   } \nanother example of a similar construction comes from the getline function that we wrote \nin  \nchapter 1, where we can replace   \n if (c == ''\\n'')  {  \ns[i] = c; \n++i;   }  \nby the more compact  \n if (c == ''\\n'') \ns[i++] = c; \nas a third example, consider the standard function strcat(s,t), which concatenates  the  \nstring t to the end of string s. strcat assumes that there is enough space in s to hol d the  \ncombination. as we have written it, strcat returns no value; the standard library ve rsion  \nreturns a pointer to the resulting string.   \n /* strcat: concatenate t to end of s; s must be big enough * \n/  \nvoid strcat(char s[], char t[] \n)  {\n\nint i, j;   \ni = j = 0;  \nwhile (s[i] != ''\\0'') /* find end of s */  \ni++;  \nwhile ((s[i++] = t[j++]) != ''\\0'') /* copy t */ \n; } \nas each member is copied from t to s, the postfix ++ is applied to both i and j to make \nsure  \nthat they are in position for the next pass through the loop.   \nexercise 2-4. write an alternative version of squeeze(s1,s2) that deletes each character in  \ns1 that matches any character in the string s2.   \nexercise 2-5. write the function any(s1,s2), which returns the first location i n a string s1  \nwhere any character from the string s2 occurs, or -1 if s1 contains no characters fr om s2.  \n(the standard library function strpbrk does the same job but returns a pointer to the  \nlocation.)   \n2.9 bitwise operators  \nc provides six operators for bit manipulation; these may only be applied to integral \noperands,  \nthat is, char, short, int, and long, whether signed or unsigned.    \n& bitwise and    \n| bitwise inclusive or   \n^ bitwise exclusive or   \n<< left shift   \n>> right shift   \n~ one''s complement (unary)   \nthe bitwise and operator & is often used to mask off some set of bits, for example   \n \n n = n & 0177;  \nsets to zero all but the low-order 7 bits of n.   \nthe bitwise or operator | is used to turn bits on:   \n x = x | set_on;\n\nsets to one in x the bits that are set to one in set_on.    \nthe bitwise exclusive or operator ^ sets a one in each bit position where its operands \nhave  \ndifferent bits, and zero where they are the same.   \none must distinguish the bitwise operators & and | from the logical operators && a nd ||,  \nwhich imply left-to-right evaluation of a truth value. for example, if x is 1 and y is 2, \nthen x  \n& y is zero while x && y is one.   \nthe shift operators << and >> perform left and right shifts of their left operand by t he \nnumber  \nof bit positions given by the right operand, which must be non-negative. thus x << 2 \nshifts  \nthe value of x by two positions, filling vacated bits with zero; this is equivalent  to\n\nmultiplication by 4. right shifting an unsigned quantity always fits the vacated bits with  \nzero. right shifting a signed quantity will fill with bit signs (``arithmetic  shift'''') on some  \nmachines and with 0-bits (``logical shift'''') on others.   \nthe unary operator ~ yields the one''s complement of an integer; that is, it conve rts each \n1-bit  \ninto a 0-bit and vice versa. for example   \n x = x & ~077  \nsets the last six bits of x to zero. note that x & ~077 is independent of word length, and is  \nthus preferable to, for example, x & 0177700, which assumes that x is a 16-bit quantity. \nthe  \nportable form involves no extra cost, since ~077 is a constant expression that can be \nevaluated  \nat compile time.   \nas an illustration of some of the bit operators, consider the function getbits(x,p,n) th at  \nreturns the (right adjusted) n-bit field of x that begins at position p. we assume t hat bit  \nposition 0 is at the right end and that n and p are sensible positive values. for example ,  \ngetbits(x,4,3) returns the three bits in positions 4, 3 and 2, right-adjusted.   \n /* getbits: get n bits from position p * \n/  \nunsigned getbits(unsigned x, int p, int n)  {      \n return (x >> (p+1-n)) & ~(~0 << n); } \nthe expression x >> (p+1-n) moves the desired field to the right end of the word. ~0 is all  \n1-bits; shifting it left n positions with ~0<<n places zeros in the rightmost n bits;   \ncomplementing that with ~ makes a mask with ones in the rightmost n bits.   \nexercise 2-6. write a function setbits(x,p,n,y) that returns x with the n bits that begi n at  \nposition p set to the rightmost n bits of y, leaving the other bits unchanged.   \nexercise 2-7. write a function invert(x,p,n) that returns x with the n bits that begin  at  \nposition p inverted (i.e., 1 changed into 0 and vice versa), leaving the others unchanged.   \nexercise 2-8. write a function rightrot(x,n) that returns the value of the inte ger x rotated  \nto the right by n positions.   \n2.10 assignment operators and expressions  \nan expression such as\n\ni = i + 2   \nin which the variable on the left side is repeated immediately on the right, can be written \nin  \nthe compressed form  \n i += 2  \nthe operator += is called an assignment operator.   \nmost binary operators (operators like + that have a left and right operand) ha ve a  \ncorresponding assignment operator op=, where op is one of   \n+ -* / % << >> & ^ |\n\nif expr1 and expr2 are expressions, then   \nexpr1 op= expr2   \nis equivalent to   \nexpr1 = (expr1) op (expr2)  \nexcept that expr1 is computed only once. notice the parentheses around expr2:   \n x *= y + 1   \nmeans  \n x = x * (y + 1)  \nrather than   \n x = x * y + 1  \nas an example, the function bitcount counts the number of 1-bits in its integer argument.   \n /* bitcount: count 1 bits in x */   \n int bitcount(unsigned x)    {    \nint b;   \n for (b = 0; x != 0; x >>= 1)  \nif (x & 01)  \nb++;  \nreturn b; } \ndeclaring the argument x to be an unsigned ensures that when it is right-shifted, vacated \nbits  \nwill be filled with zeros, not sign bits, regardless of the machine the program  is run on.  \n \nquite apart from conciseness, assignment operators have the advantage that the y \ncorrespond  \nbetter to the way people think. we say ``add 2 to i'''' or ``increment i by 2'''', not ``take i, \nadd  \n2, then put the result back in i''''. thus the expression i += 2 is preferable to i = i+2. in  \naddition, for a complicated expression like\n\nyyval[yypv[p3+p4] + yypv[p1]] += 2   \nthe assignment operator makes the code easier to understand, since the reader doesn''t \nhave to  \ncheck painstakingly that two long expressions are indeed the same, or to wonder why \nthey''re  \nnot. and an assignment operator may even help a compiler to produce efficient code.   \nwe have already seen that the assignment statement has a value and can occur i n \nexpressions;  \nthe most common example is   \n while ((c = getchar()) != eof)  ...  \nthe other assignment operators (+=, -=, etc.) can also occur in expressions, alt hough this \nis  \nless frequent.   \nin all such expressions, the type of an assignment expression is the type of its left \noperand,  \nand the value is the value after the assignment.   \nexercise 2-9. in a two''s complement number system, x &= (x-1) deletes the rightm ost 1-\nbit  \nin x. explain why. use this observation to write a faster version of bitcount.\n\n2.11 conditional expressions  \nthe statements  \n if (a > b)  \nz = a;  \nelse  \nz = b;  \ncompute in z the maximum of a and b. the conditional expression, written with the \nternary  \noperator ``?:'''', provides an alternate way to write this and similar constructions. in the  \nexpression   \nexpr1 ? expr2 : expr3  \nthe expression expr1 is evaluated first. if it is non-zero (true), then the expre ssion expr2 is  \nevaluated, and that is the value of the conditional expression. otherwise expr3 is \nevaluated,  \nand that is the value. only one of expr2 and expr3 is evaluated. thus to set z to the \nmaximum  \nof a and b,   \n z = (a > b) ? a : b; /* z = max(a, b) */  \nit should be noted that the conditional expression is indeed an expression, and it can be \nused  \nwherever any other expression can be. if expr2 and expr3 are of different types, the type \nof the   \nresult is determined by the conversion rules discussed earlier in this chapter . for \nexample, if f   \nis a float and n an int, then the expression   \n (n > 0) ? f : n  \nis of type float regardless of whether n is positive.   \nparentheses are not necessary around the first expression of a conditional expr ession, \nsince  \nthe precedence of ?: is very low, just above assignment. they are advisable anyway,  \nhowever, since they make the condition part of the expression easier to see.   \nthe conditional expression often leads to succinct code. for example, this loop prints n  \nelements of an array, 10 per line, with each column separated by one blank, and with \neach line  \n(including the last) terminated by a newline.   \n for (i = 0; i < n; i++)  \nprintf("%6d%c", a[i], (i%10==9 || i==n-1) ? ''\\n'' : '' '');  \na newline is printed after every tenth element, and after the n-th. all other el ements are\n\nfollowed by one blank. this might look tricky, but it''s more compact than the equivalent  \nif- \nelse. another good example is   \n printf("you have %d items%s.\\n", n, n==1 ? "" : "s");  \nexercise 2-10. rewrite the function lower, which converts upper case letters to lower \ncase,  \nwith a conditional expression instead of if-else.   \n2.12 precedence and order of evaluation  \ntable 2.1 summarizes the rules for precedence and associativity of all opera tors, \nincluding  \nthose that we have not yet discussed. operators on the same line have the same \nprecedence;  \nrows are in order of decreasing precedence, so, for example, *, /, and % all have the same   \nprecedence, which is higher than that of binary + and -. the ``operator'''' () refe rs to \nfunction  \ncall. the operators -> and . are used to access members of structures; the y will be covered \nin\n\nchapter 6, along with sizeof (size of an object). chapter 5 discusses * (indirection \nthrough a  \npointer) and & (address of an object), and chapter 3 discusses the comma operator.  \n \noperators associativity  \n() [] -> . left to right  \n! ~ ++ -- + - * (type) sizeof right to left  \n* / % left to right  \n+ - left to right  \n<< >> left to right  \n< <= > >= left to right  \n== != left to right  \n& left to right  \n^ left to right  \n| left to right  \n&& left to right  \n|| left to right  \n?: right to left  \n= += -= *= /= %= &= ^= |= <<= >>= right to left  \n, left to right  \nunary & +, -, and * have higher precedence than the binary forms.   \ntable 2.1: precedence and associativity of operators   \nnote that the precedence of the bitwise operators &, ^, and | falls below == a nd !=. this  \nimplies that bit-testing expressions like   \n if ((x & mask) == 0) ...   \nmust be fully parenthesized to give proper results.   \nc, like most languages, does not specify the order in which the operands of an operator \nare  \nevaluated. (the exceptions are &&, ||, ?:, and `,''.) for example, in a statement like  \n \n x = f() + g();  \nf may be evaluated before g or vice versa; thus if either f or g alters a variab le on which \nthe  \nother depends, x can depend on the order of evaluation. intermediate results can be stored \nin  \ntemporary variables to ensure a particular sequence.   \nsimilarly, the order in which function arguments are evaluated is not specified, so t he  \nstatement\n\nprintf("%d %d\\n", ++n, power(2, n)); /* wrong */  \ncan produce different results with different compilers, depending on whether n is \nincremented  \nbefore power is called. the solution, of course, is to write   \n ++n;\n\nprintf("%d %d\\n", n, power(2, n));  \nfunction calls, nested assignment statements, and increment and decrement operators \ncause  \n``side effects'''' - some variable is changed as a by-product of the evaluation of  an \nexpression.  \nin any expression involving side effects, there can be subtle dependencies on the order in   \nwhich variables taking part in the expression are updated. one unhappy situation is \ntypified  \nby the statement   \n a[i] = i++;  \nthe question is whether the subscript is the old value of i or the new. compilers can \ninterpret  \nthis in different ways, and generate different answers depending on their interpr etation. \nthe  \nstandard intentionally leaves most such matters unspecified. when side effec ts \n(assignment to  \nvariables) take place within an expression is left to the discretion of the compi ler, since \nthe  \nbest order depends strongly on machine architecture. (the standard does specify that a ll \nside  \neffects on arguments take effect before a function is called, but that would not he lp in the \ncall  \nto printf above.)    \nthe moral is that writing code that depends on order of evaluation is a bad programming   \npractice in any language. naturally, it is necessary to know what things to avoid, but if  \nyou  \ndon''t know how they are done on various machines, you won''t be tempted to take \nadvantage  \nof a particular implementation.\n\nchapter 3 - control flow   \nthe control-flow of a language specify the order in which computations are performed. \nwe  \nhave already met the most common control-flow constructions in earlier examples; here \nwe  \nwill complete the set, and be more precise about the ones discussed before.   \n3.1 statements and blocks  \nan expression such as x = 0 or i++ or printf(...) becomes a statement when it is  \nfollowed by a semicolon, as in  \n x = 0;  \ni++ \n;  \nprintf(...) \n;    \nin c, the semicolon is a statement terminator, rather than a separator as it  is in languages \nlike  \npascal.   \nbraces { and } are used to group declarations and statements together into a compound  \nstatement, or block, so that they are syntactically equivalent to a single state ment. the \nbraces  \nthat surround the statements of a function are one obvious example; braces around \nmultiple  \nstatements after an if, else, while, or for are another. (variables can be dec lared inside \nany  \nblock; we will talk about this in chapter 4.) there is no semicolon after the ri ght brace \nthat  \nends a block.   \n3.2 if-else  \nthe if-else statement is used to express decisions. formally the syntax is  \n if (expression) \nstatement1   \n else   \nstatement2\n\nwhere the else part is optional. the expression is evaluated; if it is true (that is, if \nexpression   \nhas a non-zero value), statement1 is executed. if it is false (expression is z ero) and if \nthere is  \nan else part, statement2 is executed instead.   \nsince an if tests the numeric value of an expression, certain coding shortcuts are pos sible.  \nthe most obvious is writing   \n if (expression)  \ninstead of   \n if (expression != 0)  \nsometimes this is natural and clear; at other times it can be cryptic.   \nbecause the else part of an if-else is optional,there is an ambiguity when an el se if \nomitted  \nfrom a nested if sequence. this is resolved by associating the else with the close st \nprevious  \nelse-less if. for example, in\n\nif (n > 0)  \nif (a > b) \nz = a; \nelse  \nz = b;  \nthe else goes to the inner if, as we have shown by indentation. if that isn''t what you want,  \nbraces must be used to force the proper association:   \n if (n > 0)  {  \nif (a > b)   \n z = a; }  \nelse    \nz = b;   \nthe ambiguity is especially pernicious in situations like this:   \n if (n > 0)  \nfor (i = 0; i < n; i++ \n)      \n if (s[i] > 0)  {  \nprintf("...") \n;  \nreturn i;    }  \nelse /* wrong * \n/  \nprintf("error -- n is negative\\n") \n;    \nthe indentation shows unequivocally what you want, but the compiler doesn''t get the  \nmessage, and associates the else with the inner if. this kind of bug can be hard to find; \nit''s a  \ngood idea to use braces when there are nested ifs.\n\nby the way, notice that there is a semicolon after z = a in   \n if (a > b)  \nz = a;  \nelse  \nz = b;  \nthis is because grammatically, a statement follows the if, and an expression statement \nlike  \n``z = a;'''' is always terminated by a semicolon.   \n3.3 else-if  \nthe construction   \n if (expression) \nstatement  \nelse if (expression) \nstatement  \nelse if (expression) \nstatement  \nelse if (expression) \nstatement   \n else    \nstatement    \noccurs so often that it is worth a brief separate discussion. this sequence of  if statements \nis  \nthe most general way of writing a multi-way decision. the expressions are eval uated in \norder;  \nif an expression is true, the statement associated with it is executed, and t his terminates \nthe  \nwhole chain. as always, the code for each statement is either a single stat ement, or a \ngroup of  \nthem in braces.\n\nthe last else part handles the ``none of the above'''' or default case where none of the other  \nconditions is satisfied. sometimes there is no explicit action for the default ; in that case \nthe  \ntrailing   \n else   \nstatement   \ncan be omitted, or it may be used for error checking to catch an ``impossible'''' condition.   \n \nto illustrate a three-way decision, here is a binary search function that deci des if a \nparticular  \nvalue x occurs in the sorted array v. the elements of v must be in increasing order. the  \nfunction returns the position (a number between 0 and n-1) if x occurs in v, and -1 if not.   \nbinary search first compares the input value x to the middle element of the array v.  if x is \nless  \nthan the middle value, searching focuses on the lower half of the table, otherwise on t he \nupper  \nhalf. in either case, the next step is to compare x to the middle element of the sel ected \nhalf.  \nthis process of dividing the range in two continues until the value is found or the range is   \nempty.   \n /* binsearch: find x in v[0] <= v[1] <= ... <= v[n-1] */    \n int binsearch(int x, int v[], int n)   {   \n int low, high, mid;   \nlow = 0;  \n high = n - 1;   \n while (low <= high) {   \n mid = (low+high)/2;   \n if (x < v[mid])   \n high = mid + 1;\n\nelse if (x > v[mid])    \n low = mid + 1;  \nelse /* found match */   \n return mid;   }  \nreturn -1; /* no match */   } \nthe fundamental decision is whether x is less than, greater than, or equal to the middle  \nelement v[mid] at each step; this is a natural for else-if.   \nexercise 3-1. our binary search makes two tests inside the loop, when one would suffice  \n(at  \nthe price of more tests outside.) write a version with only one test inside the l oop and  \nmeasure the difference in run-time.   \n3.4 switch  \nthe switch statement is a multi-way decision that tests whether an express ion matches \none of  \na number of constant integer values, and branches accordingly.   \n switch (expression) {   \ncase const-expr: statements  \n case const-expr: statements  \n default: statements   }\n\neach case is labeled by one or more integer-valued constants or constant expressions. if a \ncase  \nmatches the expression value, execution starts at that case. all case express ions must be  \ndifferent. the case labeled default is executed if none of the other cases are s atisfied. a  \ndefault is optional; if it isn''t there and if none of the cases match, no action at a ll takes \nplace.  \ncases and the default clause can occur in any order.   \nin chapter 1 we wrote a program to count the occurrences of each digit, white space, a nd \nall  \nother characters, using a sequence of if ... else if ... else. here is the same progr am  \nwith a switch:   \n #include <stdio.h>   \n main() /* count digits, white space, others * \n/  {  \nint c, i, nwhite, nother, ndigit[10] \n;    \n nwhite = nother = 0;  \nfor (i = 0; i < 10; i++ \n)   \nndigit[i] = 0;     \n while ((c = getchar()) != eof)  {  \nswitch (c)  {  \ncase ''0'': case ''1'': case ''2'': case ''3'': case ''4'' \n:  \ncase ''5'': case ''6'': case ''7'': case ''8'': case ''9'' \n:    \n ndigit[c-''0'']++;   \n break;  \ncase '' '' \n:  \ncase ''\\n'' \n:\n\ncase ''\\t''  \n:    \n nwhite++ \n;  \nbreak;    \n default:  \nnother++ \n;  \nbreak;    } }  \nprintf("digits =") \n;  \nfor (i = 0; i < 10; i++ \n)    \n printf(" %d", ndigit[i]);  \nprintf(", white space = %d, other = %d\\n",  \nnwhite, nother);   \nreturn 0;  } \nthe break statement causes an immediate exit from the switch. because cases serve just \nas  \nlabels, after the code for one case is done, execution falls through to the next unles s you \ntake  \nexplicit action to escape. break and return are the most common ways to leave a swi tch. \na  \nbreak statement can also be used to force an immediate exit from while, for, and do \nloops,  \nas will be discussed later in this chapter.   \nfalling through cases is a mixed blessing. on the positive side, it allows sever al cases to \nbe  \nattached to a single action, as with the digits in this example. but it also impl ies that \nnormally  \neach case must end with a break to prevent falling through to the next. falling through \nfrom  \none case to another is not robust, being prone to disintegration when the program is \nmodified.\n\nwith the exception of multiple labels for a single computation, fall-throughs should be \nused   \nsparingly, and commented.\n\nas a matter of good form, put a break after the last case (the default here) even though it''s  \nlogically unnecessary. some day when another case gets added at the end, this bit of   \ndefensive programming will save you.   \nexercise 3-2. write a function escape(s,t) that converts characters li ke newline and tab  \ninto visible escape sequences like \\n and \\t as it copies the string t to s. use a  switch. \nwrite  \na function for the other direction as well, converting escape sequences into the re al \ncharacters.   \n3.5 loops - while and for  \nwe have already encountered the while and for loops. in   \n while (expression) \nstatement   \nthe expression is evaluated. if it is non-zero, statement is executed and expression  is \nreevaluated. this cycle continues until expression becomes zero, at which point \nexecution  \nresumes after statement.   \nthe for statement   \n for (expr1; expr2; expr3)  \nstatement    \nis equivalent to   \nexpr1;  \n while (expr2)  { \nstatement \nexpr3;   } \nexcept for the behaviour of continue, which is described in section 3.7.   \ngrammatically, the three components of a for loop are expressions. most commonly, \nexpr1  \nand expr3 are assignments or function calls and expr2 is a relational expression. any of \nthe\n\nthree parts can be omitted, although the semicolons must remain. if expr1 or expr3 is  \nomitted,  \nit is simply dropped from the expansion. if the test, expr2, is not present, it is taken as  \npermanently true, so   \n for (;;) {  ...  } \nis an ``infinite'''' loop, presumably to be broken by other means, such as a break or return.   \nwhether to use while or for is largely a matter of personal preference. for exa mple, in  \n \n while ((c = getchar()) == '' '' || c == ''\\n'' || c = ''\\t'')  \n; /* skip white space characters */  \nthere is no initialization or re-initialization, so the while is most natu ral.  \n \nthe for is preferable when there is a simple initialization and increment s ince it keeps the  \nloop control statements close together and visible at the top of the loop. this is most \nobvious  \nin\n\nfor (i = 0; i < n; i++)  ...  \nwhich is the c idiom for processing the first n elements of an array, the analog of the \nfortran  \ndo loop or the pascal for. the analogy is not perfect, however, since the index variable i   \nretains its value when the loop terminates for any reason. because the components of the  \nfor  \nare arbitrary expressions, for loops are not restricted to arithmetic progress ions. \nnonetheless,  \nit is bad style to force unrelated computations into the initialization and inc rement of a \nfor,  \nwhich are better reserved for loop control operations.   \nas a larger example, here is another version of atoi for converting a string to its num eric  \nequivalent. this one is slightly more general than the one in chapter 2; it copes with \noptional  \nleading white space and an optional + or - sign. (chapter 4 shows atof, which does the \nsame  \nconversion for floating-point numbers.)   \nthe structure of the program reflects the form of the input:   \nskip white space, if any  \n get sign, if any     \n get integer part and convert it   \neach step does its part, and leaves things in a clean state for the next. the whole pr ocess  \nterminates on the first character that could not be part of a number.   \n #include <ctype.h>   \n /* atoi: convert s to integer; version 2 */   \n int atoi(char s[])   {   \n int i, n, sign;   \n for (i = 0; isspace(s[i]); i++) /* skip white space */   \n;\n\nsign = (s[i] == ''-'') ? -1 : 1;    \n if (s[i] == ''+'' || s[i] == ''-'') /* skip sign */   \ni++;  \nfor (n = 0; isdigit(s[i]); i++)  \nn = 10 * n + (s[i] - ''0'');  \nreturn sign * n;  } \nthe standard library provides a more elaborate function strtol for conversion of strings to  \nlong integers; see section 5 of appendix b.   \nthe advantages of keeping loop control centralized are even more obvious when there are  \nseveral nested loops. the following function is a shell sort for sorting an array of \nintegers.  \nthe basic idea of this sorting algorithm, which was invented in 1959 by d. l. shell, is \nthat in  \nearly stages, far-apart elements are compared, rather than adjacent ones a s in simpler  \ninterchange sorts. this tends to eliminate large amounts of disorder quickly, so la ter \nstages  \nhave less work to do. the interval between compared elements is gradually decre ased to \none,  \nat which point the sort effectively becomes an adjacent interchange method.   \n /* shellsort: sort v[0]...v[n-1] into increasing order * \n/   \nvoid shellsort(int v[], int n)   {\n\nint gap, i, j, temp;   \n for (gap = n/2; gap > 0; gap /= 2)  \n for (i = gap; i < n; i++)   \n for (j=i-gap; j>=0 && v[j]>v[j+gap]; j-=gap) {   \n temp = v[j];   \n v[j] = v[j+gap];   \n v[j+gap] = temp;   }  } \nthere are three nested loops. the outermost controls the gap between compared \nelements,  \nshrinking it from n/2 by a factor of two each pass until it becomes zero. the middle loop  \nsteps along the elements. the innermost loop compares each pair of elements that i s \nseparated  \nby gap and reverses any that are out of order. since gap is eventually reduced to one, all   \nelements are eventually ordered correctly. notice how the generality of the for m akes the  \nouter loop fit in the same form as the others, even though it is not an arithmetic  \nprogression.    \none final c operator is the comma ``,'''', which most often finds use in the for sta tement. a  \npair of expressions separated by a comma is evaluated left to right, and the type and v alue \nof  \nthe result are the type and value of the right operand. thus in a for statement, it is  \npossible to  \nplace multiple expressions in the various parts, for example to process two indice s in \nparallel.  \nthis is illustrated in the function reverse(s), which reverses the string s  in place.  \n \n #include <string.h>   \n /* reverse: reverse string s in place */   \n void reverse(char s[])   {   \n int c, i, j;\n\nfor (i = 0, j = strlen(s)-1; i < j; i++, j--) {   \n c = s[i];   \n s[i] = s[j];   \n s[j] = c;   }  } \nthe commas that separate function arguments, variables in declarations, etc., are not \ncomma  \noperators, and do not guarantee left to right evaluation.   \ncomma operators should be used sparingly. the most suitable uses are for constructs  \nstrongly  \nrelated to each other, as in the for loop in reverse, and in macros where a multist ep  \ncomputation has to be a single expression. a comma expression might also be \nappropriate for  \nthe exchange of elements in reverse, where the exchange can be thought of a single  \noperation:   \n for (i = 0, j = strlen(s)-1; i < j; i++, j--)  \nc = s[i], s[i] = s[j], s[j] = c;   \nexercise 3-3. write a function expand(s1,s2) that expands shorthand notations like a- z in  \nthe string s1 into the equivalent complete list abc...xyz in s2. allow for letters  of either  \ncase and digits, and be prepared to handle cases like a-b-c and a-z0-9 and -a-z . arrange  \nthat a leading or trailing - is taken literally.    \n3.6 loops - do-while\n\nas we discussed in chapter 1, the while and for loops test the termination condition at the  \ntop. by contrast, the third loop in c, the do-while, tests at the bottom after making e ach \npass  \nthrough the loop body; the body is always executed at least once.   \nthe syntax of the do is   do   \nstatement  \nwhile (expression) \n;   \nthe statement is executed, then expression is evaluated. if it is true, stateme nt is \nevaluated  \nagain, and so on. when the expression becomes false, the loop terminates. except for the   \nsense of the test, do-while is equivalent to the pascal repeat-until stat ement.  \n \nexperience shows that do-while is much less used than while and for. nonetheless, fro m  \ntime to time it is valuable, as in the following function itoa, which converts a numbe r to a  \ncharacter string (the inverse of atoi). the job is slightly more complicated t han might be  \nthought at first, because the easy methods of generating the digits generate them in the  \nwrong  \norder. we have chosen to generate the string backwards, then reverse it.     \n /* itoa: convert n to characters in s */   \n void itoa(int n, char s[])  {   \n int i, sign;   \n if ((sign = n) < 0) /* record sign */   \nn = -n; /* make n positive */   \ni = 0;  \ndo { /* generate digits in reverse order */   \n s[i++] = n % 10 + ''0''; /* get next digit */   \n } while ((n /= 10) > 0); /* delete it */\n\nif (sign < 0)   \n s[i++] = ''-'';   \n s[i] = ''\\0'';   \n reverse(s);   } \nthe do-while is necessary, or at least convenient, since at least one character must be  \ninstalled in the array s, even if n is zero. we also used braces around the single state ment \nthat  \nmakes up the body of the do-while, even though they are unnecessary, so the hasty reader  \nwill not mistake the while part for the beginning of a while loop.   \nexercise 3-4. in a two''s complement number representation, our version of itoa does no t  \nhandle the largest negative number, that is, the value of n equal to -(2wordsize-1). \nexplain why  \nnot. modify it to print that value correctly, regardless of the machine on which it r uns.  \n \nexercise 3-5. write the function itob(n,s,b) that converts the integer n into a ba se b  \ncharacter representation in the string s. in particular, itob(n,s,16) forma ts s as a  \nhexadecimal integer in s.   \nexercise 3-6. write a version of itoa that accepts three arguments instead o f two. the \nthird  \nargument is a minimum field width; the converted number must be padded with blanks \non the  \nleft if necessary to make it wide enough.   \n3.7 break and continue\n\nit is sometimes convenient to be able to exit from a loop other than by testing at the top \nor  \nbottom. the break statement provides an early exit from for, while, and do, just as from  \nswitch. a break causes the innermost enclosing loop or switch to be exited immediately.   \n \nthe following function, trim, removes trailing blanks, tabs and newlines from the end of \na  \nstring, using a break to exit from a loop when the rightmost non-blank, non-tab, non-\nnewline  \nis found.   \n /* trim: remove trailing blanks, tabs, newlines */  \n int trim(char s[])   {   \nint n;   \n for (n = strlen(s)-1; n >= 0; n--)  \n if (s[n] != '' '' && s[n] != ''\\t'' && s[n] != ''\\n'')   \n break;    \n s[n+1] = ''\\0'';    \nreturn n;  } \nstrlen returns the length of the string. the for loop starts at the end and scans backwa rds  \nlooking for the first character that is not a blank or tab or newline. the loop is broken \nwhen  \none is found, or when n becomes negative (that is, when the entire string has been \nscanned).  \nyou should verify that this is correct behavior even when the string is empty or contai ns \nonly  \nwhite space characters.   \nthe continue statement is related to break, but less often used; it causes t he next iteration \nof  \nthe enclosing for, while, or do loop to begin. in the while and do, this means that the test  \npart is executed immediately; in the for, control passes to the increme nt step. the \ncontinue  \nstatement applies only to loops, not to switch. a continue inside a switch inside a l oop\n\ncauses the next loop iteration.    \nas an example, this fragment processes only the non-negative elements in the array a;  \nnegative values are skipped.   \n for (i = 0; i < n; i++)  \nif (a[i] < 0) /* skip negative elements */  \ncontinue;  \n... /* do positive elements */  \nthe continue statement is often used when the part of the loop that follows is \ncomplicated,  \nso that reversing a test and indenting another level would nest the program too deeply.   \n3.8 goto and labels  \nc provides the infinitely-abusable goto statement, and labels to branch to. formally, the  \ngotostatement is never necessary, and in practice it is almost always eas y to write code \nwithout it.  \nwe have not used goto in this book.   \nnevertheless, there are a few situations where gotos may find a place. the m ost common \nis  \nto abandon processing in some deeply nested structure, such as breaking out of two or \nmore  \nloops at once. the break statement cannot be used directly since it only exits from the   \ninnermost loop. thus:\n\nfor ( ... )   \n for ( ... )  {  .. .  \nif (disaster)    \n goto error;  }  .. .  \nerror:  \n/* clean up the mess * \n/   \nthis organization is handy if the error-handling code is non-trivial, and if errors can \noccur in  \nseveral places.   \na label has the same form as a variable name, and is followed by a colon. it can be \nattached to  \nany statement in the same function as the goto. the scope of a label is the entire f unction.  \n \nas another example, consider the problem of determining whether two arrays a and b \nhave an  \nelement in common. one possibility is   \n for (i = 0; i < n; i++ \n)  \nfor (j = 0; j < m; j++ \n)  \nif (a[i] == b[j] \n)    \n goto found;  \n/* didn''t find any common element * \n/  .. .\n\nfound:   \n/* got one: a[i] == b[j] * \n/  .. .    \ncode involving a goto can always be written without one, though perhaps at the price of  \nsome repeated tests or an extra variable. for example, the array search becomes  \n \n found = 0;  \nfor (i = 0; i < n && !found; i++ \n)  \nfor (j = 0; j < m && !found; j++ \n)  \nif (a[i] == b[j] \n)  \nfound = 1;    \n if (found)  \n/* got one: a[i-1] == b[j-1] * \n/  .. .      \n else  \n/* didn''t find any common element * \n/  .. .    \nwith a few exceptions like those cited here, code that relies on goto statements  is \ngenerally  \nharder to understand and to maintain than code without gotos. although we are not \ndogmatic  \nabout the matter, it does seem that goto statements should be used rarely, if at all.\n\nchapter 4 - functions and program  \nstructure   \nfunctions break large computing tasks into smaller ones, and enable people to build on \nwhat  \nothers have done instead of starting over from scratch. appropriate functions hide details \nof  \noperation from parts of the program that don''t need to know about them, thus clarifying \nthe  \nwhole, and easing the pain of making changes.   \nc has been designed to make functions efficient and easy to use; c programs generally \nconsist  \nof many small functions rather than a few big ones. a program may reside in one or more  \nsource files. source files may be compiled separately and loaded together, a long with  \npreviously compiled functions from libraries. we will not go into that process here, \nhowever,  \nsince the details vary from system to system.   \nfunction declaration and definition is the area where the ansi standard has m ade the \nmost  \nchanges to c. as we saw first in chapter 1, it is now possible to declare the type of  \narguments  \nwhen a function is declared. the syntax of function declaration also changes, so that  \ndeclarations and definitions match. this makes it possible for a compiler to det ect many \nmore  \nerrors than it could before. furthermore, when arguments are properly declared, \nappropriate  \ntype coercions are performed automatically.   \nthe standard clarifies the rules on the scope of names; in particular, it re quires that there \nbe  \nonly one definition of each external object. initialization is more general: autom atic \narrays  \nand structures may now be initialized.   \nthe c preprocessor has also been enhanced. new preprocessor facilities include  a more  \ncomplete set of conditional compilation directives, a way to create quoted strings  from \nmacro  \narguments, and better control over the macro expansion process.   \n4.1 basics of functions  \nto begin with, let us design and write a program to print each line of its input that \ncontains a  \nparticular ``pattern'''' or string of characters. (this is a special case of  the unix program\n\ngrep.) for example, searching for the pattern of letters ``ould'''' in the set of lines \n  \n ah love! could you and i with fate conspire  \nto grasp this sorry scheme of things entire,  \nwould not we shatter it to bits -- and then  \nre-mould it nearer to the heart''s desire!    \nwill produce the output   \n ah love! could you and i with fate conspire  \nwould not we shatter it to bits -- and then  \nre-mould it nearer to the heart''s desire!    \nthe job falls neatly into three pieces:   \nwhile (there''s another line)  \nif (the line contains the pattern) \nprint it\n\nalthough it''s certainly possible to put the code for all of this in main, a better way is to \nuse the  \nstructure to advantage by making each part a separate function. three small p ieces are \nbetter  \nto deal with than one big one, because irrelevant details can be buried in the functions , \nand the  \nchance of unwanted interactions is minimized. and the pieces may even be useful in \nother  \nprograms.   \n``while there''s another line'''' is getline, a function that we wrote in chapter 1, a nd ``print \nit''''  \nis printf, which someone has already provided for us. this means we need only write a  \nroutine to decide whether the line contains an occurrence of the pattern.   \nwe can solve that problem by writing a function strindex(s,t) that returns t he position or  \nindex in the string s where the string t begins, or -1 if s does not contain t. because c \narrays  \nbegin at position zero, indexes will be zero or positive, and so a negative value like  -1 is  \nconvenient for signaling failure. when we later need more sophisticated pattern \nmatching, we  \nonly have to replace strindex; the rest of the code can remain the same. (the standard   \nlibrary provides a function strstr that is similar to strindex, except that i t returns a pointer  \ninstead of an index.)    \ngiven this much design, filling in the details of the program is straightforward. he re is \nthe   \nwhole thing, so you can see how the pieces fit together. for now, the pattern to be \nsearched  \nfor is a literal string, which is not the most general of mechanisms. we will  return shortly \nto a  \ndiscussion of how to initialize character arrays, and in chapter 5 will show how to m ake \nthe  \npattern a parameter that is set when the program is run. there is also a slight ly different  \nversion of getline; you might find it instructive to compare it to the one in chapter 1.   \n #include <stdio.h>  \n#define maxline 1000 /* maximum input line length * \n/    \n int getline(char line[], int max)  \nint strindex(char source[], char searchfor[]) \n;\n\nchar pattern[] = "ould"; /* pattern to search for */   \n /* find all lines matching pattern */   \n main()   {   \n char line[maxline];   \n int found = 0;   \n while (getline(line, maxline) > 0)  \n if (strindex(line, pattern) >= 0) {   \n printf("%s", line);   \n found++;   }  \n return found;   }     \n /* getline: get line into s, return length */   \n int getline(char s[], int lim)   {   \nint c, i;   \ni = 0;  \nwhile (--lim > 0 && (c=getchar()) != eof && c != ''\\n'' \n)  \ns[i++] = c;  \nif (c == ''\\n'' \n)  \ns[i++] = c;\n\ns[i] = ''\\0'' \n;  \nreturn i; }    \n /* strindex: return index of t in s, -1 if none */  \n int strindex(char s[], char t[])   {   \n int i, j, k;   \n for (i = 0; s[i] != ''\\0''; i++) {   \n for (j=i, k=0; t[k]!=''\\0'' && s[j]==t[k]; j++, k++)   \n;  \n if (k > 0 && t[k] == ''\\0'')   \n return i;   }    \nreturn -1;  }  \neach function definition has the form   \nreturn-type function-name(argument declarations) {   \ndeclarations and statements   }  \nvarious parts may be absent; a minimal function is   \n dummy() {}  \nwhich does nothing and returns nothing. a do-nothing function like this is sometimes \nuseful\n\nas a place holder during program development. if the return type is omitted, int is  \nassumed.   \na program is just a set of definitions of variables and functions. communication between \nthe  \nfunctions is by arguments and values returned by the functions, and through external  \nvariables. the functions can occur in any order in the source file, and the source progra m \ncan  \nbe split into multiple files, so long as no function is split.   \nthe return statement is the mechanism for returning a value from the called func tion to \nits  \ncaller. any expression can follow return:   \n return expression;  \nthe expression will be converted to the return type of the function if necessary. \nparentheses  \nare often used around the expression, but they are optional.   \nthe calling function is free to ignore the returned value. furthermore, there need t o be no  \nexpression after return; in that case, no value is returned to the caller. contr ol also returns \nto  \nthe caller with no value when execution ``falls off the end'''' of the function by reaching \nthe  \nclosing right brace. it is not illegal, but probably a sign of trouble, if a function r eturns a \nvalue   \nfrom one place and no value from another. in any case, if a function fails to return a  \nvalue, its  \n``value'''' is certain to be garbage.   \nthe pattern-searching program returns a status from main, the number of matches  found. \nthis  \nvalue is available for use by the environment that called the program   \nthe mechanics of how to compile and load a c program that resides on multiple source \nfiles  \nvary from one system to the next. on the unix system, for example, the cc command  \nmentioned in chapter 1 does the job. suppose that the three functions are stored in thre e \nfiles  \ncalled main.c, getline.c, and strindex.c. then the command\n\ncc main.c getline.c strindex.c  \ncompiles the three files, placing the resulting object code in files main.o, getline.o, and  \nstrindex.o, then loads them all into an executable file called a.out. if there is an e rror, say  \nin main.c, the file can be recompiled by itself and the result loaded with the previ ous \nobject  \nfiles, with the command   \n cc main.c getline.o strindex.o  \nthe cc command uses the ``.c'''' versus ``.o'''' naming convention to distinguish source files   \nfrom object files.   \nexercise 4-1. write the function strindex(s,t) which returns the position of the r ightmost  \noccurrence of t in s, or -1 if there is none.   \n4.2 functions returning non-integers  \nso far our examples of functions have returned either no value (void) or an int. what if a   \nfunction must return some other type? many numerical functions like sqrt, sin, and cos  \nreturn double; other specialized functions return other types. to illustrate how to de al \nwith  \nthis, let us write and use the function atof(s), which converts the string s to its doubl e- \nprecision floating-point equivalent. atof if an extension of atoi, which we showed \nversions  \nof in chapters 2 and 3. it handles an optional sign and decimal point, and the presence or  \nabsence of either part or fractional part. our version is not a high-quality input \nconversion   \nroutine; that would take more space than we care to use. the standard library i ncludes an  \natof; the header <stdlib.h> declares it.    \nfirst, atof itself must declare the type of value it returns, since it is not  int. the type name  \nprecedes the function name:  \n #include <ctype.h>   \n /* atof: convert string s to double * \n/  \ndouble atof(char s[] \n)  {    \n double val, power;  \nint i, sign;    \n for (i = 0; isspace(s[i]); i++) /* skip white space */\n\n;  \nsign = (s[i] == ''-'') ? -1 : 1;  \nif (s[i] == ''+'' || s[i] == ''-'' \n)    \ni++ \n;  \nfor (val = 0.0; isdigit(s[i]); i++ \n)  \nval = 10.0 * val + (s[i] - ''0'') \n;  \nif (s[i] == ''.'' \n)  \ni++ \n;   \n for (power = 1.0; isdigit(s[i]); i++)  {  \nval = 10.0 * val + (s[i] - ''0'') \n;  \npower *= 10;     }   \nreturn sign * val / power;  } \nsecond, and just as important, the calling routine must know that atof returns a non-int \nvalue.  \none way to ensure this is to declare atof explicitly in the calling routine. the de claration \nis  \nshown in this primitive calculator (barely adequate for check-book balancing), which \nreads\n\none number per line, optionally preceded with a sign, and adds them up, printing the \nrunning  \nsum after each input:   \n #include <stdio.h>   \n #define maxline 100   \n /* rudimentary calculator */   \n main()   {   \n double sum, atof(char []);   \n char line[maxline];   \n int getline(char line[], int max);  \n sum = 0;  \nwhile (getline(line, maxline) > 0)  \nprintf("\\t%g\\n", sum += atof(line)) \n;  \nreturn 0;  }    \nthe declaration   \n double sum, atof(char []); \nsays that sum is a double variable, and that atof is a function that takes one char[] \nargument  \nand returns a double.   \nthe function atof must be declared and defined consistently. if atof itself and the call to it \nin  \nmain have inconsistent types in the same source file, the error will be detecte d by the  \ncompiler. but if (as is more likely) atof were compiled separately, the mism atch would \nnot  \nbe detected, atof would return a double that main would treat as an int, and meaningles s  \nanswers would result.   \nin the light of what we have said about how declarations must match definitions, thi s \nmight\n\nseem surprising. the reason a mismatch can happen is that if there is no function  \nprototype, a  \nfunction is implicitly declared by its first appearance in an expression, such as  \n sum += atof(line)  \nif a name that has not been previously declared occurs in an expression and is followed \nby a  \nleft parentheses, it is declared by context to be a function name, the function is ass umed \nto  \nreturn an int, and nothing is assumed about its arguments. furthermore, if a function  \ndeclaration does not include arguments, as in   \n double atof(); \nthat too is taken to mean that nothing is to be assumed about the arguments of atof; all   \nparameter checking is turned off. this special meaning of the empty argument list is  \nintended  \nto permit older c programs to compile with new compilers. but it''s a bad idea to use i t \nwith  \nnew c programs. if the function takes arguments, declare them; if it takes no argument s, \nuse  \nvoid.   \ngiven atof, properly declared, we could write atoi (convert a string to int) in te rms of it: \n \n /* atoi: convert string s to integer using atof */   \n int atoi(char s[])    {   \n double atof(char s[]);\n\nreturn (int) atof(s) \n;  }   \nnotice the structure of the declarations and the return statement. the value of the \nexpression  \nin   \n return expression;  \nis converted to the type of the function before the return is taken. therefore, the  value of  \natof, a double, is converted automatically to int when it appears in this return, sin ce the  \nfunction atoi returns an int. this operation does potentionally discard information, \nhowever,  \nso some compilers warn of it. the cast states explicitly that the operation is  intended, and  \nsuppresses any warning.   \nexercise 4-2. extend atof to handle scientific notation of the form  \n 123.45e-6  \nwhere a floating-point number may be followed by e or e and an optionally signed \nexponent.   \n4.3 external variables  \na c program consists of a set of external objects, which are either variables or f unctions. \nthe  \nadjective ``external'''' is used in contrast to ``internal'''', which desc ribes the arguments and  \nvariables defined inside functions. external variables are defined outside of any f unction, \nand  \nare thus potentionally available to many functions. functions themselves are alw ays \nexternal,  \nbecause c does not allow functions to be defined inside other functions. by default, \nexternal  \nvariables and functions have the property that all references to them by the sam e name, \neven  \nfrom functions compiled separately, are references to the same thing. (the sta ndard calls \nthis  \nproperty external linkage.) in this sense, external variables are analogous to f ortran  \ncommon blocks or variables in the outermost block in pascal. we will see lat er how to  \ndefine external variables and functions that are visible only within a single sour ce file.  \nbecause external variables are globally accessible, they provide an alter native to function  \narguments and return values for communicating data between functions. any function \nmay  \naccess an external variable by referring to it by name, if the name has been decl ared  \nsomehow.\n\nif a large number of variables must be shared among functions, external variables are \nmore  \nconvenient and efficient than long argument lists. as pointed out in chapter 1, however, \nthis  \nreasoning should be applied with some caution, for it can have a bad effect on program  \nstructure, and lead to programs with too many data connections between functions.   \nexternal variables are also useful because of their greater scope and lifet ime. automatic  \nvariables are internal to a function; they come into existence when the function i s entered, \nand  \ndisappear when it is left. external variables, on the other hand, are permanent, so t hey can  \nretain values from one function invocation to the next. thus if two functions must shar e \nsome  \ndata, yet neither calls the other, it is often most convenient if the shared data  is kept in  \nexternal variables rather than being passed in and out via arguments.   \nlet us examine this issue with a larger example. the problem is to write a cal culator \nprogram  \nthat provides the operators +, -, * and /. because it is easier to implement, the c alculator \nwill  \nuse reverse polish notation instead of infix. (reverse polish notation is used by some \npocket  \ncalculators, and in languages like forth and postscript.)   \nin reverse polish notation, each operator follows its operands; an infix expression l ike\n\n(1 - 2) * (4 + 5)   \nis entered as  \n 1 2 - 4 5 + *  \nparentheses are not needed; the notation is unambiguous as long as we know how many  \noperands each operator expects.   \nthe implementation is simple. each operand is pushed onto a stack; when an operator \narrives,  \nthe proper number of operands (two for binary operators) is popped, the operator is \napplied to  \nthem, and the result is pushed back onto the stack. in the example above, for instance, 1 \nand 2  \nare pushed, then replaced by their difference, -1. next, 4 and 5 are pushed and then \nreplaced  \nby their sum, 9. the product of -1 and 9, which is -9, replaces them on the stack. the \nvalue on  \nthe top of the stack is popped and printed when the end of the input line is encountered.   \nthe structure of the program is thus a loop that performs the proper operation on each  \noperator and operand as it appears:   \n while (next operator or operand is not end-of-file indicator)   \nif (number)   \npush it  \n else if (operator)  \npop operands   \ndo operation   \npush result  \n else if (newline)  \npop and print top of stack  \n else   \nerror\n\nthe operation of pushing and popping a stack are trivial, but by the time error detection \nand   \nrecovery are added, they are long enough that it is better to put each in a separate func tion  \nthan to repeat the code throughout the whole program. and there should be a separate  \nfunction for fetching the next input operator or operand.   \nthe main design decision that has not yet been discussed is where the stack is, that is , \nwhich  \nroutines access it directly. on possibility is to keep it in main, and pass the st ack and the  \ncurrent stack position to the routines that push and pop it. but main doesn''t need to know  \nabout the variables that control the stack; it only does push and pop operations. so we \nhave  \ndecided to store the stack and its associated information in external variabl es accessible \nto the  \npush and pop functions but not to main.   \ntranslating this outline into code is easy enough. if for now we think of the program as  \nexisting in one source file, it will look like this:   \n#includes \n#defines   \nfunction declarations for main   \nmain() { ... }     \nexternal variables for push and pop\n\nvoid push( double f) { ...  }  \ndouble pop(void) { ...  }    \n int getop(char s[]) { ...  }  \nroutines called by getop   \nlater we will discuss how this might be split into two or more source files.   \nthe function main is a loop containing a big switch on the type of operator or operand; \nthis is  \na more typical use of switch than the one shown in section 3.4.   \n #include <stdio.h>  \n#include <stdlib.h> /* for atof() * \n/   \n #define maxop 100 /* max size of operand or operator * \n/  \n#define number ''0'' /* signal that a number was found *  \n/     \n int getop(char []) \n;  \nvoid push(double) \n;  \ndouble pop(void) \n;    \n /* reverse polish calculator * \n/  \nmain( \n)  {    \nint type;  \ndouble op2;\n\nchar s[maxop]  \n;    \n while ((type = getop(s)) != eof)  {  \nswitch (type)  {  \ncase number:    \n push(atof(s)) \n;  \nbreak;    \n case ''+'' \n:  \npush(pop() + pop()) \n;  \nbreak;    \n case ''*'' \n:  \npush(pop() * pop())  \n;   \nbreak;    \n case ''-'' \n:  \nop2 = pop() \n;  \npush(pop() - op2) \n;  \nbreak;    \n case ''/'' \n:  \nop2 = pop() \n;  \nif (op2 != 0.0)\n\npush(pop() / op2);   \nelse  \nprintf("error: zero divisor\\n");  \nbreak;   \n case ''\\n'' \n:  \nprintf("\\t%.8g\\n", pop()) \n;  \nbreak;    \n default:  \nprintf("error: unknown command %s\\n", s);  \nbreak;   } } \nreturn 0;   }\n\nbecause + and * are commutative operators, the order in which the popped operands are  \ncombined is irrelevant, but for - and / the left and right operand must be distinguished.  in  \n \n push(pop() - pop()); /* wrong */  \nthe order in which the two calls of pop are evaluated is not defined. to guarantee the \nright  \norder, it is necessary to pop the first value into a temporary variable as we di d in main.  \n \n #define maxval 100 /* maximum depth of val stack */   \n int sp = 0; /* next free stack position * \n/  \ndouble val[maxval]; /* value stack * \n/   \n /* push: push f onto value stack * \n/  \nvoid push(double f)  {    \n if (sp < maxval)  \nval[sp++] = f;  \nelse   \nprintf("error: stack full, can''t push %g\\n", f)  \n;  }    \n /* pop: pop and return top value from stack * \n/  \ndouble pop(void)  {    \n if (sp > 0)  \nreturn val[--sp] \n;    \nelse  {  \nprintf("error: stack empty\\n") \n;\n\nreturn 0.0;     } }   \na variable is external if it is defined outside of any function. thus the stack and stack \nindex  \nthat must be shared by push and pop are defined outside these functions. but main itself \ndoes  \nnot refer to the stack or stack position - the representation can be hidden.   \nlet us now turn to the implementation of getop, the function that fetches the next \noperator or  \noperand. the task is easy. skip blanks and tabs. if the next character is not a digit or  a  \nhexadecimal point, return it. otherwise, collect a string of digits (which might i nclude a  \ndecimal point), and return number, the signal that a number has been collected.  \n #include <ctype.h>   \n int getch(void) \n;  \nvoid ungetch(int) \n;      \n /* getop: get next character or numeric operand * \n/  \nint getop(char s[] \n)  {    \nint i, c;   \n while ((s[0] = c = getch()) == '' '' || c == ''\\t'')   \n;  \ns[1] = ''\\0'' \n;  \nif (!isdigit(c) && c != ''.'' \n)    \n return c; /* not a number *\n\n/   \ni = 0;  \nif (isdigit(c)) /* collect integer part * \n/    \n while (isdigit(s[++i] = c = getch()) \n)  \n;  \nif (c == ''.'') /* collect fraction part * \n/\n\nwhile (isdigit(s[++i] = c = getch()))   \n;  \n s[i] = ''\\0'';   \n if (c != eof)   \n ungetch(c);  \nreturn number;  } \nwhat are getch and ungetch? it is often the case that a program cannot determine that it \nhas  \nread enough input until it has read too much. one instance is collecting characters  that \nmake  \nup a number: until the first non-digit is seen, the number is not complete. but then the  \nprogram has read one character too far, a character that it is not prepared for.   \nthe problem would be solved if it were possible to ``un-read'''' the unwanted character. \nthen,  \nevery time the program reads one character too many, it could push it back on the input, \nso  \nthe rest of the code could behave as if it had never been read. fortunately, it''s eas y to \nsimulate  \nun-getting a character, by writing a pair of cooperating functions. getch delivers t he next  \ninput character to be considered; ungetch will return them before reading new input.   \n \nhow they work together is simple. ungetch puts the pushed-back characters into a shared  \nbuffer -- a character array. getch reads from the buffer if there is anything el se, and calls  \ngetchar if the buffer is empty. there must also be an index variable that recor ds the \nposition  \nof the current character in the buffer.   \nsince the buffer and the index are shared by getch and ungetch and must retain their \nvalues  \nbetween calls, they must be external to both routines. thus we can write getch, ungetch, \nand  \ntheir shared variables as:  \n #define bufsize 100   \n char buf[bufsize]; /* buffer for ungetch * \n/  \nint bufp = 0; /* next free position in buf * \n/\n\nint getch(void) /* get a (possibly pushed-back) character */   {   \n return (bufp > 0) ? buf[--bufp] : getchar();   }   \n void ungetch(int c) /* push character back on input */  {  \nif (bufp >= bufsize)  \nprintf("ungetch: too many characters\\n");  \nelse  \nbuf[bufp++] = c;  } \nthe standard library includes a function ungetch that provides one character of pushback; \nwe  \nwill discuss it in chapter 7. we have used an array for the pushback, rather than a single  \ncharacter, to illustrate a more general approach.   \nexercise 4-3. given the basic framework, it''s straightforward to extend the cal culator. \nadd  \nthe modulus (%) operator and provisions for negative numbers.    \nexercise 4-4. add the commands to print the top elements of the stack without popping,  \nto  \nduplicate it, and to swap the top two elements. add a command to clear the stack.\n\nexercise 4-5. add access to library functions like sin, exp, and pow. see <math.h> in  \nappendix b, section 4.   \nexercise 4-6. add commands for handling variables. (it''s easy to provide twenty-six \nvariables  \nwith single-letter names.) add a variable for the most recently printed value.   \nexercise 4-7. write a routine ungets(s) that will push back an entire string onto the input.  \nshould ungets know about buf and bufp, or should it just use ungetch?   \nexercise 4-8. suppose that there will never be more than one character of pushback. \nmodify  \ngetch and ungetch accordingly.   \nexercise 4-9. our getch and ungetch do not handle a pushed-back eof correctly. decide  \nwhat their properties ought to be if an eof is pushed back, then implement your design.   \nexercise 4-10. an alternate organization uses getline to read an entire input  line; this \nmakes  \ngetch and ungetch unnecessary. revise the calculator to use this approach.   \n4.4 scope rules  \nthe functions and external variables that make up a c program need not all be compiled \nat the  \nsame time; the source text of the program may be kept in several files, and pr eviously  \ncompiled routines may be loaded from libraries. among the questions of interest are   \n \n•  \nhow are declarations written so that variables are properly declared durin g  \ncompilation?  \n•  \nhow are declarations arranged so that all the pieces will be properly connecte d when  \nthe program is loaded?  \n•  \nhow are declarations organized so there is only one copy?  \n•  \nhow are external variables initialized?  \nlet us discuss these topics by reorganizing the calculator program into severa l files. as a  \npractical matter, the calculator is too small to be worth splitting, but it i s a fine illustration \nof  \nthe issues that arise in larger programs.   \nthe scope of a name is the part of the program within which the name can be used. for \nan\n\nautomatic variable declared at the beginning of a function, the scope is the function in  \nwhich  \nthe name is declared. local variables of the same name in different functions are \nunrelated.  \nthe same is true of the parameters of the function, which are in effect local va riables.  \n \nthe scope of an external variable or a function lasts from the point at which it is de clared \nto  \nthe end of the file being compiled. for example, if main, sp, val, push, and pop are \ndefined  \nin one file, in the order shown above, that is,   \n main() { ... }  \n int sp = 0;  \ndouble val[maxval] \n;    \n void push(double f) { ... }   \n double pop(void) { ... }\n\nthen the variables sp and val may be used in push and pop simply by naming them; no  \nfurther declarations are needed. but these names are not visible in main, nor are push and \npop  \nthemselves.   \non the other hand, if an external variable is to be referred to before it is define d, or if it is  \ndefined in a different source file from the one where it is being used, then an extern  \ndeclaration is mandatory.   \nit is important to distinguish between the declaration of an external variable a nd its \ndefinition.  \na declaration announces the properties of a variable (primarily its type); a defi nition also  \ncauses storage to be set aside. if the lines   \n int sp;   \n double val[maxval];  \nappear outside of any function, they define the external variables sp and val, cause \nstorage to  \nbe set aside, and also serve as the declarations for the rest of that source fil e. on the other  \nhand, the lines   \n extern int sp;  \n extern double val[];   \ndeclare for the rest of the source file that sp is an int and that val is a doubl e array (whose  \nsize is determined elsewhere), but they do not create the variables or rese rve storage for \nthem.    \nthere must be only one definition of an external variable among all the files that m ake up \nthe  \nsource program; other files may contain extern declarations to access it. (t here may also \nbe  \nextern declarations in the file containing the definition.) array sizes must be  specified \nwith  \nthe definition, but are optional with an extern declaration.   \ninitialization of an external variable goes only with the definition.   \nalthough it is not a likely organization for this program, the functions push and pop could \nbe  \ndefined in one file, and the variables val and sp defined and initialized in another. then \nthese  \ndefinitions and declarations would be necessary to tie them together:\n\nin file1:    \n extern int sp;  \nextern double val[] \n;    \n void push(double f) { ... }   \n double pop(void) { ... }   \nin file2:   \nint sp = 0;  \n double val[maxval];  \nbecause the extern declarations in file1 lie ahead of and outside the function definitions, \nthey  \napply to all functions; one set of declarations suffices for all of file1. this sam e \norganization  \nwould also bee needed if the definition of sp and val followed their use in one file.   \n4.5 header files\n\nlet is now consider dividing the calculator program into several source files, as it might \nbe is  \neach of the components were substantially bigger. the main function would go in one \nfile,  \nwhich we will call main.c; push, pop, and their variables go into a second file, stack.c;   \ngetop goes into a third, getop.c. finally, getch and ungetch go into a fourth file, getch.c;  \nwe separate them from the others because they would come from a separatel y-compiled  \nlibrary in a realistic program.   \nthere is one more thing to worry about - the definitions and declarations shared a mong \nfiles.  \nas much as possible, we want to centralize this, so that there is only one copy to get  and \nkeep  \nright as the program evolves. accordingly, we will place this common material  in a \nheader  \nfile, calc.h, which will be included as necessary. (the #include line is descr ibed in \nsection  \n4.11.) the resulting program then looks like this:    \nthere is a tradeoff between the desire that each file have access only to the  information it  \nneeds for its job and the practical reality that it is harder to maintain m ore header files. \nup to  \nsome moderate program size, it is probably best to have one header file that cont ains\n\neverything that is to be shared between any two parts of the program; that is the decision \nwe  \nmade here. for a much larger program, more organization and more headers would be \nneeded.   \n4.6 static variables  \nthe variables sp and val in stack.c, and buf and bufp in getch.c, are for the private use of  \nthe functions in their respective source files, and are not meant to be accesse d by \nanything  \nelse. the static declaration, applied to an external variable or function, limit s the scope of  \nthat object to the rest of the source file being compiled. external static thus  provides a \nway  \nto hide names like buf and bufp in the getch-ungetch combination, which must be \nexternal  \nso they can be shared, yet which should not be visible to users of getch and ungetch.   \nstatic storage is specified by prefixing the normal declaration with the word st atic. if the  \ntwo routines and the two variables are compiled in one file, as in   \n static char buf[bufsize]; /* buffer for ungetch * \n/  \nstatic int bufp = 0; /* next free position in buf * \n/     \n int getch(void) { ... }    \n void ungetch(int c) { ... }  \nthen no other routine will be able to access buf and bufp, and those names will not \nconflict  \nwith the same names in other files of the same program. in the same way, the variables  \nthat  \npush and pop use for stack manipulation can be hidden, by declaring sp and val to be  \nstatic.   \nthe external static declaration is most often used for variables, but it can b e applied to  \nfunctions as well. normally, function names are global, visible to any part of the enti re  \nprogram. if a function is declared static, however, its name is invisible outside  of the file \nin  \nwhich it is declared.   \nthe static declaration can also be applied to internal variables. internal s tatic variables are  \nlocal to a particular function just as automatic variables are, but unlike auto matics, they  \nremain in existence rather than coming and going each time the function is activated. \nthis\n\nmeans that internal static variables provide private, permanent storage within a single  \nfunction.    \nexercise 4-11. modify getop so that it doesn''t need to use ungetch. hint: use an internal   \nstatic variable.   \n4.7 register variables  \na register declaration advises the compiler that the variable in questi on will be heavily  \nused. the idea is that register variables are to be placed in machine regi sters, which may  \nresult in smaller and faster programs. but compilers are free to ignore the a dvice.  \n \nthe register declaration looks like   \n register int x;  \nregister char c;\n\nand so on. the register declaration can only be applied to automatic variables and to the  \nformal parameters of a function. in this later case, it looks like  \n f(register unsigned m, register long n)  {   \n register int i;   ...   } \nin practice, there are restrictions on register variables, reflecting the r ealities of \nunderlying  \nhardware. only a few variables in each function may be kept in registers, and only cer tain  \ntypes are allowed. excess register declarations are harmless, however, sin ce the word  \nregister is ignored for excess or disallowed declarations. and it is not possibl e to take the  \naddress of a register variable (a topic covered in chapter 5), regardless of w hether the \nvariable  \nis actually placed in a register. the specific restrictions on number and type s of register  \nvariables vary from machine to machine.   \n4.8 block structure  \nc is not a block-structured language in the sense of pascal or similar languages , because  \nfunctions may not be defined within other functions. on the other hand, variables can be   \ndefined in a block-structured fashion within a function. declarations of variables  \n(including   \ninitializations) may follow the left brace that introduces any compound stateme nt, not just \nthe  \none that begins a function. variables declared in this way hide any identically name d  \nvariables in outer blocks, and remain in existence until the matching right brac e. for \nexample,  \nin   \n if (n > 0)  {  \nint i; /* declare a new i * \n/    \n for (i = 0; i < n; i++)  ...  } \nthe scope of the variable i is the ``true'''' branch of the if; this i is unrela ted to any i outside\n\nthe block. an automatic variable declared and initialized in a block is initialized each \ntime the   \nblock is entered.   \nautomatic variables, including formal parameters, also hide external vari ables and \nfunctions  \nof the same name. given the declarations  \n int x;  \nint y;    \n f(double x)  {  \ndouble y; } \nthen within the function f, occurrences of x refer to the parameter, which is a double; \noutside  \nf, they refer to the external int. the same is true of the variable y.   \nas a matter of style, it''s best to avoid variable names that conceal names  in an outer \nscope; the  \npotential for confusion and error is too great.   \n4.9 initialization\n\ninitialization has been mentioned in passing many times so far, but always peripherally to  \nsome other topic. this section summarizes some of the rules, now that we have discusse d \nthe  \nvarious storage classes.   \nin the absence of explicit initialization, external and static variables ar e guaranteed to be  \ninitialized to zero; automatic and register variables have undefined (i.e., ga rbage) initial  \nvalues.   \nscalar variables may be initialized when they are defined, by following the name wit h an  \nequals sign and an expression:   \n int x = 1;  \nchar squota = ''\\'''' \n;  \nlong day = 1000l * 60l * 60l * 24l; /* milliseconds/day * \n/    \nfor external and static variables, the initializer must be a constant expre ssion; the  \ninitialization is done once, conceptionally before the program begins execution. for \nautomatic  \nand register variables, the initializer is not restricted to being a const ant: it may be any  \nexpression involving previously defined values, even function calls. for example, the  \ninitialization of the binary search program in section 3.3 could be written as     \n int binsearch(int x, int v[], int n)   {   \n int low = 0;   \n int high = n - 1;   \nint mid;   ...   }  \ninstead of   \n int low, high, mid;   \nlow = 0;\n\nhigh = n - 1;  \nin effect, initialization of automatic variables are just shorthand for assignment \nstatements.  \nwhich form to prefer is largely a matter of taste. we have generally used expl icit  \nassignments, because initializers in declarations are harder to see and f urther away from \nthe  \npoint of use.   \nan array may be initialized by following its declaration with a list of initiali zers enclosed \nin  \nbraces and separated by commas. for example, to initialize an array days with t he \nnumber of  \ndays in each month:  \n int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }  \nwhen the size of the array is omitted, the compiler will compute the length by counting \nthe  \ninitializers, of which there are 12 in this case.   \nif there are fewer initializers for an array than the specified size, the o thers will be zero \nfor  \nexternal, static and automatic variables. it is an error to have too many ini tializers. there \nis no  \nway to specify repetition of an initializer, nor to initialize an element in th e middle of an \narray   \nwithout supplying all the preceding values as well.    \ncharacter arrays are a special case of initialization; a string may be us ed instead of the \nbraces  \nand commas notation:\n\nchar pattern = "ould";   \nis a shorthand for the longer but equivalent  \n char pattern[] = { ''o'', ''u'', ''l'', ''d'', ''\\0'' };  \nin this case, the array size is five (four characters plus the terminating ''\\0'').  \n \n4.10 recursion  \nc functions may be used recursively; that is, a function may call itself either di rectly or  \nindirectly. consider printing a number as a character string. as we mentioned bef ore, the  \ndigits are generated in the wrong order: low-order digits are available befor e high-order \ndigits,  \nbut they have to be printed the other way around.   \nthere are two solutions to this problem. on is to store the digits in an array as the y are  \ngenerated, then print them in the reverse order, as we did with itoa in section 3.6. the  \nalternative is a recursive solution, in which printd first calls its elf to cope with any \nleading  \ndigits, then prints the trailing digit. again, this version can fail on the lar gest negative  \nnumber.   \n #include <stdio.h>   \n /* printd: print n in decimal */    \n void printd(int n)    {   \n if (n < 0) {   \n putchar(''-'');   \nn = -n;  }  \nif (n / 10)  \n printd(n / 10);   \n putchar(n % 10 + ''0'');  }\n\nwhen a function calls itself recursively, each invocation gets a fresh set of all the \nautomatic   \nvariables, independent of the previous set. this in printd(123) the first print d receives the  \nargument n = 123. it passes 12 to a second printd, which in turn passes 1 to a third. the  \nthird-level printd prints 1, then returns to the second level. that printd prints 2, the n \nreturns  \nto the first level. that one prints 3 and terminates.   \nanother good example of recursion is quicksort, a sorting algorithm developed by c.a.r.  \nhoare in 1962. given an array, one element is chosen and the others partitioned in two  \nsubsets - those less than the partition element and those greater than or equa l to it. the \nsame  \nprocess is then applied recursively to the two subsets. when a subset has fewer  than two  \nelements, it doesn''t need any sorting; this stops the recursion.   \nour version of quicksort is not the fastest possible, but it''s one of the simplest. w e use the  \nmiddle element of each subarray for partitioning.  \n /* qsort: sort v[left]...v[right] into increasing order */   \n void qsort(int v[], int left, int right)   {   \n int i, last;    \n void swap(int v[], int i, int j);\n\nif (left >= right) /* do nothing if array contains */   \n return; /* fewer than two elements */  \nswap(v, left, (left + right)/2); /* move partition elem */  \nlast = left; /* to v[0] */  \nfor (i = left + 1; i <= right; i++) /* partition */   \n if (v[i] < v[left])   \n swap(v, ++last, i);  \nswap(v, left, last); /* restore partition elem */  \nqsort(v, left, last-1);  \nqsort(v, last+1, right);   } \nwe moved the swapping operation into a separate function swap because it occurs three \ntimes  \nin qsort.   \n /* swap: interchange v[i] and v[j] * \n/  \nvoid swap(int v[], int i, int j)  {     \nint temp;    \n temp = v[i] \n;  \nv[i] = v[j] \n;  \nv[j] = temp;    } \nthe standard library includes a version of qsort that can sort objects of any type.   \nrecursion may provide no saving in storage, since somewhere a stack of the values being  \nprocessed must be maintained. nor will it be faster. but recursive code is m ore compact, \nand  \noften much easier to write and understand than the non-recursive equivalent. recursi on is  \nespecially convenient for recursively defined data structures like trees , we will see a nice  \nexample in section 6.6.\n\nexercise 4-12. adapt the ideas of printd to write a recursive version of itoa; that is, \nconvert   \nan integer into a string by calling a recursive routine.   \nexercise 4-13. write a recursive version of the function reverse(s), which r everses the  \nstring s in place.   \n4.11 the c preprocessor  \nc provides certain language facilities by means of a preprocessor, which is \nconceptionally a  \nseparate first step in compilation. the two most frequently used features ar e #include, to  \ninclude the contents of a file during compilation, and #define, to replace a token by an   \narbitrary sequence of characters. other features described in this secti on include \nconditional  \ncompilation and macros with arguments.   \n4.11.1 file inclusion  \nfile inclusion makes it easy to handle collections of #defines and declarations ( among \nother  \nthings). any source line of the form  \n #include "filename"   \nor   \n #include <filename>     \nis replaced by the contents of the file filename. if the filename is quoted, se arching for the \nfile  \ntypically begins where the source program was found; if it is not found there, or if the \nname is\n\nenclosed in < and >, searching follows an implementation-defined rule to find the file. an  \nincluded file may itself contain #include lines.   \nthere are often several #include lines at the beginning of a source file, to include  \ncommon  \n#define statements and extern declarations, or to access the function prototype \ndeclarations  \nfor library functions from headers like <stdio.h>. (strictly speaking, these need not b e \nfiles;  \nthe details of how headers are accessed are implementation-dependent.)   \n#include is the preferred way to tie the declarations together for a large pr ogram. it  \nguarantees that all the source files will be supplied with the same definiti ons and variable  \ndeclarations, and thus eliminates a particularly nasty kind of bug. naturally, when an \nincluded  \nfile is changed, all files that depend on it must be recompiled.   \n4.11.2 macro substitution  \na definition has the form  \n #define name replacement text  \nit calls for a macro substitution of the simplest kind - subsequent occurrences of the  token  \nname will be replaced by the replacement text. the name in a #define has the sam e form \nas a  \nvariable name; the replacement text is arbitrary. normally the replace ment text is the rest \nof  \nthe line, but a long definition may be continued onto several lines by placing a \\ at the \nend of  \neach line to be continued. the scope of a name defined with #define is from its point of  \ndefinition to the end of the source file being compiled. a definition may use previous  \ndefinitions. substitutions are made only for tokens, and do not take place within quoted  \nstrings. for example, if yes is a defined name, there would be no substitution in  \nprintf("yes") or in yesman.   \nany name may be defined with any replacement text. for example  \n #define forever for (;;) /* infinite loop */  \ndefines a new word, forever, for an infinite loop.   \nit is also possible to define macros with arguments, so the replacement text can be  \ndifferent  \nfor different calls of the macro. as an example, define a macro called max:   \n #define max(a, b) ((a) > (b) ? (a) : (b))\n\nalthough it looks like a function call, a use of max expands into in-line code. each  \noccurrence  \nof a formal parameter (here a or b) will be replaced by the corresponding actual \nargument.  \nthus the line  \n x = max(p+q, r+s);   \nwill be replaced by the line   \n x = ((p+q) > (r+s) ? (p+q) : (r+s));  \nso long as the arguments are treated consistently, this macro will serve for any dat a type;  \nthere is no need for different kinds of max for different data types, as there w ould be with  \nfunctions.\n\nif you examine the expansion of max, you will notice some pitfalls. the expressions are  \nevaluated twice; this is bad if they involve side effects like increment  operators or input \nand  \noutput. for instance   \n max(i++, j++) /* wrong */ \nwill increment the larger twice. some care also has to be taken with paren theses to make \nsure  \nthe order of evaluation is preserved; consider what happens when the macro   \n #define square(x) x * x /* wrong */ \nis invoked as square(z+1).   \nnonetheless, macros are valuable. one practical example comes from <stdi o.h>, in which  \ngetchar and putchar are often defined as macros to avoid the run-time overhead of a   \nfunction call per character processed. the functions in <ctype.h> are also usually   \nimplemented as macros.   \nnames may be undefined with #undef, usually to ensure that a routine is really a \nfunction, not  \na macro:  \n #undef getchar  \n int getchar(void) { ... }   \nformal parameters are not replaced within quoted strings. if, however, a param eter name \nis   \npreceded by a # in the replacement text, the combination will be expanded into a quoted \nstring  \nwith the parameter replaced by the actual argument. this can be combined with strin g  \nconcatenation to make, for example, a debugging print macro:  \n #define dprint(expr) printf(#expr " = %g\\n", expr)   \nwhen this is invoked, as in   \n dprint(x/y)   \nthe macro is expanded into   \n printf("x/y" " = &g\\n", x/y);   \nand the strings are concatenated, so the effect is   \n printf("x/y = &g\\n", x/y);\n\nwithin the actual argument, each " is replaced by \\" and each \\ by \\\\, so the result is a \nlegal   \nstring constant.   \nthe preprocessor operator ## provides a way to concatenate actual arguments during \nmacro  \nexpansion. if a parameter in the replacement text is adjacent to a ##, the param eter is \nreplaced  \nby the actual argument, the ## and surrounding white space are removed, and the result is \nre- \nscanned. for example, the macro paste concatenates its two arguments:  \n #define paste(front, back) front ## back  \nso paste(name, 1) creates the token name1.   \nthe rules for nested uses of ## are arcane; further details may be found in appendix a.   \nexercise 4-14. define a macro swap(t,x,y) that interchanges two arguments of t ype t.  \n(block structure will help.)\n\n4.11.3 conditional inclusion  \nit is possible to control preprocessing itself with conditional statements that are evaluated  \nduring preprocessing. this provides a way to include code selectively, depending on the \nvalue  \nof conditions evaluated during compilation.   \nthe #if line evaluates a constant integer expression (which may not include sizeof, c asts, \nor  \nenum constants). if the expression is non-zero, subsequent lines until an #endif or #el if or  \n#else are included. (the preprocessor statement #elif is like else-if.) t he expression  \ndefined(name) in a #if is 1 if the name has been defined, and 0 otherwise.   \nfor example, to make sure that the contents of a file hdr.h are included only once, the  \ncontents of the file are surrounded with a conditional like this:   \n #if !defined(hdr)  \n#define hdr    \n /* contents of hdr.h go here */   \n #endif  \nthe first inclusion of hdr.h defines the name hdr; subsequent inclusions will find the \nname  \ndefined and skip down to the #endif. a similar style can be used to avoid including files   \nmultiple times. if this style is used consistently, then each header can i tself include any \nother   \nheaders on which it depends, without the user of the header having to deal with the  \ninterdependence.   \nthis sequence tests the name system to decide which version of a header to incl ude:  \n \n #if system == sysv  \n#define hdr "sysv.h"  \n#elif system == bsd  \n#define hdr "bsd.h"  \n#elif system == msdos  \n#define hdr "msdos.h"  \n#else    \n #define hdr "default.h"  \n#endif  \n#include hdr\n\nthe #ifdef and #ifndef lines are specialized forms that test whether a name is defined. \nthe  \nfirst example of #if above could have been written  \n #ifndef hdr  \n#define hdr    \n /* contents of hdr.h go here */   \n #endif\n\nchapter 5 - pointers and arrays   \na pointer is a variable that contains the address of a variable. pointers are much used in \nc,  \npartly because they are sometimes the only way to express a computation, and partly \nbecause  \nthey usually lead to more compact and efficient code than can be obtained in other ways.  \npointers and arrays are closely related; this chapter also explores  this relationship and \nshows  \nhow to exploit it.   \npointers have been lumped with the goto statement as a marvelous way to create \nimpossible- \nto-understand programs. this is certainly true when they are used carelessly, and it  is \neasy to  \ncreate pointers that point somewhere unexpected. with discipline, however, pointer s can \nalso  \nbe used to achieve clarity and simplicity. this is the aspect that we will try t o illustrate.  \n \nthe main change in ansi c is to make explicit the rules about how pointers can be  \nmanipulated, in effect mandating what good programmers already practice and good  \ncompilers already enforce. in addition, the type void * (pointer to void) replaces char  * as  \nthe proper type for a generic pointer.   \n5.1 pointers and addresses   \nlet us begin with a simplified picture of how memory is organized. a typical machine  \nhas an  \narray of consecutively numbered or addressed memory cells that may be manipulate d  \nindividually or in contiguous groups. one common situation is that any byte can be a \nchar, a  \npair of one-byte cells can be treated as a short integer, and four adjacent bytes for m a \nlong.  \na pointer is a group of cells (often two or four) that can hold an address. so if c is a c har \nand  \np is a pointer that points to it, we could represent the situation this way:    \nthe unary operator & gives the address of an object, so the statement   \n p = &c;  \nassigns the address of c to the variable p, and p is said to ``point to'''' c. the & operator \nonly  \napplies to objects in memory: variables and array elements. it cannot be applied t o  \nexpressions, constants, or register variables.\n\nthe unary operator * is the indirection or dereferencing operator; when applied to a  \npointer, it  \naccesses the object the pointer points to. suppose that x and y are integers and ip is a \npointer  \nto int. this artificial sequence shows how to declare a pointer and how to use & and * :  \n \n int x = 1, y = 2, z[10] \n;  \nint *ip; /* ip is a pointer to int * \n/\n\nip = &x; /* ip now points to x * \n/  \ny = *ip; /* y is now 1 * \n/  \n*ip = 0; /* x is now 0 * \n/  \nip = &z[0]; /* ip now points to z[0] * \n/    \nthe declaration of x, y, and z are what we''ve seen all along. the declaration of the \npointer ip,   \n int *ip;  \nis intended as a mnemonic; it says that the expression *ip is an int. the syntax of the  \ndeclaration for a variable mimics the syntax of expressions in which the variab le might  \nappear. this reasoning applies to function declarations as well. for example,   \n double *dp, atof(char *);  \nsays that in an expression *dp and atof(s) have values of double, and that the argument of  \natof is a pointer to char.   \nyou should also note the implication that a pointer is constrained to point to a particul ar \nkind  \nof object: every pointer points to a specific data type. (there is one exception:  a ``pointer \nto  \nvoid'''' is used to hold any type of pointer but cannot be dereferenced itself. we''ll come \nback to  \nit in section 5.11.)   \nif ip points to the integer x, then *ip can occur in any context where x could, so   \n *ip = *ip + 10;  \nincrements *ip by 10.   \nthe unary operators * and & bind more tightly than arithmetic operators, so the \nassignment  \n y = *ip + 1  \ntakes whatever ip points at, adds 1, and assigns the result to y, while   \n *ip += 1  \nincrements what ip points to, as do   \n ++*ip\n\nand   \n (*ip)++  \nthe parentheses are necessary in this last example; without them, the expression would  \nincrement ip instead of what it points to, because unary operators like * and ++ associat e \nright  \nto left.   \nfinally, since pointers are variables, they can be used without dereferencing. for \nexample, if  \niq is another pointer to int,   \n iq = ip  \ncopies the contents of ip into iq, thus making iq point to whatever ip pointed to.   \n5.2 pointers and function arguments  \nsince c passes arguments to functions by value, there is no direct way for the calle d \nfunction  \nto alter a variable in the calling function. for instance, a sorting routine might e xchange \ntwo  \nout-of-order arguments with a function called swap. it is not enough to write\n\nswap(a, b);  \nwhere the swap function is defined as   \n void swap(int x, int y) /* wrong * \n/  {  \nint temp;    \ntemp = x; \nx = y; \ny = temp;   } \nbecause of call by value, swap can''t affect the arguments a and b in the routine that called \nit.  \nthe function above swaps copies of a and b.   \nthe way to obtain the desired effect is for the calling program to pass pointers to  the \nvalues to  \nbe changed:  \n swap(&a, &b);  \nsince the operator & produces the address of a variable, &a is a pointer to a . in swap \nitself, the  \nparameters are declared as pointers, and the operands are accessed indirectly t hrough \nthem.  \n void swap(int *px, int *py) /* interchange *px and *py * \n/  {  \nint temp;    \n temp = *px;  \n*px = *py;  \n*py = temp;    }  \npictorially:\n\npointer arguments enable a function to access and change objects in the function that \ncalled it.  \nas an example, consider a function getint that performs free-format input conversion  by  \nbreaking a stream of characters into integer values, one integer per call. geti nt has to \nreturn  \nthe value it found and also signal end of file when there is no more input. these values \nhave  \nto be passed back by separate paths, for no matter what value is used for eof, that c ould \nalso  \nbe the value of an input integer.   \none solution is to have getint return the end of file status as its function value, w hile \nusing a  \npointer argument to store the converted integer back in the calling function. this is  the  \nscheme used by scanf as well; see section 7.4.   \nthe following loop fills an array with integers by calls to getint:   \n int n, array[size], getint(int *);   \n for (n = 0; n < size && getint(&array[n]) != eof; n++)  \n;  \neach call sets array[n] to the next integer found in the input and increments n. notice t hat \nit  \nis essential to pass the address of array[n] to getint. otherwise there is no wa y for getint  \nto communicate the converted integer back to the caller.   \nour version of getint returns eof for end of file, zero if the next input is not a number , \nand a  \npositive value if the input contains a valid number.   \n #include <ctype.h>\n\nint getch(void) \n;  \nvoid ungetch(int) \n;    \n /* getint: get next integer from input into *pn * \n/  \nint getint(int *pn)  {    \n int c, sign;   \n while (isspace(c = getch())) /* skip white space * \n/  \n;   \n if (!isdigit(c) && c != eof && c != ''+'' && c != ''-'')  {  \nungetch(c); /* it is not a number * \n/  \nreturn 0;      }  \nsign = (c == ''-'') ? -1 : 1;  \nif (c == ''+'' || c == ''-'' \n)    \n c = getch() \n;  \nfor (*pn = 0; isdigit(c), c = getch() \n)    \n *pn = 10 * *pn + (c - ''0'') \n;  \n*pn *= sign;  \nif (c != eof)    \n ungetch(c);\n\nreturn c;  } \nthroughout getint, *pn is used as an ordinary int variable. we have also used getch and  \nungetch (described in section 4.3) so the one extra character that must be read can be \npushed  \nback onto the input.   \nexercise 5-1. as written, getint treats a + or - not followed by a digit as a val id  \nrepresentation of zero. fix it to push such a character back on the input.   \nexercise 5-2. write getfloat, the floating-point analog of getint. what type does  \ngetfloat return as its function value?   \n5.3 pointers and arrays  \nin c, there is a strong relationship between pointers and arrays, strong enough that \npointers  \nand arrays should be discussed simultaneously. any operation that can be achieved by \narray  \nsubscripting can also be done with pointers. the pointer version will in general be  faster \nbut,  \nat least to the uninitiated, somewhat harder to understand.   \nthe declaration   \n int a[10];  \ndefines an array of size 10, that is, a block of 10 consecutive objects named a[0], a[1],   \n...,a[9].\n\nthe notation a[i] refers to the i-th element of the array. if pa is a pointer to an integer,  \ndeclared as   \n int *pa;   \nthen the assignment  \n pa = &a[0];  \nsets pa to point to element zero of a; that is, pa contains the address of a[0] .  \n  \nnow the assignment   \n x = *pa;  \nwill copy the contents of a[0] into x.   \nif pa points to a particular element of an array, then by definition pa+1 points to the next  \nelement, pa+i points i elements after pa, and pa-i points i elements before. thus, if  \npapoints to a[0],   \n *(pa+1)  \nrefers to the contents of a[1], pa+i is the address of a[i], and *(pa+i) is the  contents of  \na[i].     \nthese remarks are true regardless of the type or size of the variables in th e array a. the  \nmeaning of ``adding 1 to a pointer,'''' and by extension, all pointer arithmetic, is that  \npa+1points to the next object, and pa+i points to the i-th object beyond pa.\n\nthe correspondence between indexing and pointer arithmetic is very close. by definition, \nthe  \nvalue of a variable or expression of type array is the address of element zero of the array.  \nthus after the assignment  \n pa = &a[0];  \npa and a have identical values. since the name of an array is a synonym for the locat ion \nof the  \ninitial element, the assignment pa=&a[0] can also be written as   \n pa = a;  \nrather more surprising, at first sight, is the fact that a reference to a[ i] can also be written \nas  \n*(a+i). in evaluating a[i], c converts it to *(a+i) immediately; the two forms a re  \nequivalent. applying the operator & to both parts of this equivalence, it follows that \n&a[i] \nand a+i are also identical: a+i is the address of the i-th element beyond a. a s the other \nside  \nof this coin, if pa is a pointer, expressions might use it with a subscript; pa[i] is i dentical \nto  \n*(pa+i). in short, an array-and-index expression is equivalent to one written as a pointe r \nand  \noffset.   \nthere is one difference between an array name and a pointer that must be kept in mind. a   \npointer is a variable, so pa=a and pa++ are legal. but an array name is not a varia ble;  \nconstructions like a=pa and a++ are illegal.    \nwhen an array name is passed to a function, what is passed is the location of the initi al  \nelement. within the called function, this argument is a local variable, and s o an array \nname  \nparameter is a pointer, that is, a variable containing an address. we can use this f act to \nwrite  \nanother version of strlen, which computes the length of a string.  \n /* strlen: return length of string s */  \n int strlen(char *s)   {   \nint n;   \n for (n = 0; *s != ''\\0'', s++)  \nn++;\n\nreturn n;  } \nsince s is a pointer, incrementing it is perfectly legal; s++ has no effect on the character \nstring  \nin the function that called strlen, but merely increments strlen''s private copy of t he  \npointer. that means that calls like   \n strlen("hello, world"); /* string constant * \n/  \nstrlen(array); /* char array[100]; * \n/  \nstrlen(ptr); /* char *ptr; * \n/    \nall work.   \nas formal parameters in a function definition,   \n char s[];   \nand   \n char *s;  \nare equivalent; we prefer the latter because it says more explicitly that  the variable is a  \npointer. when an array name is passed to a function, the function can at its convenience\n\nbelieve that it has been handed either an array or a pointer, and manipulate it accordingly. \nit  \ncan even use both notations if it seems appropriate and clear.   \nit is possible to pass part of an array to a function, by passing a pointer to the beginning \nof the  \nsubarray. for example, if a is an array,  \n f(&a[2])   \nand   \n f(a+2)  \nboth pass to the function f the address of the subarray that starts at a[2]. within f, the   \nparameter declaration can read   \n f(int arr[]) { ... }   \nor   \n f(int *arr) { ... }  \nso as far as f is concerned, the fact that the parameter refers to part  of a larger array is of \nno  \nconsequence.    \nif one is sure that the elements exist, it is also possible to index backwards i n an array; p[-\n1],   \np[-2], and so on are syntactically legal, and refer to the elements that immediat ely \nprecede  \np[0]. of course, it is illegal to refer to objects that are not within the arr ay bounds.  \n \n5.4 address arithmetic  \nif p is a pointer to some element of an array, then p++ increments p to point to the ne xt  \nelement, and p+=i increments it to point i elements beyond where it currently does . these  \nand similar constructions are the simples forms of pointer or address arit hmetic.  \n \nc is consistent and regular in its approach to address arithmetic; its inte gration of \npointers,  \narrays, and address arithmetic is one of the strengths of the language. let us ill ustrate by  \nwriting a rudimentary storage allocator. there are two routines. the first, a lloc(n), returns \na  \npointer to n consecutive character positions, which can be used by the caller of alloc f or  \nstoring characters. the second, afree(p), releases the storage thus acquire d so it can be \nreused later. the routines are ``rudimentary'''' because the calls to afree  must be made in \nthe\n\nopposite order to the calls made on alloc. that is, the storage managed by alloc and afree  \nis a stack, or last-in, first-out. the standard library provides analogous functions call ed  \nmalloc and free that have no such restrictions; in section 8.7 we will show how they can  \nbe  \nimplemented.   \nthe easiest implementation is to have alloc hand out pieces of a large charact er array that \nwe  \nwill call allocbuf. this array is private to alloc and afree. since they deal i n pointers, not  \narray indices, no other routine need know the name of the array, which can be declared  \nstatic in the source file containing alloc and afree, and thus be invisible outside  it. in  \npractical implementations, the array may well not even have a name; it might ins tead be  \nobtained by calling malloc or by asking the operating system for a pointer to some \nunnamed  \nblock of storage.   \nthe other information needed is how much of allocbuf has been used. we use a pointer,  \ncalled allocp, that points to the next free element. when alloc is asked for n c haracters, it\n\nchecks to see if there is enough room left in allocbuf. if so, alloc returns the current value  \nof allocp (i.e., the beginning of the free block), then increments it by n to point to the next   \nfree area. if there is no room, alloc returns zero. afree(p) merely sets a llocp to p if p is  \ninside allocbuf.     \n#define allocsize 10000 /* size of available space */   \n static char allocbuf[allocsize]; /* storage for alloc * \n/  \nstatic char *allocp = allocbuf; /* next free position * \n/    \n char *alloc(int n) /* return pointer to n characters * \n/  {    \n if (allocbuf + allocsize - allocp >= n) { /* it fits */  \nallocp += n;  \nreturn allocp - n; /* old p */  \n} else /* not enough room * \n/   \nreturn 0;   }    \n void afree(char *p) /* free storage pointed to by p * \n/  {  \nif (p >= allocbuf && p < allocbuf + allocsize)  \nallocp = p;  }   \nin general a pointer can be initialized just as any other variable can, though norma lly the \nonly  \nmeaningful values are zero or an expression involving the address of previously define d \ndata  \nof appropriate type. the declaration   \n static char *allocp = allocbuf;  \ndefines allocp to be a character pointer and initializes it to point to the beginning of\n\nallocbuf, which is the next free position when the program starts. this could also have  \nbeen  \nwritten   \n static char *allocp = &allocbuf[0];   \nsince the array name is the address of the zeroth element.   \nthe test  \n if (allocbuf + allocsize - allocp >= n) { /* it fits */\n\nchecks if there''s enough room to satisfy a request for n characters. if there is, the new \nvalue of  \nallocp would be at most one beyond the end of allocbuf. if the request can be satisfied,  \nalloc returns a pointer to the beginning of a block of characters (notice the decla ration of \nthe  \nfunction itself). if not, alloc must return some signal that there is no space left. c \nguarantees  \nthat zero is never a valid address for data, so a return value of zero can be used to si gnal \nan  \nabnormal event, in this case no space.   \npointers and integers are not interchangeable. zero is the sole exception: the cons tant \nzero  \nmay be assigned to a pointer, and a pointer may be compared with the constant zero. the  \nsymbolic constant null is often used in place of zero, as a mnemonic to indicate more \nclearly  \nthat this is a special value for a pointer. null is defined in <stdio.h>. we will  use \nnull  \nhenceforth.   \ntests like  \n if (allocbuf + allocsize - allocp >= n) { /* it fits */   \nand     \n if (p >= allocbuf && p < allocbuf + allocsize) \nshow several important facets of pointer arithmetic. first, pointers may be c ompared \nunder  \ncertain circumstances. if p and q point to members of the same array, then relati ons like \n==,  \n!=, <, >=, etc., work properly. for example,  \n p < q  \nis true if p points to an earlier element of the array than q does. any pointer can be  \nmeaningfully compared for equality or inequality with zero. but the behavior is \nundefined for  \narithmetic or comparisons with pointers that do not point to members of the same  array.  \n(there is one exception: the address of the first element past the end of an arra y can be \nused in  \npointer arithmetic.)   \nsecond, we have already observed that a pointer and an integer may be added or \nsubtracted.  \nthe construction\n\np + n  \nmeans the address of the n-th object beyond the one p currently points to. this is true  \nregardless of the kind of object p points to; n is scaled according to the size of the objects \nppoints to, which is determined by the declaration of p. if an int is four bytes, for \nexample, the  \nint will be scaled by four.   \npointer subtraction is also valid: if p and q point to elements of the same array, and p <q, \nthen  \nq-p+1 is the number of elements from p to q inclusive. this fact can be used to write  yet  \nanother version of strlen:   \n /* strlen: return length of string s */   \n int strlen(char *s)   {   \n char *p = s;   \n while (*p != ''\\0'' \n)  \np++ \n;  \nreturn p - s;   }\n\nin its declaration, p is initialized to s, that is, to point to the first character of the string. in \nthe  \nwhile loop, each character in turn is examined until the ''\\0'' at the end is seen. be cause \nppoints to characters, p++ advances p to the next character each time, and p-s gives t he \nnumber  \nof characters advanced over, that is, the string length. (the number of characters  in the \nstring  \ncould be too large to store in an int. the header <stddef.h> defines a type ptrdiff_t t hat  \nis large enough to hold the signed difference of two pointer values. if we were being \ncautious,  \nhowever, we would use size_t for the return value of strlen, to match the standard l ibrary  \nversion. size_t is the unsigned integer type returned by the sizeof operator.   \npointer arithmetic is consistent: if we had been dealing with floats, whic h occupy more  \nstorage that chars, and if p were a pointer to float, p++ would advance to the next float .  \nthus we could write another version of alloc that maintains floats instead of char s, \nmerely  \nby changing char to float throughout alloc and afree. all the pointer manipulations  \nautomatically take into account the size of the objects pointed to.   \nthe valid pointer operations are assignment of pointers of the same type, adding or  \nsubtracting a pointer and an integer, subtracting or comparing two pointers to members  of \nthe  \nsame array, and assigning or comparing to zero. all other pointer arithmetic is il legal. it \nis not   \nlegal to add two pointers, or to multiply or divide or shift or mask them, or to add float or   \ndouble to them, or even, except for void *, to assign a pointer of one type to a pointer of   \nanother type without a cast.   \n5.5 character pointers and functions  \na string constant, written as  \n "i am a string"  \nis an array of characters. in the internal representation, the array is t erminated with the \nnull  \ncharacter ''\\0'' so that programs can find the end. the length in storage is thus one m ore \nthan  \nthe number of characters between the double quotes.   \nperhaps the most common occurrence of string constants is as arguments to functi ons, as \nin   \n printf("hello, world\\n");  \nwhen a character string like this appears in a program, access to it is throu gh a character  \npointer; printf receives a pointer to the beginning of the character array. that  is, a string\n\nconstant is accessed by a pointer to its first element.    \nstring constants need not be function arguments. if pmessage is declared as   \n char *pmessage;   \nthen the statement   \n pmessage = "now is the time";  \nassigns to pmessage a pointer to the character array. this is not a string copy; only \npointers  \nare involved. c does not provide any operators for processing an entire string of \ncharacters as  \na unit.   \nthere is an important difference between these definitions:\n\nchar amessage[] = "now is the time"; /* an array */  \n char *pmessage = "now is the time"; /* a pointer */  \namessage is an array, just big enough to hold the sequence of characters and ''\\0'' that  \ninitializes it. individual characters within the array may be changed but ame ssage will \nalways  \nrefer to the same storage. on the other hand, pmessage is a pointer, initialized to poi nt to \na  \nstring constant; the pointer may subsequently be modified to point elsewhere, but the \nresult is  \nundefined if you try to modify the string contents.    \nwe will illustrate more aspects of pointers and arrays by studying versions of tw o useful  \nfunctions adapted from the standard library. the first function is strcpy(s,t), whi ch copies  \nthe string t to the string s. it would be nice just to say s=t but this copies t he pointer, not \nthe  \ncharacters. to copy the characters, we need a loop. the array version first:   \n /* strcpy: copy t to s; array subscript version * \n/  \nvoid strcpy(char *s, char *t)  {     \nint i;    \ni = 0;  \nwhile ((s[i] = t[i]) != ''\\0'')  \ni++; } \nfor contrast, here is a version of strcpy with pointers:  \n /* strcpy: copy t to s; pointer version * \n/  \nvoid strcpy(char *s, char *t)  {    \nint i;   \ni = 0;  \n while ((*s = *t) != ''\\0'')  {\n\ns++  \n;  \nt++ \n;   } } \nbecause arguments are passed by value, strcpy can use the parameters s and t in any way \nit  \npleases. here they are conveniently initialized pointers, which are marched along t he \narrays a  \ncharacter at a time, until the ''\\0'' that terminates t has been copied int o s.  \n \nin practice, strcpy would not be written as we showed it above. experienced c \nprogrammers  \nwould prefer   \n /* strcpy: copy t to s; pointer version 2 * \n/  \nvoid strcpy(char *s, char *t)  {    \n while ((*s++ = *t++) != ''\\0'' \n)   \n;\n\n} \nthis moves the increment of s and t into the test part of the loop. the value of *t++ is the  \ncharacter that t pointed to before t was incremented; the postfix ++ doesn''t c hange t until  \nafter this character has been fetched. in the same way, the character is s tored into the old \ns  \nposition before s is incremented. this character is also the value that is co mpared against  \n''\\0'' to control the loop. the net effect is that characters are copied from t  to s, up and  \nincluding the terminating ''\\0''.   \nas the final abbreviation, observe that a comparison against ''\\0'' is redundant, since t he  \nquestion is merely whether the expression is zero. so the function would likely be writ ten \nas   \n /* strcpy: copy t to s; pointer version 3 * \n/  \nvoid strcpy(char *s, char *t)  {    \n while (*s++ = *t++ \n)  \n; }    \nalthough this may seem cryptic at first sight, the notational convenience is conside rable, \nand   \nthe idiom should be mastered, because you will see it frequently in c programs.   \nthe strcpy in the standard library (<string.h>) returns the target string as its  function  \nvalue.   \nthe second routine that we will examine is strcmp(s,t), which compares the char acter  \nstrings s and t, and returns negative, zero or positive if s is lexicographically less  than, \nequal  \nto, or greater than t. the value is obtained by subtracting the characters at the fir st \nposition  \nwhere s and t disagree.   \n /* strcmp: return <0 if s<t, 0 if s==t, >0 if s>t * \n/  \nint strcmp(char *s, char *t)  {\n\nint i;    \n for (i = 0; s[i] == t[i]; i++)  \nif (s[i] == ''\\0'')  \nreturn 0;  \nreturn s[i] - t[i];  } \nthe pointer version of strcmp:   \n /* strcmp: return <0 if s<t, 0 if s==t, >0 if s>t * \n/  \nint strcmp(char *s, char *t)  {    \n for ( ; *s == *t; s++, t++)  \nif (*s == ''\\0'')  \nreturn 0;  \nreturn *s - *t;  } \nsince ++ and -- are either prefix or postfix operators, other combinations of * and ++ and \n- \noccur, although less frequently. for example,   \n *--p  \ndecrements p before fetching the character that p points to. in fact, the pair of e xpressions \n \n *p++ = val; /* push val onto stack * \n/  \nval = *--p; /* pop top of stack into val * \n/\n\nare the standard idiom for pushing and popping a stack; see section 4.3.   \nthe header <string.h> contains declarations for the functions mentioned in this section, \nplus  \na variety of other string-handling functions from the standard library.   \nexercise 5-3. write a pointer version of the function strcat that we showed in chapt er 2:  \nstrcat(s,t) copies the string t to the end of s.   \nexercise 5-4. write the function strend(s,t), which returns 1 if the string t occur s at the  \nend of the string s, and zero otherwise.   \nexercise 5-5. write versions of the library functions strncpy, strncat, and strncm p, which  \noperate on at most the first n characters of their argument strings. for example,  \nstrncpy(s,t,n) copies at most n characters of t to s. full descriptions are  in appendix b.  \n \nexercise 5-6. rewrite appropriate programs from earlier chapters and e xercises with \npointers  \ninstead of array indexing. good possibilities include getline (chapters 1 and 4), atoi, it oa,  \nand their variants (chapters 2, 3, and 4), reverse (chapter 3), and strindex and \ngetop(chapter 4).   \n5.6 pointer arrays; pointers to pointers  \nsince pointers are variables themselves, they can be stored in arrays j ust as other \nvariables   \ncan. let us illustrate by writing a program that will sort a set of text lines i nto alphabetic  \norder, a stripped-down version of the unix program sort.    \nin chapter 3, we presented a shell sort function that would sort an array of integer s, and \nin  \nchapter 4 we improved on it with a quicksort. the same algorithms will work, except \nthat  \nnow we have to deal with lines of text, which are of different lengths, and which, unlike  \nintegers, can''t be compared or moved in a single operation. we need a data representa tion \nthat  \nwill cope efficiently and conveniently with variable-length text lines.   \nthis is where the array of pointers enters. if the lines to be sorted are stor ed end-to-end in \none  \nlong character array, then each line can be accessed by a pointer to its first char acter. the  \npointers themselves can bee stored in an array. two lines can be compared by passing \ntheir  \npointers to strcmp. when two out-of-order lines have to be exchanged, the pointers in the   \npointer array are exchanged, not the text lines themselves.\n\nthis eliminates the twin problems of complicated storage management and high overhead \nthat  \nwould go with moving the lines themselves.   \nthe sorting process has three steps:\n\nread all the lines of input  \nsort them  \nprint them in order   \nas usual, it''s best to divide the program into functions that match this natural division, \nwith  \nthe main routine controlling the other functions. let us defer the sorting step for a \nmoment,  \nand concentrate on the data structure and the input and output.   \nthe input routine has to collect and save the characters of each line, and build an arra y of  \npointers to the lines. it will also have to count the number of input lines, since tha t  \ninformation is needed for sorting and printing. since the input function can only cope \nwith a  \nfinite number of input lines, it can return some illegal count like -1 if too much input is   \npresented.   \nthe output routine only has to print the lines in the order in which they appear in the \narray of  \npointers.   \n #include <stdio.h>  \n#include <string.h>      \n #define maxlines 5000 /* max #lines to be sorted */   \n char *lineptr[maxlines]; /* pointers to text lines */   \n int readlines(char *lineptr[], int nlines) \n;  \nvoid writelines(char *lineptr[], int nlines) \n;    \n void qsort(char *lineptr[], int left, int right);   \n /* sort input lines * \n/  \nmain( \n)  {\n\nint nlines; /* number of input lines read */    \n if ((nlines = readlines(lineptr, maxlines)) >= 0)  {  \nqsort(lineptr, 0, nlines-1) \n;  \nwritelines(lineptr, nlines) \n;  \nreturn 0;    \n} else  {  \nprintf("error: input too big to sort\\n") \n;  \nreturn 1;    } }    \n #define maxlen 1000 /* max length of any input line * \n/  \nint getline(char *, int) \n;   \nchar *alloc(int)  \n;    \n /* readlines: read input lines * \n/  \nint readlines(char *lineptr[], int maxlines)  {    \n int len, nlines;  \nchar *p, line[maxlen] \n;   \n nlines = 0;  \nwhile ((len = getline(line, maxlen)) > 0)  \nif (nlines >= maxlines || p = alloc(len) == null)  \nreturn -1;  \nelse\n\n{\n\nline[len-1] = ''\\0''; /* delete newline * \n/  \nstrcpy(p, line) \n;  \nlineptr[nlines++] = p;    }  \nreturn nlines;  }    \n /* writelines: write output lines * \n/  \nvoid writelines(char *lineptr[], int nlines)  {    \nint i;   \n for (i = 0; i < nlines; i++)  \nprintf("%s\\n", lineptr[i]);  } \nthe function getline is from section 1.9.    \nthe main new thing is the declaration for lineptr:    \n char *lineptr[maxlines]  \nsays that lineptr is an array of maxlines elements, each element of which is a pointer \nto a  \nchar. that is, lineptr[i] is a character pointer, and *lineptr[i] is the cha racter it points  \nto, the first character of the i-th saved text line.   \nsince lineptr is itself the name of an array, it can be treated as a pointer i n the same \nmanner  \nas in our earlier examples, and writelines can be written instead as   \n /* writelines: write output lines * \n/  \nvoid writelines(char *lineptr[], int nlines)  {    \n while (nlines-- > 0)  \nprintf("%s\\n", *lineptr++);\n\n}  \ninitially, *lineptr points to the first line; each element advances it to the next line pointer  \nwhile nlines is counted down.   \nwith input and output under control, we can proceed to sorting. the quicksort from \nchapter 4  \nneeds minor changes: the declarations have to be modified, and the comparison operation   \nmust be done by calling strcmp. the algorithm remains the same, which gives us some  \nconfidence that it will still work.   \n /* qsort: sort v[left]...v[right] into increasing order * \n/  \nvoid qsort(char *v[], int left, int right)  {    \n int i, last;  \nvoid swap(char *v[], int i, int j) \n;    \n if (left >= right) /* do nothing if array contains */   \n return; /* fewer than two elements * \n/  \nswap(v, left, (left + right)/2)  \n;   \nlast = left;  \nfor (i = left+1; i <= right; i++ \n)    \n if (strcmp(v[i], v[left]) < 0)  \n swap(v, ++last, i) \n;  \nswap(v, left, last) \n;  \nqsort(v, left, last-1) \n;\n\nqsort(v, last+1, right) \n;  }   \nsimilarly, the swap routine needs only trivial changes:  \n /* swap: interchange v[i] and v[j] * \n/  \nvoid swap(char *v[], int i, int j)  {    \n char *temp;   \n temp = v[i] \n;  \nv[i] = v[j] \n;  \nv[j] = temp;    } \nsince any individual element of v (alias lineptr) is a character pointer, temp must be also, \nso   \none can be copied to the other.    \nexercise 5-7. rewrite readlines to store lines in an array supplied by main, rathe r than  \ncalling alloc to maintain storage. how much faster is the program?   \n5.7 multi-dimensional arrays  \nc provides rectangular multi-dimensional arrays, although in practice the y are much less \nused  \nthan arrays of pointers. in this section, we will show some of their propertie s.  \n \nconsider the problem of date conversion, from day of the month to day of the year and \nvice  \nversa. for example, march 1 is the 60th day of a non-leap year, and the 61st day of a leap  \nyear. let us define two functions to do the conversions: day_of_year converts the month \nand  \nday into the day of the year, and month_day converts the day of the year into the month \nand  \nday. since this latter function computes two values, the month and day arguments will be  \npointers:\n\nmonth_day(1988, 60, &m, &d)   \nsets m to 2 and d to 29 (february 29th).   \nthese functions both need the same information, a table of the number of days in each \nmonth  \n(``thirty days hath september ...''''). since the number of days per month differs for leap \nyears  \nand non-leap years, it''s easier to separate them into two rows of a two-dimensional array \nthan  \nto keep track of what happens to february during computation. the array and the \nfunctions  \nfor performing the transformations are as follows:   \n static char daytab[2][13] =  {  {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} ,  {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}    \n};  \n /* day_of_year: set day of year from month & day * \n/  \nint day_of_year(int year, int month, int day)  {      \n int i, leap;  \nleap = year%4 == 0 && year%100 != 0 || year%400 == 0;  \nfor (i = 1; i < month; i++ \n)    \n day += daytab[leap][i] \n;  \nreturn day;  }\n\n/* month_day: set month, day from day of year */   \n void month_day(int year, int yearday, int *pmonth, int *pday)   {   \n int i, leap;   \n leap = year%4 == 0 && year%100 != 0 || year%400 == 0;   \n for (i = 1; yearday > daytab[leap][i]; i++)   \n yearday -= daytab[leap][i];   \n *pmonth = i;   \n *pday = yearday;   } \nrecall that the arithmetic value of a logical expression, such as the one for leap, is either \nzero  \n(false) or one (true), so it can be used as a subscript of the array daytab.   \nthe array daytab has to be external to both day_of_year and month_day, so they can both  \nuse it. we made it char to illustrate a legitimate use of char for storing sm all non-\ncharacter  \nintegers.   \ndaytab is the first two-dimensional array we have dealt with. in c, a two-dimensi onal \narray is  \nreally a one-dimensional array, each of whose elements is an array. hence subscri pts are  \nwritten as  \n daytab[i][j] /* [row][col] */   \nrather than   \n daytab[i,j] /* wrong */ \nother than this notational distinction, a two-dimensional array can be treated in m uch the  \nsame way as in other languages. elements are stored by rows, so the rightmost subscript , \nor  \ncolumn, varies fastest as elements are accessed in storage order.   \nan array is initialized by a list of initializers in braces; each row of a  two-dimensional \narray is\n\ninitialized by a corresponding sub-list. we started the array daytab with a column of zero \nso   \nthat month numbers can run from the natural 1 to 12 instead of 0 to 11. since space is not \nat a  \npremium here, this is clearer than adjusting the indices.   \nif a two-dimensional array is to be passed to a function, the parameter declar ation in the  \nfunction must include the number of columns; the number of rows is irrelevant, since \nwhat is  \npassed is, as before, a pointer to an array of rows, where each row is an array of 13 ints. \nin  \nthis particular case, it is a pointer to objects that are arrays of 13 ints. thu s if the array  \ndaytab is to be passed to a function f, the declaration of f would be:   \n f(int daytab[2][13]) { ... }   \nit could also be  \n f(int daytab[][13]) { ... }   \nsince the number of rows is irrelevant, or it could be  \n f(int (*daytab)[13]) { ... }  \nwhich says that the parameter is a pointer to an array of 13 integers. the parenthe ses are  \nnecessary since brackets [] have higher precedence than *. without parentheses, the  \ndeclaration     \n int *daytab[13]\n\nis an array of 13 pointers to integers. more generally, only the first dimension (subscript) \nof  \nan array is free; all the others have to be specified.   \nsection 5.12 has a further discussion of complicated declarations.   \nexercise 5-8. there is no error checking in day_of_year or month_day. remedy this \ndefect.   \n5.8 initialization of pointer arrays  \nconsider the problem of writing a function month_name(n), which returns a pointer to a  \ncharacter string containing the name of the n-th month. this is an ideal application fo r an  \ninternal static array. month_name contains a private array of character s trings, and returns \na  \npointer to the proper one when called. this section shows how that array of names is  \ninitialized.   \nthe syntax is similar to previous initializations:   \n /* month_name: return name of n-th month */   \n char *month_name(int n)   {    \n static char *name[] = {    \n "illegal month",   \n "january", "february", "march",   \n "april", "may", "june",   \n "july", "august", "september",  \n "october", "november", "december"   \n};   \n return (n < 1 || n > 12) ? name[0] : name[n];  } \nthe declaration of name, which is an array of character pointers, is the same as  lineptr in \nthe  \nsorting example. the initializer is a list of character strings; eac h is assigned to the\n\ncorresponding position in the array. the characters of the i-th string are placed  \nsomewhere,  \nand a pointer to them is stored in name[i]. since the size of the array name is not \nspecified,  \nthe compiler counts the initializers and fills in the correct number.   \n5.9 pointers vs. multi-dimensional arrays  \nnewcomers to c are sometimes confused about the difference between a two-\ndimensional  \narray and an array of pointers, such as name in the example above. given the definitions  \n int a[10][20];  \n int *b[10];  \nthen a[3][4] and b[3][4] are both syntactically legal references to a single int. but a is a  \ntrue two-dimensional array: 200 int-sized locations have been set aside, and the \nconventional  \nrectangular subscript calculation 20 * row +col is used to find the element a[row ,col]. for \nb,  \nhowever, the definition only allocates 10 pointers and does not initialize them; \ninitialization  \nmust be done explicitly, either statically or with code. assuming that each element  of b \ndoes  \npoint to a twenty-element array, then there will be 200 ints set aside, plus ten cel ls for the  \npointers. the important advantage of the pointer array is that the rows of the arra y may \nbe of   \ndifferent lengths. that is, each element of b need not point to a twenty-element vect or; \nsome   \nmay point to two elements, some to fifty, and some to none at all.\n\nalthough we have phrased this discussion in terms of integers, by far the most frequent \nuse of  \narrays of pointers is to store character strings of diverse lengths, as in the  function  \nmonth_name. compare the declaration and picture for an array of pointers:  \n char *name[] = { "illegal month", "jan", "feb", "mar" };    \nwith those for a two-dimensional array:  \n char aname[][15] = { "illegal month", "jan", "feb", "mar" };    \nexercise 5-9. rewrite the routines day_of_year and month_day with pointers instead of   \nindexing.   \n5.10 command-line arguments  \nin environments that support c, there is a way to pass command-line arguments or \nparameters  \nto a program when it begins executing. when main is called, it is called with two \narguments.  \nthe first (conventionally called argc, for argument count) is the number of comm and-line  \narguments the program was invoked with; the second (argv, for argument vector) is a \npointer  \nto an array of character strings that contain the arguments, one per string. we cus tomarily \nuse  \nmultiple levels of pointers to manipulate these character strings.   \nthe simplest illustration is the program echo, which echoes its command-line ar guments \non a  \nsingle line, separated by blanks. that is, the command  \n echo hello, world   \nprints the output   \n hello, world  \nby convention, argv[0] is the name by which the program was invoked, so argc is at least 1.  \nif argc is 1, there are no command-line arguments after the program name. in the \nexample  \nabove, argc is 3, and argv[0], argv[1], and argv[2] are "echo", "hello,", and "world"  \nrespectively. the first optional argument is argv[1] and the last is argv[argc- 1];  \nadditionally, the standard requires that argv[argc] be a null pointer.\n\nthe first version of echo treats argv as an array of character pointers:   \n #include <stdio.h>   \n /* echo command-line arguments; 1st version * \n/  \nmain(int argc, char *argv[] \n)  {    \nint i;   \n for (i = 1; i < argc; i++)   \n printf("%s%s", argv[i], (i < argc-1) ? " " : "") \n;  \nprintf("\\n") \n;  \nreturn 0;   } \nsince argv is a pointer to an array of pointers, we can manipulate the pointer rather than  \nindex the array. this next variant is based on incrementing argv, which is a pointer to  \npointer   \nto char, while argc is counted down:   \n #include <stdio.h>   \n /* echo command-line arguments; 2nd version * \n/  \nmain(int argc, char *argv[] \n)  {    \n while (--argc > 0)   \n printf("%s%s", *++argv, (argc > 1) ? " " : "") \n;  \nprintf("\\n") \n;  \nreturn 0;\n\n} \nsince argv is a pointer to the beginning of the array of argument strings, incrementing it by 1  \n(++argv) makes it point at the original argv[1] instead of argv[0]. each successive  \nincrement moves it along to the next argument; *argv is then the pointer to that ar gument. \nat  \nthe same time, argc is decremented; when it becomes zero, there are no argume nts left to  \nprint.   \nalternatively, we could write the printf statement as   \n printf((argc > 1) ? "%s " : "%s", *++argv);  \nthis shows that the format argument of printf can be an expression too.   \nas a second example, let us make some enhancements to the pattern-finding program \nfrom  \nsection 4.1. if you recall, we wired the search pattern deep into the program, an \nobviously  \nunsatisfactory arrangement. following the lead of the unix program grep, let us enhanc e \nthe  \nprogram so the pattern to be matched is specified by the first argument on the command \nline.\n\n#include <stdio.h>  \n#include <string.h>  \n#define maxline 1000    \n int getline(char *line, int max);   \n /* find: print lines that match pattern from 1st arg * \n/  \nmain(int argc, char *argv[] \n)  {    \n char line[maxline] \n;  \nint found = 0;    \n if (argc != 2)  \nprintf("usage: find pattern\\n") \n;  \nelse  \nwhile (getline(line, maxline) > 0)      \n if (strstr(line, argv[1]) != null) {  \nprintf("%s", line);  \nfound++;  }  \nreturn found;  } \nthe standard library function strstr(s,t) returns a pointer to the first occurrence of the  \nstring t in the string s, or null if there is none. it is declared in <string. h>.  \n \nthe model can now be elaborated to illustrate further pointer constructions. suppose we \nwant  \nto allow two optional arguments. one says ``print all the lines except those  that match the  \npattern;'''' the second says ``precede each printed line by its line number.''''   \na common convention for c programs on unix systems is that an argument that begins \nwith  \na minus sign introduces an optional flag or parameter. if we choose -x (for ``except'' '') to  \nsignal the inversion, and -n (``number'''') to request line numbering, then the command\n\nfind -x -npattern   \nwill print each line that doesn''t match the pattern, preceded by its line number.  \n \noptional arguments should be permitted in any order, and the rest of the program should \nbe  \nindependent of the number of arguments that we present. furthermore, it is convenien t \nfor  \nusers if option arguments can be combined, as in   \n find -nx pattern   \nhere is the program:   \n #include <stdio.h>  \n#include <string.h>  \n#define maxline 1000    \n int getline(char *line, int max);   \n /* find: print lines that match pattern from 1st arg * \n/  \nmain(int argc, char *argv[] \n)   {     \n char line[maxline] \n;  \nlong lineno = 0;  \nint c, except = 0, number = 0, found = 0;    \n while (--argc > 0 && (*++argv)[0] == ''-'')\n\nwhile (c = *++argv[0] \n)  \nswitch (c)  {  \ncase ''x'' \n:    \n except = 1; \nbreak;   \n case ''n'' \n:  \nnumber = 1; \nbreak;   \n default:  \nprintf("find: illegal option %c\\n", c);  \nargc = 0; \nfound = -1; \nbreak;  }   \nif (argc != 1)   \nprintf("usage: find -x -n pattern\\n") \n;  \nelse    \n while (getline(line, maxline) > 0) {  \nlineno++;  \nif ((strstr(line, *argv) != null) != except) {   \n if (number)   \n printf("%ld:", lineno);  \nprintf("%s", line);  \nfound++;  } }  \nreturn found;  }\n\nargc is decremented and argv is incremented before each optional argument. at the end \nof   \nthe loop, if there are no errors, argc tells how many arguments remain unprocessed and \nargv  \npoints to the first of these. thus argc should be 1 and *argv should point at the pattern.  \nnotice that *++argv is a pointer to an argument string, so (*++argv)[0] is its fi rst \ncharacter.  \n(an alternate valid form would be **++argv.) because [] binds tighter than * and ++, the  \nparentheses are necessary; without them the expression would be taken as *++(ar gv[0]). \nin  \nfact, that is what we have used in the inner loop, where the task is to walk along a \nspecific  \nargument string. in the inner loop, the expression *++argv[0] increments the pointer  \nargv[0]!   \nit is rare that one uses pointer expressions more complicated than these; in s uch cases,  \nbreaking them into two or three steps will be more intuitive.   \nexercise 5-10. write the program expr, which evaluates a reverse polish expres sion from \nthe  \ncommand line, where each operator or operand is a separate argument. for example,   \n expr 2 3 4 + *  \nevaluates 2 * (3+4).    \nexercise 5-11. modify the program entab and detab (written as exercises in chapter 1)  to  \naccept a list of tab stops as arguments. use the default tab settings if there  are no \narguments.    \nexercise 5-12. extend entab and detab to accept the shorthand   \n entab -m +n   \nto mean tab stops every n columns, starting at column m. choose convenient (for the \nuser)  \ndefault behavior.\n\nexercise 5-13. write the program tail, which prints the last n lines of its input. by default, \nn  \nis set to 10, let us say, but it can be changed by an optional argument so that   \n tail -n   \nprints the last n lines. the program should behave rationally no matter how unreas onable \nthe  \ninput or the value of n. write the program so it makes the best use of available storage ; \nlines  \nshould be stored as in the sorting program of section 5.6, not in a two-dimensional array \nof  \nfixed size.   \n5.11 pointers to functions  \nin c, a function itself is not a variable, but it is possible to define pointers to functi ons, \nwhich  \ncan be assigned, placed in arrays, passed to functions, returned by functions, and so on. \nwe  \nwill illustrate this by modifying the sorting procedure written earlier in thi s chapter so \nthat if  \nthe optional argument -n is given, it will sort the input lines numerically inst ead of  \nlexicographically.   \na sort often consists of three parts -a comparison that determines the ordering of  any pair \nof  \nobjects, an exchange that reverses their order, and a sorting algorithm that makes \ncomparisons  \nand exchanges until the objects are in order. the sorting algorithm is independent of the   \ncomparison and exchange operations, so by passing different comparison and exchange  \nfunctions to it, we can arrange to sort by different criteria. this is the approach t aken in \nour  \nnew sort.   \nlexicographic comparison of two lines is done by strcmp, as before; we will also need a   \nroutine numcmp that compares two lines on the basis of numeric value and returns the  \nsame  \nkind of condition indication as strcmp does. these functions are declared ahead of main \nand  \na pointer to the appropriate one is passed to qsort. we have skimped on error processing \nfor  \narguments, so as to concentrate on the main issues.   \n #include <stdio.h>  \n#include <string.h>\n\n#define maxlines 5000 /* max #lines to be sorted * \n/  \nchar *lineptr[maxlines]; /* pointers to text lines * \n/    \n int readlines(char *lineptr[], int nlines) \n;  \nvoid writelines(char *lineptr[], int nlines) \n;    \n void qsort(void *lineptr[], int left, int right,  \nint (*comp)(void *, void *)) \n;  \nint numcmp(char *, char *) \n;    \n /* sort input lines * \n/  \nmain(int argc, char *argv[] \n)  {      \n int nlines; /* number of input lines read * \n/  \nint numeric = 0; /* 1 if numeric sort * \n/    \n if (argc > 1 && strcmp(argv[1], "-n") == 0)  \nnumeric = 1;  \nif ((nlines = readlines(lineptr, maxlines)) >= 0) {  \nqsort((void**) lineptr, 0, nlines-1,  \n(int (*)(void*,void*))(numeric ? numcmp : strcmp));  \nwritelines(lineptr, nlines);\n\nreturn 0;   \n} else  {  \nprintf("input too big to sort\\n") \n;  \nreturn 1;    } } \nin the call to qsort, strcmp and numcmp are addresses of functions. since they are known \nto  \nbe functions, the & is not necessary, in the same way that it is not needed before an array  \nname.   \nwe have written qsort so it can process any data type, not just character strings . as \nindicated  \nby the function prototype, qsort expects an array of pointers, two integers, and a function  \nwith two pointer arguments. the generic pointer type void * is used for the pointer  \narguments. any pointer can be cast to void * and back again without loss of information, \nso  \nwe can call qsort by casting arguments to void *. the elaborate cast of the function  \nargument casts the arguments of the comparison function. these will generally have no \neffect   \non actual representation, but assure the compiler that all is well.   \n /* qsort: sort v[left]...v[right] into increasing order * \n/  \nvoid qsort(void *v[], int left, int right,  \nint (*comp)(void *, void *) \n)  {  \nint i, last;    \n void swap(void *v[], int, int);   \n if (left >= right) /* do nothing if array contains */   \n return; /* fewer than two elements * \n/  \nswap(v, left, (left + right)/2) \n;  \nlast = left;\n\nfor (i = left+1; i <= right; i++  \n)   \n if ((*comp)(v[i], v[left]) < 0)  \n swap(v, ++last, i) \n;  \nswap(v, left, last) \n;  \nqsort(v, left, last-1, comp) \n;  \nqsort(v, last+1, right, comp) \n;    } \nthe declarations should be studied with some care. the fourth parameter of qsort is  \n int (*comp)(void *, void *) \nwhich says that comp is a pointer to a function that has two void * arguments and returns \nan  \nint.   \nthe use of comp in the line   \n if ((*comp)(v[i], v[left]) < 0)   \nis consistent with the declaration: comp is a pointer to a function, *comp is the function, \nand   \n (*comp)(v[i], v[left])   \nis the call to it. the parentheses are needed so the components are correctly  associated;  \nwithout them,  \n int *comp(void *, void *) /* wrong */  \nsays that comp is a function returning a pointer to an int, which is very different.\n\nwe have already shown strcmp, which compares two strings. here is numcmp, which  \ncompares two strings on a leading numeric value, computed by calling atof:   \n #include <stdlib.h>   \n /* numcmp: compare s1 and s2 numerically */   \n int numcmp(char *s1, char *s2)   {   \n double v1, v2;   \n v1 = atof(s1);   \n v2 = atof(s2);   \n if (v1 < v2)   \n return -1;  \nelse if (v1 > v2)  \nreturn 1;  \nelse  \nreturn 0;  }  \nthe swap function, which exchanges two pointers, is identical to what we presented  \nearlier in  \nthe chapter, except that the declarations are changed to void *.   \n void swap(void *v[], int i, int j;)   {   \n void *temp;   \n temp = v[i];   \n v[i] = v[j];   \n v[j] = temp;   } \na variety of other options can be added to the sorting program; some make challenging  \nexercises.\n\nexercise 5-14. modify the sort program to handle a -r flag, which indicates sorting in \nreverse   \n(decreasing) order. be sure that -r works with -n.   \nexercise 5-15. add the option -f to fold upper and lower case together, so that case  \ndistinctions are not made during sorting; for example, a and a compare equal.   \nexercise 5-16. add the -d (``directory order'''') option, which makes comparisons only  on  \nletters, numbers and blanks. make sure it works in conjunction with -f.   \nexercise 5-17. add a field-searching capability, so sorting may bee done on fields with in  \nlines, each field sorted according to an independent set of options. (the index for this book  \nwas sorted with -df for the index category and -n for the page numbers.)   \n5.12 complicated declarations  \nc is sometimes castigated for the syntax of its declarations, particularl y ones that involve  \npointers to functions. the syntax is an attempt to make the declaration and the use ag ree; \nit  \nworks well for simple cases, but it can be confusing for the harder ones, because \ndeclarations  \ncannot be read left to right, and because parentheses are over-used. the differenc e \nbetween   \n int *f(); /* f: function returning pointer to int */    \nand\n\nint (*pf)(); /* pf: pointer to function returning int */  \nillustrates the problem: * is a prefix operator and it has lower precedence than (), so  \nparentheses are necessary to force the proper association.   \nalthough truly complicated declarations rarely arise in practice, it is impor tant to know \nhow  \nto understand them, and, if necessary, how to create them. one good way to synthesize  \ndeclarations is in small steps with typedef, which is discussed in section 6.7. a s an  \nalternative, in this section we will present a pair of programs that conver t from valid c to \na  \nword description and back again. the word description reads left to right.   \nthe first, dcl, is the more complex. it converts a c declaration into a word descrip tion, as \nin  \nthese examples:   \nchar **argv  \n argv: pointer to char  \nint (*daytab)[13]  \n daytab: pointer to array[13] of int  \nint *daytab[13]   \n daytab: array[13] of pointer to int   \nvoid *comp()   \n comp: function returning pointer to void  \nvoid (*comp)()  \n comp: pointer to function returning void  \nchar (*(*x())[])()   \n x: function returning pointer to array[] of  \npointer to function returning char  \nchar (*(*x[3])())[5]   \n x: array[3] of pointer to function returning  \npointer to array[5] of char  \ndcl is based on the grammar that specifies a declarator, which is spelled out pr ecisely in  \nappendix a, section 8.5; this is a simplified form:   \ndcl: optional *''s direct-dcl   \ndirect-dcl name\n\n(dcl)   \ndirect-dcl()   \ndirect-dcl[optional size]   \nin words, a dcl is a direct-dcl, perhaps preceded by *''s. a direct-dcl is a name, or a  \nparenthesized dcl, or a direct-dcl followed by parentheses, or a direct-dcl fol lowed by  \nbrackets with an optional size.   \nthis grammar can be used to parse functions. for instance, consider this declarat or: \n \n (*pfa[])()  \npfa will be identified as a name and thus as a direct-dcl. then pfa[] is also a dir ect-dcl. \nthen  \n*pfa[] is recognized as a dcl, so (*pfa[]) is a direct-dcl. then (*pfa[])() is a  direct-dcl  \nand thus a dcl. we can also illustrate the parse with a tree like this (where dir ect-dcl has \nbeen  \nabbreviated to dir-dcl):\n\nthe heart of the dcl program is a pair of functions, dcl and dirdcl, that parse a declaration  \naccording to this grammar. because the grammar is recursively defined, the  functions call  \neach other recursively as they recognize pieces of a declaration; the program  is called a  \nrecursive-descent parser.   \n /* dcl: parse a declarator * \n/  \nvoid dcl(void) {    \nint ns;   \n for (ns = 0; gettoken() == ''*''; ) /* count *''s */   \nns++ \n; \ndirdcl() \n;  \nwhile (ns-- > 0)    \n strcat(out, " pointer to") \n;  }      \n /* dirdcl: parse a direct declarator * \n/  \nvoid dirdcl(void)  {    \nint type;   \n if (tokentype == ''('') { /* ( dcl ) * \n/  \ndcl() \n;  \nif (tokentype != '')'' \n)    \n printf("error: missing )\\n") \n;\n\n} else if (tokentype == name) /* variable name *  \n/  \nstrcpy(name, token) \n;\n\nelse   \n printf("error: expected name or (dcl)\\n");  \nwhile ((type=gettoken()) == parens || type == brackets)  \nif (type == parens)  \nstrcat(out, " function returning");   \nelse  {  \nstrcat(out, " array") \n;  \nstrcat(out, token) \n;  \nstrcat(out, " of") \n;    } }   \nsince the programs are intended to be illustrative, not bullet-proof, there are significant  \nrestrictions on dcl. it can only handle a simple data type line char or int. it does not  \nhandle  \nargument types in functions, or qualifiers like const. spurious blanks confuse it. it doesn'' t \ndo  \nmuch error recovery, so invalid declarations will also confuse it. these improvem ents are \nleft  \nas exercises.   \nhere are the global variables and the main routine:  \n #include <stdio.h>  \n#include <string.h>  \n#include <ctype.h>    \n #define maxtoken 100   \n enum { name, parens, brackets };   \n void dcl(void) \n;  \nvoid dirdcl(void) \n;\n\nint gettoken(void) \n;  \nint tokentype; /* type of last token * \n/  \nchar token[maxtoken]; /* last token string * \n/  \nchar name[maxtoken]; /* identifier name * \n/  \nchar datatype[maxtoken]; /* data type = char, int, etc. * \n/  \nchar out[1000] \n;    \n main() /* convert declaration to words * \n/  {    \n while (gettoken() != eof) { /* 1st token on line * \n/  \nstrcpy(datatype, token); /* is the datatype * \n/  \nout[0] = ''\\0''  \n;   \ndcl(); /* parse rest of line * \n/  \nif (tokentype != ''\\n'' \n)    \n printf("syntax error\\n");   \n printf("%s: %s %s\\n", name, out, datatype) \n;  } \nreturn 0;   } \nthe function gettoken skips blanks and tabs, then finds the next token in the input; a \n``token''''  \nis a name, a pair of parentheses, a pair of brackets perhaps including a number, or any \nother\n\nsingle character.    \n int gettoken(void) /* return next token */   {  \nint c, getch(void) \n;  \nvoid ungetch(int) \n;  \nchar *p = token;    \n while ((c = getch()) == '' '' || c == ''\\t'')\n\n;  \nif (c == ''('')  {    \n if ((c = getch()) == '')'')  {  \nstrcpy(token, "()") \n;  \nreturn tokentype = parens;   \n } else  {  \nungetch(c) \n;  \nreturn tokentype = ''('' \n;    }  \n} else if (c == ''['')  {  \nfor (*p++ = c; (*p++ = getch()) != '']'';  \n)      \n;  \n*p = ''\\0'' \n;  \nreturn tokentype = brackets;    \n } else if (isalpha(c))  {  \nfor (*p++ = c; isalnum(c = getch());  \n)    \n *p++ = c;  \n*p = ''\\0'' \n;  \nungetch(c) \n;  \nreturn tokentype = name;\n\n} else  \nreturn tokentype = c;    } \ngetch and ungetch are discussed in chapter 4.   \ngoing in the other direction is easier, especially if we do not worry about generating  \nredundant parentheses. the program undcl converts a word description like ``x is a \nfunction  \nreturning a pointer to an array of pointers to functions returning char,'''' which we w ill \nexpress  \nas   \n x () * [] * () char   \nto   \n char (*(*x())[])()  \nthe abbreviated input syntax lets us reuse the gettoken function. undcl also uses the sa me  \nexternal variables as dcl does.   \n /* undcl: convert word descriptions to declarations * \n/   \nmain(  \n)  {    \nint type;  \nchar temp[maxtoken] \n;    \n while (gettoken() != eof)  {  \nstrcpy(out, token) \n;  \nwhile ((type = gettoken()) != ''\\n'' \n)    \n if (type == parens || type == brackets)  \nstrcat(out, token);\n\nelse if (type == ''*'') {  \nsprintf(temp, "(*%s)", out);  \nstrcpy(out, temp);   \n } else if (type == name) {  \nsprintf(temp, "%s %s", token, out);  \nstrcpy(out, temp);   \n } else   \n printf("invalid input at %s\\n", token) \n;  } \nreturn 0;   }\n\nexercise 5-18. make dcl recover from input errors.  \nexercise 5-19. modify undcl so that it does not add redundant parentheses to \ndeclarations.  \nexercise 5-20. expand dcl to handle declarations with function argument types, qualifiers  \n  \nlike const, and so on.\n\nchapter 6 - structures   \na structure is a collection of one or more variables, possibly of different types, grouped  \ntogether under a single name for convenient handling. (structures are called ``r ecords'''' in  \nsome languages, notably pascal.) structures help to organize complicated dat a, \nparticularly in  \nlarge programs, because they permit a group of related variables to be treated as a  unit \ninstead  \nof as separate entities.   \none traditional example of a structure is the payroll record: an employee is des cribed by \na set  \nof attributes such as name, address, social security number, salary, etc. so me of these in \nturn  \ncould be structures: a name has several components, as does an address and even a salary.   \nanother example, more typical for c, comes from graphics: a point is a pair of \ncoordinate, a  \nrectangle is a pair of points, and so on.   \nthe main change made by the ansi standard is to define structure assignment  - \nstructures  \nmay be copied and assigned to, passed to functions, and returned by functions. this has \nbeen  \nsupported by most compilers for many years, but the properties are now precisely \ndefined.   \nautomatic structures and arrays may now also be initialized.    \n6.1 basics of structures  \nlet us create a few structures suitable for graphics. the basic object is a  point, which we \nwill  \nassume has an x coordinate and a y coordinate, both integers.    \nthe two components can be placed in a structure declared like this:   \n struct point  { \nint x; \nint y;   \n}; \nthe keyword struct introduces a structure declaration, which is a list of dec larations  \nenclosed in braces. an optional name called a structure tag may follow the word st ruct \n(as\n\nwith point here). the tag names this kind of structure, and can be used subsequently as a   \nshorthand for the part of the declaration in braces.\n\nthe variables named in a structure are called members. a structure member or tag and an  \nordinary (i.e., non-member) variable can have the same name without conflict, s ince they \ncan  \nalways be distinguished by context. furthermore, the same member names may occur in  \ndifferent structures, although as a matter of style one would normally use the same na mes  \nonly for closely related objects.   \na struct declaration defines a type. the right brace that terminates the l ist of members \nmay  \nbe followed by a list of variables, just as for any basic type. that is,   \n struct { ... } x, y, z;   \nis syntactically analogous to  \n int x, y, z;  \nin the sense that each statement declares x, y and z to be variables of the named type a nd  \ncauses space to be set aside for them.   \na structure declaration that is not followed by a list of variables reserves n o storage; it \nmerely  \ndescribes a template or shape of a structure. if the declaration is tagge d, however, the tag \ncan  \nbe used later in definitions of instances of the structure. for example, given the \ndeclaration of   \npoint above,    \n struct point pt;  \ndefines a variable pt which is a structure of type struct point. a structure can be  \ninitialized  \nby following its definition with a list of initializers, each a constant expres sion, for the  \nmembers:  \n struct maxpt = { 320, 200 };  \nan automatic structure may also be initialized by assignment or by calling a functi on that  \nreturns a structure of the right type.   \na member of a particular structure is referred to in an expression by a cons truction of the  \nform   \nstructure-name.member   \nthe structure member operator ``.'''' connects the structure name and the member  name. \nto  \nprint the coordinates of the point pt, for instance,\n\nprintf("%d,%d", pt.x, pt.y);  \nor to compute the distance from the origin (0,0) to pt,   \n double dist, sqrt(double);  \n dist = sqrt((double)pt.x * pt.x + (double)pt.y * pt.y);   \nstructures can be nested. one representation of a rectangle is a pair of points that denote \nthe  \ndiagonally opposite corners:\n\nstruct rect  {  \nstruct point pt1;  \nstruct point pt2;    \n}; \nthe rect structure contains two point structures. if we declare screen as  \n \n struct rect screen;   \nthen   \n screen.pt1.x  \nrefers to the x coordinate of the pt1 member of screen.   \n6.2 structures and functions  \nthe only legal operations on a structure are copying it or assigning to it as a unit, taki ng \nits  \naddress with &, and accessing its members. copy and assignment include passing \narguments  \nto functions and returning values from functions as well. structures may not be \ncompared. a  \nstructure may be initialized by a list of constant member values; an automatic s tructure \nmay   \nalso be initialized by an assignment.    \nlet us investigate structures by writing some functions to manipulate points a nd \nrectangles.  \nthere are at least three possible approaches: pass components separately,  pass an entire  \nstructure, or pass a pointer to it. each has its good points and bad points.   \nthe first function, makepoint, will take two integers and return a point structure:  \n /* makepoint: make a point from x and y components * \n/  \nstruct point makepoint(int x, int y)  {    \n struct point temp;   \n temp.x = x;  \ntemp.y = y;  \nreturn temp;\n\n}  \nnotice that there is no conflict between the argument name and the member with the \nsame  \nname; indeed the re-use of the names stresses the relationship.   \nmakepoint can now be used to initialize any structure dynamically, or to provide structure   \narguments to a function:  \n struct rect screen;\n\nstruct point middle;  \nstruct point makepoint(int, int) \n;    \n screen.pt1 = makepoint(0,0) \n;  \nscreen.pt2 = makepoint(xmax, ymax) \n;  \nmiddle = makepoint((screen.pt1.x + screen.pt2.x)/2,    \n (screen.pt1.y + screen.pt2.y)/2);   \nthe next step is a set of functions to do arithmetic on points. for instance,   \n /* addpoints: add two points * \n/  \nstruct addpoint(struct point p1, struct point p2)  {    \n p1.x += p2.x;  \np1.y += p2.y;  \nreturn p1;     }  \nhere both the arguments and the return value are structures. we incremented the \ncomponents  \nin p1 rather than using an explicit temporary variable to emphasize that structure \nparameters  \nare passed by value like any others.   \nas another example, the function ptinrect tests whether a point is inside a rect angle, \nwhere  \nwe have adopted the convention that a rectangle includes its left and bottom si des but not \nits  \ntop and right sides:   \n /* ptinrect: return 1 if p in r, 0 if not * \n/  \nint ptinrect(struct point p, struct rect r)  {\n\nreturn p.x >= r.pt1.x && p.x < r.pt2.x  \n&& p.y >= r.pt1.y && p.y < r.pt2.y;  } \nthis assumes that the rectangle is presented in a standard form where the pt1 coordinates \nare  \nless than the pt2 coordinates. the following function returns a rectangle guaranteed t o be \nin  \ncanonical form:   \n #define min(a, b) ((a) < (b) ? (a) : (b) \n)  \n#define max(a, b) ((a) > (b) ? (a) : (b) \n)    \n /* canonrect: canonicalize coordinates of rectangle * \n/  \nstruct rect canonrect(struct rect r)  {    \n struct rect temp;   \n temp.pt1.x = min(r.pt1.x, r.pt2.x)  \n;   \ntemp.pt1.y = min(r.pt1.y, r.pt2.y) \n;  \ntemp.pt2.x = max(r.pt1.x, r.pt2.x) \n;  \ntemp.pt2.y = max(r.pt1.y, r.pt2.y) \n;  \nreturn temp;    }  \nif a large structure is to be passed to a function, it is generally more effi cient to pass a \npointer  \nthan to copy the whole structure. structure pointers are just like pointers to or dinary \nvariables.  \nthe declaration   \n struct point *pp;  \nsays that pp is a pointer to a structure of type struct point. if pp points to a point struct ure,\n\n*pp is the structure, and (*pp).x and (*pp).y are the members. to use pp, we might write,   \nfor example,  \n struct point origin, *pp;\n\npp = &origin;  \nprintf("origin is (%d,%d)\\n", (*pp).x, (*pp).y);  \nthe parentheses are necessary in (*pp).x because the precedence of the structure member  \noperator . is higher then *. the expression *pp.x means *(pp.x), which is illegal here  \nbecause x is not a pointer.   \npointers to structures are so frequently used that an alternative notation is provi ded as a  \nshorthand. if p is a pointer to a structure, then   \n p->member-of-structure   \nrefers to the particular member. so we could write instead  \n printf("origin is (%d,%d)\\n", pp->x, pp->y);  \nboth . and -> associate from left to right, so if we have   \n struct rect r, *rp = &r;   \nthen these four expressions are equivalent:   \n r.pt1. x  \nrp->pt1. x  \n(r.pt1).  x   \n(rp->pt1). x    \nthe structure operators . and ->, together with () for function calls and [] for subsc ripts, \nare  \nat the top of the precedence hierarchy and thus bind very tightly. for example, given the  \ndeclaration   \n struct  {  \nint len; \nchar *str;   \n } *p;   \nthen\n\n++p->len   \nincrements len, not p, because the implied parenthesization is ++(p->len). parentheses \ncan  \nbe used to alter binding: (++p)->len increments p before accessing len, and (p++)- >len  \nincrements p afterward. (this last set of parentheses is unnecessary.)   \nin the same way, *p->str fetches whatever str points to; *p->str++ increment s str after  \naccessing whatever it points to (just like *s++); (*p->str)++ increme nts whatever str \npoints  \nto; and *p++->str increments p after accessing whatever str points to.   \n6.3 arrays of structures  \nconsider writing a program to count the occurrences of each c keyword. we need an \narray of  \ncharacter strings to hold the names, and an array of integers for the counts. one \npossibility is  \nto use two parallel arrays, keyword and keycount, as in  \n char *keyword[nkeys] \n;  \nint keycount[nkeys] \n;    \nbut the very fact that the arrays are parallel suggests a different organ ization, an array of  \nstructures. each keyword is a pair:    \n char *word;  \nint cout;    \nand there is an array of pairs. the structure declaration\n\nstruct key  {  \nchar *word;  \nint count;   \n } keytab[nkeys];   \ndeclares a structure type key, defines an array keytab of structures of this type, and sets \naside   \nstorage for them. each element of the array is a structure. this could also be wri tten  \n \n struct key  {  \nchar *word;  \nint count;   \n};  \n struct key keytab[nkeys];   \nsince the structure keytab contains a constant set of names, it is easies t to make it an \nexternal     \nvariable and initialize it once and for all when it is defined. the structure i nitialization is  \n \nanalogous to earlier ones - the definition is followed by a list of initializer s enclosed in \nbraces:   \n struct key  {  \nchar *word;  \nint count;   \n } keytab[] =  { \n"auto", 0,  \n"break", 0, \n"case", 0, \n"char", 0,  \n"const", 0,  \n"continue", 0,\n\n"default", 0,   \n/* ... * \n/  \n"unsigned", 0,  \n"void", 0,  \n"volatile", 0,  \n"while",  0   \n};  \nthe initializers are listed in pairs corresponding to the structure members. it would be \nmore  \nprecise to enclose the initializers for each "row" or structure in bra ces, as in \n \n { "auto", 0 } ,  \n{ "break", 0 } ,  \n{ "case", 0 } ,  .. .     \nbut inner braces are not necessary when the initializers are simple varia bles or character  \nstrings, and when all are present. as usual, the number of entries in the array keyt ab will \nbe   \ncomputed if the initializers are present and the [] is left empty.   \nthe keyword counting program begins with the definition of keytab. the main routine \nreads  \nthe input by repeatedly calling a function getword that fetches one word at a time. e ach \nword  \nis looked up in keytab with a version of the binary search function that we wrote in \nchapter   \n3. the list of keywords must be sorted in increasing order in the table.  \n#include <stdio.h>  \n#include <ctype.h>  \n#include <string.h>    \n #define maxword 100\n\nint getword(char *, int)  \n;  \nint binsearch(char *, struct key *, int) \n;\n\n/* count c keywords * \n/  \nmain( \n)  {    \nint n;  \nchar word[maxword] \n;    \n while (getword(word, maxword) != eof)  \nif (isalpha(word[0]) \n)  \nif ((n = binsearch(word, keytab, nkeys)) >= 0)  \nkeytab[n].count++ \n;  \nfor (n = 0; n < nkeys; n++ \n)  \nif (keytab[n].count > 0)  \nprintf("%4d %s\\n" ,  \nkeytab[n].count, keytab[n].word) \n;   \nreturn 0;  }    \n /* binsearch: find word in tab[0]...tab[n-1] * \n/  \nint binsearch(char *word, struct key tab[], int n) {    \nint cond;  \nint low, high, mid;    \nlow = 0;  \nhigh = n - 1;  \nwhile (low <= high)  {\n\nmid = (low+high) / 2;   \nif ((cond = strcmp(word, tab[mid].word)) < 0)  \nhigh = mid - 1;  \nelse if (cond > 0)  \nlow = mid + 1; \nelse   \n return mid;  } \nreturn -1;   } \nwe will show the function getword in a moment; for now it suffices to say that each call \nto  \ngetword finds a word, which is copied into the array named as its first argument.   \nthe quantity nkeys is the number of keywords in keytab. although we could count this by  \nhand, it''s a lot easier and safer to do it by machine, especially if the list is subj ect to \nchange.  \none possibility would be to terminate the list of initializers with a null pointe r, then loop  \nalong keytab until the end is found.   \nbut this is more than is needed, since the size of the array is completely det ermined at  \ncompile time. the size of the array is the size of one entry times the number of ent ries, so \nthe  \nnumber of entries is just   \nsize of keytab / size of struct key   \nc provides a compile-time unary operator called sizeof that can be used to compute the  \nsize  \nof any object. the expressions   \n sizeof object   \nand   \n sizeof (type name)\n\nyield an integer equal to the size of the specified object or type in bytes. (strictly, sizeof  \nproduces an unsigned integer value whose type, size_t, is defined in the header  \n<stddef.h>.) an object can be a variable or array or structure. a type name can be the \nname  \nof a basic type like int or double, or a derived type like a structure or a pointer.   \nin our case, the number of keywords is the size of the array divided by the size of one  \nelement. this computation is used in a #define statement to set the value of nkeys :  \n \n #define nkeys (sizeof keytab / sizeof(struct key))  \nanother way to write this is to divide the array size by the size of a specific  element:  \n \n #define nkeys (sizeof keytab / sizeof(keytab[0]))   \nthis has the advantage that it does not need to be changed if the type changes.   \na sizeof can not be used in a #if line, because the preprocessor does not parse type \nnames.  \nbut the expression in the #define is not evaluated by the preprocessor, so the code here i s  \nlegal.   \nnow for the function getword. we have written a more general getword than is necessar y \nfor  \nthis program, but it is not complicated. getword fetches the next ``word'''' from t he input,  \nwhere a word is either a string of letters and digits beginning with a letter, or  a single \nnonwhite space character. the function value is the first character of the word, or  eof \nfor end of  \nfile, or the character itself if it is not alphabetic.   \n /* getword: get next word or character from input * \n/  \nint getword(char *word, int lim)  {    \n int c, getch(void) \n;  \nvoid ungetch(int) \n;  \nchar *w = word;    \n while (isspace(c = getch()) \n)\n\n;   \nif (c != eof)  \n*w++ = c;    \n if (!isalpha(c))  {  \n*w = ''\\0'' \n;  \nreturn c;    }  \nfor ( ; --lim > 0; w++ \n)    \n if (!isalnum(*w = getch()))  {  \nungetch(*w) \n;  \nbreak;    } \n*w = ''\\0''  \n;   \nreturn word[0] \n;    } \ngetword uses the getch and ungetch that we wrote in chapter 4. when the collection of an  \nalphanumeric token stops, getword has gone one character too far. the call to ungetch  \npushes that character back on the input for the next call. getword also uses isspace  to skip  \nwhitespace, isalpha to identify letters, and isalnum to identify letters a nd digits; all are \nfrom  \nthe standard header <ctype.h>.   \nexercise 6-1. our version of getword does not properly handle underscores, string \nconstants,  \ncomments, or preprocessor control lines. write a better version.\n\n6.4 pointers to structures  \nto illustrate some of the considerations involved with pointers to and arrays of structures, \nlet  \nus write the keyword-counting program again, this time using pointers instead of arra y  \nindices.   \nthe external declaration of keytab need not change, but main and binsearch do need  \nmodification.  \n #include <stdio.h>  \n#include <ctype.h>  \n#include <string.h>  \n#define maxword 100    \n int getword(char *, int) \n;  \nstruct key *binsearch(char *, struct key *, int) \n;    \n /* count c keywords; pointer version * \n/  \nmain( \n)   {     \n char word[maxword] \n;  \nstruct key *p;    \n while (getword(word, maxword) != eof)  \nif (isalpha(word[0]) \n)  \nif ((p=binsearch(word, keytab, nkeys)) != null)  \np->count++ \n;  \nfor (p = keytab; p < keytab + nkeys; p++ \n)  \nif (p->count > 0)  \nprintf("%4d %s\\n", p->count, p->word) \n; \nreturn 0;\n\n}     \n /* binsearch: find word in tab[0]...tab[n-1] * \n/  \nstruct key *binsearch(char *word, struck key *tab, int n)  {    \nint cond;  \nstruct key *low = &tab[0] \n;  \nstruct key *high = &tab[n] \n;  \nstruct key *mid;    \n while (low < high)  {  \nmid = low + (high-low) / 2;  \nif ((cond = strcmp(word, mid->word)) < 0)    \n high = mid;  \nelse if (cond > 0)  \nlow = mid + 1;  \nelse     \n return mid;  }  \nreturn null;    } \nthere are several things worthy of note here. first, the declaration of binsearch must  \nindicate that it returns a pointer to struct key instead of an integer; this i s declared both in  \nthe function prototype and in binsearch. if binsearch finds the word, it returns a pointer  to  \nit; if it fails, it returns null.\n\nsecond, the elements of keytab are now accessed by pointers. this requires significant  \nchanges in binsearch.   \nthe initializers for low and high are now pointers to the beginning and just past the end \nof the  \ntable.   \nthe computation of the middle element can no longer be simply  \n mid = (low+high) / 2 /* wrong */  \nbecause the addition of pointers is illegal. subtraction is legal, however, so high-l ow is \nthe  \nnumber of elements, and thus   \n mid = low + (high-low) / 2sets mid to the element halfway between low and high.   \nthe most important change is to adjust the algorithm to make sure that it does  not \ngenerate an  \nillegal pointer or attempt to access an element outside the array. the problem i s that \n&tab[ \n1] and &tab[n] are both outside the limits of the array tab. the former is strictl y illegal, \nand  \nit is illegal to dereference the latter. the language definition does guarant ee, however, \nthat  \npointer arithmetic that involves the first element beyond the end of an array (that i s, \n&tab[n])  \nwill work correctly.   \nin main we wrote   \n for (p = keytab; p < keytab + nkeys; p++)  \nif p is a pointer to a structure, arithmetic on p takes into account the size of the  structure, \nso  \np++ increments p by the correct amount to get the next element of the array of structur es, \nand  \nthe test stops the loop at the right time.   \ndon''t assume, however, that the size of a structure is the sum of the sizes  of its members.  \nbecause of alignment requirements for different objects, there may be unnamed `` holes'''' \nin a  \nstructure. thus, for instance, if a char is one byte and an int four bytes, the structure  \n struct  {  \nchar c;\n\nint i;    \n}; \nmight well require eight bytes, not five. the sizeof operator returns the proper value.  \n \nfinally, an aside on program format: when a function returns a complicated type like  a  \nstructure pointer, as in   \n struct key *binsearch(char *word, struct key *tab, int n)   \nthe function name can be hard to see, and to find with a text editor. accordingly an \nalternate  \nstyle is sometimes used:   \n struct key  *  \nbinsearch(char *word, struct key *tab, int n)    \nthis is a matter of personal taste; pick the form you like and hold to it.\n\n6.5 self-referential structures  \nsuppose we want to handle the more general problem of counting the occurrences of all \nthe  \nwords in some input. since the list of words isn''t known in advance, we can''t \nconveniently  \nsort it and use a binary search. yet we can''t do a linear search for each word as it arrives, \nto  \nsee if it''s already been seen; the program would take too long. (more precisely, its  \nrunning  \ntime is likely to grow quadratically with the number of input words.) how can we \norganize  \nthe data to copy efficiently with a list or arbitrary words?   \none solution is to keep the set of words seen so far sorted at all times, by placing ea ch \nword  \ninto its proper position in the order as it arrives. this shouldn''t be done by shifting words \nin a  \nlinear array, though - that also takes too long. instead we will use a data structure c alled a  \nbinary tree.   \nthe tree contains one ``node'''' per distinct word; each node contains   \n•  \na pointer to the text of the word,  \n•   \na count of the number of occurrences,   \n•  \na pointer to the left child node,  \n•  \na pointer to the right child node.  \nno node may have more than two children; it might have only zero or one.   \nthe nodes are maintained so that at any node the left subtree contains only words that ar e  \nlexicographically less than the word at the node, and the right subtree contains onl y \nwords  \nthat are greater. this is the tree for the sentence ``now is the time for  all good men to \ncome to  \nthe aid of their party'''', as built by inserting each word as it is encountered:    \nto find out whether a new word is already in the tree, start at the root and compare t he \nnew  \nword to the word stored at that node. if they match, the question is answered \naffirmatively. if\n\nthe new record is less than the tree word, continue searching at the left child, otherwise at \nthe   \nright child. if there is no child in the required direction, the new word is not in the  tree, \nand in  \nfact the empty slot is the proper place to add the new word. this process is recurs ive, \nsince  \nthe search from any node uses a search from one of its children. accordingly, recursiv e  \nroutines for insertion and printing will be most natural.   \ngoing back to the description of a node, it is most conveniently represented as a structure   \nwith four components:\n\nstruct tnode { /* the tree node: * \n/  \nchar *word; /* points to the text * \n/ \nint count; /* number of occurrences * \n/  \nstruct tnode *left; /* left child * \n/  \nstruct tnode *right; /* right child * \n/    \n};  \nthis recursive declaration of a node might look chancy, but it''s correct. it is illegal for a  \nstructure to contain an instance of itself, but   \n struct tnode *left;  \ndeclares left to be a pointer to a tnode, not a tnode itself.   \noccasionally, one needs a variation of self-referential structures: two st ructures that refer \nto  \neach other. the way to handle this is:  \n struct t   {   .. .  \nstruct s *p; /* p points to an s * \n/    \n};  \n struct s  {  .. .  \nstruct t *q; /* q points to a t * \n/    \n};\n\nthe code for the whole program is surprisingly small, given a handful of supporting  \nroutines  \nlike getword that we have already written. the main routine reads words with getword \nand  \ninstalls them in the tree with addtree.   \n #include <stdio.h>  \n#include <ctype.h>  \n#include <string.h>    \n #define maxword 100  \nstruct tnode *addtree(struct tnode *, char *) \n;  \nvoid treeprint(struct tnode *) \n;  \nint getword(char *, int) \n;    \n /* word frequency count * \n/  \nmain( \n)  {      \n struct tnode *root;  \nchar word[maxword] \n;    \n root = null;  \nwhile (getword(word, maxword) != eof)  \nif (isalpha(word[0]) \n)    \n root = addtree(root, word) \n;  \ntreeprint(root) \n;  \nreturn 0;   }\n\nthe function addtree is recursive. a word is presented by main to the top level (the root) \nof   \nthe tree. at each stage, that word is compared to the word already stored at the node,  and \nis  \npercolated down to either the left or right subtree by a recursive call to adtre e. eventually,  \nthe word either matches something already in the tree (in which case the count is   \nincremented), or a null pointer is encountered, indicating that a node must be create d and  \nadded to the tree. if a new node is created, addtree returns a pointer to it, which i s \ninstalled  \nin the parent node.   \n struct tnode *talloc(void);\n\nchar *strdup(char *);   \n /* addtree: add a node with w, at or below p */   \n struct treenode *addtree(struct tnode *p, char *w)  {   \nint cond;   \n if (p == null) { /* a new word has arrived * \n/  \np = talloc(); /* make a new node * \n/  \np->word = strdup(w) \n;  \np->count = 1;  \np->left = p->right = null;    \n } else if ((cond = strcmp(w, p->word)) == 0)  \np->count++; /* repeated word */  \nelse if (cond < 0) /* less than into left subtree */  \np->left = addtree(p->left, w); \nelse /* greater than into right subtree */   \np->right = addtree(p->right, w);   \nreturn p; } \nstorage for the new node is fetched by a routine talloc, which returns a pointer to a free  \nspace suitable for holding a tree node, and the new word is copied into a hidden space by  \nstrdup. (we will discuss these routines in a moment.) the count is initializ ed, and the two  \nchildren are made null. this part of the code is executed only at the leaves of t he tree, \nwhen a  \nnew node is being added. we have (unwisely) omitted error checking on the values \nreturned  \nby strdup and talloc.   \ntreeprint prints the tree in sorted order; at each node, it prints the left  subtree (all the \nwords  \nless than this word), then the word itself, then the right subtree (all the words gr eater). if \nyou  \nfeel shaky about how recursion works, simulate treeprint as it operates on the tre e shown  \nabove.   \n /* treeprint: in-order print of tree p */\n\nvoid treeprint(struct tnode *p)   {   \n if (p != null) {   \n treeprint(p->left);   \n printf("%4d %s\\n", p->count, p->word);   \n treeprint(p->right);   }  } \na practical note: if the tree becomes ``unbalanced'''' because the words don''t arrive in \nrandom  \norder, the running time of the program can grow too much. as a worst case, if the words \nare  \nalready in order, this program does an expensive simulation of linear search. there a re  \ngeneralizations of the binary tree that do not suffer from this worst-case behavior , but we \nwill  \nnot describe them here.   \nbefore leaving this example, it is also worth a brief digression on a problem relat ed to \nstorage  \nallocators. clearly it''s desirable that there be only one storage alloca tor in a program, \neven  \nthough it allocates different kinds of objects. but if one allocator is to proces s requests \nfor,  \nsay, pointers to chars and pointers to struct tnodes, two questions arise. first, how does i t  \nmeet the requirement of most real machines that objects of certain types m ust satisfy  \nalignment restrictions (for example, integers often must be located at even addr esses)?  \nsecond, what declarations can cope with the fact that an allocator must necess arily return  \ndifferent kinds of pointers?\n\nalignment requirements can generally be satisfied easily, at the cost of some wasted \nspace, by  \nensuring that the allocator always returns a pointer that meets all alignment r estrictions. \nthe  \nalloc of chapter 5 does not guarantee any particular alignment, so we will use the \nstandard  \nlibrary function malloc, which does. in chapter 8 we will show one way to implement  \nmalloc.   \nthe question of the type declaration for a function like malloc is a vexing one for any  \nlanguage that takes its type-checking seriously. in c, the proper method is to declare  that  \nmalloc returns a pointer to void, then explicitly coerce the pointer into the desir ed type \nwith  \na cast. malloc and related routines are declared in the standard header <st dlib.h>. thus  \ntalloc can be written as  \n #include <stdlib.h>   \n /* talloc: make a tnode */  \n struct tnode *talloc(void)  {   \n return (struct tnode *) malloc(sizeof(struct tnode));   }  \nstrdup merely copies the string given by its argument into a safe place, obtained by a ca ll \non  \nmalloc:   \n char *strdup(char *s) /* make a duplicate of s * \n/ {  \nchar *p;    \n p = (char *) malloc(strlen(s)+1); /* +1 for ''\\0'' */  \nif (p != null)  \nstrcpy(p, s);  \nreturn p; } \nmalloc returns null if no space is available; strdup passes that value on, l eaving error- \nhandling to its caller.   \nstorage obtained by calling malloc may be freed for re-use by calling free; see  chapters 8\n\nand 7.    \nexercise 6-2. write a program that reads a c program and prints in alphabetical order \neach  \ngroup of variable names that are identical in the first 6 characters, but dif ferent \nsomewhere  \nthereafter. don''t count words within strings and comments. make 6 a parameter that  can \nbe  \nset from the command line.   \nexercise 6-3. write a cross-referencer that prints a list of all w ords in a document, and for  \neach word, a list of the line numbers on which it occurs. remove noise words like ``the,''''   \n``and,'''' and so on.   \nexercise 6-4. write a program that prints the distinct words in its input sor ted into \ndecreasing  \norder of frequency of occurrence. precede each word by its count.   \n6.6 table lookup  \nin this section we will write the innards of a table-lookup package, to illustrat e more \naspects  \nof structures. this code is typical of what might be found in the symbol table \nmanagement\n\nroutines of a macro processor or a compiler. for example, consider the #define statement.  \nwhen a line like  \n #define in 1  \nis encountered, the name in and the replacement text 1 are stored in a table. later , when \nthe  \nname in appears in a statement like  \n state = in;  \nit must be replaced by 1.   \nthere are two routines that manipulate the names and replacement texts. instal l(s,t)  \nrecords the name s and the replacement text t in a table; s and t are just  character strings.  \nlookup(s) searches for s in the table, and returns a pointer to the place where  it was found,  \nor null if it wasn''t there.   \nthe algorithm is a hash-search -the incoming name is converted into a small non-\nnegative  \ninteger, which is then used to index into an array of pointers. an array element points to \nthe  \nbeginning of a linked list of blocks describing names that have that hash value. it is \nnull if no  \nnames have hashed to that value.     \na block in the list is a structure containing pointers to the name, the replacement t ext, and \nthe   \nnext block in the list. a null next-pointer marks the end of the list.   \n struct nlist { /* table entry: * \n/  \nstruct nlist *next; /* next entry in chain * \n/  \nchar *name; /* defined name * \n/  \nchar *defn; /* replacement text * \n/    \n};  \nthe pointer array is just   \n #define hashsize 101\n\nstatic struct nlist *hashtab[hashsize]; /* pointer table */   \nthe hashing function, which is used by both lookup and install, adds each character value  \nin the string to a scrambled combination of the previous ones and returns the remainder  \nmodulo the array size. this is not the best possible hash function, but it is short and \neffective.  \n /* hash: form hash value for string s * \n/  \nunsigned hash(char *s)  {    \n unsigned hashval;   \n for (hashval = 0; *s != ''\\0''; s++ \n)  \nhashval = *s + 31 * hashval;\n\nreturn hashval % hashsize;  }   \nunsigned arithmetic ensures that the hash value is non-negative.   \nthe hashing process produces a starting index in the array hashtab; if the string is to be  \nfound anywhere, it will be in the list of blocks beginning there. the search is performed by  \nlookup. if lookup finds the entry already present, it returns a pointer to it; if not, it r eturns  \nnull.   \n /* lookup: look for s in hashtab * \n/  \nstruct nlist *lookup(char *s)  {    \n struct nlist *np;   \n for (np = hashtab[hash(s)]; np != null; np = np->next)  \nif (strcmp(s, np->name) == 0)  \nreturn np; /* found */  \nreturn null; /* not found */  }  \nthe for loop in lookup is the standard idiom for walking along a linked list:    \n for (ptr = head; ptr != null; ptr = ptr->next)  ...  \ninstall uses lookup to determine whether the name being installed is already pres ent; if so,  \nthe new definition will supersede the old one. otherwise, a new entry is created. ins tall  \nreturns null if for any reason there is no room for a new entry.   \n struct nlist *lookup(char *) \n;  \nchar *strdup(char *) \n;    \n /* install: put (name, defn) in hashtab * \n/  \nstruct nlist *install(char *name, char *defn)  {\n\nstruct nlist *np;   \nunsigned hashval;    \n if ((np = lookup(name)) == null) { /* not found */  \nnp = (struct nlist *) malloc(sizeof(*np));  \nif (np == null || (np->name = strdup(name)) == null)   \n return null;  \nhashval = hash(name) \n;  \nnp->next = hashtab[hashval] \n;  \nhashtab[hashval] = np;    \n} else /* already there */  \nfree((void *) np->defn); /*free previous defn */  \nif ((np->defn = strdup(defn)) == null)  \nreturn null;  \nreturn np; } \nexercise 6-5. write a function undef that will remove a name and definition from the \ntable  \nmaintained by lookup and install.    \nexercise 6-6. implement a simple version of the #define processor (i.e., no arguments)   \nsuitable for use with c programs, based on the routines of this section. you may also f ind  \ngetch and ungetch helpful.    \n6.7 typedef\n\nc provides a facility called typedef for creating new data type names. for example, the  \ndeclaration   \n typedef int length;  \nmakes the name length a synonym for int. the type length can be used in declarations,  \ncasts, etc., in exactly the same ways that the int type can be:   \n length len, maxlen;  \nlength *lengths[] \n;    \nsimilarly, the declaration   \n typedef char *string;  \nmakes string a synonym for char * or character pointer, which may then be used in  \ndeclarations and casts:   \n string p, lineptr[maxlines], alloc(int) \n;  \nint strcmp(string, string) \n;  \np = (string) malloc(100) \n;      \nnotice that the type being declared in a typedef appears in the position of a variable  \nname,  \nnot right after the word typedef. syntactically, typedef is like the storage cl asses extern,  \nstatic, etc. we have used capitalized names for typedefs, to make them stand out.   \nas a more complicated example, we could make typedefs for the tree nodes shown earl ier \nin  \nthis chapter:  \n typedef struct tnode *treeptr;   \n typedef struct tnode { /* the tree node: * \n/  \nchar *word; /* points to the text * \n/ \nint count; /* number of occurrences * \n/  \nstruct tnode *left; /* left child * \n/\n\nstruct tnode *right; /* right child *  \n/    \n } treenode;  \nthis creates two new type keywords called treenode (a structure) and treeptr (a pointer \nto  \nthe structure). then the routine talloc could become  \n treeptr talloc(void)  {  \nreturn (treeptr) malloc(sizeof(treenode));  } \nit must be emphasized that a typedef declaration does not create a new type in any sens e; \nit  \nmerely adds a new name for some existing type. nor are there any new semantics:  \nvariables  \ndeclared this way have exactly the same properties as variables whose declara tions are \nspelled  \nout explicitly. in effect, typedef is like #define, except that since it is interpr eted by the  \ncompiler, it can cope with textual substitutions that are beyond the capabilit ies of the  \npreprocessor. for example,  \n typedef int (*pfi)(char *, char *);  \ncreates the type pfi, for ``pointer to function (of two char * arguments) returni ng int,''''  \nwhich can be used in contexts like     \n pfi strcmp, numcmp;   \nin the sort program of chapter 5.   \nbesides purely aesthetic issues, there are two main reasons for using typedefs . the first is \nto  \nparameterize a program against portability problems. if typedefs are used for dat a types \nthat\n\nmay be machine-dependent, only the typedefs need change when the program is moved. \none  \ncommon situation is to use typedef names for various integer quantities, then make an  \nappropriate set of choices of short, int, and long for each host machine. types like size _t  \nand ptrdiff_t from the standard library are examples.   \nthe second purpose of typedefs is to provide better documentation for a program -a type  \ncalled treeptr may be easier to understand than one declared only as a pointer t o a  \ncomplicated structure.   \n6.8 unions  \na union is a variable that may hold (at different times) objects of different t ypes and \nsizes,  \nwith the compiler keeping track of size and alignment requirements. unions provide a \nway to  \nmanipulate different kinds of data in a single area of storage, without embedding any  \nmachine-dependent information in the program. they are analogous to variant records in   \npascal.   \nas an example such as might be found in a compiler symbol table manager, suppose that \na  \nconstant may be an int, a float, or a character pointer. the value of a particular c onstant  \nmust be stored in a variable of the proper type, yet it is most convenient for table \nmanagement  \nif the value occupies the same amount of storage and is stored in the same place  \nregardless of   \nits type. this is the purpose of a union - a single variable that can legitimatel y hold any of \none  \nof several types. the syntax is based on structures:   \n union u_tag {   \nint ival;  \n float fval;   \n char *sval;   \n } u;  \nthe variable u will be large enough to hold the largest of the three types; the speci fic size \nis  \nimplementation-dependent. any of these types may be assigned to u and then used in  \nexpressions, so long as the usage is consistent: the type retrieved must be the type m ost  \nrecently stored. it is the programmer''s responsibility to keep track of which t ype is \ncurrently\n\nstored in a union; the results are implementation-dependent if something is stored as one \ntype   \nand extracted as another.   \nsyntactically, members of a union are accessed as   \nunion-name.member   \nor   \nunion-pointer->member   \njust as for structures. if the variable utype is used to keep track of the current type s tored \nin u,  \nthen one might see code such as   \n if (utype == int)   \n printf("%d\\n", u.ival);   \n if (utype == float)   \n printf("%f\\n", u.fval);\n\nif (utype == string)  \nprintf("%s\\n", u.sval) \n;  \nelse  \nprintf("bad type %d in utype\\n", utype) \n;    \nunions may occur within structures and arrays, and vice versa. the notation for accessing \na  \nmember of a union in a structure (or vice versa) is identical to that for nested s tructures. \nfor  \nexample, in the structure array defined by  \n struct  {  \nchar *name;  \nint flags; \nint utype; \nunion  {   \n int ival;  \nfloat fval;   \nchar *sval;     \n} u;  \n} symtab[nsym];  \nthe member ival is referred to as  \n symtab[i].u.ival  \nand the first character of the string sval by either of   \n *symtab[i].u.sval   \n symtab[i].u.sval[0]   \nin effect, a union is a structure in which all members have offset zero from the ba se, the  \nstructure is big enough to hold the ``widest'''' member, and the alignment is appropria te for \nall  \nof the types in the union. the same operations are permitted on unions as on structures:   \nassignment to or copying as a unit, taking the address, and accessing a member.\n\na union may only be initialized with a value of the type of its first member; thus union u  \ndescribed above can only be initialized with an integer value.    \nthe storage allocator in chapter 8 shows how a union can be used to force a variable t o \nbe  \naligned on a particular kind of storage boundary.   \n6.9 bit-fields  \nwhen storage space is at a premium, it may be necessary to pack several objec ts into a \nsingle  \nmachine word; one common use is a set of single-bit flags in applications like com piler  \nsymbol tables. externally-imposed data formats, such as interfaces to hardwar e devices, \nalso  \noften require the ability to get at pieces of a word.   \nimagine a fragment of a compiler that manipulates a symbol table. each identifie r in a  \nprogram has certain information associated with it, for example, whether or not i t is a  \nkeyword, whether or not it is external and/or static, and so on. the most compact way to  \nencode such information is a set of one-bit flags in a single char or int.   \nthe usual way this is done is to define a set of ``masks'''' corresponding to the relevant bi t  \npositions, as in  \n #define keyword 01  \n#define extrenal 02  \n#define static 04\n\nor   \n enum { keyword = 01, external = 02, static = 04 }; \nthe numbers must be powers of two. then accessing the bits becomes a matter of \n``bitfiddling'''' with the shifting, masking, and complementing operators that were \ndescribed in  \nchapter 2.   \ncertain idioms appear frequently:   \n flags |= external | static;  \nturns on the external and static bits in flags, while   \n flags &= ~(external | static);   \nturns them off, and   \n if ((flags & (external | static)) == 0) ...   \nis true if both bits are off.   \nalthough these idioms are readily mastered, as an alternative c offers the capability of  \ndefining and accessing fields within a word directly rather than by bitwise logica l \noperators.  \na bit-field, or field for short, is a set of adjacent bits within a single im plementation-\ndefined  \nstorage unit that we will call a ``word.'''' for example, the symbol table #de fines above \ncould  \nbe replaced by the definition of three fields:   \n struct  {  \nunsigned int is_keyword : 1;  \nunsigned int is_extern : 1;  \nunsigned int is_static : 1;   \n } flags;  \nthis defines a variable table called flags that contains three 1-bit fie lds. the number  \nfollowing the colon represents the field width in bits. the fields are declared uns igned int  \nto ensure that they are unsigned quantities.   \nindividual fields are referenced in the same way as other structure mem bers:  \nflags.is_keyword, flags.is_extern, etc. fields behave like small integers, and  may\n\nparticipate in arithmetic expressions just like other integers. thus the previous examples \nmay   \nbe written more naturally as   \n flags.is_extern = flags.is_static = 1;  \nto turn the bits on;  \n flags.is_extern = flags.is_static = 0;  \nto turn them off; and   \n if (flags.is_extern == 0 && flags.is_static == 0)  .. .    \nto test them.   \nalmost everything about fields is implementation-dependent. whether a field m ay \noverlap a  \nword boundary is implementation-defined. fields need not be names; unnamed fields (a \ncolon  \nand width only) are used for padding. the special width 0 may be used to force alignment \nat  \nthe next word boundary.\n\nfields are assigned left to right on some machines and right to left on others. this means \nthat  \nalthough fields are useful for maintaining internally-defined data structures, the  question \nof  \nwhich end comes first has to be carefully considered when picking apart externa lly-\ndefined  \ndata; programs that depend on such things are not portable. fields may be declared only \nas  \nints; for portability, specify signed or unsigned explicitly. they are not arrays and they  do  \nnot have addresses, so the & operator cannot be applied on them.\n\nchapter 7 - input and output   \ninput and output are not part of the c language itself, so we have not emphasized them in \nour  \npresentation thus far. nonetheless, programs interact with their environment in much \nmore  \ncomplicated ways than those we have shown before. in this chapter we will describe t he  \nstandard library, a set of functions that provide input and output, string handling, storage  \nmanagement, mathematical routines, and a variety of other services for c progra ms. we \nwill  \nconcentrate on input and output   \nthe ansi standard defines these library functions precisely, so that they c an exist in  \ncompatible form on any system where c exists. programs that confine their system  \ninteractions to facilities provided by the standard library can be moved from one s ystem \nto  \nanother without change.   \nthe properties of library functions are specified in more than a dozen headers; we  have  \nalready seen several of these, including <stdio.h>, <string.h>, and <ctype.h>. we will   \nnot present the entire library here, since we are more interested in writing  c programs \nthat use  \nit. the library is described in detail in appendix b.   \n7.1 standard input and output   \nas we said in chapter 1, the library implements a simple model of text input and outpu t. \na   \ntext stream consists of a sequence of lines; each line ends with a newline cha racter. if the  \nsystem doesn''t operate that way, the library does whatever necessary to make it  appear as \nif it  \ndoes. for instance, the library might convert carriage return and linefeed to newline  on \ninput  \nand back again on output.   \nthe simplest input mechanism is to read one character at a time from the sta ndard input,  \nnormally the keyboard, with getchar:   \n int getchar(void)  \ngetchar returns the next input character each time it is called, or eof when i t encounters \nend  \nof file. the symbolic constant eof is defined in <stdio.h>. the value is typically  -1, bus  \ntests should be written in terms of eof so as to be independent of the specific val ue.  \n \nin many environments, a file may be substituted for the keyboard by using the < \nconvention\n\nfor input redirection: if a program prog uses getchar, then the command line    \n prog <infile  \ncauses prog to read characters from infile instead. the switching of the input is done in  \nsuch a way that prog itself is oblivious to the change; in particular, the string `` <infile'''' is  \nnot included in the command-line arguments in argv. input switching is also invisible if  \nthe  \ninput comes from another program via a pipe mechanism: on some systems, the \ncommand  \nline  \n otherprog | prog\n\nruns the two programs otherprog and prog, and pipes the standard output of otherprog \ninto  \nthe standard input for prog.   \nthe function  \n int putchar(int)  \nis used for output: putchar(c) puts the character c on the standard output, which is by  \ndefault the screen. putchar returns the character written, or eof is an e rror occurs. again,  \noutput can usually be directed to a file with >filename: if prog uses putchar,   \n prog >outfile  \nwill write the standard output to outfile instead. if pipes are supported,   \n prog | anotherprog  \nputs the standard output of prog into the standard input of anotherprog.   \noutput produced by printf also finds its way to the standard output. calls to putchar and  \nprintf may be interleaved - output happens in the order in which the calls are made.   \neach source file that refers to an input/output library function must contain the l ine \n \n #include <stdio.h>  \nbefore the first reference. when the name is bracketed by < and > a search is made  for the  \nheader in a standard set of places (for example, on unix systems, typically in the  \ndirectory   \n/usr/include).   \nmany programs read only one input stream and write only one output stream; for such  \nprograms, input and output with getchar, putchar, and printf may be entirely adequate,  \nand is certainly enough to get started. this is particularly true if redirectio n is used to \nconnect  \nthe output of one program to the input of the next. for example, consider the program \nlower,  \nwhich converts its input to lower case:   \n #include <stdio.h>  \n#include <ctype.h>    \n main() /* lower: convert input to lower case*/   {   \nint c\n\nwhile ((c = getchar()) != eof)  \nputchar(tolower(c));  \nreturn 0; } \nthe function tolower is defined in <ctype.h>; it converts an upper case letter to lower \ncase,  \nand returns other characters untouched. as we mentioned earlier, ``functions '''' like getchar  \nand putchar in <stdio.h> and tolower in <ctype.h> are often macros, thus avoiding the  \noverhead of a function call per character. we will show how this is done in section 8.5.  \nregardless of how the <ctype.h> functions are implemented on a given machine, \nprograms  \nthat use them are shielded from knowledge of the character set.   \nexercise 7-1. write a program that converts upper case to lower or lower case t o upper,  \ndepending on the name it is invoked with, as found in argv[0].\n\n7.2 formatted output - printf  \nthe output function printf translates internal values to characters. we have used \nprintfinformally in previous chapters. the description here covers most typical use s but is \nnot  \ncomplete; for the full story, see appendix b.   \n int printf(char *format, arg1, arg2, ...);  \nprintf converts, formats, and prints its arguments on the standard output under control of \nthe  \nformat. it returns the number of characters printed.   \nthe format string contains two types of objects: ordinary characters, which ar e copied to \nthe  \noutput stream, and conversion specifications, each of which causes conversion and \nprinting of  \nthe next successive argument to printf. each conversion specification begins wit h a % \nand  \nends with a conversion character. between the % and the conversion character t here may \nbe,  \nin order:   \n•  \na minus sign, which specifies left adjustment of the converted argument.  \n•  \na number that specifies the minimum field width. the converted argument will be   \nprinted in a field at least this wide. if necessary it will be padded on the left  (or right,  \nif left adjustment is called for) to make up the field width.   \n•  \na period, which separates the field width from the precision.  \n•  \na number, the precision, that specifies the maximum number of characters to be   \nprinted from a string, or the number of digits after the decimal point of a floating-point   \nvalue, or the minimum number of digits for an integer.  \n•  \nan h if the integer is to be printed as a short, or l (letter ell) if as a long.  \nconversion characters are shown in table 7.1. if the character after the % is not a \nconversion  \nspecification, the behavior is undefined.   \ntable 7.1 basic printf conversions   \ncharacter argument type; printed as  \nd,i int; decimal number  \no int; unsigned octal number (without a leading zero)  \nx,x int; unsigned hexadecimal number (without a leading 0x or 0x), using abcdef or\n\nabcdef for 10, ...,15.   \nu int; unsigned decimal number  \nc int; single character  \ns char *; print characters from the string until a ''\\0'' or the number of characters  \ngiven by the precision.  \nf double; [-]m.dddddd, where the number of d''s is given by the precision (default  \n6).  \ne,e double; [-]m.dddddde+/-xx or [-]m.dddddde+/-xx, where the number of d''s is  \ngiven by the precision (default 6).  \ng,g  \ndouble; use %e or %e if the exponent is less than -4 or greater than or equal to the   \nprecision; otherwise use %f. trailing zeros and a trailing decimal point a re not  \nprinted.  \np void *; pointer (implementation-dependent representation).\n\n% no argument is converted; print a %  \na width or precision may be specified as *, in which case the value is computed by  \nconverting the next argument (which must be an int). for example, to print at most max  \ncharacters from a string s,   \n printf("%.*s", max, s);   \nmost of the format conversions have been illustrated in earlier chapters. one exception is \nthe  \nprecision as it relates to strings. the following table shows the effect of a  variety of  \nspecifications in printing ``hello, world'''' (12 characters). we have put colons a round each  \nfield so you can see it extent.   \n :%s: :hello, world:  \n:%10s: :hello, world:  \n:%.10s: :hello, wor:  \n:%-10s: :hello, world:  \n:%.15s: :hello, world:  \n:%-15s: :hello, world  \n:  \n:%15.10s: : hello, wor:  \n:%-15.10s: :hello, wor  \n:     \na warning: printf uses its first argument to decide how many arguments follow and wha t  \ntheir type is. it will get confused, and you will get wrong answers, if there are not e nough  \narguments of if they are the wrong type. you should also be aware of the difference  \nbetween  \nthese two calls:  \n printf(s); /* fails if s contains % */  \nprintf("%s", s); /* safe */  \nthe function sprintf does the same conversions as printf does, but stores the output in a  \nstring:   \n int sprintf(char *string, char *format, arg1, arg2, ...);  \nsprintf formats the arguments in arg1, arg2, etc., according to format as before, but pl aces  \nthe result in string instead of the standard output; string must be big enough to rec eive the  \nresult.   \nexercise 7-2. write a program that will print arbitrary input in a sensible  way. as a  \nminimum, it should print non-graphic characters in octal or hexadecimal according to \nlocal  \ncustom, and break long text lines.\n\n7.3 variable-length argument lists  \nthis section contains an implementation of a minimal version of printf, to show how to  \nwrite a function that processes a variable-length argument list in a portable w ay. since we \nare  \nmainly interested in the argument processing, minprintf will process the forma t string and  \narguments but will call the real printf to do the format conversions.   \nthe proper declaration for printf is   \n int printf(char *fmt, ...) \nwhere the declaration ... means that the number and types of these arguments may vary. \nthe  \ndeclaration ... can only appear at the end of an argument list. our minprintf is decla red as\n\nvoid minprintf(char *fmt, ...)  \nsince we will not return the character count that printf does.   \nthe tricky bit is how minprintf walks along the argument list when the list doesn''t even \nhave  \na name. the standard header <stdarg.h> contains a set of macro definitions that def ine \nhow  \nto step through an argument list. the implementation of this header will vary from \nmachine to  \nmachine, but the interface it presents is uniform.   \nthe type va_list is used to declare a variable that will refer to each ar gument in turn; in  \nminprintf, this variable is called ap, for ``argument pointer.'''' the macro va_star t \ninitializes  \nap to point to the first unnamed argument. it must be called once before ap is used. there   \nmust be at least one named argument; the final named argument is used by va_start to get   \nstarted.   \neach call of va_arg returns one argument and steps ap to the next; va_arg uses a type \nname  \nto determine what type to return and how big a step to take. finally, va_end does \nwhatever  \ncleanup is necessary. it must be called before the program returns.   \nthese properties form the basis of our simplified printf:     \n #include <stdarg.h>   \n /* minprintf: minimal printf with variable argument list * \n/  \nvoid minprintf(char *fmt, ... \n)  {    \n va_list ap; /* points to each unnamed arg in turn * \n/  \nchar *p, *sval;  \nint ival;  \ndouble dval;    \n va_start(ap, fmt); /* make ap point to 1st unnamed arg */  \nfor (p = fmt; *p; p++) {\n\nif (*p != ''%'')   {  \nputchar(*p) \n;  \ncontinue;    }  \nswitch (*++p)  {  \ncase ''d'' \n:    \n ival = va_arg(ap, int) \n;  \nprintf("%d", ival) \n;  \nbreak;    \n case ''f'' \n:  \ndval = va_arg(ap, double) \n;  \nprintf("%f", dval)  \n;   \nbreak;    \n case ''s'':  \nfor (sval = va_arg(ap, char *); *sval; sval++)  \nputchar(*sval);  \nbreak;   \n default:  \nputchar(*p) \n;  \nbreak;    } }  \nva_end(ap); /* clean up when done * \n/\n\n} \nexercise 7-3. revise minprintf to handle more of the other facilities of printf.\n\n7.4 formatted input - scanf  \nthe function scanf is the input analog of printf, providing many of the same conversion  \nfacilities in the opposite direction.   \n int scanf(char *format, ...)  \nscanf reads characters from the standard input, interprets them according to the \nspecification  \nin format, and stores the results through the remaining arguments. the format argume nt \nis  \ndescribed below; the other arguments, each of which must be a pointer, indicate where  \nthe  \ncorresponding converted input should be stored. as with printf, this section is a summary \nof  \nthe most useful features, not an exhaustive list.   \nscanf stops when it exhausts its format string, or when some input fails to mat ch the \ncontrol  \nspecification. it returns as its value the number of successfully matc hed and assigned \ninput  \nitems. this can be used to decide how many items were found. on the end of file, eof is   \nreturned; note that this is different from 0, which means that the next input charac ter does \nnot  \nmatch the first specification in the format string. the next call to scanf resu mes searching  \nimmediately after the last character already converted.    \nthere is also a function sscanf that reads from a string instead of the stand ard input:  \n  \n int sscanf(char *string, char *format, arg1, arg2, ...)  \nit scans the string according to the format in format and stores the resulting va lues \nthrough  \narg1, arg2, etc. these arguments must be pointers.   \nthe format string usually contains conversion specifications, which are used t o control  \nconversion of input. the format string may contain:   \n•  \nblanks or tabs, which are not ignored.  \n•  \nordinary characters (not %), which are expected to match the next non-white spa ce  \ncharacter of the input stream.  \n•  \nconversion specifications, consisting of the character %, an optional assignm ent  \nsuppression character *, an optional number specifying a maximum field width, an  \noptional h, l or l indicating the width of the target, and a conversion character.\n\na conversion specification directs the conversion of the next input field. normally the \nresult   \nis places in the variable pointed to by the corresponding argument. if assignment \nsuppression  \nis indicated by the * character, however, the input field is skipped; no assignment is \nmade. an  \ninput field is defined as a string of non-white space characters; it extends eit her to the \nnext  \nwhite space character or until the field width, is specified, is exhausted. thi s implies that  \nscanf will read across boundaries to find its input, since newlines are white s pace. (white  \nspace characters are blank, tab, newline, carriage return, vertical tab, and  formfeed.)  \n \nthe conversion character indicates the interpretation of the input field. the correspo nding  \nargument must be a pointer, as required by the call-by-value semantics of c. convers ion  \ncharacters are shown in table 7.2.   \ntable 7.2: basic scanf conversions   \ncharacter input data; argument type\n\nd  \ni  o  u  x  \nc  \ns  \ne,f,g  \n%  \ndecimal integer; int *  \ninteger; int *. the integer may be in octal (leading 0) or hexadecimal (leading  \n0x or 0x).  \noctal integer (with or without leading zero); int *  \nunsigned decimal integer; unsigned int *  \nhexadecimal integer (with or without leading 0x or 0x); int *  \ncharacters; char *. the next input characters (default 1) are placed at  the  \nindicated spot. the normal skip-over white space is suppressed; to read the next  \nnon-white space character, use %1s  \ncharacter string (not quoted); char *, pointing to an array of characters long  \nenough for the string and a terminating ''\\0'' that will be added.  \nfloating-point number with optional sign, optional decimal point and optional  \nexponent; float *  \nliteral %; no assignment is made.   \nthe conversion characters d, i, o, u, and x may be preceded by h to indicate that a pointer  \nto   \nshort rather than int appears in the argument list, or by l (letter ell) to indic ate that a \npointer  \nto long appears in the argument list.   \nas a first example, the rudimentary calculator of chapter 4 can be written wit h scanf to \ndo  \nthe input conversion:  \n #include <stdio.h>   \n main() /* rudimentary calculator * \n/  {  \ndouble sum, v;    \nsum = 0;  \nwhile (scanf("%lf", &v) == 1)  \nprintf("\\t%.2f\\n", sum += v)\n\n;   \nreturn 0; }   \nsuppose we want to read input lines that contain dates of the form  \n 25 dec 1988  \nthe scanf statement is   \n int day, year;  \nchar monthname[20] \n;    \n scanf("%d %s %d", &day, monthname, &year);  \nno & is used with monthname, since an array name is a pointer.   \nliteral characters can appear in the scanf format string; they must match the same \ncharacters  \nin the input. so we could read dates of the form mm/dd/yy with the scanf statement:   \n int day, month, year;   \n scanf("%d/%d/%d", &month, &day, &year);\n\nscanf ignores blanks and tabs in its format string. furthermore, it skips over white space  \n(blanks, tabs, newlines, etc.) as it looks for input values. to read input whose format  is \nnot  \nfixed, it is often best to read a line at a time, then pick it apart with scanf. for exa mple,  \nsuppose we want to read lines that might contain a date in either of the forms above.  then \nwe  \ncould write   \n while (getline(line, sizeof(line)) > 0) {  \nif (sscanf(line, "%d %s %d", &day, monthname, &year) == 3)  \nprintf("valid: %s\\n", line); /* 25 dec 1988 form */  \nelse if (sscanf(line, "%d/%d/%d", &month, &day, &year) == 3)  \nprintf("valid: %s\\n", line); /* mm/dd/yy form */  \nelse  \nprintf("invalid: %s\\n", line); /* invalid form */  } \ncalls to scanf can be mixed with calls to other input functions. the next call to any i nput  \nfunction will begin by reading the first character not read by scanf.   \na final warning: the arguments to scanf and sscanf must be pointers. by far the most   \ncommon error is writing  \n scanf("%d", n);   \ninstead of     \n scanf("%d", &n);   \nthis error is not generally detected at compile time.   \nexercise 7-4. write a private version of scanf analogous to minprintf from the previ ous  \nsection.   \nexercise 5-5. rewrite the postfix calculator of chapter 4 to use scanf and/or  sscanf to do  \nthe input and number conversion.   \n7.5 file access  \nthe examples so far have all read the standard input and written the standard outpu t, \nwhich  \nare automatically defined for a program by the local operating system.   \nthe next step is to write a program that accesses a file that is not already c onnected to the  \nprogram. one program that illustrates the need for such operations is cat, which \nconcatenates\n\na set of named files into the standard output. cat is used for printing files on the screen, \nand   \nas a general-purpose input collector for programs that do not have the capability of \naccessing  \nfiles by name. for example, the command   \n cat x.c y.c  \nprints the contents of the files x.c and y.c (and nothing else) on the standard output.   \nthe question is how to arrange for the named files to be read - that is, how to connect the   \nexternal names that a user thinks of to the statements that read the data.   \nthe rules are simple. before it can be read or written, a file has to be opened by the  \nlibrary  \nfunction fopen. fopen takes an external name like x.c or y.c, does some housekeeping and\n\nnegotiation with the operating system (details of which needn''t concern us), and returns a  \npointer to be used in subsequent reads or writes of the file.   \nthis pointer, called the file pointer, points to a structure that contains inf ormation about \nthe  \nfile, such as the location of a buffer, the current character position in the buffer , whether \nthe  \nfile is being read or written, and whether errors or end of file have occurred. users don ''t \nneed  \nto know the details, because the definitions obtained from <stdio.h> include a stru cture  \ndeclaration called file. the only declaration needed for a file pointer is exe mplified by \n \n file *fp;   \n file *fopen(char *name, char *mode);  \nthis says that fp is a pointer to a file, and fopen returns a pointer to a file. notice  that  \nfile is a type name, like int, not a structure tag; it is defined with a typede f. (details of  \nhow fopen can be implemented on the unix system are given in section 8.5.)   \nthe call to fopen in a program is  \n fp = fopen(name, mode);  \nthe first argument of fopen is a character string containing the name of the fi le. the \nsecond  \nargument is the mode, also a character string, which indicates how one intends to use the  \nfile.  \nallowable modes include read ("r"), write ("w"), and append ("a"). some syste ms  \ndistinguish between text and binary files; for the latter, a "b" must be appende d to the \nmode  \nstring.   \nif a file that does not exist is opened for writing or appending, it is created i f possible.  \nopening an existing file for writing causes the old contents to be discarded, while \nopening for  \nappending preserves them. trying to read a file that does not exist is an error, and t here \nmay  \nbe other causes of error as well, like trying to read a file when you don''t have perm ission. \nif  \nthere is any error, fopen will return null. (the error can be identified more pr ecisely; \nsee the  \ndiscussion of error-handling functions at the end of section 1 in appendix b.)   \nthe next thing needed is a way to read or write the file once it is open. getc returns t he \nnext  \ncharacter from a file; it needs the file pointer to tell it which file.\n\nint getc(file *fp)  \ngetc returns the next character from the stream referred to by fp; it returns eof for end of \nfile  \nor error.   \nputc is an output function:  \n int putc(int c, file *fp)  \nputc writes the character c to the file fp and returns the character writt en, or eof if an \nerror  \noccurs. like getchar and putchar, getc and putc may be macros instead of functions.   \nwhen a c program is started, the operating system environment is responsible for \nopening  \nthree files and providing pointers for them. these files are the standard input, the \nstandard  \noutput, and the standard error; the corresponding file pointers are called stdi n, stdout, and  \nstderr, and are declared in <stdio.h>. normally stdin is connected to the keyboard and\n\nstdout and stderr are connected to the screen, but stdin and stdout may be redirected to  \nfiles or pipes as described in section 7.1.   \ngetchar and putchar can be defined in terms of getc, putc, stdin, and stdout as follows:  \n #define getchar() getc(stdin)  \n#define putchar(c) putc((c), stdout) \nfor formatted input or output of files, the functions fscanf and fprintf may be used. these  \nare identical to scanf and printf, except that the first argument is a file point er that \nspecifies  \nthe file to be read or written; the format string is the second argument.   \n int fscanf(file *fp, char *format, ...)  \nint fprintf(file *fp, char *format, ...)  \nwith these preliminaries out of the way, we are now in a position to write the program c at \nto  \nconcatenate files. the design is one that has been found convenient for many programs. if  \nthere are command-line arguments, they are interpreted as filenames, and pr ocessed in \norder.  \nif there are no arguments, the standard input is processed.   \n #include <stdio.h>   \n /* cat: concatenate files, version 1 * \n/   \nmain(int argc, char *argv[]  \n)  {    \nfile *fp;  \nvoid filecopy(file *, file * \n)    \n if (argc == 1) /* no args; copy standard input * \n/  \nfilecopy(stdin, stdout) \n;  \nelse  \nwhile(--argc > 0)    \n if ((fp = fopen(*++argv, "r")) == null) {  \nprintf("cat: can''t open %s\\n, *argv);\n\nreturn 1;   \n } else  {  \nfilecopy(fp, stdout) \n;  \nfclose(fp) \n;   }  \nreturn 0;  }    \n /* filecopy: copy file ifp to file ofp * \n/  \nvoid filecopy(file *ifp, file *ofp)  {   \n int c;   \n while ((c = getc(ifp)) != eof)  \nputc(c, ofp);  }  \nthe file pointers stdin and stdout are objects of type file *. they are constants,  \nhowever,  \nnot variables, so it is not possible to assign to them.   \nthe function  \n int fclose(file *fp)  \nis the inverse of fopen, it breaks the connection between the file pointer and the external  \nname that was established by fopen, freeing the file pointer for another file. since  most  \noperating systems have some limit on the number of files that a program may have open\n\nsimultaneously, it''s a good idea to free the file pointers when they are no longer needed, \nas we  \ndid in cat. there is also another reason for fclose on an output file - it flushes the buffer in  \nwhich putc is collecting output. fclose is called automatically for each open fil e when a  \nprogram terminates normally. (you can close stdin and stdout if they are not needed. \nthey  \ncan also be reassigned by the library function freopen.)   \n7.6 error handling - stderr and exit  \nthe treatment of errors in cat is not ideal. the trouble is that if one of the fil es can''t be  \naccessed for some reason, the diagnostic is printed at the end of the concatenated out put. \nthat  \nmight be acceptable if the output is going to a screen, but not if it''s going into a file or \ninto  \nanother program via a pipeline.   \nto handle this situation better, a second output stream, called stderr, is assigned t o a  \nprogram in the same way that stdin and stdout are. output written on stderr normally  \nappears on the screen even if the standard output is redirected.   \nlet us revise cat to write its error messages on the standard error.   \n #include <stdio.h>   \n /* cat: concatenate files, version 2 */     \n main(int argc, char *argv[])   {   \nfile *fp;  \n void filecopy(file *, file *);   \n char *prog = argv[0]; /* program name for errors */   \n if (argc == 1 ) /* no args; copy standard input */   \n filecopy(stdin, stdout);   \nelse   \n while (--argc > 0)  \n if ((fp = fopen(*++argv, "r")) == null) {\n\nfprintf(stderr, "%s: can''t open %s\\n",   \n prog, *argv);   \nexit(1);  \n } else {   \n filecopy(fp, stdout);   \n fclose(fp);   }  \n if (ferror(stdout)) {   \n fprintf(stderr, "%s: error writing stdout\\n", prog);   \n exit(2);   } \nexit(0); } \nthe program signals errors in two ways. first, the diagnostic output produced by fprintf  \ngoes to stderr, so it finds its way to the screen instead of disappearing down a pipeli ne or  \ninto an output file. we included the program name, from argv[0], in the message, so if  \nthis  \nprogram is used with others, the source of an error is identified.   \nsecond, the program uses the standard library function exit, which terminates program   \nexecution when it is called. the argument of exit is available to whatever proces s called \nthis  \none, so the success or failure of the program can be tested by another program that uses \nthis  \none as a sub-process. conventionally, a return value of 0 signals that all is well; non- zero\n\nvalues usually signal abnormal situations. exit calls fclose for each open output file, to  \nflush out any buffered output.   \nwithin main, return expr is equivalent to exit(expr). exit has the advantage tha t it can be  \ncalled from other functions, and that calls to it can be found with a pattern-searching \nprogram  \nlike those in chapter 5.   \nthe function ferror returns non-zero if an error occurred on the stream fp.   \n int ferror(file *fp)  \nalthough output errors are rare, they do occur (for example, if a disk fills up), so a \nproduction  \nprogram should check this as well.   \nthe function feof(file *) is analogous to ferror; it returns non-zero if end of f ile has  \noccurred on the specified file.   \n int feof(file *fp)  \nwe have generally not worried about exit status in our small illustrative program s, but \nany  \nserious program should take care to return sensible, useful status values.   \n7.7 line input and output  \nthe standard library provides an input and output routine fgets that is similar to the  \ngetline   \nfunction that we have used in earlier chapters:  \n char *fgets(char *line, int maxline, file *fp)  \nfgets reads the next input line (including the newline) from file fp into the char acter array  \nline; at most maxline-1 characters will be read. the resulting line is te rminated with ''\\0''.  \nnormally fgets returns line; on end of file or error it returns null. (our ge tline returns \nthe  \nline length, which is a more useful value; zero means end of file.)   \nfor output, the function fputs writes a string (which need not contain a newline) to a file :  \n \n int fputs(char *line, file *fp)  \nit returns eof if an error occurs, and non-negative otherwise.   \nthe library functions gets and puts are similar to fgets and fputs, but operate on stdin  \nand stdout. confusingly, gets deletes the terminating ''\\n'', and puts adds it.   \nto show that there is nothing special about functions like fgets and fputs, here they are,  \ncopied from the standard library on our system:\n\n/* fgets: get at most n chars from iop */   \n char *fgets(char *s, int n, file *iop)  {   \n register int c;   \n register char *cs;   \ncs = s;  \nwhile (--n > 0 && (c = getc(iop)) != eof)\n\nif ((*cs++ = c) == ''\\n'')   \n break;  \n*cs = ''\\0'' \n;  \nreturn (c == eof && cs == s) ? null : s;    }   \n /* fputs: put string s on file iop * \n/  \nint fputs(char *s, file *iop)  {    \nint c;   \n while (c = *s++)  \nputc(c, iop);  \nreturn ferror(iop) ? eof : 0;  } \nfor no obvious reason, the standard specifies different return values for ferror and fputs.  \n \nit is easy to implement our getline from fgets:     \n /* getline: read a line, return length * \n/  \nint getline(char *line, int max)  {    \n if (fgets(line, max, stdin) == null)  \nreturn 0;  \nelse  \nreturn strlen(line) \n;  }   \nexercise 7-6. write a program to compare two files, printing the first line  where they \ndiffer.   \nexercise 7-7. modify the pattern finding program of chapter 5 to take its input from a set  \nof\n\nnamed files or, if no files are named as arguments, from the standard input. should the \nfile   \nname be printed when a matching line is found?   \nexercise 7-8. write a program to print a set of files, starting each new one on a new  page,  \nwith a title and a running page count for each file.   \n7.8 miscellaneous functions  \nthe standard library provides a wide variety of functions. this section is a brief s ynopsis \nof  \nthe most useful. more details and many other functions can be found in appendix b.   \n7.8.1 string operations  \nwe have already mentioned the string functions strlen, strcpy, strcat, and strcmp, found   \nin <string.h>. in the following, s and t are char *''s, and c and n are ints.  \nstrcat(s,t) concatenate t to end of s   \nstrncat(s,t,n) concatenate n characters of t to end of s   \nstrcmp(s,t) return negative, zero, or positive for s < t, s == t, s > t   \nstrncmp(s,t,n) same as strcmp but only in first n characters  \nstrcpy(s,t) copy t to  \ns    \nstrncpy(s,t,n) copy at most n characters of t to s    \nstrlen(s) return length of s   \nstrchr(s,c) return pointer to first c in s, or null if not present\n\nstrrchr(s,c) return pointer to last c in s, or null if not present   \n7.8.2 character class testing and conversion  \nseveral functions from <ctype.h> perform character tests and conversions. in the \nfollowing,  \nc is an int that can be represented as an unsigned char or eof. the function returns int.  \nisalpha(c) non-zero if c is alphabetic, 0 if not  \nisupper(c) non-zero if c is upper case, 0 if not  \nislower(c) non-zero if c is lower case, 0 if not  \nisdigit(c) non-zero if c is digit, 0 if not   \nisalnum(c) non-zero if isalpha(c) or isdigit(c), 0 if not   \nisspace(c) non-zero if c is blank, tab, newline, return, formfeed, vertical ta b  \ntoupper(c) return c converted to upper case   \ntolower(c) return c converted to lower case   \n7.8.3 ungetc  \nthe standard library provides a rather restricted version of the function ungetch tha t we  \nwrote in chapter 4; it is called ungetc.   \n int ungetc(int c, file *fp)  \npushes the character c back onto file fp, and returns either c, or eof for an error. onl y \none   \ncharacter of pushback is guaranteed per file. ungetc may be used with any of the input   \nfunctions like scanf, getc, or getchar.   \n7.8.4 command execution  \nthe function system(char *s) executes the command contained in the character str ing s,  \nthen resumes execution of the current program. the contents of s depend strongly on the \nlocal  \noperating system. as a trivial example, on unix systems, the statement   \n system("date");  \ncauses the program date to be run; it prints the date and time of day on the standard \noutput.  \nsystem returns a system-dependent integer status from the command executed. in the  \nunix  \nsystem, the status return is the value returned by exit.   \n7.8.5 storage management  \nthe functions malloc and calloc obtain blocks of memory dynamically.  \n void *malloc(size_t n)\n\nreturns a pointer to n bytes of uninitialized storage, or null if the request cannot be \nsatisfied.    \n void *calloc(size_t n, size_t size)  \nreturns a pointer to enough free space for an array of n objects of the specified size, or  \nnull if  \nthe request cannot be satisfied. the storage is initialized to zero.   \nthe pointer returned by malloc or calloc has the proper alignment for the object in \nquestion,  \nbut it must be cast into the appropriate type, as in\n\nint *ip;   \n ip = (int *) calloc(n, sizeof(int));  \nfree(p) frees the space pointed to by p, where p was originally obtained by a call to \nmalloc  \nor calloc. there are no restrictions on the order in which space is freed, but it is a ghastly  \nerror to free something not obtained by calling malloc or calloc.   \nit is also an error to use something after it has been freed. a typical but in correct piece of  \ncode is this loop that frees items from a list:   \n for (p = head; p != null; p = p->next) /* wrong * \n/ \nfree(p) \n;   \nthe right way is to save whatever is needed before freeing:   \n for (p = head; p != null; p = q)  {  \nq = p->next;  \nfree(p) \n;     } \nsection 8.7 shows the implementation of a storage allocator like malloc, in whic h \nallocated  \nblocks may be freed in any order.   \n7.8.6 mathematical functions  \nthere are more than twenty mathematical functions declared in <math.h>; here a re some \nof  \nthe more frequently used. each takes one or two double arguments and returns a double.  \nsin(x) sine of x, x in radians  \ncos(x) cosine of x, x in radians  \natan2(y,x) arctangent of y/x, in radians  \nexp(x) exponential function ex   \nlog(x) natural (base e) logarithm of x (x>0)  \nlog10(x) common (base 10) logarithm of x (x>0)  \npow(x,y) xy   \nsqrt(x) square root of x (x>0)\n\nfabs(x) absolute value of x    \n7.8.7 random number generation  \nthe function rand() computes a sequence of pseudo-random integers in the range zero to  \nrand_max, which is defined in <stdlib.h>. one way to produce random floating-point  \nnumbers greater than or equal to zero but less than one is   \n #define frand() ((double) rand() / (rand_max+1.0))  \n(if your library already provides a function for floating-point random numbers, it is like ly \nto  \nhave better statistical properties than this one.)   \nthe function srand(unsigned) sets the seed for rand. the portable implementation of rand  \nand srand suggested by the standard appears in section 2.7.   \nexercise 7-9. functions like isupper can be implemented to save space or to save tim e.  \nexplore both possibilities.\n\nchapter 8 -the unix system interface   \nthe unix operating system provides its services through a set of system calls, which are \nin  \neffect functions within the operating system that may be called by user programs. thi s  \nchapter describes how to use some of the most important system calls from c program s. \nif  \nyou use unix, this should be directly helpful, for it is sometimes necessary to employ \nsystem  \ncalls for maximum efficiency, or to access some facility that is not in t he library. even if \nyou  \nuse c on a different operating system, however, you should be able to glean insight into \nc  \nprogramming from studying these examples; although details vary, similar code wil l be \nfound  \non any system. since the ansi c library is in many cases modeled on unix facilities , \nthis  \ncode may help your understanding of the library as well.   \nthis chapter is divided into three major parts: input/output, file system, and storage  \nallocation.  \nthe first two parts assume a modest familiarity with the external cha racteristics of unix  \nsystems.   \nchapter 7 was concerned with an input/output interface that is uniform across operat ing  \nsystems. on any particular system the routines of the standard library have to be writ ten \nin  \nterms of the facilities provided by the host system. in the next few sections we w ill \ndescribe  \nthe unix system calls for input and output, and show how parts of the standard library \ncan be  \nimplemented with them.   \n8.1 file descriptors  \nin the unix operating system, all input and output is done by reading or writing files,  \nbecause all peripheral devices, even keyboard and screen, are files in the fil e system. this  \nmeans that a single homogeneous interface handles all communication between a \nprogram  \nand peripheral devices.   \nin the most general case, before you read and write a file, you must inform the system of \nyour  \nintent to do so, a process called opening the file. if you are going to write on a file it may \nalso\n\nbe necessary to create it or to discard its previous contents. the system checks your right \nto   \ndo so (does the file exist? do you have permission to access it?) and if all is w ell, returns \nto  \nthe program a small non-negative integer called a file descriptor. whenever input o r \noutput is  \nto be done on the file, the file descriptor is used instead of the name to identify the f ile. \n(a file  \ndescriptor is analogous to the file pointer used by the standard library, or to the fi le \nhandle of  \nms-dos.) all information about an open file is maintained by the system; the user \nprogram  \nrefers to the file only by the file descriptor.   \nsince input and output involving keyboard and screen is so common, special \narrangements  \nexist to make this convenient. when the command interpreter (the ``shell'''') runs  a \nprogram,  \nthree files are open, with file descriptors 0, 1, and 2, called the standard input, the \nstandard  \noutput, and the standard error. if a program reads 0 and writes 1 and 2, it can do input and  \noutput without worrying about opening files.   \nthe user of a program can redirect i/o to and from files with < and >:   \n prog <infile >outfile\n\nin this case, the shell changes the default assignments for the file descriptors 0 and 1 to \nthe  \nnamed files. normally file descriptor 2 remains attached to the screen, s o error messages \ncan  \ngo there. similar observations hold for input or output associated with a pipe. in all  cases, \nthe  \nfile assignments are changed by the shell, not by the program. the program does not \nknow  \nwhere its input comes from nor where its output goes, so long as it uses file 0 for inp ut \nand 1  \nand 2 for output.   \n8.2 low level i/o - read and write  \ninput and output uses the read and write system calls, which are accessed from c \nprograms  \nthrough two functions called read and write. for both, the first argument is a file \ndescriptor.  \nthe second argument is a character array in your program where the data is to go to  or to  \ncome from. the third argument is the number is the number of bytes to be transferr ed. \n \n int n_read = read(int fd, char *buf, int n) \n;  \nint n_written = write(int fd, char *buf, int n) \n;      \neach call returns a count of the number of bytes transferred. on reading, the number of \nbytes  \nreturned may be less than the number requested. a return value of zero bytes implies  end \nof  \nfile, and -1 indicates an error of some sort. for writing, the return value is the number  of  \nbytes written; an error has occurred if this isn''t equal to the number requested.   \n \nany number of bytes can be read or written in one call. the most common values are 1,  \nwhich means one character at a time (``unbuffered''''), and a number like 1024 or 4096 that  \ncorresponds to a physical block size on a peripheral device. larger sizes will be  more \nefficient  \nbecause fewer system calls will be made.   \nputting these facts together, we can write a simple program to copy its input to i ts output, \nthe  \nequivalent of the file copying program written for chapter 1. this program will copy \nanything  \nto anything, since the input and output can be redirected to any file or device.\n\n#include "syscalls.h"    \n main() /* copy input to output */   {   \n char buf[bufsiz];   \nint n;   \n while ((n = read(0, buf, bufsiz)) > 0)  \nwrite(1, buf, n);  \nreturn 0; } \nwe have collected function prototypes for the system calls into a file called syscalls.h so  \nwe can include it in the programs of this chapter. this name is not standard, however .  \n \nthe parameter bufsiz is also defined in syscalls.h; its value is a good size for  the local  \nsystem. if the file size is not a multiple of bufsiz, some read will return  a smaller \nnumber of  \nbytes to be written by write; the next call to read after that will return z ero.  \n \nit is instructive to see how read and write can be used to construct higher-level r outines \nlike  \ngetchar, putchar, etc. for example, here is a version of getchar that does unbuffered input,   \nby reading the standard input one character at a time.\n\n#include "syscalls.h"   \n /* getchar: unbuffered single character input * \n/  \nint getchar(void)  {    \nchar c;   \n return (read(0, &c, 1) == 1) ? (unsigned char) c : eof;  }  \nc must be a char, because read needs a character pointer. casting c to unsigned char in the  \nreturn statement eliminates any problem of sign extension.   \nthe second version of getchar does input in big chunks, and hands out the characters one \nat  \na time.   \n #include "syscalls.h"   \n /* getchar: simple buffered version * \n/  \nint getchar(void)  {      \n static char buf[bufsiz] \n;  \nstatic char *bufp = buf;  \nstatic int n = 0;    \n if (n == 0) { /* buffer is empty * \n/  \nn = read(0, buf, sizeof buf) \n;  \nbufp = buf;    }  \nreturn (--n >= 0) ? (unsigned char) *bufp++ : eof;  } \nif these versions of getchar were to be compiled with <stdio.h> included, it would be   \nnecessary to #undef the name getchar in case it is implemented as a macro.\n\n8.3 open, creat, close, unlink  \nother than the default standard input, output and error, you must explicitly open files in \norder  \nto read or write them. there are two system calls for this, open and creat [sic].  \n \nopen is rather like the fopen discussed in chapter 7, except that instead of returning a  file  \npointer, it returns a file descriptor, which is just an int. open returns -1 if a ny error occurs.  \n \n #include <fcntl.h>   \n int fd;  \nint open(char *name, int flags, int perms) \n;    \n fd = open(name, flags, perms);  \nas with fopen, the name argument is a character string containing the filename. the \nsecond  \nargument, flags, is an int that specifies how the file is to be opened; the main val ues are  \n \no_rdonly open for reading only  \no_wronly open for writing only  \no_rdwr open for both reading and writing\n\nthese constants are defined in <fcntl.h> on system v unix systems, and in <sys/file.h>  \non berkeley (bsd) versions.   \nto open an existing file for reading,  \n fd = open(name, o_rdonly,0);  \nthe perms argument is always zero for the uses of open that we will discuss.   \nit is an error to try to open a file that does not exist. the system call creat i s provided to  \ncreate new files, or to re-write old ones.   \n int creat(char *name, int perms);   \n fd = creat(name, perms);  \nreturns a file descriptor if it was able to create the file, and -1 if not . if the file already \nexists,  \ncreat will truncate it to zero length, thereby discarding its previous cont ents; it is not an \nerror  \nto creat a file that already exists.   \nif the file does not already exist, creat creates it with the permissions s pecified by the \npermsargument. in the unix file system, there are nine bits of permission inf ormation \nassociated  \nwith a file that control read, write and execute access for the owner of t he file, for the \nowner''s   \ngroup, and for all others. thus a three-digit octal number is convenient for specifying t he  \npermissions. for example, 0775 specifies read, write and execute permission for the  \nowner,  \nand read and execute permission for the group and everyone else.   \nto illustrate, here is a simplified version of the unix program cp, which copies  one file \nto  \nanother. our version copies only one file, it does not permit the second argument to be a   \ndirectory, and it invents permissions instead of copying them.   \n #include <stdio.h>  \n#include <fcntl.h>  \n#include "syscalls.h"  \n#define perms 0666 /* rw for owner, group, others * \n/    \n void error(char *, ...);   \n /* cp: copy f1 to f2 *\n\n/   \nmain(int argc, char *argv[] \n)  {    \n int f1, f2, n;  \nchar buf[bufsiz] \n;    \n if (argc != 3)  \nerror("usage: cp from to") \n;  \nif ((f1 = open(argv[1], o_rdonly, 0)) == -1)  \nerror("cp: can''t open %s", argv[1]) \n;  \nif ((f2 = creat(argv[2], perms)) == -1)  \nerror("cp: can''t create %s, mode %03o" ,  \nargv[2], perms) \n;  \nwhile ((n = read(f1, buf, bufsiz)) > 0)  \nif (write(f2, buf, n) != n)  \nerror("cp: write error on file %s", argv[2]) \n;   \nreturn 0;  }\n\nthis program creates the output file with fixed permissions of 0666. with the stat system  \ncall, described in section 8.6, we can determine the mode of an existing file and thus  give \nthe  \nsame mode to the copy.   \nnotice that the function error is called with variable argument lists much li ke printf. the  \nimplementation of error illustrates how to use another member of the printf fam ily. the  \nstandard library function vprintf is like printf except that the variable a rgument list is  \nreplaced by a single argument that has been initialized by calling the va_start mac ro.  \nsimilarly, vfprintf and vsprintf match fprintf and sprintf.   \n #include <stdio.h>  \n#include <stdarg.h>    \n /* error: print an error message and die */   \n void error(char *fmt, ...)  {   \n va_list args;   \n va_start(args, fmt);    \n fprintf(stderr, "error: ");    \n vprintf(stderr, fmt, args);   \n fprintf(stderr, "\\n");  \n va_end(args);   \nexit(1);  } \nthere is a limit (often about 20) on the number of files that a program may open  \nsimultaneously. accordingly, any program that intends to process many files must be  \nprepared to re-use file descriptors. the function close(int fd) breaks the conne ction  \nbetween a file descriptor and an open file, and frees the file descriptor for use  with some \nother  \nfile; it corresponds to fclose in the standard library except that there is no buff er to flush.  \ntermination of a program via exit or return from the main program closes all open files .  \n \nthe function unlink(char *name) removes the file name from the file system. it\n\ncorresponds to the standard library function remove.    \nexercise 8-1. rewrite the program cat from chapter 7 using read, write, open, and close  \ninstead of their standard library equivalents. perform experiments to determine  the \nrelative  \nspeeds of the two versions.   \n8.4 random access - lseek  \ninput and output are normally sequential: each read or write takes place at a positi on in \nthe  \nfile right after the previous one. when necessary, however, a file can be read or w ritten in \nany  \narbitrary order. the system call lseek provides a way to move around in a file without   \nreading or writing any data:   \n long lseek(int fd, long offset, int origin);  \nsets the current position in the file whose descriptor is fd to offset, which is t aken relative \nto  \nthe location specified by origin. subsequent reading or writing will begin at that posit ion.  \norigin can be 0, 1, or 2 to specify that offset is to be measured from the beginning, from  \nthe current position, or from the end of the file respectively. for example, to append to a \nfile  \n(the redirection >> in the unix shell, or "a" for fopen), seek to the end before wr iting:  \n \n lseek(fd, 0l, 2);\n\nto get back to the beginning (``rewind''''),   \n lseek(fd, 0l, 0);  \nnotice the 0l argument; it could also be written as (long) 0 or just as 0 if lseek is \nproperly  \ndeclared.   \nwith lseek, it is possible to treat files more or less like arrays, at the  price of slower \naccess.  \nfor example, the following function reads any number of bytes from any arbitrary place \nin a  \nfile. it returns the number read, or -1 on error.   \n #include "syscalls.h"   \n /*get: read n bytes from position pos * \n/  \nint get(int fd, long pos, char *buf, int n)  {    \n if (lseek(fd, pos, 0) >= 0) /* get to pos */  \nreturn read(fd, buf, n);  \nelse  \nreturn -1;   }  \nthe return value from lseek is a long that gives the new position in the file, or -1 if  an \nerror  \noccurs. the standard library function fseek is similar to lseek except that  the first \nargument  \nis a file * and the return is non-zero if an error occurred.   \n8.5 example - an implementation of fopen and getc  \nlet us illustrate how some of these pieces fit together by showing an implementation of  \nthe  \nstandard library routines fopen and getc.   \nrecall that files in the standard library are described by file pointers r ather than file  \ndescriptors. a file pointer is a pointer to a structure that contains severa l pieces of \ninformation  \nabout the file: a pointer to a buffer, so the file can be read in large chunks; a count of t he  \nnumber of characters left in the buffer; a pointer to the next character posi tion in the \nbuffer;  \nthe file descriptor; and flags describing read/write mode, error status, etc.\n\nthe data structure that describes a file is contained in <stdio.h>, which must be included \n(by   \n#include) in any source file that uses routines from the standard input/output librar y. it is  \nalso included by functions in that library. in the following excerpt from a typical \n<stdio.h>,  \nnames that are intended for use only by functions of the library begin with an underscore \nso  \nthey are less likely to collide with names in a user''s program. this convention is us ed by \nall  \nstandard library routines.  \n #define null  0  \n#define eof (-1)  \n#define bufsiz 1024  \n#define open_max 20 /* max #files open at once * \n/    \n typedef struct _iobuf {   \nint cnt; /* characters left */   \nchar *ptr; /* next character position */   \n char *base; /* location of buffer */     \nint flag; /* mode of file access */   \nint fd; /* file descriptor */   \n } file;\n\nextern file _iob[open_max];   \n #define stdin (&_iob[0] \n)  \n#define stdout (&_iob[1] \n)  \n#define stderr (&_iob[2] \n)   \n enum _flags  {  \n_read = 01, /* file open for reading * \n/  \n_write = 02, /* file open for writing * \n/  \n_unbuf = 04, /* file is unbuffered * \n/  \n_eof = 010, /* eof has occurred on this file * \n/  \n_err = 020 /* error occurred on this file * \n/    \n};    \n int _fillbuf(file *) \n;  \nint _flushbuf(int, file *) \n;   \n #define feof(p) ((p)->flag & _eof) != 0)  \n#define ferror(p) ((p)->flag & _err) != 0)  \n#define fileno(p) ((p)->fd)    \n #define getc(p) (--(p)->cnt >= 0  \n\\  \n? (unsigned char) *(p)->ptr++ : _fillbuf(p) \n)  \n#define putc(x,p) (--(p)->cnt >= 0  \n\\  \n? *(p)->ptr++ = (x) : _flushbuf((x),p) \n)\n\n#define getchar() getc(stdin)  \n#define putcher(x) putc((x), stdout)  \nthe getc macro normally decrements the count, advances the pointer, and returns the  \ncharacter. (recall that a long #define is continued with a backslash.) if th e count goes  \nnegative, however, getc calls the function _fillbuf to replenish the buffer, re-i nitialize the  \nstructure contents, and return a character. the characters are returne d unsigned, which  \nensures that all characters will be positive.   \nalthough we will not discuss any details, we have included the definition of putc to show  \nthat it operates in much the same way as getc, calling a function _flushbuf when its buf fer  \nis full. we have also included macros for accessing the error and end-of-file sta tus and \nthe file  \ndescriptor.   \nthe function fopen can now be written. most of fopen is concerned with getting the file  \nopened and positioned at the right place, and setting the flag bits to indicate the prop er \nstate.  \nfopen does not allocate any buffer space; this is done by _fillbuf when the file is firs t \nread.   \n #include <fcntl.h>  \n#include "syscalls.h"  \n#define perms 0666 /* rw for owner, group, others * \n/      \n file *fopen(char *name, char *mode)   {  \nint fd; \nfile *fp;    \n if (*mode != ''r'' && *mode != ''w'' && *mode != ''a'' \n)  \nreturn null;    \n for (fp = _iob; fp < _iob + open_max; fp++ \n)  \nif ((fp->flag & (_read | _write)) == 0)  \nbreak; /* found free slot * \n/\n\nif (fp >= _iob + open_max) /* no free slots * \n/  \nreturn null;\n\nif (*mode == ''w'' \n)  \nfd = creat(name, perms) \n;  \nelse if (*mode == ''a'')  {  \nif ((fd = open(name, o_wronly, 0)) == -1)  \nfd = creat(name, perms) \n;  \nlseek(fd, 0l, 2) \n;  \n} else  \nfd = open(name, o_rdonly, 0) \n;  \nif (fd == -1) /* couldn''t access name * \n/    \n return null;  \nfp->fd = fd;  \nfp->cnt = 0;  \nfp->base = null;  \nfp->flag = (*mode == ''r'') ? _read : _write;  \nreturn fp;     } \nthis version of fopen does not handle all of the access mode possibilities of the standard,  \nthough adding them would not take much code. in particular, our fopen does not \nrecognize  \nthe ``b'''' that signals binary access, since that is meaningless on unix syst ems, nor the \n``+''''  \nthat permits both reading and writing.   \nthe first call to getc for a particular file finds a count of zero, which forces a  call of  \n_fillbuf. if _fillbuf finds that the file is not open for reading, it returns eof imme diately.  \notherwise, it tries to allocate a buffer (if reading is to be buffered).   \nonce the buffer is established, _fillbuf calls read to fill it, sets the c ount and pointers, and  \nreturns the character at the beginning of the buffer. subsequent calls to _fillbuf wil l find a  \nbuffer allocated.   \n #include "syscalls.h"   \n /* _fillbuf: allocate and fill input buffer *\n\n/   \nint _fillbuf(file *fp)  {    \n int bufsize;   \n if ((fp->flag&(_read|_eof_err)) != _read)   \n return eof;  \nbufsize = (fp->flag & _unbuf) ? 1 : bufsiz;  \nif (fp->base == null) /* no buffer yet * \n/    \n if ((fp->base = (char *) malloc(bufsize)) == null)   \n return eof; /* can''t get buffer * \n/  \nfp->ptr = fp->base;  \nfp->cnt = read(fp->fd, fp->ptr, bufsize) \n;  \nif (--fp->cnt < 0)  {     \n if (fp->cnt == -1)   \nfp->flag |= _eof;  \nelse    \n fp->flag |= _err;  \nfp->cnt = 0;  \nreturn eof;    }  \nreturn (unsigned char) *fp->ptr++; } \nthe only remaining loose end is how everything gets started. the array _iob must be \ndefined  \nand initialized for stdin, stdout and stderr:   \n file _iob[open_max] = { /* stdin, stdout, stderr */\n\n{ 0, (char *) 0, (char *) 0, _read, 0 } ,  \n{ 0, (char *) 0, (char *) 0, _write, 1 } ,  \n{ 0, (char *) 0, (char *) 0, _write, | _unbuf, 2  }    \n}; \nthe initialization of the flag part of the structure shows that stdin is to be read, stdout is \nto  \nbe written, and stderr is to be written unbuffered.   \nexercise 8-2. rewrite fopen and _fillbuf with fields instead of explicit bit opera tions.  \ncompare code size and execution speed.   \nexercise 8-3. design and write _flushbuf, fflush, and fclose.   \nexercise 8-4. the standard library function   \n int fseek(file *fp, long offset, int origin)  \nis identical to lseek except that fp is a file pointer instead of a file desc riptor and return \nvalue  \nis an int status, not a position. write fseek. make sure that your fseek coordinates \nproperly   \nwith the buffering done for the other functions of the library.    \n8.6 example - listing directories  \na different kind of file system interaction is sometimes called for - determ ining \ninformation  \nabout a file, not what it contains. a directory-listing program such as the unix c ommand \nls  \nis an example - it prints the names of files in a directory, and, optionally, other \ninformation,  \nsuch as sizes, permissions, and so on. the ms-dos dir command is analogous.   \nsince a unix directory is just a file, ls need only read it to retrieve the  filenames. but is \nis  \nnecessary to use a system call to access other information about a file, such as i ts size. on  \nother systems, a system call may be needed even to access filenames; this is the  case on \nmsdos for instance. what we want is provide access to the information in a re latively \nsystem- \nindependent way, even though the implementation may be highly system-dependent.   \nwe will illustrate some of this by writing a program called fsize. fsize is  a special form of\n\nls that prints the sizes of all files named in its commandline argument list. if one of the \nfiles   \nis a directory, fsize applies itself recursively to that directory. if ther e are no arguments at  \nall, it processes the current directory.   \nlet us begin with a short review of unix file system structure. a directory is a f ile that  \ncontains a list of filenames and some indication of where they are located. the  ``location'''' \nis  \nan index into another table called the ``inode list.'''' the inode for a file is wher e all  \ninformation about the file except its name is kept. a directory entry generally c onsists of \nonly  \ntwo items, the filename and an inode number.   \nregrettably, the format and precise contents of a directory are not the same on all \nversions of  \nthe system. so we will divide the task into two pieces to try to isolate the non-por table \nparts.  \nthe outer level defines a structure called a dirent and three routines opendir , readdir, and  \nclosedir to provide system-independent access to the name and inode number in a \ndirectory  \nentry. we will write fsize with this interface. then we will show how to imple ment these \non  \nsystems that use the same directory structure as version 7 and system v uni x; variants \nare  \nleft as exercises.\n\nthe dirent structure contains the inode number and the name. the maximum length of a  \nfilename component is name_max, which is a system-dependent value. opendir \nreturns a  \npointer to a structure called dir, analogous to file, which is used by readdir and \nclosedir.  \nthis information is collected into a file called dirent.h.   \n #define name_max 14 /* longest filename component; * \n/  \n/* system-dependent * \n/    \n typedef struct { /* portable directory entry * \n/  \nlong ino; /* inode number * \n/  \nchar name[name_max+1]; /* name + ''\\0'' terminator * \n/    \n } dirent;   \n typedef struct { /* minimal dir: no buffering, etc. * \n/   \nint fd; /* file descriptor for the directory *  \n/  \ndirent d; /* the directory entry * \n/   \n } dir;   \n dir *opendir(char *dirname) \n;  \ndirent *readdir(dir *dfd) \n;  \nvoid closedir(dir *dfd) \n;    \nthe system call stat takes a filename and returns all of the information in the inode for \nthat  \nfile, or -1 if there is an error. that is,\n\nchar *name;   \nstruct stat stbuf;  \nint stat(char *, struct stat *) \n;    \n stat(name, &stbuf);  \nfills the structure stbuf with the inode information for the file name. the structure \ndescribing  \nthe value returned by stat is in <sys/stat.h>, and typically looks like this:  \n struct stat /* inode information returned by stat */   {  \ndev_t st_dev; /* device of inode * \n/  \nino_t st_ino; /* inode number * \n/  \nshort st_mode; /* mode bits * \n/  \nshort st_nlink; /* number of links to file * \n/  \nshort st_uid; /* owners user id * \n/  \nshort st_gid; /* owners group id * \n/   \ndev_t st_rdev; /* for special files *  \n/ \noff_t st_size; /* file size in characters * \n/  \ntime_t st_atime; /* time last accessed * \n/ \ntime_t st_mtime; /* time last modified * \n/ \ntime_t st_ctime; /* time originally created * \n/    \n}; \nmost of these values are explained by the comment fields. the types like dev_t and ino_t   \nare defined in <sys/types.h>, which must be included too.   \nthe st_mode entry contains a set of flags describing the file. the flag definitions  are also  \nincluded in <sys/types.h>; we need only the part that deals with file type:   \n #define s_ifmt 0160000 /* type of file: *\n\n/   \n#define s_ifdir 0040000 /* directory * \n/  \n#define s_ifchr 0020000 /* character special * \n/  \n#define s_ifblk 0060000 /* block special * \n/  \n#define s_ifreg 0010000 /* regular * \n/  \n/* ... * \n/\n\nnow we are ready to write the program fsize. if the mode obtained from stat indicates \nthat  \na file is not a directory, then the size is at hand and can be printed directly. if  the name is \na  \ndirectory, however, then we have to process that directory one file at a time;  it may in \nturn  \ncontain sub-directories, so the process is recursive.   \nthe main routine deals with command-line arguments; it hands each argument to the  \nfunction  \nfsize.   \n #include <stdio.h>  \n#include <string.h>  \n#include "syscalls.h"  \n#include <fcntl.h> /* flags for read and write * \n/  \n#include <sys/types.h> /* typedefs * \n/  \n#include <sys/stat.h> /* structure returned by stat * \n/  \n#include "dirent.h"    \n void fsize(char *)     \n /* print file name * \n/  \nmain(int argc, char **argv)  {    \n if (argc == 1) /* default: current directory */  \nfsize(".");  \nelse  \nwhile (--argc > 0)  \nfsize(*++argv);  \nreturn 0; } \nthe function fsize prints the size of the file. if the file is a directory, howe ver, fsize first  \ncalls dirwalk to handle all the files in it. note how the flag names s_ifmt and s _ifdir \nare  \nused to decide if the file is a directory. parenthesization matters, because t he precedence \nof &  \nis lower than that of ==.\n\nint stat(char *, struct stat *) \n;  \nvoid dirwalk(char *, void (*fcn)(char *)) \n;    \n /* fsize: print the name of file "name" * \n/  \nvoid fsize(char *name)  {    \n struct stat stbuf;   \n if (stat(name, &stbuf) == -1)  {  \nfprintf(stderr, "fsize: can''t access %s\\n", name) \n;  \nreturn;    }  \nif ((stbuf.st_mode & s_ifmt) == s_ifdir)  \ndirwalk(name, fsize);  \nprintf("%8ld %s\\n", stbuf.st_size, name);   }  \nthe function dirwalk is a general routine that applies a function to each file in a directory. \nit  \nopens the directory, loops through the files in it, calling the function on each, then close s \nthe  \ndirectory and returns. since fsize calls dirwalk on each directory, the two funct ions call  \neach other recursively.  \n #define max_path 1024   \n /* dirwalk: apply fcn to all files in dir * \n/  \nvoid dirwalk(char *dir, void (*fcn)(char *) \n)  {\n\nchar name[max_path] \n;  \ndirent *dp;  \ndir *dfd;    \n if ((dfd = opendir(dir)) == null) {   \n fprintf(stderr, "dirwalk: can''t open %s\\n", dir);   \n return;   }  \n while ((dp = readdir(dfd)) != null) {   \n if (strcmp(dp->name, ".") == 0  \n || strcmp(dp->name, ".."))  \n continue; /* skip self and parent */  \n if (strlen(dir)+strlen(dp->name)+2 > sizeof(name))   \n fprintf(stderr, "dirwalk: name %s %s too long\\n",     \n dir, dp->name);   \nelse {  \n sprintf(name, "%s/%s", dir, dp->name);  \n (*fcn)(name);   }  }  \n closedir(dfd);   } \neach call to readdir returns a pointer to information for the next file, or null when there \nare  \nno files left. each directory always contains entries for itself, calle d ".", and its parent, \n"..";\n\nthese must be skipped, or the program will loop forever.    \ndown to this last level, the code is independent of how directories are formatted. the \nnext  \nstep is to present minimal versions of opendir, readdir, and closedir for a specific s ystem.  \nthe following routines are for version 7 and system v unix systems; they use the \ndirectory  \ninformation in the header <sys/dir.h>, which looks like this:  \n #ifndef dirsiz  \n #define dirsiz 14   \n #endif   \n struct direct { /* directory entry */  \n ino_t d_ino; /* inode number */   \nchar d_name[dirsiz]; /* long name does not have ''\\0'' */   \n}; \nsome versions of the system permit much longer names and have a more complicated  \ndirectory structure.   \nthe type ino_t is a typedef that describes the index into the inode list. it happens to be   \nunsigned short on the systems we use regularly, but this is not the sort of informati on to  \nembed in a program; it might be different on a different system, so the typedef is bette r. \na  \ncomplete set of ``system'''' types is found in <sys/types.h>.   \nopendir opens the directory, verifies that the file is a directory (this tim e by the system \ncall  \nfstat, which is like stat except that it applies to a file descriptor), a llocates a directory  \nstructure, and records the information:   \n int fstat(int fd, struct stat *);   \n /* opendir: open a directory for readdir calls */  \n dir *opendir(char *dirname)   {   \nint fd;\n\nstruct stat stbuf;\n\ndir *dp;   \n if ((fd = open(dirname, o_rdonly, 0)) == - 1  \n|| fstat(fd, &stbuf) == - 1  \n|| (stbuf.st_mode & s_ifmt) != s_ifdir  \n|| (dp = (dir *) malloc(sizeof(dir))) == null)    \n return null;  \ndp->fd = fd;  \nreturn dp;   } \nclosedir closes the directory file and frees the space:   \n /* closedir: close directory opened by opendir * \n/  \nvoid closedir(dir *dp)  {    \nif (dp)   {   \nclose(dp->fd) \n;  \nfree(dp) \n;    } } \nfinally, readdir uses read to read each directory entry. if a directory slot is not currently \nin  \nuse (because a file has been removed), the inode number is zero, and this position is \nskipped.  \notherwise, the inode number and name are placed in a static structure and a pointer  to \nthat  \nis returned to the user. each call overwrites the information from the previous one .  \n \n #include <sys/dir.h> /* local directory structure */   \n /* readdir: read directory entries in sequence *\n\n/   \ndirent *readdir(dir *dp)  {    \n struct direct dirbuf; /* local directory structure */  \nstatic dirent d; /* return: portable structure */   \n while (read(dp->fd, (char *) &dirbuf, sizeof(dirbuf) \n)  \n== sizeof(dirbuf))  {  \nif (dirbuf.d_ino == 0) /* slot not in use * \n/    \n continue;  \nd.ino = dirbuf.d_ino;  \nstrncpy(d.name, dirbuf.d_name, dirsiz);  \nd.name[dirsiz] = ''\\0''; /* ensure termination */  \nreturn &d;   }  \nreturn null;  } \nalthough the fsize program is rather specialized, it does illustrate a couple of important  \nideas. first, many programs are not ``system programs''''; they merely use informati on that \nis  \nmaintained by the operating system. for such programs, it is crucial that the \nrepresentation of  \nthe information appear only in standard headers, and that programs include those headers   \ninstead of embedding the declarations in themselves. the second observation is that  with \ncare  \nit is possible to create an interface to system-dependent objects that is  itself relatively \nsystem- \nindependent. the functions of the standard library are good examples.   \nexercise 8-5. modify the fsize program to print the other information contained in the  \ninode  \nentry.   \n8.7 example - a storage allocator  \nin chapter 5, we presented a vary limited stack-oriented storage allocator. t he version \nthat we  \nwill now write is unrestricted. calls to malloc and free may occur in any or der; malloc \ncalls\n\nupon the operating system to obtain more memory as necessary. these routines illustrate  \nsome of the considerations involved in writing machine-dependent code in a relativel y  \nmachine-independent way, and also show a real-life application of structures, unions and  \ntypedef.   \nrather than allocating from a compiled-in fixed-size array, malloc will  request space \nfrom  \nthe operating system as needed. since other activities in the program may al so request \nspace  \nwithout calling this allocator, the space that malloc manages may not be contiguous. thus  \nits  \nfree storage is kept as a list of free blocks. each block contains a size, a poi nter to the \nnext  \nblock, and the space itself. the blocks are kept in order of increasing storage address , and \nthe  \nlast block (highest address) points to the first.    \nwhen a request is made, the free list is scanned until a big-enough block is found. this  \nalgorithm is called ``first fit,'''' by contrast with ``best fit,'''' which looks for  the smallest \nblock  \nthat will satisfy the request. if the block is exactly the size requested it i s unlinked from \nthe  \nlist and returned to the user. if the block is too big, it is split, and the proper amount i s  \nreturned to the user while the residue remains on the free list. if no big-enough block is  \nfound,  \nanother large chunk is obtained by the operating system and linked into the free list.   \nfreeing also causes a search of the free list, to find the proper place to inser t the block \nbeing  \nfreed. if the block being freed is adjacent to a free block on either side, it is c oalesced \nwith it  \ninto a single bigger block, so storage does not become too fragmented. determining the  \nadjacency is easy because the free list is maintained in order of decreas ing address.  \n \none problem, which we alluded to in chapter 5, is to ensure that the storage returned  by  \nmalloc is aligned properly for the objects that will be stored in it. although machi nes \nvary,  \nfor each machine there is a most restrictive type: if the most restric tive type can be stored \nat a  \nparticular address, all other types may be also. on some machines, the most res trictive \ntype is  \na double; on others, int or long suffices.\n\na free block contains a pointer to the next block in the chain, a record of the size of the \nblock,   \nand then the free space itself; the control information at the beginning is cal led the \n``header.''''  \nto simplify alignment, all blocks are multiples of the header size, and the heade r is \naligned  \nproperly. this is achieved by a union that contains the desired header structure and a n  \ninstance of the most restrictive alignment type, which we have arbitrarily ma de a long:  \n \n typedef long align; /* for alignment to long boundary */   \n union header { /* block header */\n\nstruct {  \n union header *ptr; /* next block if on free list */   \n unsigned size; /* size of this block */  \n} s;  \nalign x; /* force alignment of blocks */   \n};  \n typedef union header header;  \nthe align field is never used; it just forces each header to be aligned on a worst-case  \nboundary.   \nin malloc, the requested size in characters is rounded up to the proper number of hea der-\nsized  \nunits; the block that will be allocated contains one more unit, for the header it self, and \nthis is  \nthe value recorded in the size field of the header. the pointer returned by malloc  points at  \nthe free space, not at the header itself. the user can do anything with the space requ ested, \nbut  \nif anything is written outside of the allocated space the list is likely to be scr ambled.  \n    \nthe size field is necessary because the blocks controlled by malloc need not be \ncontiguous -  \nit is not possible to compute sizes by pointer arithmetic.   \nthe variable base is used to get started. if freep is null, as it is at the fi rst call of \nmalloc,  \nthen a degenerate free list is created; it contains one block of size zero, an d points to \nitself. in  \nany case, the free list is then searched. the search for a free block of adequate s ize begins \nat  \nthe point (freep) where the last block was found; this strategy helps keep the lis t  \nhomogeneous. if a too-big block is found, the tail end is returned to the user; in this way \nthe  \nheader of the original needs only to have its size adjusted. in all cases, the pointe r \nreturned to  \nthe user points to the free space within the block, which begins one unit beyond the \nheader.   \n static header base; /* empty list to get started *\n\n/   \nstatic header *freep = null; /* start of free list * \n/    \n /* malloc: general-purpose storage allocator * \n/  \nvoid *malloc(unsigned nbytes)  {    \n header *p, *prevp;  \nheader *moreroce(unsigned) \n;  \nunsigned nunits;    \n nunits = (nbytes+sizeof(header)-1)/sizeof(header) + 1;   \n if ((prevp = freep) == null) { /* no free list yet */  \nbase.s.ptr = freeptr = prevptr = &base;  \nbase.s.size = 0;   }\n\nfor (p = prevp->s.ptr; ; prevp = p, p = p->s.ptr)  {  \nif (p->s.size >= nunits) { /* big enough * \n/  \nif (p->s.size == nunits) /* exactly * \n/  \nprevp->s.ptr = p->s.ptr;    \n else { /* allocate tail end */  \np->s.size -= nunits;  \np += p->s.size;  \np->s.size = nunits;   }  \nfreep = prevp;  \nreturn (void *)(p+1) \n;    }  \nif (p == freep) /* wrapped around free list */  \nif ((p = morecore(nunits)) == null)  \nreturn null; /* none left */  }  }  \nthe function morecore obtains storage from the operating system. the details of how it \ndoes  \nthis vary from system to system. since asking the system for memory is a compara tively  \nexpensive operation. we don''t want to do that on every call to malloc, so morecore \nrequests  \nal least nalloc units; this larger block will be chopped up as needed. after sett ing the \nsize  \nfield, morecore inserts the additional memory into the arena by calling free.   \nthe unix system call sbrk(n) returns a pointer to n more bytes of storage. sbrk ret urns -1  \nif there was no space, even though null could have been a better design. the -1 must \nbe cast  \nto char * so it can be compared with the return value. again, casts make the function   \nrelatively immune to the details of pointer representation on different machine s. there is \nstill  \none assumption, however, that pointers to different blocks returned by sbrk can be  \nmeaningfully compared. this is not guaranteed by the standard, which permits pointer  \ncomparisons only within an array. thus this version of malloc is portable only among  \nmachines for which general pointer comparison is meaningful.\n\n#define nalloc 1024 /* minimum #units to request */   \n /* morecore: ask system for more memory * \n/  \nstatic header *morecore(unsigned nu)  {    \n char *cp, *sbrk(int) \n;  \nheader *up;    \n if (nu < nalloc)   \n nu = nalloc;  \ncp = sbrk(nu * sizeof(header)) \n;  \nif (cp == (char *) -1) /* no space at all * \n/   \n return null;  \nup = (header *) cp;  \nup->s.size = nu;   \nfree((void *)(up+1))  \n;  \nreturn freep;    } \nfree itself is the last thing. it scans the free list, starting at freep, looking for the place to  \ninsert the free block. this is either between two existing blocks or at the end of the li st. in \nany  \ncase, if the block being freed is adjacent to either neighbor, the adjacent blocks  are \ncombined.  \nthe only troubles are keeping the pointers pointing to the right things and the sizes \ncorrect.   \n /* free: put block ap in free list * \n/  \nvoid free(void *ap)  {\n\nheader *bp, *p;   \n bp = (header *)ap - 1; /* point to block header */  \nfor (p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)  \nif (p >= p->s.ptr && (bp > p || bp < p->s.ptr))  \nbreak; /* freed block at start or end of arena */  \n if (bp + bp->size == p->s.ptr) { /* join to upper nbr */  \n bp->s.size += p->s.ptr->s.size;  \n bp->s.ptr = p->s.ptr->s.ptr;   \n} else  \n bp->s.ptr = p->s.ptr;   \n if (p + p->size == bp) { /* join to lower nbr */  \n p->s.size += bp->s.size;   \n p->s.ptr = bp->s.ptr;   \n} else   \n p->s.ptr = bp;    \nfreep = p;  } \nalthough storage allocation is intrinsically machine-dependent, the code above illustrates \nhow  \nthe machine dependencies can be controlled and confined to a very small part of the \nprogram.  \nthe use of typedef and union handles alignment (given that sbrk supplies an appropriate  \npointer). casts arrange that pointer conversions are made explicit, and even cope wi th a  \nbadly-designed system interface. even though the details here are related to st orage  \nallocation, the general approach is applicable to other situations as well.   \nexercise 8-6. the standard library function calloc(n,size) returns a pointer  to n objects of  \nsize size, with the storage initialized to zero. write calloc, by calling ma lloc or by  \nmodifying it.   \nexercise 8-7. malloc accepts a size request without checking its plausib ility; free believes  \nthat the block it is asked to free contains a valid size field. improve these routine s so they\n\nmake more pains with error checking.    \nexercise 8-8. write a routine bfree(p,n) that will free any arbitrary block p of n characters  \ninto the free list maintained by malloc and free. by using bfree, a user can add a st atic or  \nexternal array to the free list at any time.\n\nappendix a - reference manual   \na.1 introduction  \nthis manual describes the c language specified by the draft submitted to ansi on 31  \noctober, 1988, for approval as ``american standard for information systems - \nprogramming  \nlanguage c, x3.159-1989.'''' the manual is an interpretation of the proposed standard, not \nthe  \nstandard itself, although care has been taken to make it a reliable guide to the la nguage.  \n \nfor the most part, this document follows the broad outline of the standard, which in turn   \nfollows that of the first edition of this book, although the organization differs in detail . \nexcept  \nfor renaming a few productions, and not formalizing the definitions of the lexical tok ens \nor  \nthe preprocessor, the grammar given here for the language proper is equivalent to tha t of \nthe  \nstandard.   \nthroughout this manual, commentary material is indented and written in smaller  type, as \nthis is. most  \noften these comments highlight ways in which ansi standard c differs from the \nlanguage defined by  \nthe first edition of this book, or from refinements subsequently introduced in various \ncompilers.     \na.2 lexical conventions  \na program consists of one or more translation units stored in files. it is trans lated in \nseveral  \nphases, which are described in par.a.12. the first phases do low-level lexical  \ntransformations, carry out directives introduced by the lines beginning with the # \ncharacter,  \nand perform macro definition and expansion. when the preprocessing of par.a.12 is  \ncomplete, the program has been reduced to a sequence of tokens.   \na.2.1 tokens  \nthere are six classes of tokens: identifiers, keywords, constants, string lite rals, operators, \nand  \nother separators. blanks, horizontal and vertical tabs, newlines, formfeeds and c omments \nas  \ndescribed below (collectively, ``white space'''') are ignored except as they se parate tokens.  \nsome white space is required to separate otherwise adjacent identifi ers, keywords, and  \nconstants.\n\nif the input stream has been separated into tokens up to a given character, the next token \nis the   \nlongest string of characters that could constitute a token.   \na.2.2 comments  \nthe characters /* introduce a comment, which terminates with the character s */. \ncomments  \ndo not nest, and they do not occur within a string or character literals.   \na.2.3 identifiers  \nan identifier is a sequence of letters and digits. the first character must  be a letter; the  \nunderscore _ counts as a letter. upper and lower case letters are different . identifiers may  \nhave any length, and for internal identifiers, at least the first 31 character s are significant;\n\nsome implementations may take more characters significant. internal identifiers include  \npreprocessor macro names and all other names that do not have external linkage \n(par.a.11.2).  \nidentifiers with external linkage are more restricted: implementations  may make as few \nas the  \nfirst six characters significant, and may ignore case distinctions.   \na.2.4 keywords  \nthe following identifiers are reserved for the use as keywords, and may not be used   \notherwise:  \nauto double int struct  \nbreak  \ncase  \nchar  \nelse  \nenum  \nextern  \nlongregisterreturn  \nswitch  \ntypedefunion  \nconst  \ncontinue  \ndefault  do   \nfloat   \nfor  \ngotoif  \nshort  \nsignedsizeof  \nstatic  \nunsignedvoid  \nvolatile  \nwhile   \nsome implementations also reserve the words fortran and asm.  \nthe keywords const, signed, and volatile are new with the ansi standard; enum and void  \nare new since the first edition, but in common use; entry, formerly reserved but never  \nused, is no  \nlonger reserved.   \na.2.5 constants  \nthere are several kinds of constants. each has a data type; par.a.4.2 discusses t he basic \ntypes:\n\nconstant:   \ninteger-constant  \ncharacter-constant  \nfloating-constant  \nenumeration-constant   \na.2.5.1 integer constants  \nan integer constant consisting of a sequence of digits is taken to be octal if it begins with \n0  \n(digit zero), decimal otherwise. octal constants do not contain the digits 8 or 9. a \nsequence of  \ndigits preceded by 0x or 0x (digit zero) is taken to be a hexadecimal integer. the \nhexadecimal  \ndigits include a or a through f or f with values 10 through 15.   \nan integer constant may be suffixed by the letter u or u, to specify that it is unsigned. i t \nmay  \nalso be suffixed by the letter l or l to specify that it is long.   \nthe type of an integer constant depends on its form, value and suffix. (see par.a.4 for a  \ndiscussion of types). if it is unsuffixed and decimal, it has the first of these types  in which \nits  \nvalue can be represented: int, long int, unsigned long int. if it is unsuffixed, octal or  \nhexadecimal, it has the first possible of these types: int, unsigned int, long int,  \nunsigned long int. if it is suffixed by u or u, then unsigned int, unsigned long int. if  \nit is suffixed by l or l, then long int, unsigned long int. if an integer constant is suffixed   \nby ul, it is unsigned long.   \nthe elaboration of the types of integer constants goes considerably beyond the first \nedition, which  \nmerely caused large integer constants to be long. the u suffixes are new.\n\na.2.5.2 character constants  \na character constant is a sequence of one or more characters enclosed in single quotes as \nin  \n''x''. the value of a character constant with only one character is the numeric value  of the  \ncharacter in the machine''s character set at execution time. the value of a m ulti-character  \nconstant is implementation-defined.   \ncharacter constants do not contain the '' character or newlines; in order to repr esent them, \nand  \ncertain other characters, the following escape sequences may be used:   \nnewline nl (lf) \\n backslash \\ \\\\  \nhorizontal tab ht \\t question mark ? \\?  \nvertical tab vt \\v single quote '' \\''  \nbackspace bs \\b double quote " \\"  \ncarriage return cr \\r octal number ooo \\ooo  \nformfeed ff \\f hex number hh \\xhh  \naudible alert bel \\a  \nthe escape \\ooo consists of the backslash followed by 1, 2, or 3 octal digits, which are \ntaken  \nto specify the value of the desired character. a common example of this constructi on is \\0  \n(not followed by a digit), which specifies the character nul. the escape \\xhh consist s of \nthe  \nbackslash, followed by x, followed by hexadecimal digits, which are taken to specify the  \nvalue of the desired character. there is no limit on the number of digits, but the beha vior \nis  \nundefined if the resulting character value exceeds that of the largest char acter. for either \noctal  \nor hexadecimal escape characters, if the implementation treats the char ty pe as signed, the  \nvalue is sign-extended as if cast to char type. if the character following th e \\ is not one of  \nthose specified, the behavior is undefined.   \nin some implementations, there is an extended set of characters that cannot be \nrepresented in  \nthe char type. a constant in this extended set is written with a preceding l , for example \nl''x'',  \nand is called a wide character constant. such a constant has type wchar_t, an integra l type  \ndefined in the standard header <stddef.h>. as with ordinary character constants,  \nhexadecimal escapes may be used; the effect is undefined if the specified val ue exceeds \nthat  \nrepresentable with wchar_t.   \nsome of these escape sequences are new, in particular the hexadecimal chara cter \nrepresentation.\n\nextended characters are also new. the character sets commonly used in the americas and \nwestern   \neurope can be encoded to fit in the char type; the main intent in adding wchar_t was to  \naccommodate asian languages.   \na.2.5.3 floating constants  \na floating constant consists of an integer part, a decimal part, a fraction part , an e or e, an  \noptionally signed integer exponent and an optional type suffix, one of f, f, l, or l. the \ninteger  \nand fraction parts both consist of a sequence of digits. either the integer part, or  the \nfraction  \npart (not both) may be missing; either the decimal point or the e and the exponent (not \nboth)  \nmay be missing. the type is determined by the suffix; f or f makes it float, l or l makes  \nit  \nlong double, otherwise it is double.   \na2.5.4 enumeration constants\n\nidentifiers declared as enumerators (see par.a.8.4) are constants of type int.  \n \na.2.6 string literals  \na string literal, also called a string constant, is a sequence of characters  surrounded by \ndouble  \nquotes as in "...". a string has type ``array of characters'''' and storage class  static (see  \npar.a.3 below) and is initialized with the given characters. whether identic al string \nliterals  \nare distinct is implementation-defined, and the behavior of a program that attem pts to \nalter a  \nstring literal is undefined.   \nadjacent string literals are concatenated into a single string. after any conc atenation, a \nnull  \nbyte \\0 is appended to the string so that programs that scan the string can find its end. \nstring  \nliterals do not contain newline or double-quote characters; in order to repres ent them, the  \nsame escape sequences as for character constants are available.   \nas with character constants, string literals in an extended character set a re written with a  \npreceding l, as in l"...". wide-character string literals have type ``array of  wchar_t.''''  \nconcatenation of ordinary and wide string literals is undefined.   \nthe specification that string literals need not be distinct, and the prohibiti on against \nmodifying them,   \nare new in the ansi standard, as is the concatenation of adjacent string litera ls. wide-\ncharacter string   \nliterals are new.   \na.3 syntax notation  \nin the syntax notation used in this manual, syntactic categories are indicate d by italic \ntype,  \nand literal words and characters in typewriter style. alternative cat egories are usually \nlisted  \non separate lines; in a few cases, a long set of narrow alternatives is presen ted on one \nline,  \nmarked by the phrase ``one of.'''' an optional terminal or nonterminal symbol carries the   \nsubscript ``opt,'''' so that, for example,   \n{ expressionopt }   \nmeans an optional expression, enclosed in braces. the syntax is summarized in par.a.13.   \n \nunlike the grammar given in the first edition of this book, the one given here makes \nprecedence and\n\nassociativity of expression operators explicit.    \na.4 meaning of identifiers  \nidentifiers, or names, refer to a variety of things: functions; tags of structures, unions, and  \nenumerations; members of structures or unions; enumeration constants; typede f names; \nand  \nobjects. an object, sometimes called a variable, is a location in storage, and i ts \ninterpretation  \ndepends on two main attributes: its storage class and its type. the storage cla ss \ndetermines the  \nlifetime of the storage associated with the identified object; the type dete rmines the \nmeaning  \nof the values found in the identified object. a name also has a scope, which is the region \nof  \nthe program in which it is known, and a linkage, which determines whether the same \nname in  \nanother scope refers to the same object or function. scope and linkage are discusse d in  \npar.a.11.   \na.4.1 storage class\n\nthere are two storage classes: automatic and static. several keywords, together with the  \ncontext of an object''s declaration, specify its storage class. automatic objec ts are local to \na  \nblock (par.9.3), and are discarded on exit from the block. declarations within a block \ncreate  \nautomatic objects if no storage class specification is mentioned, or if the aut o specifier is  \nused. objects declared register are automatic, and are (if possible) stored i n fast registers \nof  \nthe machine.   \nstatic objects may be local to a block or external to all blocks, but in either ca se retain \ntheir  \nvalues across exit from and reentry to functions and blocks. within a block, including a \nblock  \nthat provides the code for a function, static objects are declared with the keyword s tatic.  \nthe objects declared outside all blocks, at the same level as function definitions , are \nalways  \nstatic. they may be made local to a particular translation unit by use of the stat ic \nkeyword;  \nthis gives them internal linkage. they become global to an entire program by omitting an  \nexplicit storage class, or by using the keyword extern; this gives them external linkag e.  \n \na.4.2 basic types  \nthere are several fundamental types. the standard header <limits.h> described in \nappendix   \nb defines the largest and smallest values of each type in the local impleme ntation. the  \nnumbers given in appendix b show the smallest acceptable magnitudes.    \nobjects declared as characters (char) are large enough to store any member  of the \nexecution  \ncharacter set. if a genuine character from that set is stored in a char obj ect, its value is  \nequivalent to the integer code for the character, and is non-negative. other quantities  may \nbe  \nstored into char variables, but the available range of values, and especially whe ther the \nvalue  \nis signed, is implementation-dependent.   \nunsigned characters declared unsigned char consume the same amount of space as pl ain  \ncharacters, but always appear non-negative; explicitly signed characters de clared signed  \nchar likewise take the same space as plain characters.   \nunsigned char type does not appear in the first edition of this book, but is in common use. \nsigned  \nchar is new.\n\nbesides the char types, up to three sizes of integer, declared short int, int, and long int,  \nare available. plain int objects have the natural size suggested by the host ma chine  \narchitecture; the other sizes are provided to meet special needs. longer integer s provide \nat   \nleast as much storage as shorter ones, but the implementation may make plain i ntegers  \nequivalent to either short integers, or long integers. the int types all represent s igned \nvalues  \nunless specified otherwise.   \nunsigned integers, declared using the keyword unsigned, obey the laws of arithmetic \nmodulo  \n2n where n is the number of bits in the representation, and thus arithmetic on unsigned  \nquantities can never overflow. the set of non-negative values that can be stored in a \nsigned  \nobject is a subset of the values that can be stored in the corresponding unsigned object, \nand  \nthe representation for the overlapping values is the same.   \nany of single precision floating point (float), double precision floating point (double), \nand  \nextra precision floating point (long double) may be synonymous, but the ones later in the  \nlist are at least as precise as those before.\n\nlong double is new. the first edition made long float equivalent to double; the locution \nhas  \nbeen withdrawn.   \nenumerations are unique types that have integral values; associated with each \nenumeration is  \na set of named constants (par.a.8.4). enumerations behave like integers, but it i s \ncommon for  \na compiler to issue a warning when an object of a particular enumeration is assigned   \nsomething other than one of its constants, or an expression of its type.   \nbecause objects of these types can be interpreted as numbers, they will be referr ed to as  \narithmetic types. types char, and int of all sizes, each with or without sign, and a lso  \nenumeration types, will collectively be called integral types. the types float, doubl e, and  \nlong double will be called floating types.   \nthe void type specifies an empty set of values. it is used as the type returned by functi ons  \nthat generate no value.   \na.4.3 derived types  \nbeside the basic types, there is a conceptually infinite class of derived typ es constructed \nfrom  \nthe fundamental types in the following ways:   \narrays of objects of a given type;     \nfunctions returning objects of a given type;   \npointers to objects of a given type;   \nstructures containing a sequence of objects of various types;   \nunions capable of containing any of one of several objects of various types.   \nin general these methods of constructing objects can be applied recursively.   \na.4.4 type qualifiers  \nan object''s type may have additional qualifiers. declaring an object const announces  that \nits  \nvalue will not be changed; declaring it volatile announces that it has special proper ties  \nrelevant to optimization. neither qualifier affects the range of values or  arithmetic \nproperties  \nof the object. qualifiers are discussed in par.a.8.2.   \na.5 objects and lvalues\n\nan object is a named region of storage; an lvalue is an expression referring to an object. \nan   \nobvious example of an lvalue expression is an identifier with suitable type and stor age \nclass.  \nthere are operators that yield lvalues, if e is an expression of pointer type, then *e  is an \nlvalue  \nexpression referring to the object to which e points. the name ``lvalue'''' comes from  the  \nassignment expression e1 = e2 in which the left operand e1 must be an lvalue \nexpression.  \nthe discussion of each operator specifies whether it expects lvalue operands and whet her \nit  \nyields an lvalue.   \na.6 conversions  \nsome operators may, depending on their operands, cause conversion of the value of an  \noperand from one type to another. this section explains the result to be expected from \nsuch\n\nconversions. par.6.5 summarizes the conversions demanded by most ordinary operators; \nit  \nwill be supplemented as required by the discussion of each operator.   \na.6.1 integral promotion  \na character, a short integer, or an integer bit-field, all either signed or not, or  an object of  \nenumeration type, may be used in an expression wherever an integer may be used. if an \nint  \ncan represent all the values of the original type, then the value is converted to int;  \notherwise  \nthe value is converted to unsigned int. this process is called integral promotion.   \na.6.2 integral conversions  \nany integer is converted to a given unsigned type by finding the smallest non-negative \nvalue  \nthat is congruent to that integer, modulo one more than the largest value that can be  \nrepresented in the unsigned type. in a two''s complement representation, this is equ ivalent \nto  \nleft-truncation if the bit pattern of the unsigned type is narrower, and to zero-fi lling \nunsigned  \nvalues and sign-extending signed values if the unsigned type is wider.   \nwhen any integer is converted to a signed type, the value is unchanged if it can be \nrepresented  \nin the new type and is implementation-defined otherwise.     \na.6.3 integer and floating  \nwhen a value of floating type is converted to integral type, the fractional par t is \ndiscarded; if  \nthe resulting value cannot be represented in the integral type, the behavior i s undefined. \nin  \nparticular, the result of converting negative floating values to unsigned integral t ypes is \nnot  \nspecified.   \nwhen a value of integral type is converted to floating, and the value is in the \nrepresentable  \nrange but is not exactly representable, then the result may be either the next higher  or \nnext  \nlower representable value. if the result is out of range, the behavior is undefi ned.  \n \na.6.4 floating types  \nwhen a less precise floating value is converted to an equally or more precise fl oating \ntype, the\n\nvalue is unchanged. when a more precise floating value is converted to a less precise \nfloating   \ntype, and the value is within representable range, the result may be either the nex t higher \nor  \nthe next lower representable value. if the result is out of range, the behavior is unde fined.  \n \na.6.5 arithmetic conversions  \nmany operators cause conversions and yield result types in a similar way. the ef fect is to  \nbring operands into a common type, which is also the type of the result. this pattern is \ncalled  \nthe usual arithmetic conversions.   \n•  \nfirst, if either operand is long double, the other is converted to long double.  \n•  \notherwise, if either operand is double, the other is converted to double.  \n•  \notherwise, if either operand is float, the other is converted to float.  \n•  \notherwise, the integral promotions are performed on both operands; then, if either  \noperand is unsigned long int, the other is converted to unsigned long int.\n\n•  \notherwise, if one operand is long int and the other is unsigned int, the effect  \ndepends on whether a long int can represent all values of an unsigned int; if so,  \nthe unsigned int operand is converted to long int; if not, both are converted to  \nunsigned long int.  \n•  \notherwise, if one operand is long int, the other is converted to long int.  \n•  \notherwise, if either operand is unsigned int, the other is converted to unsigned  \nint.  \n•  \notherwise, both operands have type int.  \nthere are two changes here. first, arithmetic on float operands may be done in single \nprecision,  \nrather than double; the first edition specified that all floating arithmetic was double \nprecision. second,  \nshorter unsigned types, when combined with a larger signed type, do not propagate the \nunsigned  \nproperty to the result type; in the first edition, the unsigned always dominated. the new  \nrules are  \nslightly more complicated, but reduce somewhat the surprises that may occur when an \nunsigned  \nquantity meets signed. unexpected results may still occur when an unsigned expressi on is \ncompared to  \na signed expression of the same size.     \na.6.6 pointers and integers  \nan expression of integral type may be added to or subtracted from a pointer; in such a \ncase  \nthe integral expression is converted as specified in the discussion of the additi on operator  \n(par.a.7.7).   \ntwo pointers to objects of the same type, in the same array, may be subtracted; the r esult \nis  \nconverted to an integer as specified in the discussion of the subtraction operator  \n(par.a.7.7).   \nan integral constant expression with value 0, or such an expression cast to type void *, \nmay  \nbe converted, by a cast, by assignment, or by comparison, to a pointer of any type. this  \nproduces a null pointer that is equal to another null pointer of the same type, but unequa l \nto  \nany pointer to a function or object.\n\ncertain other conversions involving pointers are permitted, but have implementation-\ndefined   \naspects. they must be specified by an explicit type-conversion operator, or cast \n(pars.a.7.5  \nand a.8.8).   \na pointer may be converted to an integral type large enough to hold it; the required size \nis  \nimplementation-dependent. the mapping function is also implementation-dependent.   \na pointer to one type may be converted to a pointer to another type. the resulting pointer \nmay  \ncause addressing exceptions if the subject pointer does not refer to an object suit ably \naligned  \nin storage. it is guaranteed that a pointer to an object may be converted to a pointer t o an  \nobject whose type requires less or equally strict storage alignment and back agai n without  \nchange; the notion of ``alignment'''' is implementation-dependent, but objects of the char \ntypes  \nhave least strict alignment requirements. as described in par.a.6.8, a pointer ma y also be  \nconverted to type void * and back again without change.   \na pointer may be converted to another pointer whose type is the same except for the \naddition  \nor removal of qualifiers (pars.a.4.4, a.8.2) of the object type to which the pointer refers . \nif  \nqualifiers are added, the new pointer is equivalent to the old except for restric tions \nimplied by  \nthe new qualifiers. if qualifiers are removed, operations on the underlying object r emain  \nsubject to the qualifiers in its actual declaration.\n\nfinally, a pointer to a function may be converted to a pointer to another function type. \ncalling  \nthe function specified by the converted pointer is implementation-dependent; however, if \nthe  \nconverted pointer is reconverted to its original type, the result is identical  to the original  \npointer.   \na.6.7 void  \nthe (nonexistent) value of a void object may not be used in any way, and neither explicit \nnor  \nimplicit conversion to any non-void type may be applied. because a void expression \ndenotes a  \nnonexistent value, such an expression may be used only where the value is not required, \nfor  \nexample as an expression statement (par.a.9.2) or as the left operand of a comma \noperator  \n(par.a.7.18).   \nan expression may be converted to type void by a cast. for example, a void cast \ndocuments  \nthe discarding of the value of a function call used as an expression statement.   \nvoiddid not appear in the first edition of this book, but has become common since.   \na.6.8 pointers to void   \nany pointer to an object may be converted to type void * without loss of information. if  \nthe  \nresult is converted back to the original pointer type, the original pointer i s recovered. \nunlike  \nthe pointer-to-pointer conversions discussed in par.a.6.6, which generally require an \nexplicit  \ncast, pointers may be assigned to and from pointers of type void *, and may be compared  \nwith them.   \nthis interpretation of void * pointers is new; previously, char * pointers played the role \nof generic   \npointer. the ansi standard specifically blesses the meeting of void * pointers with \nobject pointers in   \nassignments and relationals, while requiring explicit casts for other pointer m ixtures.  \n \na.7 expressions  \nthe precedence of expression operators is the same as the order of the major subsecti ons \nof\n\nthis section, highest precedence first. thus, for example, the expressions referred to as the  \noperands of + (par.a.7.7) are those expressions defined in pars.a.7.1-a.7.6. within each   \nsubsection, the operators have the same precedence. left- or right-associativity  is \nspecified in  \neach subsection for the operators discussed therein. the grammar given in par.13 \nincorporates  \nthe precedence and associativity of the operators.   \nthe precedence and associativity of operators is fully specified, but the order of \nevaluation of  \nexpressions is, with certain exceptions, undefined, even if the subexpressions involve si de  \neffects. that is, unless the definition of the operator guarantees that its ope rands are \nevaluated  \nin a particular order, the implementation is free to evaluate operands in an y order, or even \nto  \ninterleave their evaluation. however, each operator combines the values produce d by its  \noperands in a way compatible with the parsing of the expression in which it appears.   \n \nthis rule revokes the previous freedom to reorder expressions with operators that are  \nmathematically  \ncommutative and associative, but can fail to be computationally associative. the  change \naffects only  \nfloating-point computations near the limits of their accuracy, and situations whe re \noverflow is possible.   \nthe handling of overflow, divide check, and other exceptions in expression evaluation is  \nnot   \ndefined by the language. most existing implementations of c ignore overflow in \nevaluation of  \nsigned integral expressions and assignments, but this behavior is not guarante ed. \ntreatment of\n\ndivision by 0, and all floating-point exceptions, varies among implementations; \nsometimes it  \nis adjustable by a non-standard library function.   \na.7.1 pointer conversion  \nif the type of an expression or subexpression is ``array of t,'''' for some type t, then the \nvalue  \nof the expression is a pointer to the first object in the array, and the type of the expression \nis  \naltered to ``pointer to t.'''' this conversion does not take place if the expression is  in the  \noperand of the unary & operator, or of ++, --, sizeof, or as the left operand of an \nassignment  \noperator or the . operator. similarly, an expression of type ``function returning t,''''  except  \nwhen used as the operand of the & operator, is converted to ``pointer to function \nreturning t.''''   \na.7.2 primary expressions  \nprimary expressions are identifiers, constants, strings, or expressions in par entheses.  \n \n primary-expression  \nidentifier  \nconstant  \nstring  \n(expression)      \nan identifier is a primary expression, provided it has been suitably declared as dis cussed  \nbelow. its type is specified by its declaration. an identifier is an lvalue i f it refers to an \nobject  \n(par.a.5) and if its type is arithmetic, structure, union, or pointer.   \na constant is a primary expression. its type depends on its form as discussed in par.a.2.5.   \n \na string literal is a primary expression. its type is originally ``array of  char'''' (for wide-\nchar  \nstrings, ``array of wchar_t''''), but following the rule given in par.a.7.1, this is usually  \nmodified to ``pointer to char'''' (wchar_t) and the result is a pointer to the f irst character in \nthe  \nstring. the conversion also does not occur in certain initializers; see par.a.8.7.   \n \na parenthesized expression is a primary expression whose type and value are identical t o  \nthose of the unadorned expression. the precedence of parentheses does not affect \nwhether the  \nexpression is an lvalue.\n\na.7.3 postfix expressions   \nthe operators in postfix expressions group left to right.   \n postfix-expression:  \nprimary-expression  \npostfix-expression[expression]  \npostfix-expression(argument-expression-listopt)  \npostfix-expression.identifier  \npostfix-expression->identifier  \npostfix-expression+ \n+  \npostfix-expression-\n\nargument-expression-list:  \nassignment-expression  \nassignment-expression-list , assignment-expression   \na.7.3.1 array references  \na postfix expression followed by an expression in square brackets is a postfix expression  \ndenoting a subscripted array reference. one of the two expressions must have type \n``pointer to  \nt'''', where t is some type, and the other must have integral type; the type of the subscript  \nexpression is t. the expression e1[e2] is identical (by definition) to *((e1)+(e2)) . see  \npar.a.8.6.2 for further discussion.   \na.7.3.2 function calls  \na function call is a postfix expression, called the function designator, followed by \nparentheses  \ncontaining a possibly empty, comma-separated list of assignment expressions \n(par.a7.17),  \nwhich constitute the arguments to the function. if the postfix expression consists of a n  \nidentifier for which no declaration exists in the current scope, the identifier  is implicitly  \ndeclared as if the declaration   \nextern int identifier();   \nhad been given in the innermost block containing the function call. the postfix  \nexpression   \n(after possible explicit declaration and pointer generation, par.a7.1) must be of t ype \n``pointer  \nto function returning t,'''' for some type t, and the value of the function call has type t.   \nin the first edition, the type was restricted to ``function,'''' and an explicit * ope rator was \nrequired to call  \nthrough pointers to functions. the ansi standard blesses the practice of some existi ng \ncompilers by  \npermitting the same syntax for calls to functions and to functions specified by pointers . \nthe older  \nsyntax is still usable.   \nthe term argument is used for an expression passed by a function call; the term \nparameter is  \nused for an input object (or its identifier) received by a function definition, or des cribed \nin a  \nfunction declaration. the terms ``actual argument (parameter)'''' and ``formal  argument  \n(parameter)'''' respectively are sometimes used for the same distinction.\n\nin preparing for the call to a function, a copy is made of each argument; all argument- \npassing  \nis strictly by value. a function may change the values of its parameter objects, which are  \ncopies of the argument expressions, but these changes cannot affect the values of the   \narguments. however, it is possible to pass a pointer on the understanding that the \nfunction  \nmay change the value of the object to which the pointer points.   \nthere are two styles in which functions may be declared. in the new style, the types o f  \nparameters are explicit and are part of the type of the function; such a declarati on os also  \ncalled a function prototype. in the old style, parameter types are not specified. f unction  \ndeclaration is issued in pars.a.8.6.3 and a.10.1.   \nif the function declaration in scope for a call is old-style, then default argu ment \npromotion is  \napplied to each argument as follows: integral promotion (par.a.6.1) is performe d on each  \nargument of integral type, and each float argument is converted to double. the effect of  \nthe  \ncall is undefined if the number of arguments disagrees with the number of paramet ers in \nthe  \ndefinition of the function, or if the type of an argument after promotion disagrees wit h \nthat of  \nthe corresponding parameter. type agreement depends on whether the function''s \ndefinition is\n\nnew-style or old-style. if it is old-style, then the comparison is between the promoted type \nof  \nthe arguments of the call, and the promoted type of the parameter, if the definition i s \nnew- \nstyle, the promoted type of the argument must be that of the parameter itself, w ithout  \npromotion.   \nif the function declaration in scope for a call is new-style, then the arguments  are \nconverted,  \nas if by assignment, to the types of the corresponding parameters of the function''s \nprototype.  \nthe number of arguments must be the same as the number of explicitly described \nparameters,  \nunless the declaration''s parameter list ends with the ellipsis notation ( , ...). in that case, \nthe  \nnumber of arguments must equal or exceed the number of parameters; trailing a rguments  \nbeyond the explicitly typed parameters suffer default argument promotion as describe d in \nthe  \npreceding paragraph. if the definition of the function is old-style, then the type of each   \nparameter in the definition, after the definition parameter''s type has underg one argument  \npromotion.   \nthese rules are especially complicated because they must cater to a mixtu re of old- and \nnew-style  \nfunctions. mixtures are to be avoided if possible.     \nthe order of evaluation of arguments is unspecified; take note that various compile rs \ndiffer.  \nhowever, the arguments and the function designator are completely evaluated, including \nall  \nside effects, before the function is entered. recursive calls to any function ar e permitted.  \n \na.7.3.3 structure references  \na postfix expression followed by a dot followed by an identifier is a postfix expression. \nthe  \nfirst operand expression must be a structure or a union, and the identifier must nam e a  \nmember of the structure or union. the value is the named member of the structure or  \nunion,  \nand its type is the type of the member. the expression is an lvalue if the first e xpression \nis an  \nlvalue, and if the type of the second expression is not an array type.   \na postfix expression followed by an arrow (built from -and >) followed by an identifier is \na\n\npostfix expression. the first operand expression must be a pointer to a structure or union, \nand   \nthe identifier must name a member of the structure or union. the result refers to t he \nnamed  \nmember of the structure or union to which the pointer expression points, and the type is \nthe  \ntype of the member; the result is an lvalue if the type is not an array type.   \nthus the expression e1->mos is the same as (*e1).mos. structures and unions are  \ndiscussed  \nin par.a.8.3.   \nin the first edition of this book, it was already the rule that a member name in such an \nexpression had to  \nbelong to the structure or union mentioned in the postfix expression; however, a note \nadmitted that this  \nrule was not firmly enforced. recent compilers, and ansi, do enforce it.   \na.7.3.4 postfix incrementation  \na postfix expression followed by a ++ or -- operator is a postfix expression. the value of \nthe  \nexpression is the value of the operand. after the value is noted, the operand is \nincremented ++  \nor decremented --by 1. the operand must be an lvalue; see the discussion of additive  \noperators (par.a.7.7) and assignment (par.a.7.17) for further constraints on the operand \nand   \ndetails of the operation. the result is not an lvalue.    \na.7.4 unary operators\n\nexpressions with unary operators group right-to-left.   \nunary-expression:  \npostfix expression \n++unary expression \n--unary expression \nunary-operator cast-expression \nsizeof unary-expression \nsizeof(type-name)    \nunary operator: one of   \n& * + - ~ !   \na.7.4.1 prefix incrementation operators  \na unary expression followed by a ++ or -- operator is a unary expression. the operand is  \nincremented ++ or decremented --by 1. the value of the expression is the value after the  \nincrementation (decrementation). the operand must be an lvalue; see the discussi on of  \nadditive operators (par.a.7.7) and assignment (par.a.7.17) for further constraints on the   \noperands and details of the operation. the result is not an lvalue.   \na.7.4.2 address operator  \nthe unary operator & takes the address of its operand. the operand must be an lvalue \nreferring   \nneither to a bit-field nor to an object declared as register, or must be of function  type. the  \nresult is a pointer to the object or function referred to by the lvalue. if the  type of the \noperand   \nis t, the type of the result is ``pointer to t.''''   \na.7.4.3 indirection operator  \nthe unary * operator denotes indirection, and returns the object or function to which its   \noperand points. it is an lvalue if the operand is a pointer to an object of arithmetic , \nstructure,  \nunion, or pointer type. if the type of the expression is ``pointer to t,'''' the type of the result  \nis   \nt.  \na.7.4.4 unary plus operator  \nthe operand of the unary + operator must have arithmetic type, and the result is the va lue \nof  \nthe operand. an integral operand undergoes integral promotion. the type of the result is  \nthe  \ntype of the promoted operand.\n\nthe unary + is new with the ansi standard. it was added for symmetry with the unary -.    \na.7.4.5 unary minus operator  \nthe operand of the unary - operator must have arithmetic type, and the result is the \nnegative  \nof its operand. an integral operand undergoes integral promotion. the negative of an  \nunsigned quantity is computed by subtracting the promoted value from the largest value \nof the  \npromoted type and adding one; but negative zero is zero. the type of the result is the type \nof  \nthe promoted operand.   \na.7.4.6 one''s complement operator\n\nthe operand of the ~ operator must have integral type, and the result is the one''s \ncomplement  \nof its operand. the integral promotions are performed. if the operand is unsigned, the \nresult is  \ncomputed by subtracting the value from the largest value of the promoted type. if the \noperand  \nis signed, the result is computed by converting the promoted operand to the \ncorresponding  \nunsigned type, applying ~, and converting back to the signed type. the type of the result \nis the  \ntype of the promoted operand.   \na.7.4.7 logical negation operator  \nthe operand of the ! operator must have arithmetic type or be a pointer, and the result is 1 \nif  \nthe value of its operand compares equal to 0, and 0 otherwise. the type of the result is  \nint.   \na.7.4.8 sizeof operator  \nthe sizeof operator yields the number of bytes required to store an object of the type  of \nits  \noperand. the operand is either an expression, which is not evaluated, or a parenthesi zed \ntype  \nname. when sizeof is applied to a char, the result is 1; when applied to an arr ay, the result \nis   \nthe total number of bytes in the array. when applied to a structure or union, the resu lt is \nthe   \nnumber of bytes in the object, including any padding required to make the object tile an \narray:  \nthe size of an array of n elements is n times the size of one element. the operato r may not \nbe  \napplied to an operand of function type, or of incomplete type, or to a bit-field. the result \nis an  \nunsigned integral constant; the particular type is implementation-defined. t he standard \nheader  \n<stddef.h> (see appendix b) defines this type as size_t.   \na.7.5 casts  \na unary expression preceded by the parenthesized name of a type causes conversion of \nthe  \nvalue of the expression to the named type.   \n cast-expression:  \nunary expression  \n(type-name) cast-expression\n\nthis construction is called a cast. the names are described in par.a.8.8. the effects of  \nconversions are described in par.a.6. an expression with a cast is not an lvalue.   \na.7.6 multiplicative operators  \nthe multiplicative operators *, /, and % group left-to-right.   \nmultiplicative-expression:  \nmultiplicative-expression * cast-expression \nmultiplicative-expression / cast-expression \nmultiplicative-expression % cast-expression   \nthe operands of * and / must have arithmetic type; the operands of % must have integra l \ntype.  \nthe usual arithmetic conversions are performed on the operands, and predict the t ype of \nthe  \nresult.   \nthe binary * operator denotes multiplication.\n\nthe binary / operator yields the quotient, and the % operator the remainder, of the \ndivision of  \nthe first operand by the second; if the second operand is 0, the result is undefined. \notherwise,  \nit is always true that (a/b)*b + a%b is equal to a. if both operands are non-negative, then \nthe  \nremainder is non-negative and smaller than the divisor, if not, it is guaranteed only t hat \nthe  \nabsolute value of the remainder is smaller than the absolute value of the divisor.   \na.7.7 additive operators  \nthe additive operators + and - group left-to-right. if the operands have arithmeti c type, \nthe  \nusual arithmetic conversions are performed. there are some additional type possi bilities \nfor  \neach operator.   \nadditive-expression:  \nmultiplicative-expression \nadditive-expression + multiplicative-expression \nadditive-expression -multiplicative-expression   \nthe result of the + operator is the sum of the operands. a pointer to an object in an arra y \nand a   \nvalue of any integral type may be added. the latter is converted to an address offse t by  \nmultiplying it by the size of the object to which the pointer points. the sum is a pointer  of \nthe   \nsame type as the original pointer, and points to another object in the same array, \nappropriately  \noffset from the original object. thus if p is a pointer to an object in an array, the  \nexpression  \np+1 is a pointer to the next object in the array. if the sum pointer points outside the \nbounds of  \nthe array, except at the first location beyond the high end, the result is undefined.   \nthe provision for pointers just beyond the end of an array is new. it legitimizes a \ncommon idiom for  \nlooping over the elements of an array.   \nthe result of the - operator is the difference of the operands. a value of any integral  type \nmay  \nbe subtracted from a pointer, and then the same conversions and conditions as for \naddition  \napply.\n\nif two pointers to objects of the same type are subtracted, the result is a signed integral \nvalue  \nrepresenting the displacement between the pointed-to objects; pointers to succe ssive \nobjects  \ndiffer by 1. the type of the result is defined as ptrdiff_t in the standard header  \n<stddef.h>. the value is undefined unless the pointers point to objects within the same   \narray; however, if p points to the last member of an array, then (p+1)-p has value 1.   \n \na.7.8 shift operators  \nthe shift operators << and >> group left-to-right. for both operators, each operand m ust \nbe  \nintegral, and is subject to integral the promotions. the type of the result is  that of the  \npromoted left operand. the result is undefined if the right operand is negative, or great er \nthan  \nor equal to the number of bits in the left expression''s type.   \nshift-expression:  \nadditive-expression \nshift-expression << additive-expression \nshift-expression >> additive-expression   \nthe value of e1<<e2 is e1 (interpreted as a bit pattern) left-shifted e2 bits;  in the \nabsence of  \noverflow, this is equivalent to multiplication by 2e2. the value of e1>>e2 is e1 right- \nshifted\n\ne2 bit positions. the right shift is equivalent to division by 2e2 if e1 is unsigned or it has \na  \nnon-negative value; otherwise the result is implementation-defined.   \na.7.9 relational operators  \nthe relational operators group left-to-right, but this fact is not useful; a <b<c is parsed as  \n(a<b)<c, and evaluates to either 0 or 1.   \nrelational-expression:  \nshift-expression \nrelational-expression < shift-expression \nrelational-expression > shift-expression \nrelational-expression <= shift-expression \nrelational-expression >= shift-expression   \nthe operators < (less), > (greater), <= (less or equal) and >= (greater o r equal) all yield 0 \nif the  \nspecified relation is false and 1 if it is true. the type of the result is int . the usual \narithmetic  \nconversions are performed on arithmetic operands. pointers to objects of the same  type  \n(ignoring any qualifiers) may be compared; the result depends on the relative locat ions in \nthe  \naddress space of the pointed-to objects. pointer comparison is defined only for part s of \nthe   \nsame object; if two pointers point to the same simple object, they compare equal; if  the  \npointers are to members of the same structure, pointers to objects declare d later in the  \nstructure compare higher; if the pointers refer to members of an array, t he comparison is  \nequivalent to comparison of the the corresponding subscripts. if p points to the last  \nmember of  \nan array, then p+1 compares higher than p, even though p+1 points outside the array.  \notherwise, pointer comparison is undefined.   \nthese rules slightly liberalize the restrictions stated in the first e dition, by permitting \ncomparison of  \npointers to different members of a structure or union. they also legalize compar ison with \na pointer just  \noff the end of an array.   \na.7.10 equality operators  \nequality-expression:  \nrelational-expression \nequality-expression == relational-expression \nequality-expression != relational-expression\n\nthe == (equal to) and the != (not equal to) operators are analogous to the relational \noperators  \nexcept for their lower precedence. (thus a<b == c<d is 1 whenever a<b and c<d have the   \nsame truth-value.)   \nthe equality operators follow the same rules as the relational operator s, but permit \nadditional  \npossibilities: a pointer may be compared to a constant integral expression wit h value 0, or \nto a  \npointer to void. see par.a.6.6.   \na.7.11 bitwise and operator  \nand-expression:  \nequality-expression \nand-expression & equality-expression\n\nthe usual arithmetic conversions are performed; the result is the bitwise and function of \nthe  \noperands. the operator applies only to integral operands.   \na.7.12 bitwise exclusive or operator  \nexclusive-or-expression:  \nand-expression \nexclusive-or-expression ^ and-expression   \nthe usual arithmetic conversions are performed; the result is the bitwise e xclusive or  \nfunction of the operands. the operator applies only to integral operands.   \na.7.13 bitwise inclusive or operator  \ninclusive-or-expression:  \nexclusive-or-expression \ninclusive-or-expression | exclusive-or-expression   \nthe usual arithmetic conversions are performed; the result is the bitwise i nclusive or  \nfunction of the operands. the operator applies only to integral operands.   \na.7.14 logical and operator  \nlogical-and-expression:  \ninclusive-or-expression  \nlogical-and-expression && inclusive-or-expression    \nthe && operator groups left-to-right. it returns 1 if both its operands compare unequa l to \nzero,  \n0 otherwise. unlike &, && guarantees left-to-right evaluation: the first oper and is \nevaluated,  \nincluding all side effects; if it is equal to 0, the value of the expression is 0. ot herwise, \nthe  \nright operand is evaluated, and if it is equal to 0, the expression''s value is 0, otherwis e 1.  \n \nthe operands need not have the same type, but each must have arithmetic type or be a \npointer.  \nthe result is int.   \na.7.15 logical or operator  \nlogical-or-expression:  \nlogical-and-expression \nlogical-or-expression || logical-and-expression\n\nthe || operator groups left-to-right. it returns 1 if either of its operands compare unequal \nto  \nzero, and 0 otherwise. unlike |, || guarantees left-to-right evaluation: the fir st operand is  \nevaluated, including all side effects; if it is unequal to 0, the value of the expres sion is 1.  \notherwise, the right operand is evaluated, and if it is unequal to 0, the expression''s  value \nis 1,  \notherwise 0.   \nthe operands need not have the same type, but each must have arithmetic type or be a \npointer.  \nthe result is int.   \na.7.16 conditional operator\n\nconditional-expression:  \nlogical-or-expression \nlogical-or-expression ? expression : conditional-expression   \nthe first expression is evaluated, including all side effects; if it compares unequal to 0, \nthe  \nresult is the value of the second expression, otherwise that of the third express ion. only \none of  \nthe second and third operands is evaluated. if the second and third operands are \narithmetic,  \nthe usual arithmetic conversions are performed to bring them to a common type, and that \ntype  \nis the type of the result. if both are void, or structures or unions of the same type, or \npointers  \nto objects of the same type, the result has the common type. if one is a pointer and the \nother  \nthe constant 0, the 0 is converted to the pointer type, and the result has that type. if  one is \na  \npointer to void and the other is another pointer, the other pointer is converted to a pointer  \nto  \nvoid, and that is the type of the result.   \nin the type comparison for pointers, any type qualifiers (par.a.8.2) in the type to which \nthe   \npointer points are insignificant, but the result type inherits qualifiers from  both arms of \nthe   \nconditional.   \na.7.17 assignment expressions  \nthere are several assignment operators; all group right-to-left.   \nassignment-expression:  \nconditional-expression \nunary-expression assignment-operator assignment-expression   \nassignment-operator: one of   \n= *= /= %= += -= <<= >>= &= ^= |=   \nall require an lvalue as left operand, and the lvalue must be modifiable: it must  not be an  \narray, and must not have an incomplete type, or be a function. also, its type must not be  \nqualified with const; if it is a structure or union, it must not have any member or, \nrecursively,\n\nsubmember qualified with const. the type of an assignment expression is that of its left  \noperand, and the value is the value stored in the left operand after the assignment  has \ntaken   \nplace.   \nin the simple assignment with =, the value of the expression replaces that of the obj ect  \nreferred to by the lvalue. one of the following must be true: both operands have \narithmetic  \ntype, in which case the right operand is converted to the type of the left by the \nassignment; or  \nboth operands are structures or unions of the same type; or one operand is a pointer and \nthe  \nother is a pointer to void, or the left operand is a pointer and the right operand is a \nconstant  \nexpression with value 0; or both operands are pointers to functions or objects whose types  \nare  \nthe same except for the possible absence of const or volatile in the right operand.   \nan expression of the form e1 op= e2 is equivalent to e1 = e1 op (e2) except that e1 is  \nevaluated only once.   \na.7.18 comma operator  \nexpression:  \nassignment-expression \nexpression , assignment-expression\n\na pair of expressions separated by a comma is evaluated left-to-right, and the value of the \nleft  \nexpression is discarded. the type and value of the result are the type and value of the \nright  \noperand. all side effects from the evaluation of the left-operand are completed be fore  \nbeginning the evaluation of the right operand. in contexts where comma is given a special   \nmeaning, for example in lists of function arguments (par.a.7.3.2) and lists of initializ ers  \n(par.a.8.7), the required syntactic unit is an assignment expression, so the com ma \noperator  \nappears only in a parenthetical grouping, for example,   \n f(a, (t=3, t+2), c)   \nhas three arguments, the second of which has the value 5.   \na.7.19 constant expressions  \nsyntactically, a constant expression is an expression restricted to a subset of ope rators:  \n \nconstant-expression:  \nconditional-expression   \nexpressions that evaluate to a constant are required in several contexts: af ter case, as \narray  \nbounds and bit-field lengths, as the value of an enumeration constant, in initializer s, and \nin  \ncertain preprocessor expressions.   \nconstant expressions may not contain assignments, increment or decrement operators,   \nfunction calls, or comma operators; except in an operand of sizeof. if the constant   \nexpression is required to be integral, its operands must consist of integer, enumer ation,  \ncharacter, and floating constants; casts must specify an integral type, and any fl oating  \nconstants must be cast to integer. this necessarily rules out arrays, indirect ion, address-\nof,  \nand structure member operations. (however, any operand is permitted for sizeof.)   \nmore latitude is permitted for the constant expressions of initializers; t he operands may \nbe  \nany type of constant, and the unary & operator may be applied to external or static \nobjects, and  \nto external and static arrays subscripted with a constant expression. the unary &  operator \ncan  \nalso be applied implicitly by appearance of unsubscripted arrays and functions. \ninitializers\n\nmust evaluate either to a constant or to the address of a previously declared external or \nstatic   \nobject plus or minus a constant.   \nless latitude is allowed for the integral constant expressions after #if;  sizeof expressions,  \nenumeration constants, and casts are not permitted. see par.a.12.5.   \na.8 declarations  \ndeclarations specify the interpretation given to each identifier; they do not ne cessarily \nreserve  \nstorage associated with the identifier. declarations that reserve  storage are called \ndefinitions.  \ndeclarations have the form   \ndeclaration:  \ndeclaration-specifiers init-declarator-listopt;   \nthe declarators in the init-declarator list contain the identifiers bei ng declared; the  \ndeclaration-specifiers consist of a sequence of type and storage class speci fiers.\n\ndeclaration-specifiers:  \nstorage-class-specifier declaration-specifiersopt \ntype-specifier declaration-specifiersopt \ntype-qualifier declaration-specifiersopt   \ninit-declarator-list:  \ninit-declarator \ninit-declarator-list , init-declarator   \ninit-declarator:  \ndeclarator \ndeclarator = initializer   \ndeclarators will be discussed later (par.a.8.5); they contain the names being declared. a  \ndeclaration must have at least one declarator, or its type specifier must dec lare a structure \ntag,  \na union tag, or the members of an enumeration; empty declarations are not permit ted.  \n \na.8.1 storage class specifiers  \nthe storage class specifiers are:   \nstorage-class specifier:     \nauto \nregister \nstatic \nextern \ntypedef   \nthe meaning of the storage classes were discussed in par.a.4.4.   \nthe auto and register specifiers give the declared objects automatic stora ge class, and \nmay  \nbe used only within functions. such declarations also serve as definitions and cause \nstorage to  \nbe reserved. a register declaration is equivalent to an auto declaration, but hints  that the  \ndeclared objects will be accessed frequently. only a few objects are actually pl aced into  \nregisters, and only certain types are eligible; the restrictions are impl ementation-\ndependent.  \nhowever, if an object is declared register, the unary & operator may not be applied to i t,  \nexplicitly or implicitly.\n\nthe rule that it is illegal to calculate the address of an object declared register, but \nactually taken to  \nbe auto, is new.   \nthe static specifier gives the declared objects static storage clas s, and may be used either  \ninside or outside functions. inside a function, this specifier causes storage t o be allocated, \nand  \nserves as a definition; for its effect outside a function, see par.a.11.2.   \na declaration with extern, used inside a function, specifies that the storag e for the \ndeclared  \nobjects is defined elsewhere; for its effects outside a function, see par .a.11.2.  \n \nthe typedef specifier does not reserve storage and is called a storage cla ss specifier only \nfor  \nsyntactic convenience; it is discussed in par.a.8.9.\n\nat most one storage class specifier may be given in a declaration. if none is given, these \nrules  \nare used: objects declared inside a function are taken to be auto; functions declar ed within \na  \nfunction are taken to be extern; objects and functions declared outside a function are  \ntaken to  \nbe static, with external linkage. see pars. a.10-a.11.   \na.8.2 type specifiers  \nthe type-specifiers are   \ntype specifier:   \nvoid \nchar \nshort \nint \nlong \nfloat \ndouble \nsigned \nunsigned   \nstruct-or-union-specifier  \nenum-specifier  \ntypedef-name   \nat most one of the words long or short may be specified together with int; the meaning is   \nthe same if int is not mentioned. the word long may be specified together with double. \nat  \nmost one of signed or unsigned may be specified together with int or any of its short or  \nlong varieties, or with char. either may appear alone in which case int is underst ood. the  \nsigned specifier is useful for forcing char objects to carry a sign; it is permis sible but  \nredundant with other integral types.   \notherwise, at most one type-specifier may be given in a declaration. if the type-speci fier \nis  \nmissing from a declaration, it is taken to be int.   \ntypes may also be qualified, to indicate special properties of the objects being decl ared.  \n \ntype-qualifier:\n\nconst  \nvolatile   \ntype qualifiers may appear with any type specifier. a const object may be initialized, but \nnot  \nthereafter assigned to. there are no implementation-dependent semantics for volati le  \nobjects.   \nthe const and volatile properties are new with the ansi standard. the purpose of con st \nis to  \nannounce objects that may be placed in read-only memory, and perhaps to increase \nopportunities for  \noptimization. the purpose of volatile is to force an implementation to suppress \noptimization that  \ncould otherwise occur. for example, for a machine with memory-mapped input/output, a \npointer to a  \ndevice register might be declared as a pointer to volatile, in order to prevent t he compiler \nfrom  \nremoving apparently redundant references through the pointer. except that it should \ndiagnose explicit  \nattempts to change constobjects, a compiler may ignore these qualifiers.   \na.8.3 structure and union declarations\n\na structure is an object consisting of a sequence of named members of various types. a \nunion  \nis an object that contains, at different times, any of several members of various  types.  \nstructure and union specifiers have the same form.   \nstruct-or-union-specifier:  \nstruct-or-union identifieropt{ struct-declaration-list  } \nstruct-or-union identifier   \nstruct-or-union:   \nstruct \nunion   \na struct-declaration-list is a sequence of declarations for the member s of the structure or  \nunion:   \nstruct-declaration-list:  \nstruct declaration \nstruct-declaration-list struct declaration    \nstruct-declaration: specifier-qualifier-list struct-declar ator-list;  \n  \nspecifier-qualifier-list:  \ntype-specifier specifier-qualifier-listopt \ntype-qualifier specifier-qualifier-listopt   \nstruct-declarator-list:  \nstruct-declarator \nstruct-declarator-list , struct-declarator   \nusually, a struct-declarator is just a declarator for a member of a str ucture or union. a  \nstructure member may also consist of a specified number of bits. such a member i s also \ncalled  \na bit-field; its length is set off from the declarator for the field name by a  colon.  \n \nstruct-declarator:  \ndeclarator declaratoropt : constant-expression\n\na type specifier of the form   \nstruct-or-union identifier { struct-declaration-list }   \ndeclares the identifier to be the tag of the structure or union specified by the list. a \nsubsequent  \ndeclaration in the same or an inner scope may refer to the same type by using the tag in a   \nspecifier without the list:   \nstruct-or-union identifier   \nif a specifier with a tag but without a list appears when the tag is not decla red, an \nincomplete  \ntype is specified. objects with an incomplete structure or union type may be ment ioned in  \ncontexts where their size is not needed, for example in declarations (not definit ions), for  \nspecifying a pointer, or for creating a typedef, but not otherwise. the type becomes \ncomplete  \non occurrence of a subsequent specifier with that tag, and containing a declarati on list. \neven\n\nin specifiers with a list, the structure or union type being declared is incomplete within \nthe  \nlist, and becomes complete only at the } terminating the specifier.   \na structure may not contain a member of incomplete type. therefore, it is i mpossible to  \ndeclare a structure or union containing an instance of itself. however, besides giving  a \nname  \nto the structure or union type, tags allow definition of self-referential struct ures; a \nstructure or  \nunion may contain a pointer to an instance of itself, because pointers to incomplete t ypes \nmay  \nbe declared.   \na very special rule applies to declarations of the form   \nstruct-or-union identifier;   \nthat declare a structure or union, but have no declaration list and no declarators. even i f \nthe  \nidentifier is a structure or union tag already declared in an outer scope (par.a .11.1), this  \ndeclaration makes the identifier the tag of a new, incompletely-typed structure  or union in \nthe  \ncurrent scope.   \nthis recondite is new with ansi. it is intended to deal with mutually-recurs ive structures \ndeclared in an  \ninner scope, but whose tags might already be declared in the outer scope.   \na structure or union specifier with a list but no tag creates a unique type; it ca n be \nreferred to  \ndirectly only in the declaration of which it is a part.   \nthe names of members and tags do not conflict with each other or with ordinary \nvariables. a  \nmember name may not appear twice in the same structure or union, but the same m ember  \nname may be used in different structures or unions.   \nin the first edition of this book, the names of structure and union members were not \nassociated with  \ntheir parent. however, this association became common in compilers well before  the \nansi standard.   \na non-field member of a structure or union may have any object type. a field member \n(which  \nneed not have a declarator and thus may be unnamed) has type int, unsigned int, or\n\nsigned int, and is interpreted as an object of integral type of the specified length in bits;  \nwhether an int field is treated as signed is implementation-dependent. adjacent f ield  \nmembers of structures are packed into implementation-dependent storage uni ts in an  \nimplementation-dependent direction. when a field following another field will not fi t into \na   \npartially-filled storage unit, it may be split between units, or the unit may be padde d. an  \nunnamed field with width 0 forces this padding, so that the next field will begin at the \nedge of  \nthe next allocation unit.   \nthe ansi standard makes fields even more implementation-dependent than did the fir st \nedition. it is  \nadvisable to read the language rules for storing bit-fields as ``impleme ntation-dependent'''' \nwithout  \nqualification. structures with bit-fields may be used as a portable way of att empting to \nreduce the  \nstorage required for a structure (with the probable cost of increasing the in struction space, \nand time,  \nneeded to access the fields), or as a non-portable way to describe a storage layout kno wn \nat the bit- \nlevel. in the second case, it is necessary to understand the rules of the local \nimplementation.   \nthe members of a structure have addresses increasing in the order of their dec larations. a  \nnon-field member of a structure is aligned at an addressing boundary depending on its \ntype;   \ntherefore, there may be unnamed holes in a structure. if a pointer to a structur e is cast to \nthe   \ntype of a pointer to its first member, the result refers to the first member.\n\na union may be thought of as a structure all of whose members begin at offset 0 and \nwhose  \nsize is sufficient to contain any of its members. at most one of the members can be stored \nin a  \nunion at any time. if a pointr to a union is cast to the type of a pointer to a member, the \nresult  \nrefers to that member.   \na simple example of a structure declaration is   \n struct tnode  {  \nchar tword[20] \n;  \nint count;  \nstruct tnode *left;  \nstruct tnode *right;    }  \nwhich contains an array of 20 characters, an integer, and two pointers to similar \nstructures.  \nonce this declaration has bene given, the declaration    \n struct tnode s, *sp;   \ndeclares s to be a structure of the given sort, and sp to be a pointer to a structure  of the \ngiven  \nsort. with these declarations, the expression   \n sp->count  \nrefers to the count field of the structure to which sp points;   \n s.left  \nrefers to the left subtree pointer of the structure s, and   \n s.right->tword[0]  \nrefers to the first character of the tword member of the right subtree of  s.  \n \nin general, a member of a union may not be inspected unless the value of the union has \nbeen  \nassigned using the same member. however, one special guarantee simplifies the use of   \nunions: if a union contains several structures that share a common initial sequence , and \nthe\n\nunion currently contains one of these structures, it is permitted to refer to the common \ninitial   \npart of any of the contained structures. for example, the following is a legal fragme nt: \n \n union  {  \nstruct  {   \n int type;  \n} n; \nstruct  {   \n int type;   \n int intnode;  \n} ni; \nstruct  {   \n int type;  \nfloat floatnode;      \n} nf;  \n} u;  .. .  \nu.nf.type = float;  \nu.nf.floatnode = 3.14;  .. .  \nif (u.n.type == float)    \n ... sin(u.nf.floatnode) ...   \na.8.4 enumerations\n\nenumerations are unique types with values ranging over a set of named constants called  \nenumerators. the form of an enumeration specifier borrows from that of structure s and  \nunions.   \nenum-specifier:  \nenum identifieropt { enumerator-list  } \nenum identifier   \nenumerator-list:  \nenumerator \nenumerator-list , enumerator   \nenumerator:  \nidentifier \nidentifier = constant-expression   \nthe identifiers in an enumerator list are declared as constants of type i nt, and may appear  \nwherever constants are required. if no enumerations with = appear, then the values  of the  \ncorresponding constants begin at 0 and increase by 1 as the declaration is read from l eft \nto  \nright. an enumerator with = gives the associated identifier the value speci fied; \nsubsequent  \nidentifiers continue the progression from the assigned value.   \nenumerator names in the same scope must all be distinct from each other and fr om \nordinary  \nvariable names, but the values need not be distinct.   \nthe role of the identifier in the enum-specifier is analogous to that of the structur e tag in \na  \nstruct-specifier; it names a particular enumeration. the rules for enum-s pecifiers with and  \nwithout tags and lists are the same as those for structure or union specifiers, exce pt that  \nincomplete enumeration types do not exist; the tag of an enum-specifier without an  \nenumerator list must refer to an in-scope specifier with a list.   \nenumerations are new since the first edition of this book, but have been part of the \nlanguage for some  \nyears.   \na.8.5 declarators  \ndeclarators have the syntax:\n\ndeclarator:  \npointeropt direct-declarator   \ndirect-declarator:  \nidentifier \n(declarator) \ndirect-declarator [ constant-expressionopt  \n] \ndirect-declarator ( parameter-type-list  \n) \ndirect-declarator ( identifier-listopt  \n)   \npointer:   \n* type-qualifier-listopt  \n* type-qualifier-listopt pointer\n\ntype-qualifier-list:  \ntype-qualifier \ntype-qualifier-list type-qualifier   \nthe structure of declarators resembles that of indirection, function, and array expressions; \nthe  \ngrouping is the same.   \na.8.6 meaning of declarators  \na list of declarators appears after a sequence of type and storage class spec ifiers. each  \ndeclarator declares a unique main identifier, the one that appears as the  first alternative of \nthe  \nproduction for direct-declarator. the storage class specifiers apply directl y to this \nidentifier,  \nbut its type depends on the form of its declarator. a declarator is read as an as sertion that  \nwhen its identifier appears in an expression of the same form as the declara tor, it yields \nan  \nobject of the specified type.   \nconsidering only the type parts of the declaration specifiers (par. a.8.2) and a pa rticular  \ndeclarator, a declaration has the form ``t d,'''' where t is a type and d is a dec larator. the \ntype  \nattributed to the identifier in the various forms of declarator is described i nductively \nusing this   \nnotation.    \nin a declaration t d where d is an unadored identifier, the type of the identifier  is t.  \n \nin a declaration t d where d has the form  \n ( d1 ) \nthen the type of the identifier in d1 is the same as that of d. the parentheses do not  alter \nthe  \ntype, but may change the binding of complex declarators.   \na.8.6.1 pointer declarators  \nin a declaration t d where d has the form   \n* type-qualifier-listopt d1  \nand the type of the identifier in the declaration t d1 is ``type-modifier t,'''' the type  of the  \nidentifier of d is ``type-modifier type-qualifier-list pointer to t.'''' q ualifiers following * \napply  \nto pointer itself, rather than to the object to which the pointer points.\n\nfor example, consider the declaration    \nint *ap[]; \nhere, ap[] plays the role of d1; a declaration ``int ap[]'''' (below) would give ap the type  \n``array of int,'''' the type-qualifier list is empty, and the type-modifier is ``ar ray of.'''' hence \nthe  \nactual declaration gives ap the type ``array to pointers to int.''''   \nas other examples, the declarations  \n int i, *pi, *const cpi = &i;  \nconst int ci = 3, *pci;\n\ndeclare an integer i and a pointer to an integer pi. the value of the constant pointer cpi \nmay  \nnot be changed; it will always point to the same location, although the value to which it \nrefers  \nmay be altered. the integer ci is constant, and may not be changed (though it may be  \ninitialized, as here.) the type of pci is ``pointer to const int,'''' and pci itself may be  \nchanged to point to another place, but the value to which it points may not be altered by  \nassigning through pci.   \na.8.6.2 array declarators  \nin a declaration t d where d has the form   \nd1 [constant-expressionopt]   \nand the type of the identifier in the declaration t d1 is ``type-modifier t,'''' the type  of the  \nidentifier of d is ``type-modifier array of t.'''' if the constant-expression is  present, it must \nhave  \nintegral type, and value greater than 0. if the constant expression specifying the bound i s  \nmissing, the array has an incomplete type.   \nan array may be constructed from an arithmetic type, from a pointer, from a structu re or  \nunion, or from another array (to generate a multi-dimensional array). any type from \nwhich an  \narray is constructed must be complete; it must not be an array of structure of inc omplete \ntype.   \nthis implies that for a multi-dimensional array, only the first dimension may be m issing. \nthe   \ntype of an object of incomplete aray type is completed by another, complete, declara tion \nfor  \nthe object (par.a.10.2), or by initializing it (par.a.8.7). for example,  \n float fa[17], *afp[17]; \ndeclares an array of float numbers and an array of pointers to float numbers. also,  \n static int x3d[3][5][7];  \ndeclares a static three-dimensional array of integers, with rank 3 x 5 x 7. in c omplete \ndetail,  \nx3d is an array of three items: each item is an array of five arrays; each of the lat ter arrays \nis  \nan array of seven integers. any of the expressions x3d, x3d[i], x3d[i][j], x3d[i][j][k] \nmay reasonably appear in an expression. the first three have type ``array,'''', the last ha s \ntype  \nint. more specifically, x3d[i][j] is an array of 7 integers, and x3d[i] is an array of  5  \narrays of 7 integers.\n\nthe array subscripting operation is defined so that e1[e2] is identical to *(e1+e2).  \ntherefore, despite its asymmetric appearance, subscripting is a commut ative operation.  \nbecause of the conversion rules that apply to + and to arrays (pars.a6.6, a.7.1, a.7.7), if  \ne1 is  \nan array and e2 an integer, then e1[e2] refers to the e2-th member of e1.   \nin the example, x3d[i][j][k] is equivalent to *(x3d[i][j] + k). the first subexpressi on  \nx3d[i][j] is converted by par.a.7.1 to type ``pointer to array of integers,'''' by par.a.7.7, \nthe  \naddition involves multiplication by the size of an integer. it follows from the rul es that \narrays  \nare stored by rows (last subscript varies fastest) and that the firs t subscript in the \ndeclaration  \nhelps determine the amount of storage consumed by an array, but plays no other part in  \nsubscript calculations.   \na.8.6.3 function declarators  \nin a new-style function declaration t d where d has the form\n\nd1 (parameter-type-list)   \nand the type of the identifier in the declaration t d1 is ``type-modifier t,'''' the type of the  \nidentifier of d is ``type-modifier function with arguments parameter-type-l ist returning \nt.''''   \nthe syntax of the parameters is   \nparameter-type-list:  \nparameter-list \nparameter-list , .. .   \nparameter-list:  \nparameter-declaration \nparameter-list , parameter-declaration   \nparameter-declaration:  \ndeclaration-specifiers declarator \ndeclaration-specifiers abstract-declaratoropt   \nin the new-style declaration, the parameter list specifies the types of the  parameters. as a  \nspecial case, the declarator for a new-style function with no parameters has a pa rameter \nlist  \nconsisting soley of the keyword void. if the parameter list ends with an ellipsis ``, ...'' '', \nthen  \nthe function may accept more arguments than the number of parameters explicitly \ndescribed,  \nsee par.a.7.3.2.   \nthe types of parameters that are arrays or functions are altered to pointers, in a ccordance \nwith  \nthe rules for parameter conversions; see par.a.10.1. the only storage class spe cifier \npermitted  \nin a parameter''s declaration is register, and this specifier is ignore d unless the function  \ndeclarator heads a function definition. similarly, if the declarators in the  parameter  \ndeclarations contain identifiers and the function declarator does not head a  function \ndefinition,  \nthe identifiers go out of scope immediately. abstract declarators, which do not ment ion \nthe  \nidentifiers, are discussed in par.a.8.8.\n\nin an old-style function declaration t d where d has the form    \nd1(identifier-listopt)   \nand the type of the identifier in the declaration t d1 is ``type-modifier t,'''' the type of the  \nidentifier of d is ``type-modifier function of unspecified arguments returning t .'''' the  \nparameters (if present) have the form   \nidentifier-list:  \nidentifier \nidentifier-list , identifier   \nin the old-style declarator, the identifier list must be absent unless the dec larator is used \nin the  \nhead of a function definition (par.a.10.1). no information about the types of the \nparameters is  \nsupplied by the declaration.   \nfor example, the declaration\n\nint f(), *fpi(), (*pfi)();  \ndeclares a function f returning an integer, a function fpi returning a pointer to an integer, \nand  \na pointer pfi to a function returning an integer. in none of these are the parameter types   \nspecified; they are old-style.   \nin the new-style declaration   \n int strcpy(char *dest, const char *source), rand(void);  \nstrcpy is a function returning int, with two arguments, the first a character  pointer, and the  \nsecond a pointer to constant characters. the parameter names are effectivel y comments. \nthe  \nsecond function rand takes no arguments and returns int.   \nfunction declarators with parameter prototypes are, by far, the most important  language \nchange  \nintroduced by the ansi standard. they offer an advantage over the ``old-style'''' \ndeclarators of the first  \nedition by providing error-detection and coercion of arguments across function calls, but  \nat a cost:  \nturmoil and confusion during their introduction, and the necessity of accomodating both \nforms. some  \nsyntactic ugliness was required for the sake of compatibility, namely void as an expl icit \nmarker of  \nnew-style functions without parameters.     \nthe ellipsis notation ``, ...'''' for variadic functions is also new, and, together wi th the \nmacros in the  \nstandard header <stdarg.h>, formalizes a mechanism that was officially for bidden but \nunofficially  \ncondoned in the first edition.   \nthese notations were adapted from the c++ language.   \na.8.7 initialization  \nwhen an object is declared, its init-declarator may specify an initial val ue for the \nidentifier  \nbeing declared. the initializer is preceded by =, and is either an expression, or a list  of  \ninitializers nested in braces. a list may end with a comma, a nicety for neat for matting.  \n \ninitializer:  \nassignment-expression \n{ initializer-list  } \n{ initializer-list ,\n\n}    \ninitializer-list:  \ninitializer \ninitializer-list , initializer   \nall the expressions in the initializer for a static object or array must be constant \nexpressions as  \ndescribed in par.a.7.19. the expressions in the initializer for an auto or registe r object or  \narray must likewise be constant expressions if the initializer is a brace- enclosed list. \nhowever,  \nif the initializer for an automatic object is a single expression, it need not  be a constant  \nexpression, but must merely have appropriate type for assignment to the object.   \nthe first edition did not countenance initialization of automatic structures , unions, or \narrays. the ansi  \nstandard allows it, but only by constant constructions unless the initializer can be \nexpressed by a simple  \nexpression.   \na static object not explicitly initialized is initialized as if it (or i ts members) were \nassigned the  \nconstant 0. the initial value of an automatic object not explicitly intialized is  undefined.\n\nthe initializer for a pointer or an object of arithmetic type is a single expression, perhaps \nin  \nbraces. the expression is assigned to the object.   \nthe initializer for a structure is either an expression of the same type, or a brac e-enclosed \nlist  \nof initializers for its members in order. unnamed bit-field members are ignore d, and are \nnot  \ninitialized. if there are fewer initializers in the list than member s of the structure, the \ntrailing  \nmembers are initialized with 0. there may not be more initializers than me mbers. \nunnamed  \nbit-field members are ignored,and are not initialized.   \nthe initializer for an array is a brace-enclosed list of initializers for i ts members. if the \narray  \nhas unknown size, the number of initializers determines the size of the array, and it s type  \nbecomes complete. if the array has fixed size, the number of initializers ma y not exceed \nthe  \nnumber of members of the array; if there are fewer, the trailing members  are initialized \nwith   0.  \nas a special case, a character array may be initialized by a string liter al; successive \ncharacters   \nof the string initialize successive members of the array. similarly, a wid e character literal  \n(par.a.2.6) may initialize an array of type wchar_t. if the array has unknown size, the   \nnumber of characters in the string, including the terminating null character , determines its  \nsize; if its size is fixed, the number of characters in the string, not countin g the \nterminating   \nnull character, must not exceed the size of the array.   \nthe initializer for a union is either a single expression of the same type, or a br ace-\nenclosed  \ninitializer for the first member of the union.   \nthe first edition did not allow initialization of unions. the ``first-member'''' r ule is clumsy, \nbut is hard to  \ngeneralize without new syntax. besides allowing unions to be explicitly initializ ed in at \nleast a primitive  \nway, this ansi rule makes definite the semantics of static unions not explicit ly \ninitialized.   \nan aggregate is a structure or array. if an aggregate contains members of aggrega te type, \nthe\n\ninitialization rules apply recursively. braces may be elided in the initialization as follows: \nif   \nthe initializer for an aggregate''s member that itself is an aggregate begins  with a left \nbrace,  \nthen the succeding comma-separated list of initializers initializes t he members of the  \nsubaggregate; it is erroneous for there to be more initializers than members. if, how ever, \nthe  \ninitializer for a subaggregate does not begin with a left brace, then only enough element s \nfrom  \nthe list are taken into account for the members of the subaggregate; any remaining \nmembers  \nare left to initialize the next member of the aggregate of which the subaggrega te is a part.  \n \nfor example,   \n int x[] = { 1, 3, 5 };  \ndeclares and initializes x as a 1-dimensional array with three members, s ince no size was  \nspecified and there are three initializers.  \n float y[4][3] = {    { 1, 3, 5 },    { 2, 4, 6 },    { 3, 5, 7 },     \n}; \nis a completely-bracketed initialization: 1, 3 and 5 initialize the first row  of the array y[0],  \nnamely y[0][0], y[0][1], and y[0][2]. likewise the next two lines initialize y[1]  and  \ny[2]. the initializer ends early, and therefore the elements of y[3] are init ialized with 0.  \nprecisely the same effect could have been achieved by\n\nfloat y[4][3] = {  1, 3, 5, 2, 4, 6, 3, 5, 7  \n}; \nthe initializer for y begins with a left brace, but that for y[0] does not; therefore three  \nelements from the list are used. likewise the next three are taken successive ly for y[1] \nand  \nfor y[2]. also,   \n float y[4][3] = {  { 1 }, { 2 }, { 3 }, { 4 }  \n}; \ninitializes the first column of y (regarded as a two-dimensional array) and  leaves the rest \n0.   \nfinally,   \n char msg[] = "syntax error on line %s\\n";  \nshows a character array whose members are initialized with a string; i ts size includes the  \nterminating null character.   \na.8.8 type names  \nin several contexts (to specify type conversions explicitly with a cast, to dec lare \nparameter  \ntypes in function declarators, and as argument of sizeof) it is necessary to supply t he \nname   \nof a data type. this is accomplished using a type name, which is syntactically a  \ndeclaration for  \nan object of that type omitting the name of the object.   \ntype-name:  \nspecifier-qualifier-list abstract-declaratoropt   \nabstract-declarator:  \npointer \npointeropt direct-abstract-declarator   \ndirect-abstract-declarator:  \n( abstract-declarator  \n)  \ndirect-abstract-declaratoropt [constant-expressionopt]  \ndirect-abstract-declaratoropt (parameter-type-listopt)\n\nit is possible to identify uniquely the location in the abstract-declarator where the \nidentifier   \nwould appear if the construction were a declarator in a declaration. the named type is \nthen the  \nsame as the type of the hypothetical identifier. for example,   \n int  \nint  *  \nint *[3]  \nint (*)[ \n]  \nint *( \n)  \nint (*[])(void)    \nname respectively the types ``integer,'''' ``pointer to integer,'''' ``array of 3 p ointers to \nintegers,''''  \n``pointer to an unspecified number of integers,'''' ``function of unspecified parame ters \nreturning  \npointer to integer,'''' and ``array, of unspecified size, of pointers to functions with no  \nparameters each returning an integer.''''\n\na.8.9 typedef  \ndeclarations whose storage class specifier is typedef do not declare objects; instead they  \ndefine identifiers that name types. these identifiers are called typedef name s.  \n \ntypedef-name:  \nidentifier   \na typedef declaration attributes a type to each name among its declarators  in the usual \nway  \n(see par.a.8.6). thereafter, each such typedef name is syntactically equivale nt to a type  \nspecifier keyword for the associated type.   \nfor example, after   \n typedef long blockno, *blockptr;  \ntypedef struct { double r, theta; } complex;    \nthe constructions   \n blockno b;   \n extern blockptr bp;    \n complex z, *zp;   \nare legal declarations. the type of b is long, that of bp is ``pointer to long,'''' and that of z \nis  \nthe specified structure; zp is a pointer to such a structure.   \ntypedef does not introduce new types, only synonyms for types that could be specified in  \nanother way. in the example, b has the same type as any long object.   \ntypedef names may be redeclared in an inner scope, but a non-empty set of type \nspecifiers  \nmust be given. for example,  \n extern blockno;  \ndoes not redeclare blockno, but   \n extern int blockno;   \ndoes.   \na.8.10 type equivalence\n\ntwo type specifier lists are equivalent if they contain the same set of type specifiers, \ntaking   \ninto account that some specifiers can be implied by others (for example, long alone \nimplies  \nlong int). structures, unions, and enumerations with different tags are distinct, and a \ntagless  \nunion, structure, or enumeration specifies a unique type.   \ntwo types are the same if their abstract declarators (par.a.8.8), after expandi ng any \ntypedeftypes, and deleting any function parameter specifiers, are the same up to the \nequivalence of  \ntype specifier lists. array sizes and function parameter types are signif icant.  \n \na.9 statements  \nexcept as described, statements are executed in sequence. statements are e xecuted for \ntheir  \neffect, and do not have values. they fall into several groups.\n\nstatement:  \nlabeled-statement \nexpression-statement \ncompound-statement \nselection-statement \niteration-statement \njump-statement   \na.9.1 labeled statements  \nstatements may carry label prefixes.   \nlabeled-statement:  \nidentifier : statement \ncase constant-expression : statement \ndefault : statement   \na label consisting of an identifier declares the identifier. the only use of an identifier \nlabel is  \nas a target of goto. the scope of the identifier is the current function. because label s have  \ntheir own name space, they do not interfere with other identifiers and cannot be \nredeclared.  \nsee par.a.11.1.    \ncase labels and default labels are used with the switch statement (par.a.9.4) . the \nconstant   \nexpression of case must have integral type.   \nlabels themselves do not alter the flow of control.   \na.9.2 expression statement  \nmost statements are expression statements, which have the form   \nexpression-statement:  \nexpressionopt;   \nmost expression statements are assignments or function calls. all side e ffects from the  \nexpression are completed before the next statement is executed. if the expressi on is \nmissing,  \nthe construction is called a null statement; it is often used to supply an empty body to an   \niteration statement to place a label.   \na.9.3 compound statement\n\nso that several statements can be used where one is expected, the compound statement \n(also   \ncalled ``block'''') is provided. the body of a function definition is a compound statement.   \ncompound-statement:  \n{ declaration-listopt statement-listopt  }   \ndeclaration-list:  \ndeclaration \ndeclaration-list declaration\n\nstatement-list:  \nstatement \nstatement-list statement   \nif an identifier in the declaration-list was in scope outside the block, the outer declaration \nis  \nsuspended within the block (see par.a.11.1), after which it resumes its force. an \nidentifier  \nmay be declared only once in the same block. these rules apply to identifiers in the sa me  \nname space (par.a.11); identifiers in different name spaces are treated a s distinct.  \n \ninitialization of automatic objects is performed each time the block is ente red at the top, \nand  \nproceeds in the order of the declarators. if a jump into the block is executed, these   \ninitializations are not performed. initialization of static objects are  performed only once,  \nbefore the program begins execution.   \na.9.4 selection statements  \nselection statements choose one of several flows of control.   \nselection-statement:  \nif (expression) statement \nif (expression) statement else statement \nswitch (expression) statement     \nin both forms of the if statement, the expression, which must have arithmetic or point er \ntype,  \nis evaluated, including all side effects, and if it compares unequal to 0, the fi rst \nsubstatement  \nis executed. in the second form, the second substatement is executed if the expressi on is \n0.  \nthe else ambiguity is resolved by connecting an else with the last encountered els e-less if  \nat the same block nesting level.   \nthe switch statement causes control to be transferred to one of several state ments \ndepending  \non the value of an expression, which must have integral type. the substatement \ncontrolled by  \na switch is typically compound. any statement within the substatement may be label ed \nwith  \none or more case labels (par.a.9.1). the controlling expression undergoes integral \npromotion\n\n(par.a.6.1), and the case constants are converted to the promoted type. no two of these  \ncase  \nconstants associated with the same switch may have the same value after conversion. \nthere  \nmay also be at most one default label associated with a switch. switches may be  nested; a  \ncase or default label is associated with the smallest switch that conta ins it.  \n \nwhen the switch statement is executed, its expression is evaluated, including a ll side \neffects,  \nand compared with each case constant. if one of the case constants is equal to the va lue of \nthe  \nexpression, control passes to the statement of the matched case label. if no ca se constant  \nmatches the expression, and if there is a default label, control passes to the l abeled  \nstatement. if no case matches, and if there is no default, then none of the substatement s of  \nthe swtich is executed.   \nin the first edition of this book, the controlling expression of switch, and the case \nconstants, were  \nrequired to have inttype.   \na.9.5 iteration statements  \niteration statements specify looping.\n\niteration-statement:  \nwhile (expression) statement  \ndo statement while (expression);  \nfor (expressionopt; expressionopt; expressionopt) statement   \nin the while and do statements, the substatement is executed repeatedly so long as the \nvalue  \nof the expression remains unequal to 0; the expression must have arithmetic or pointe r \ntype.  \nwith while, the test, including all side effects from the expression, occurs befor e each  \nexecution of the statement; with do, the test follows each iteration.   \nin the for statement, the first expression is evaluated once, and thus specifies ini tialization \nfor  \nthe loop. there is no restriction on its type. the second expression must have arithmetic \nor  \npointer type; it is evaluated before each iteration, and if it becomes equal to 0, the  for is  \nterminated. the third expression is evaluated after each iteration, and thu s specifies a re- \ninitialization for the loop. there is no restriction on its type. side-effect s from each \nexpression  \nare completed immediately after its evaluation. if the substatement does not c ontain  \ncontinue, a statement   \nfor (expression1; expression2; expression3) statement    \nis equivalent to    \nexpression1;  \nwhile (expression2) {  \nstatement   \nexpression3; } \nany of the three expressions may be dropped. a missing second expression makes the  \nimplied test equivalent to testing a non-zero element.   \na.9.6 jump statements  \njump statements transfer control unconditionally.   \njump-statement:  \ngoto identifier;  \ncontinue;  \nbreak;\n\nreturn expressionopt;    \nin the goto statement, the identifier must be a label (par.a.9.1) located in the current  \nfunction. control transfers to the labeled statement.   \na continue statement may appear only within an iteration statement. it causes cont rol to \npass  \nto the loop-continuation portion of the smallest enclosing such statement. more preci sely,  \nwithin each of the statements   \n while (...) { do { for (...) {  ... ... ...  \ncontin: ;  }  \ncontin: ;  \n} while (...);  \ncontin: ; }\n\na continue not contained in a smaller iteration statement is the same as goto contin.  \n \na break statement may appear only in an iteration statement or a switch stat ement, and  \nterminates execution of the smallest enclosing such statement; control passe s to the \nstatement  \nfollowing the terminated statement.   \na function returns to its caller by the return statement. when return is foll owed by an  \nexpression, the value is returned to the caller of the function. the expression is conve rted, \nas  \nby assignment, to the type returned by the function in which it appears.   \nflowing off the end of a function is equivalent to a return with no expression. in either \ncase,  \nthe returned value is undefined.   \na.10 external declarations  \nthe unit of input provided to the c compiler is called a translation unit; it consists of a   \nsequence of external declarations, which are either declarations or functio n definitions.  \n \ntranslation-unit:  \nexternal-declaration \ntranslation-unit external-declaration    \nexternal-declaration:   \nfunction-definition \ndeclaration   \nthe scope of external declarations persists to the end of the translation unit  in which they \nare  \ndeclared, just as the effect of declarations within the blocks persists to the  end of the \nblock.  \nthe syntax of external declarations is the same as that of all declarations,  except that only \nat  \nthis level may the code for functions be given.   \na.10.1 function definitions  \nfunction definitions have the form   \nfunction-definition:  \ndeclaration-specifiersopt declarator declaration-listopt compound-state ment\n\nthe only storage-class specifiers allowed among the declaration specifiers are extern or  \nstatic; see par.a.11.2 for the distinction between them.    \na function may return an arithmetic type, a structure, a union, a pointer, or void, but not a  \nfunction or an array. the declarator in a function declaration must specify explici tly that \nthe  \ndeclared identifier has function type; that is, it must contain one of the forms  (see  \npar.a.8.6.3).   \ndirect-declarator ( parameter-type-list )   \ndirect-declarator ( identifier-listopt )   \nwhere the direct-declarator is an identifier or a parenthesized identi fier. in particular, it \nmust  \nnot achieve function type by means of a typedef.\n\nin the first form, the definition is a new-style function, and its parameters, together with \ntheir  \ntypes, are declared in its parameter type list; the declaration-list f ollowing the function''s  \ndeclarator must be absent. unless the parameter type list consists solel y of void, showing \nthat  \nthe function takes no parameters, each declarator in the parameter type list  must contain \nan  \nidentifier. if the parameter type list ends with ``, ...'''' then the function may be cal led with  \nmore arguments than parameters; the va_arg macro mechanism defined in the standa rd  \nheader <stdarg.h> and described in appendix b must be used to refer to the extra  \narguments. variadic functions must have at least one named parameter.   \nin the second form, the definition is old-style: the identifier list names t he parameters, \nwhile  \nthe declaration list attributes types to them. if no declaration is given for a  parameter, its \ntype  \nis taken to be int. the declaration list must declare only parameters named in t he list,  \ninitialization is not permitted, and the only storage-class specifier possib le is register.  \n \nin both styles of function definition, the parameters are understood to be declared just  \nafter  \nthe beginning of the compound statement constituting the function''s body, and thus the \nsame  \nidentifiers must not be redeclared there (although they may, like other identifier s, be  \nredeclared in inner blocks). if a parameter is declared to have type ``array of  type,'''' the  \ndeclaration is adjusted to read ``pointer to type;'''' similarly, if a paramet er is declared to \nhave  \ntype ``function returning type,'''' the declaration is adjusted to read ``pointer to f unction  \nreturning type.'''' during the call to a function, the arguments are converted as necess ary \nand  \nassigned to the parameters; see par.a.7.3.2.   \nnew-style function definitions are new with the ansi standard. there is als o a small \nchange in the  \ndetails of promotion; the first edition specified that the declarations of  float parameters \nwere adjusted  \nto read double. the difference becomes noticable when a pointer to a parameter is \ngenerated within a  \nfunction.   \na complete example of a new-style function definition is   \n int max(int a, int b, int c)   {\n\nint m;   \n m = (a > b) ? a : b;  \nreturn (m > c) ? m : c; } \nhere int is the declaration specifier; max(int a, int b, int c) is the function''s  \ndeclarator, and { ... } is the block giving the code for the function. the corresponding \nold- \nstyle definition would be   \n int max(a, b, c)  \nint a, b, c;  {    \n/* ... */ } \nwhere now int max(a, b, c) is the declarator, and int a, b, c; is the declaration list  for  \nthe parameters.   \na.10.2 external declarations  \nexternal declarations specify the characteristics of objects, functions and ot her identifiers. \nthe  \nterm ``external'''' refers to their location outside functions, and is not directl y connected \nwith\n\nthe extern keyword; the storage class for an externally-declared object may be left empty, \nor  \nit may be specified as extern or static.   \nseveral external declarations for the same identifier may exist within t he same translation \nunit  \nif they agree in type and linkage, and if there is at most one definition for the identif ier.  \n \ntwo declarations for an object or function are deemed to agree in type under the rule  \ndiscussed in par.a.8.10. in addition, if the declarations differ because one type is a n  \nincomplete structure, union, or enumeration type (par.a.8.3) and the other is the  \ncorresponding completed type with the same tag, the types are taken to agree. moreover , \nif  \none type is an incomplete array type (par.a.8.6.2) and the other is a completed array t ype, \nthe  \ntypes, if otherwise identical, are also taken to agree. finally, if one type spec ifies an old-\nstyle  \nfunction, and the other an otherwise identical new-style function, with parameter  \ndeclarations,  \nthe types are taken to agree.   \nif the first external declarator for a function or object includes the sta tic specifier, the  \nidentifier has internal linkage; otherwise it has external linkage. linkage  is discussed in  \npar.11.2.    \nan external declaration for an object is a definition if it has an initialize r. an external \nobject   \ndeclaration that does not have an initializer, and does not contain the extern speci fier, is a  \ntentative definition. if a definition for an object appears in a translation unit , any tentative  \ndefinitions are treated merely as redundant declarations. if no definition for  the object \nappears  \nin the translation unit, all its tentative definitions become a single defini tion with \ninitializer 0.   \neach object must have exactly one definition. for objects with internal linkage, t his rule  \napplies separately to each translation unit, because internally-linked objects a re unique to \na  \ntranslation unit. for objects with external linkage, it applies to the enti re program.  \n \nalthough the one-definition rule is formulated somewhat differently in the first  edition of \nthis book, it is  \nin effect identical to the one stated here. some implementations relax it  by generalizing \nthe notion of  \ntentative definition. in the alternate formulation, which is usual in unix syst ems and \nrecognized as a\n\ncommon extension by the standard, all the tentative definitions for an externally linked \nobject,   \nthroughout all the translation units of the program, are considered together instead of i n \neach translation  \nunit separately. if a definition occurs somewhere in the program, then the tentati ve \ndefinitions become  \nmerely declarations, but if no definition appears, then all its tentative definitions  become \na definition  \nwith initializer 0.   \na.11 scope and linkage  \na program need not all be compiled at one time: the source text may be kept in several \nfiles  \ncontaining translation units, and precompiled routines may be loaded from libraries .  \ncommunication among the functions of a program may be carried out both through calls \nand  \nthrough manipulation of external data.   \ntherefore, there are two kinds of scope to consider: first, the lexical scope of  an identifier  \nwhich is the region of the program text within which the identifier''s characteri stics are  \nunderstood; and second, the scope associated with objects and functions with external  \nlinkage,  \nwhich determines the connections between identifiers in separately compiled t ranslation \nunits.   \na.11.1 lexical scope\n\nidentifiers fall into several name spaces that do not interfere with one another; the same  \nidentifier may be used for different purposes, even in the same scope, if the uses ar e in  \ndifferent name spaces. these classes are: objects, functions, typedef names, a nd enum  \nconstants; labels; tags of structures or unions, and enumerations; and member s of each  \nstructure or union individually.   \nthese rules differ in several ways from those described in the first edi tion of this manual. \nlabels did not   \npreviously have their own name space; tags of structures and unions each had a separat e \nspace, and in   \nsome implementations enumerations tags did as well; putting different kinds of  tags into \nthe same space   \nis a new restriction. the most important departure from the first edition is t hat each \nstructure or union   \ncreates a separate name space for its members, so that the same name m ay appear in \nseveral different   \nstructures. this rule has been common practice for several years.   \nthe lexical scope of an object or function identifier in an external declaration begi ns at \nthe   \nend of its declarator and persists to the end of the translation unit in which it  appears. the  \nscope of a parameter of a function definition begins at the start of the block defini ng the  \nfunction, and persists through the function; the scope of a parameter in a function  \ndeclaration  \nends at the end of the declarator. the scope of an identifier declared at the head of a \nblock  \nbegins at the end of its declarator, and persists to the end of the block. the scope of a \nlabel is  \nthe whole of the function in which it appears. the scope of a structure, union, or \nenumeration  \ntag, or an enumeration constant, begins at its appearance in a type specifier, and pe rsists \nto the  \nend of a translation unit (for declarations at the external level) or to the e nd of the block \n(for  \ndeclarations within a function).   \nif an identifier is explicitly declared at the head of a block, including the block \nconstituting a  \nfunction, any declaration of the identifier outside the block is suspended until t he end of \nthe\n\nblock.    \na.11.2 linkage  \nwithin a translation unit, all declarations of the same object or function identifier with  \ninternal linkage refer to the same thing, and the object or function is unique to that  \ntranslation  \nunit. all declarations for the same object or function identifier with external  linkage refer \nto  \nthe same thing, and the object or function is shared by the entire program.   \nas discussed in par.a.10.2, the first external declaration for an identifier give s the \nidentifier  \ninternal linkage if the static specifier is used, external linkage othe rwise. if a declaration \nfor  \nan identifier within a block does not include the extern specifier, then the identi fier has no  \nlinkage and is unique to the function. if it does include extern, and an external decla ration  \nfor is active in the scope surrounding the block, then the identifier has the same l inkage \nas the  \nexternal declaration, and refers to the same object or function; but if no external \ndeclaration is  \nvisible, its linkage is external.   \na.12 preprocessing  \na preprocessor performs macro substitution, conditional compilation, and inclusion of \nnamed  \nfiles. lines beginning with #, perhaps preceded by white space, communicate with this   \npreprocessor. the syntax of these lines is independent of the rest of the language; th ey \nmay  \nappear anywhere and have effect that lasts (independent of scope) until the end of t he  \ntranslation unit. line boundaries are significant; each line is analyzed  individually (bus \nsee  \npar.a.12.2 for how to adjoin lines). to the preprocessor, a token is any language token, \nor a  \ncharacter sequence giving a file name as in the #include directive (par.a.12.4);  in \naddition,\n\nany character not otherwise defined is taken as a token. however, the effect of white \nspaces  \nother than space and horizontal tab is undefined within preprocessor lines.   \npreprocessing itself takes place in several logically successive phase s that may, in a \nparticular  \nimplementation, be condensed.   1.  \nfirst, trigraph sequences as described in par.a.12.1 are replaced by their equiva lents.  \nshould the operating system environment require it, newline characters are introduce d  \nbetween the lines of the source file.  2.  \neach occurrence of a backslash character \\ followed by a newline is deleted, thi s  \nsplicing lines (par.a.12.2).  3.  \nthe program is split into tokens separated by white-space characters; comment s are  \nreplaced by a single space. then preprocessing directives are obeyed, and macros  \n(pars.a.12.3-a.12.10) are expanded.  4.  \nescape sequences in character constants and string literals (pars. a.2.5.2, a.2.6) a re  \nreplaced by their equivalents; then adjacent string literals are concat enated.  \n5.  \nthe result is translated, then linked together with other programs and libraries, by   \ncollecting the necessary programs and data, and connecting external functions and   \nobject references to their definitions.   \na.12.1 trigraph sequences  \nthe character set of c source programs is contained within seven-bit ascii, but is  a \nsuperset  \nof the iso 646-1983 invariant code set. in order to enable programs to be represented in \nthe  \nreduced set, all occurrences of the following trigraph sequences are replaced by t he  \ncorresponding single character. this replacement occurs before any other proce ssing. \n \n ??= # ??( [ ??<  { \n??/ \\ ??) ] ??>  } \n??'' ^ ??! | ??- \n~    \nno other such replacements occur.  \ntrigraph sequences are new with the ansi standard.\n\na.12.2 line splicing   \nlines that end with the backslash character \\ are folded by deleting the backslash and the  \nfollowing newline character. this occurs before division into tokens.   \na.12.3 macro definition and expansion  \na control line of the form   \n# define identifier token-sequence   \ncauses the preprocessor to replace subsequent instances of the identifier  with the given  \nsequence of tokens; leading and trailing white space around the token sequence is \ndiscarded.  \na second #define for the same identifier is erroneous unless the second token sequence is   \nidentical to the first, where all white space separations are taken to be e quivalent.  \n \na line of the form   \n# define identifier (identifier-list) token-sequence\n\nwhere there is no space between the first identifier and the (, is a macro definition with  \nparameters given by the identifier list. as with the first form, leading and t railing white \nspace  \narround the token sequence is discarded, and the macro may be redefined only with a  \ndefinition in which the number and spelling of parameters, and the token sequence, is  \nidentical.   \na control line of the form   \n# undef identifier   \ncauses the identifier''s preprocessor definition to be forgotten. it is not e rroneous to apply  \n#undef to an unknown identifier.   \nwhen a macro has been defined in the second form, subsequent textual instances of the  \nmacro  \nidentifier followed by optional white space, and then by (, a sequence of tokens separated by  \ncommas, and a ) constitute a call of the macro. the arguments of the call are the c omma- \nseparated token sequences; commas that are quoted or protected by nested parenthese s do \nnot  \nseparate arguments. during collection, arguments are not macro-expanded. the number  \nof  \narguments in the call must match the number of parameters in the definition. after t he  \narguments are isolated, leading and trailing white space is removed from them. t hen the  \ntoken sequence resulting from each argument is substituted for each unquoted occurrenc e \nof  \nthe corresponding parameter''s identifier in the replacement token sequence  of the macro.  \nunless the parameter in the replacement sequence is preceded by #, or preceded or \nfollowed  \nby ##, the argument tokens are examined for macro calls, and expanded as necessary, just  \nbefore insertion.   \ntwo special operators influence the replacement process. first, if an occur rence of a  \nparameter in the replacement token sequence is immediately preceded by #, stri ng quotes \n(")  \nare placed around the corresponding parameter, and then both the # and the parameter  \nidentifier are replaced by the quoted argument. a \\ character is inserted befor e each " or \\  \ncharacter that appears surrounding, or inside, a string literal or characte r constant in the  \nargument.   \nsecond, if the definition token sequence for either kind of macro contains a ## operato r, \nthen  \njust after replacement of the parameters, each ## is deleted, together wit h any white space \non\n\neither side, so as to concatenate the adjacent tokens and form a new token. the effect is  \nundefined if invalid tokens are produced, or if the result depends on the order of  \nprocessing of  \nthe ## operators. also, ## may not appear at the beginning or end of a replacement token  \nsequence.   \nin both kinds of macro, the replacement token sequence is repeatedly rescanned for m ore  \ndefined identifiers. however, once a given identifier has been replaced in a give n \nexpansion,  \nit is not replaced if it turns up again during rescanning; instead it is left unchange d.  \n \neven if the final value of a macro expansion begins with with #, it is not taken to be a  \npreprocessing directive.   \nthe details of the macro-expansion process are described more precisely in t he ansi \nstandard than in  \nthe first edition. the most important change is the addition of the # and ## operators, \nwhich make  \nquotation and concatenation admissible. some of the new rules, especially those \ninvolving  \nconcatenation, are bizarre. (see example below.)\n\nfor example, this facility may be used for ``manifest-constants,'''' as in  \n #define tabsize 100  \nint table[tabsize] \n;    \nthe definition   \n #define absdiff(a, b) ((a)>(b) ? (a)-(b) : (b)-(a))   \ndefines a macro to return the absolute value of the difference between its arguments. \nunlike a  \nfunction to do the same thing, the arguments and returned value may have any arithmetic \ntype  \nor even be pointers. also, the arguments, which might have side effects, are evaluated \ntwice,  \nonce for the test and once to produce the value.   \ngiven the definition   \n #define tempfile(dir) #dir "%s"  \nthe macro call tempfile(/usr/tmp) yields  \n "/usr/tmp" "%s"     \nwhich will subsequently be catenated into a single string. after   \n #define cat(x, y) x ## y  \nthe call cat(var, 123) yields var123. however, the call cat(cat(1,2),3) is undefined:   \nthe presence of ## prevents the arguments of the outer call from being expanded. thus it  \nproduces the token string  \n cat ( 1 , 2 )3and )3 (the catenation of the last token of the first argument with the fi rst \ntoken of the second)  \nis not a legal token. if a second level of macro definition is introduced,   \n #define xcat(x, y) cat(x,y)  \nthings work more smoothly; xcat(xcat(1, 2), 3) does produce 123, because the  \nexpansion of xcat itself does not involve the ## operator.   \nlikewise, absdiff(absdiff(a,b),c) produces the expected, fully-expanded res ult.  \n \na.12.4 file inclusion  \na control line of the form\n\n# include <filename>   \ncauses the replacement of that line by the entire contents of the file filename. the \ncharacters  \nin the name filename must not include > or newline, and the effect is undefined if it  \ncontains  \nany of ", '', \\, or /*. the named file is searched for in a sequence of implementation -\ndefined  \nplaces.   \nsimilarly, a control line of the form   \n# include "filename"\n\nsearches first in association with the original source file (a deliberately implementation- \ndependent phrase), and if that search fails, then as in the first form. the effe ct of using '', \n\\, or  \n/* in the filename remains undefined, but > is permitted.   \nfinally, a directive of the form   \n# include token-sequence   \nnot matching one of the previous forms is interpreted by expanding the token sequence as \nfor  \nnormal text; one of the two forms with <...> or "..." must result, and is then treated as   \npreviously described.   \n#include files may be nested.   \na.12.5 conditional compilation  \nparts of a program may be compiled conditionally, according to the following schemati c  \nsyntax.   \npreprocessor-conditional:  \nif-line text elif-parts else-partopt #endif   \nif-line:   \n# if constant-expression  \n# ifdef identifier \n# ifndef identifier   \nelif-parts:  \nelif-line text \nelif-partsopt   \nelif-line:  \n# elif constant-expression   \nelse-part:  \nelse-line text   \nelse-line:\n\n#else    \neach of the directives (if-line, elif-line, else-line, and #endif) appears alone on a line. the  \nconstant expressions in #if and subsequent #elif lines are evaluated in order unti l an  \nexpression with a non-zero value is found; text following a line with a zero value is \ndiscarded.  \nthe text following the successful directive line is treated normally. ``t ext'''' here refers to \nany  \nmaterial, including preprocessor lines, that is not part of the conditional struc ture; it may \nbe  \nempty. once a successful #if or #elif line has been found and its text processed, \nsucceeding  \n#elif and #else lines, together with their text, are discarded. if all the  expressions are zero,  \nand there is an #else, the text following the #else is treated normally. text contr olled by  \ninactive arms of the conditional is ignored except for checking the nesting of \nconditionals.\n\nthe constant expression in #if and #elif is subject to ordinary macro replacement.  \nmoreover, any expressions of the form   \ndefined identifier   \nor   \ndefined (identifier)   \nare replaced, before scanning for macros, by 1l if the identifier is defined in the \npreprocessor,  \nand by 0l if not. any identifiers remaining after macro expansion are replaced by 0l. \nfinally,  \neach integer constant is considered to be suffixed with l, so that all arithme tic is taken to \nbe  \nlong or unsigned long.   \nthe resulting constant expression (par.a.7.19) is restricted: it must be inte gral, and may \nnot  \ncontain sizeof, a cast, or an enumeration constant.   \nthe control lines   \n#ifdef identifier \n#ifndef identifier     \nare equivalent to   \n# if defined identifier \n# if ! defined identifier   \nrespectively.   \n#elif is new since the first edition, although it has been available is some preproce ssors. \nthe  \ndefined preprocessor operator is also new.   \na.12.6 line control  \nfor the benefit of other preprocessors that generate c programs, a line in one of the f orms  \n \n# line constant "filename" \n# line constant\n\ncauses the compiler to believe, for purposes of error diagnostics, that the line number of \nthe  \nnext source line is given by the decimal integer constant and the current input file  is \nnamed by  \nthe identifier. if the quoted filename is absent, the remembered name does not change . \nmacros  \nin the line are expanded before it is interpreted.   \na.12.7 error generation  \na preprocessor line of the form   \n# error token-sequenceopt   \ncauses the preprocessor to write a diagnostic message that includes the to ken sequence.\n\na.12.8 pragmas  \na control line of the form   \n# pragma token-sequenceopt   \ncauses the preprocessor to perform an implementation-dependent action. an \nunrecognized  \npragma is ignored.   \na.12.9 null directive  \na control line of the form   #   \nhas no effect.   \na.12.10 predefined names  \nseveral identifiers are predefined, and expand to produce special information. they, and \nalso  \nthe preprocessor expansion operator defined, may not be undefined or redefined.  \n__line__ a decimal constant containing the current source line number.  \n__file__ a string literal containing the name of the file being compiled.  \n__date__ a string literal containing the date of compilation, in the form "mmmm dd \nyyyy"  \n__time__ a string literal containing the time of compilation, in the form "hh:mm:ss"   \n__stdc__ the constant 1. it is intended that this identifier be defined to be 1 only in \nstandard- \nconforming implementations.  \n#error and #pragma are new with the ansi standard; the predefined preprocessor  macros \nare new,  \nbut some of them have been available in some implementations.   \na.13 grammar  \nbelow is a recapitulation of the grammar that was given throughout the earlier pa rt of this  \nappendix. it has exactly the same content, but is in different order.   \nthe grammar has undefined terminal symbols integer-constant, character-constan t, \nfloating- \nconstant, identifier, string, and enumeration-constant; the typewriter sty le words and  \nsymbols are terminals given literally. this grammar can be transformed mec hanically \ninto  \ninput acceptable for an automatic parser-generator. besides adding whatever synta ctic  \nmarking is used to indicate alternatives in productions, it is necessary to expand the  ``one \nof''''  \nconstructions, and (depending on the rules of the parser-generator) to duplicate each\n\nproduction with an opt symbol, once with the symbol and once without. with one further   \nchange, namely deleting the production typedef-name: identifier and making typedef-\nname a  \nterminal symbol, this grammar is acceptable to the yacc parser-generator. it has only \none  \nconflict, generated by the if-else ambiguity.   \ntranslation-unit:  \nexternal-declaration \ntranslation-unit external-declaration\n\nexternal-declaration:  \nfunction-definition  \ndeclaration   \nfunction-definition:  \ndeclaration-specifiersopt declarator declaration-listopt compound-statement  \n \ndeclaration:  \ndeclaration-specifiers init-declarator-listopt;   \ndeclaration-list:  \ndeclaration  \ndeclaration-list declaration   \ndeclaration-specifiers:  \nstorage-class-specifier declaration-specifiersopt  \ntype-specifier declaration-specifiersopt  \ntype-qualifier declaration-specifiersopt   \nstorage-class specifier: one of   \nauto register static extern typedef   \ntype specifier: one of    \nvoid char short int long float double signed  \nunsigned struct-or-union-specifier enum-specifier typedef-name   \ntype-qualifier: one of   \nconst volatile   \nstruct-or-union-specifier:  \nstruct-or-union identifieropt { struct-declaration-list } \nstruct-or-union identifier   \nstruct-or-union: one of   \nstruct union   \nstruct-declaration-list:  \nstruct declaration  \nstruct-declaration-list struct declaration\n\ninit-declarator-list:   \ninit-declarator  \ninit-declarator-list, init-declarator   \ninit-declarator:  \ndeclarator  \ndeclarator = initializer   \nstruct-declaration:  \nspecifier-qualifier-list struct-declarator-list;\n\nspecifier-qualifier-list:  \ntype-specifier specifier-qualifier-listopt  \ntype-qualifier specifier-qualifier-listopt   \nstruct-declarator-list:  \nstruct-declarator  \nstruct-declarator-list , struct-declarator   \nstruct-declarator:  \ndeclarator  \ndeclaratoropt : constant-expression   \nenum-specifier:  \nenum identifieropt { enumerator-list }  \nenum identifier   \nenumerator-list:  \nenumerator  \nenumerator-list , enumerator   \nenumerator:  \nidentifier  \nidentifier = constant-expression   \ndeclarator:   \npointeropt direct-declarator    \ndirect-declarator:  \nidentifier  \n(declarator) \ndirect-declarator [ constant-expressionopt ] \ndirect-declarator ( parameter-type-list ) \ndirect-declarator ( identifier-listopt )   \npointer:   \n* type-qualifier-listopt  \n* type-qualifier-listopt pointer  \ntype-qualifier-list:  \ntype-qualifier  \ntype-qualifier-list type-qualifier   \nparameter-type-list:  \nparameter-list  \nparameter-list , ...\n\nparameter-list:  \nparameter-declaration  \nparameter-list , parameter-declaration\n\nparameter-declaration:  \ndeclaration-specifiers declarator  \ndeclaration-specifiers abstract-declaratoropt   \nidentifier-list:  \nidentifier  \nidentifier-list , identifier   \ninitializer:  \nassignment-expression  \n{ initializer-list } \n{ initializer-list , }   \ninitializer-list:  \ninitializer  \ninitializer-list , initializer   \ntype-name:  \nspecifier-qualifier-list abstract-declaratoropt   \nabstract-declarator:  \npointer  \npointeropt direct-abstract-declarator   \ndirect-abstract-declarator:   \n( abstract-declarator )   \ndirect-abstract-declaratoropt [constant-expressionopt]  \ndirect-abstract-declaratoropt (parameter-type-listopt)   \ntypedef-name:  \nidentifier   \nstatement:  \nlabeled-statement  \nexpression-statement  \ncompound-statement  \nselection-statement  \niteration-statement  \njump-statement   \nlabeled-statement:  \nidentifier : statement  \ncase constant-expression : statement  \ndefault : statement\n\nexpression-statement:   \nexpressionopt;   \ncompound-statement:  \n{ declaration-listopt statement-listopt }\n\nstatement-list:  \nstatement  \nstatement-list statement   \nselection-statement:  \nif (expression) statement  \nif (expression) statement else statement  \nswitch (expression) statement   \niteration-statement:  \nwhile (expression) statement  \ndo statement while (expression);  \nfor (expressionopt; expressionopt; expressionopt) statement   \njump-statement:  \ngoto identifier;  \ncontinue;  \nbreak;  \nreturn expressionopt;   \nexpression:  \nassignment-expression  \nexpression , assignment-expression   \nassignment-expression:   \nconditional-expression   \nunary-expression assignment-operator assignment-expression   \nassignment-operator: one of   \n= *= /= %= += -= <<= >>= &= ^= |=   \nconditional-expression:  \nlogical-or-expression  \nlogical-or-expression ? expression : conditional-expression   \nconstant-expression:  \nconditional-expression   \nlogical-or-expression:  \nlogical-and-expression  \nlogical-or-expression || logical-and-expression   \nlogical-and-expression:  \ninclusive-or-expression\n\nlogical-and-expression && inclusive-or-expression    \ninclusive-or-expression:  \nexclusive-or-expression  \ninclusive-or-expression | exclusive-or-expression\n\nexclusive-or-expression:  \nand-expression  \nexclusive-or-expression ^ and-expression   \nand-expression:  \nequality-expression  \nand-expression & equality-expression   \nequality-expression:  \nrelational-expression  \nequality-expression == relational-expression  \nequality-expression != relational-expression   \nrelational-expression:  \nshift-expression  \nrelational-expression < shift-expression  \nrelational-expression > shift-expression  \nrelational-expression <= shift-expression  \nrelational-expression >= shift-expression   \nshift-expression:  \nadditive-expression  \nshift-expression << additive-expression  \nshift-expression >> additive-expression    \nadditive-expression:   \nmultiplicative-expression  \nadditive-expression + multiplicative-expression  \nadditive-expression -multiplicative-expression   \nmultiplicative-expression:  \nmultiplicative-expression * cast-expression  \nmultiplicative-expression / cast-expression  \nmultiplicative-expression % cast-expression   \ncast-expression:  \nunary expression  \n(type-name) cast-expression   \nunary-expression:  \npostfix expression  \n++unary expression  \n--unary expression  \nunary-operator cast-expression  \nsizeof unary-expression\n\nsizeof (type-name)    \nunary operator: one of   \n& * + - ~ !   \npostfix-expression:  \nprimary-expression\n\npostfix-expression[expression]  \npostfix-expression(argument-expression-listopt)  \npostfix-expression.identifier \npostfix-expression->+identifier \npostfix-expression+ \n+ \npostfix-expression-   \nprimary-expression:  \nidentifier \nconstant \nstring  \n(expression)    \nargument-expression-list:  \nassignment-expression \nassignment-expression-list , assignment-expression   \nconstant:  \ninteger-constant \ncharacter-constant \nfloating-constant  \nenumeration-constant    \nthe following grammar for the preprocessor summarizes the structure of control lines, \nbut is  \nnot suitable for mechanized parsing. it includes the symbol text, which means ordina ry  \nprogram text, non-conditional preprocessor control lines, or complete preprocesso r  \nconditional instructions.   \ncontrol-line:  \n# define identifier token-sequence \n# define identifier(identifier, ... , identifier) token-sequence \n# undef identifier \n# include <filename> \n# include "filename" \n# line constant "filename" \n# line constant \n# error token-sequenceopt \n# pragma token-sequenceopt #\n\npreprocessor-conditional   \npreprocessor-conditional:  \nif-line text elif-parts else-partopt #endif   \nif-line:  \n# if constant-expression \n# ifdef identifier \n# ifndef identifier   \nelif-parts:  \nelif-line text \nelif-partsopt\n\nelif-line:  \n# elif constant-expression   \nelse-part:  \nelse-line text   \nelse-line:   \n#else\n\nappendix b - standard library   \nthis appendix is a summary of the library defined by the ansi standard. the standard \nlibrary  \nis not part of the c language proper, but an environment that supports standard c will \nprovide  \nthe function declarations and type and macro definitions of this library. we have omitted \na  \nfew functions that are of limited utility or easily synthesized from others; w e have \nomitted  \nmulti-byte characters; and we have omitted discussion of locale issues; t hat is, properties \nthat  \ndepend on local language, nationality, or culture.   \nthe functions, types and macros of the standard library are declared in standard hea ders:  \n \n <assert.h> <float.h> <math.h> <stdarg.h> <stdlib.h>  \n<ctype.h> <limits.h> <setjmp.h> <stddef.h> <string.h>  \n<errno.h> <locale.h> <signal.h> <stdio.h> <time.h>    \na header can be accessed by   \n#include <header>    \nheaders may be included in any order and any number of times. a header must be  \nincluded  \noutside of any external declaration or definition and before any use of anything it \ndeclares. a  \nheader need not be a source file.   \nexternal identifiers that begin with an underscore are reserved for use by the libra ry, as \nare all  \nother identifiers that begin with an underscore and an upper-case letter or a nother \nunderscore.   \nb.1 input and output: <stdio.h>  \nthe input and output functions, types, and macros defined in <stdio.h> represent nearly \none  \nthird of the library.   \na stream is a source or destination of data that may be associated with a di sk or other  \nperipheral. the library supports text streams and binary streams, although on some \nsystems,\n\nnotably unix, these are identical. a text stream is a sequence of lines; each line has zero \nor   \nmore characters and is terminated by ''\\n''. an environment may need to convert a te xt \nstream  \nto or from some other representation (such as mapping ''\\n'' to carriage return and \nlinefeed).  \na binary stream is a sequence of unprocessed bytes that record internal data, with  the \nproperty  \nthat if it is written, then read back on the same system, it will compare equa l.  \n \na stream is connected to a file or device by opening it; the connection is broken by \nclosing  \nthe stream. opening a file returns a pointer to an object of type file, which records  \nwhatever  \ninformation is necessary to control the stream. we will use ``file pointer '''' and ``stream''''  \ninterchangeably when there is no ambiguity.   \nwhen a program begins execution, the three streams stdin, stdout, and stderr are already  \nopen.   \nb.1.1 file operations\n\nthe following functions deal with operations on files. the type size_t is the unsigned  \n \nintegral type produced by the sizeof operator.   \nfile *fopen(const char *filename, const char *mode) \nfopen opens the named file, and returns a stream, or null if the attempt fails. leg al  \nvalues for mode include:  \n"r" open text file for reading  \n"w" create text file for writing; discard previous contents if any  \n"a" append; open or create text file for writing at end of file  \n"r+" open text file for update (i.e., reading and writing)  \n"w+" create text file for update, discard previous contents if any  \n"a+" append; open or create text file for update, writing at end  \nupdate mode permits reading and writing the same file; fflush or a file-posit ioning  \nfunction must be called between a read and a write or vice versa. if the mode include s  \nb after the initial letter, as in "rb" or "w+b", that indicates a binary fi le. filenames are  \nlimited to filename_max characters. at most fopen_max files may be ope n at \nonce.   \nfile *freopen(const char *filename, const char *mode, file *stream) \nfreopen opens the file with the specified mode and associates the stream with it.  it  \nreturns stream, or null if an error occurs. freopen is normally used to change t he  \nfiles associated with stdin, stdout, or stderr.   \nint fflush(file *stream)  \non an output stream, fflush causes any buffered but unwritten data to be written; on   \nan input stream, the effect is undefined. it returns eof for a write error, a nd zero  \notherwise. fflush(null) flushes all output streams.   \nint fclose(file *stream) \nfclose flushes any unwritten data for stream, discards any unread buffered input,  \nfrees any automatically allocated buffer, then closes the stream. it retur ns eof if any  \nerrors occurred, and zero otherwise.   \nint remove(const char *filename)  \nremove removes the named file, so that a subsequent attempt to open it will fail.  it  \nreturns non-zero if the attempt fails.   \nint rename(const char *oldname, const char *newname)  \nrename changes the name of a file; it returns non-zero if the attempt fails.   \nfile *tmpfile(void) \ntmpfile creates a temporary file of mode "wb+" that will be automatica lly removed  \nwhen closed or when the program terminates normally. tmpfile returns a stream, or   \nnull if it could not create the file.\n\nchar *tmpnam(char s[l_tmpnam]) \ntmpnam(null) creates a string that is not the name of an existing file, and returns a  \npointer to an internal static array. tmpnam(s) stores the string in s as well a s returning  \nit as the function value; s must have room for at least l_tmpnam characters. tmpna m  \ngenerates a different name each time it is called; at most tmp_max dif ferent names are  \nguaranteed during execution of the program. note that tmpnam creates a name, not a  \nfile.   \nint setvbuf(file *stream, char *buf, int mode, size_t size) \nsetvbuf controls buffering for the stream; it must be called before reading, writ ing or  \nany other operation. a mode of _iofbf causes full buffering, _iolbf line buffering of  \ntext files, and _ionbf no buffering. if buf is not null, it will be used as the buffer,  \notherwise a buffer will be allocated. size determines the buffer size. s etvbuf returns  \nnon-zero for any error.   \nvoid setbuf(file *stream, char *buf) \nif buf is null, buffering is turned off for the stream. otherwise, setbuf is  equivalent  \nto (void) setvbuf(stream, buf, _iofbf, bufsiz).\n\nb.1.2 formatted output  \nthe printf functions provide formatted output conversion.   \n int fprintf(file *stream, const char *format, ...) \nfprintf converts and writes output to stream under the control of format. the return value  \nis the number of characters written, or negative if an error occurred.   \nthe format string contains two types of objects: ordinary characters, which ar e copied to \nthe  \noutput stream, and conversion specifications, each of which causes conversion and \nprinting of  \nthe next successive argument to fprintf. each conversion specification begins wit h the  \ncharacter % and ends with a conversion character. between the % and the conversi on \ncharacter  \nthere may be, in order:   \n•  \nflags (in any order), which modify the specification:  \no-, which specifies left adjustment of the converted argument in its field.  \no+, which specifies that the number will always be printed with a sign.  o  \nspace: if the first character is not a sign, a space will be prefixed.  o  \n0: for numeric conversions, specifies padding to the field width with leading  \nzeros.   o   \n#, which specifies an alternate output form. for o, the first digit will become  \nzero. for x or x, 0x or 0x will be prefixed to a non-zero result. for e, e, f, g,  \nand g, the output will always have a decimal point; for g and g, trailing zeros  \nwill not be removed.  \n•  \na number specifying a minimum field width. the converted argument will be printed  \nin a field at least this wide, and wider if necessary. if the converted argume nt has  \nfewer characters than the field width it will be padded on the left (or righ t, if left  \nadjustment has been requested) to make up the field width. the padding character is  \nnormally space, but is 0 if the zero padding flag is present.  \n•  \na period, which separates the field width from the precision.  \n•  \na number, the precision, that specifies the maximum number of characters to be   \nprinted from a string, or the number of digits to be printed after the decimal point for  \ne, e, or f conversions, or the number of significant digits for g or g conversion, or the  \nnumber of digits to be printed for an integer (leading 0s will be added to make up the  \nnecessary width).  \n•\n\na length modifier h, l (letter ell), or l. ``h'''' indicates that the corresponding argument  \nis to be printed as a short or unsigned short; ``l'''' indicates that the argument is  a  \nlong or unsigned long, ``l'''' indicates that the argument is a long double.   \nwidth or precision or both may be specified as *, in which case the value is computed by  \nconverting the next argument(s), which must be int.   \nthe conversion characters and their meanings are shown in table b.1. if the character \nafter  \nthe % is not a conversion character, the behavior is undefined.   \ntable b.1 printf conversions   \ncharacter argument type; printed as  \nd,i int; signed decimal notation.  \no int; unsigned octal notation (without a leading zero).\n\nx,x unsigned int; unsigned hexadecimal notation (without a leading 0x or 0x),  \nusing abcdef for 0x or abcdef for 0x.  \nu int; unsigned decimal notation.  \nc int; single character, after conversion to unsigned char  \ns char *; characters from the string are printed until a ''\\0'' is reached or until the  \nnumber of characters indicated by the precision have been printed.  \nf  \ndouble; decimal notation of the form [-]mmm.ddd, where the number of d''s is  \ngiven by the precision. the default precision is 6; a precision of 0 suppresses the  \ndecimal point.  \ne,e  \ndouble; decimal notation of the form [-]m.dddddde+/-xx or [-]m.dddddde+/- \nxx, where the number of d''s is specified by the precision. the default precision is  \n6; a precision of 0 suppresses the decimal point.  \ng,g  \ndouble; %e or %e is used if the exponent is less than -4 or greater than or equal to  \nthe precision; otherwise %f is used. trailing zeros and a trailing decimal point a re  \nnot printed.  \np void *; print as a pointer (implementation-dependent representation).  \nn int *; the number of characters written so far by this call to printf is wri tten  \ninto the argument. no argument is converted.  \n% no argument is converted; print a %  \nint printf(const char *format, ...) \nprintf(...) is equivalent to fprintf(stdout, ...).    \nint sprintf(char *s, const char *format, ...)  \nsprintf is the same as printf except that the output is written into the stri ng s,  \nterminated with ''\\0''. s must be big enough to hold the result. the return count does  \nnot include the ''\\0''.   \nint vprintf(const char *format, va_list arg)  \nint vfprintf(file *stream, const char *format, va_list arg) \nint vsprintf(char *s, const char *format, va_list arg)  \nthe functions vprintf, vfprintf, and vsprintf are equivalent to the corresponding  \nprintf functions, except that the variable argument list is replaced by arg, which ha s  \nbeen initialized by the va_start macro and perhaps va_arg calls. see the discussion   \nof <stdarg.h> in section b.7.   \nb.1.3 formatted input  \nthe scanf function deals with formatted input conversion.   \nint fscanf(file *stream, const char *format, ... \n)  \nfscanf reads from stream under control of format, and assigns converted values  through\n\nsubsequent arguments, each of which must be a pointer. it returns when format is  \nexhausted.  \nfscanf returns eof if end of file or an error occurs before any conversion; otherwise it \nreturns  \nthe number of input items converted and assigned.   \nthe format string usually contains conversion specifications, which are used t o direct  \ninterpretation of input. the format string may contain:    \n•  \nblanks or tabs, which are not ignored.  \n•  \nordinary characters (not %), which are expected to match the next non-white spa ce  \ncharacter of the input stream.\n\n•  \nconversion specifications, consisting of a %, an optional assignment suppression  \ncharacter *, an optional number specifying a maximum field width, an optional h, l, or  \nl indicating the width of the target, and a conversion character.  \na conversion specification determines the conversion of the next input field. normally \nthe  \nresult is placed in the variable pointed to by the corresponding argument. if assignment   \nsuppression is indicated by *, as in %*s, however, the input field is simply skipped; no  \nassignment is made. an input field is defined as a string of non-white space charact ers; it  \nextends either to the next white space character or until the field width, if  specified, is  \nexhausted. this implies that scanf will read across line boundaries to find its input , since  \nnewlines are white space. (white space characters are blank, tab, newline, car riage return,  \nvertical tab, and formfeed.)   \nthe conversion character indicates the interpretation of the input field. the correspo nding  \nargument must be a pointer. the legal conversion characters are shown in table b .2.  \n \nthe conversion characters d, i, n, o, u, and x may be preceded by h if the argument is a  \npointer to short rather than int, or by l (letter ell) if the argument is a pointer  to long. the  \nconversion characters e, f, and g may be preceded by l if a pointer to double rather t han  \nfloat is in the argument list, and by l if a pointer to a long double.   \ntable b.2 scanf conversions   \ncharacter input data; argument type   \nd decimal integer; int*   \ni integer; int*. the integer may be in octal (leading 0) or hexadecimal (leading 0x  \nor 0x).  \no octal integer (with or without leading zero); int *.  \nu unsigned decimal integer; unsigned int *.  \nx hexadecimal integer (with or without leading 0x or 0x); int*.  \nc  \ncharacters; char*. the next input characters are placed in the indicated array, up   \nto the number given by the width field; the default is 1. no ''\\0'' is added. the  \nnormal skip over white space characters is suppressed in this case; to read  the next  \nnon-white space character, use %1s.  \ns  \nstring of non-white space characters (not quoted); char *, pointing to an array of  \ncharacters large enough to hold the string and a terminating ''\\0'' that will be  \nadded.  \ne,f,g  \nfloating-point number; float *. the input format for float''s is an optional sign,  \na string of numbers possibly containing a decimal point, and an optional exponent  \nfield containing an e or e followed by a possibly signed integer.  \np pointer value as printed by printf("%p");, void *.\n\nn writes into the argument the number of characters read so far by this call; int *.  \nno input is read. the converted item count is not incremented.   \n[...] matches the longest non-empty string of input characters from the set betw een  \nbrackets; char *. a ''\\0'' is added. []...] includes ] in the set.  \n[^...] matches the longest non-empty string of input characters not from the set betw een  \nbrackets; char *. a ''\\0'' is added. [^]...] includes ] in the set.\n\n% literal %; no assignment is made.  \nint scanf(const char *format, ...) \nscanf(...) is identical to fscanf(stdin, ...).   \nint sscanf(const char *s, const char *format, ...) \nsscanf(s, ...) is equivalent to scanf(...) except that the input characters are  \ntaken from the string s.   \nb.1.4 character input and output functions  \nint fgetc(file *stream) \nfgetc returns the next character of stream as an unsigned char (converted to an  \nint), or eof if end of file or error occurs.   \nchar *fgets(char *s, int n, file *stream) \nfgets reads at most the next n-1 characters into the array s, stopping if a newline  is  \nencountered; the newline is included in the array, which is terminated by ''\\0''. fgets   \nreturns s, or null if end of file or error occurs.   \nint fputc(int c, file *stream) \nfputc writes the character c (converted to an unsigend char) on stream. it returns   \nthe character written, or eof for error.   \nint fputs(const char *s, file *stream) \nfputs writes the string s (which need not contain \\n) on stream; it returns nonnega tive, or \neof for an error.     \nint getc(file *stream)  \ngetc is equivalent to fgetc except that if it is a macro, it may evaluate str eam more  \nthan once.   \nint getchar(void) \ngetchar is equivalent to getc(stdin).   \nchar *gets(char *s)  \ngets reads the next input line into the array s; it replaces the terminat ing newline with  \n''\\0''. it returns s, or null if end of file or error occurs.   \nint putc(int c, file *stream)  \nputc is equivalent to fputc except that if it is a macro, it may evaluate stre am more  \nthan once.   \nint putchar(int c) \nputchar(c) is equivalent to putc(c,stdout).   \nint puts(const char *s)\n\nputs writes the string s and a newline to stdout. it returns eof if an error occurs,  \nnon-negative otherwise.    \nint ungetc(int c, file *stream)  \nungetc pushes c (converted to an unsigned char) back onto stream, where it will be  \nreturned on the next read. only one character of pushback per stream is guaranteed.  \neof may not be pushed back. ungetc returns the character pushed back, or eof for  \nerror.   \nb.1.5 direct input and output functions  \nsize_t fread(void *ptr, size_t size, size_t nobj, file *stream) \nfread reads from stream into the array ptr at most nobj objects of size size. f read  \nreturns the number of objects read; this may be less than the number request ed. feof  \nand ferror must be used to determine status.   \nsize_t fwrite(const void *ptr, size_t size, size_t nobj, file *stream) \nfwrite writes, from the array ptr, nobj objects of size size on stream. it ret urns the  \nnumber of objects written, which is less than nobj on error.\n\nb.1.6 file positioning functions  \nint fseek(file *stream, long offset, int origin) \nfseek sets the file position for stream; a subsequent read or write will access data  \nbeginning at the new position. for a binary file, the position is set to offset  \ncharacters from origin, which may be seek_set (beginning), seek_cur (current   \nposition), or seek_end (end of file). for a text stream, offset must be zero, or a val ue  \nreturned by ftell (in which case origin must be seek_set). fseek returns non -zero  \non error.   \nlong ftell(file *stream) \nftell returns the current file position for stream, or -1 on error.  \nvoid rewind(file *stream) \nrewind(fp) is equivalent to fseek(fp, 0l, seek_set); clearerr(fp).   \nint fgetpos(file *stream, fpos_t *ptr) \nfgetpos records the current position in stream in *ptr, for subsequent use by  \nfsetpos. the type fpos_t is suitable for recording such values. fgetpos returns nonzero on \nerror.   \nint fsetpos(file *stream, const fpos_t *ptr) \nfsetpos positions stream at the position recorded by fgetpos in *ptr. fsetpos  \nreturns non-zero on error.   \nb.1.7 error functions  \nmany of the functions in the library set status indicators when error or end of file  occur. \nthese  \nindicators may be set and tested explicitly. in addition, the integer expressi on errno \n(declared  \nin <errno.h>) may contain an error number that gives further information about the most   \nrecent error.   \nvoid clearerr(file *stream) \nclearerr clears the end of file and error indicators for stream.  \nint feof(file *stream) \nfeof returns non-zero if the end of file indicator for stream is set.  \nint ferror(file *stream) \nferror returns non-zero if the error indicator for stream is set.   \nvoid perror(const char *s) \nperror(s) prints s and an implementation-defined error message corresponding to   \nthe integer in errno, as if by   \nfprintf(stderr, "%s: %s\\n", s, "error message");   \nsee strerror in section b.3.\n\nb.2 character class tests: <ctype.h>  \nthe header <ctype.h> declares functions for testing characters. for each function, the  \nargument list is an int, whose value must be eof or representable as an unsigned cha r, \nand  \nthe return value is an int. the functions return non-zero (true) if the argument c  satisfies \nthe  \ncondition described, and zero if not.   \nisalnum(c) isalpha(c) or isdigit(c) is true   \nisalpha(c) isupper(c) or islower(c) is true   \niscntrl(c) control character  \nisdigit(c) decimal digit\n\nisgraph(c) printing character except space  \nislower(c) lower-case letter  \nisprint(c) printing character including space  \nispunct(c) printing character except space or letter or digit  \nisspace(c) space, formfeed, newline, carriage return, tab, vertical tab  \nisupper(c) upper-case letter  \nisxdigit(c) hexadecimal digit   \nin the seven-bit ascii character set, the printing characters are 0x20 ('' '') to 0x7e (''-'');  \nthe control characters are 0 nul to 0x1f (us), and 0x7f (del).   \nin addition, there are two functions that convert the case of letters:   \nint tolower(c) convert c to lower case  \nint toupper(c) convert c to upper case   \nif c is an upper-case letter, tolower(c) returns the corresponding lower- case letter,  \ntoupper(c) returns the corresponding upper-case letter; otherwise it ret urns c.  \n \nb.3 string functions: <string.h>  \nthere are two groups of string functions defined in the header <string.h>. the first have  \nnames beginning with str; the second have names beginning with mem. except for \nmemmove,  \nthe behavior is undefined if copying takes place between overlapping objects. \ncomparison   \nfunctions treat arguments as unsigned char arrays.    \nin the following table, variables s and t are of type char *; cs and ct are of type c onst  \nchar *; n is of type size_t; and c is an int converted to char.   \nchar *strcpy(s,ct) copy string ct to string s, including ''\\0''; return s.   \nchar copy at most n characters of string ct to s; return s. pad with ''\\0'''' \ns \n*strncpy(s,ct,n) if ct has fewer than n characters.  \nchar *strcat(s,ct) concatenate string ct to end of string s; return s.  \nchar concatenate at most n characters of string ct to string s, terminate  \ns   \n*strncat(s,ct,n) with ''\\0''; return s.  \nint strcmp(cs,ct) compare string cs to string ct, return <0 if cs<ct, 0 if cs ==ct, or >0  \nif cs>ct.   \nint compare at most n characters of string cs to string ct; return <0 if\n\nstrncmp(cs,ct,n) cs<ct, 0 if cs==ct, or >0 if cs>ct.   \nchar *strchr(cs,c) return pointer to first occurrence of c in cs or null if not present.  \nchar *strrchr(cs,c) return pointer to last occurrence of c in cs or null if not  present. \n  \nsize_t   \nstrspn(cs,ct) return length of prefix of cs consisting of characters in ct.  \nsize_t   \nstrcspn(cs,ct) return length of prefix of cs consisting of characters not in ct .  \n \nchar return pointer to first occurrence in string cs of any character string  \n*strpbrk(cs,ct) ct, or null if not present.\n\nchar *strstr(cs,ct) return pointer to first occurrence of string ct in cs, or null if not  \npresent.  \nsize_t strlen(cs) return length of cs.  \nchar *strerror(n) return pointer to implementation-defined string correspo nding to  \nerror n.  \nchar *strtok(s,ct) strtok searches s for tokens delimited by characters from c t; see  \nbelow.   \na sequence of calls of strtok(s,ct) splits s into tokens, each delimited by a  character from  \nct. the first call in a sequence has a non-null s, it finds the first toke n in s consisting of  \ncharacters not in ct; it terminates that by overwriting the next character of s  with ''\\0'' and  \nreturns a pointer to the token. each subsequent call, indicated by a null value of s, \nreturns the  \nnext such token, searching from just past the end of the previous one. strtok returns \nnull  \nwhen no further token is found. the string ct may be different on each call.   \nthe mem... functions are meant for manipulating objects as character arrays ; the intent is \nan  \ninterface to efficient routines. in the following table, s and t are of type void *;  cs and ct  \nare of type const void *; n is of type size_t; and c is an int converted to an unsigned  \nchar.   \nvoid    \n*memcpy(s,ct,n) copy n characters from ct to s, and return s.   \nvoid   \n*memmove(s,ct,n) same as memcpy except that it works even if the objects over lap.  \n \nint memcmp(cs,ct,n) compare the first n characters of cs with ct; retu rn as with strcmp.  \n \nvoid return pointer to first occurrence of character c in cs, or null if not  \n*memchr(cs,c,n) present among the first n characters.  \nvoid *memset(s,c,n) place character c into first n characters of s, return s .  \n  \nb.4 mathematical functions: <math.h>  \nthe header <math.h> declares mathematical functions and macros.   \nthe macros edom and erange (found in <errno.h>) are non-zero integral constants  \nthat are  \nused to signal domain and range errors for the functions; huge_val is a positive \ndouble\n\nvalue. a domain error occurs if an argument is outside the domain over which the  \nfunction is  \ndefined. on a domain error, errno is set to edom; the return value is implementation-\ndefined.  \na range error occurs if the result of the function cannot be represented as a double. i f the  \nresult overflows, the function returns huge_val with the right sign, and errno is se t to  \nerange. if the result underflows, the function returns zero; whether errno is s et to \nerange is  \nimplementation-defined.   \nin the following table, x and y are of type double, n is an int, and all functions return  \ndouble. angles for trigonometric functions are expressed in radians.   \nsin(x) sine of x  \ncos(x) cosine of x  \ntan(x) tangent of x  \nasin(x) sin-1(x) in range [-pi/2,pi/2], x in [-1,1].\n\nacos(x)  \ncos-1(x) in range [0,pi], x in [-1,1].   \natan(x)  \ntan-1(x) in range [-pi/2,pi/2].   \natan2(y,x)  \ntan-1(y/x) in range [-pi,pi].   \nsinh(x)  \nhyperbolic sine of x   \ncosh(x)  \nhyperbolic cosine of x   \ntanh(x)  \nhyperbolic tangent of x   \nexp(x)  \nexponential function ex   \nlog(x)  \nnatural logarithm ln(x), x>0.   \nlog10(x)   \nbase 10 logarithm log10(x), x>0.    \npow(x,y)  \nxy. a domain error occurs if x=0 and y<=0, or if x<0 and y is not an integer.   \nsqrt(x)  \nsqare root of x, x>=0.   \nceil(x)  \nsmallest integer not less than x, as a double.   \nfloor(x)  \nlargest integer not greater than x, as a double.   \nfabs(x)  \nabsolute value |x|   \nldexp(x,n)  x*2n  \nsplits x into a normalized fraction in the interval [1/2,1) which is returned,\n\nfrexp(x, int  \nand a power of 2, which is stored in *exp. if x is zero, both parts of the   \n*ip)   \nresult are zero.   \nmodf(x,  \nsplits x into integral and fractional parts, each with the same sign as x. it   \ndouble *ip)  \nstores the integral part in *ip, and returns the fractional part.   \nfmod(x,y)  \nfloating-point remainder of x/y, with the same sign as x. if y is zero, the  \nresult is implementation-defined.   \nb.5 utility functions: <stdlib.h>  \nthe header <stdlib.h> declares functions for number conversion, storage allocation, and  \n \nsimilar tasks. double atof(const char *s)  \natof converts s to double; it is equivalent to strtod(s, (char**)null).   \nint atoi(const char *s) \nconverts s to int; it is equivalent to (int)strtol(s, (char**)null , 10).  \n \nlong atol(const char *s) \nconverts s to long; it is equivalent to strtol(s, (char**)null, 10).   \ndouble strtod(const char *s, char **endp) \nstrtod converts the prefix of s to double, ignoring leading white space; it stores a   \npointer to any unconverted suffix in *endp unless endp is null. if the answer would  \noverflow, huge_val is returned with the proper sign; if the answer would underflow ,  \nzero is returned. in either case errno is set to erange.   \nlong strtol(const char *s, char **endp, int base) \nstrtol converts the prefix of s to long, ignoring leading white space; it stores a  \npointer to any unconverted suffix in *endp unless endp is null. if base is between 2  \nand 36, conversion is done assuming that the input is written in that base. if base is  \nzero, the base is 8, 10, or 16; leading 0 implies octal and leading 0x or 0x  \nhexadecimal. letters in either case represent digits from 10 to base-1; a l eading 0x or  \n0x is permitted in base 16. if the answer would overflow, long_max or long_min \nis  \nreturned, depending on the sign of the result, and errno is set to erange.\n\nunsigned long strtoul(const char *s, char **endp, int base)  \nstrtoul is the same as strtol except that the result is unsigned long and the error  \nvalue is ulong_max.\n\nint rand(void) \nrand returns a pseudo-random integer in the range 0 to rand_max, which is at least  \n32767.   \nvoid srand(unsigned int seed) \nsrand uses seed as the seed for a new sequence of pseudo-random numbers. the  \ninitial seed is 1.   \nvoid *calloc(size_t nobj, size_t size) \ncalloc returns a pointer to space for an array of nobj objects, each of size size , or  \nnull if the request cannot be satisfied. the space is initialized to zero byt es.  \n \nvoid *malloc(size_t size) \nmalloc returns a pointer to space for an object of size size, or null if the re quest  \ncannot be satisfied. the space is uninitialized.   \nvoid *realloc(void *p, size_t size) \nrealloc changes the size of the object pointed to by p to size. the contents will be  \nunchanged up to the minimum of the old and new sizes. if the new size is larger, the  \nnew space is uninitialized. realloc returns a pointer to the new space, or null i f the  \nrequest cannot be satisfied, in which case *p is unchanged.   \nvoid free(void *p) \nfree deallocates the space pointed to by p; it does nothing if p is null. p must be a  \npointer to space previously allocated by calloc, malloc, or realloc.     \nvoid abort(void) \nabort causes the program to terminate abnormally, as if by raise(sigabrt).   \nvoid exit(int status) \nexit causes normal program termination. atexit functions are called in rever se order  \nof registration, open files are flushed, open streams are closed, and control is retur ned  \nto the environment. how status is returned to the environment is implementation - \ndependent, but zero is taken as successful termination. the values exit_succes s and  \nexit_failure may also be used.   \nint atexit(void (*fcn)(void)) \natexit registers the function fcn to be called when the program terminates normal ly;  \nit returns non-zero if the registration cannot be made.   \nint system(const char *s)  \nsystem passes the string s to the environment for execution. if s is null, system   \nreturns non-zero if there is a command processor. if s is not null, the return val ue is  \nimplementation-dependent.\n\nchar *getenv(const char *name)   \ngetenv returns the environment string associated with name, or null if no string  \nexists. details are implementation-dependent.   \nvoid *bsearch(const void *key, const void *base,  \nsize_t n, size_t size,  \nint (*cmp)(const void *keyval, const void *datum))  \nbsearch searches base[0]...base[n-1] for an item that matches *key. the function  \ncmp must return negative if its first argument (the search key) is less tha n its second (a  \ntable entry), zero if equal, and positive if greater. items in the array bas e must be in  \nascending order. bsearch returns a pointer to a matching item, or null if none exis ts.  \n \nvoid qsort(void *base, size_t n, size_t size,  \nint (*cmp)(const void *, const void *))  \nqsort sorts into ascending order an array base[0]...base[n-1] of objects of size  \nsize. the comparison function cmp is as in bsearch.  \nint abs(int n) \nabs returns the absolute value of its int argument.  \nlong labs(long n) \nlabs returns the absolute value of its long argument.\n\ndiv_t div(int num, int denom) \ndiv computes the quotient and remainder of num/denom. the results are stored in the  \nint members quot and rem of a structure of type div_t.   \nldiv_t ldiv(long num, long denom) \nldiv computes the quotient and remainder of num/denom. the results are stored in the  \nlong members quot and rem of a structure of type ldiv_t.   \nb.6 diagnostics: <assert.h>  \nthe assert macro is used to add diagnostics to programs:   \nvoid assert(int expression)   \nif expression is zero when   \nassert(expression)   \nis executed, the assert macro will print on stderr a message, such as   \nassertion failed: expression, file filename, line nnn   \nit then calls abort to terminate execution. the source filename and line number come \nfrom  \nthe preprocessor macros __file__ and __line__.    \nif ndebug is defined at the time <assert.h> is included, the assert ma cro is ignored.  \n  \nb.7 variable argument lists: <stdarg.h>  \nthe header <stdarg.h> provides facilities for stepping through a list of function \narguments  \nof unknown number and type.   \nsuppose lastarg is the last named parameter of a function f with a variable number  of  \narguments. then declare within f a variable of type va_list that will point to each \nargument  \nin turn:   \n va_list ap;  \nap must be initialized once with the macro va_start before any unnamed argument is   \naccessed:   \nva_start(va_list ap, lastarg);   \nthereafter, each execution of the macro va_arg will produce a value that has the  type and  \nvalue of the next unnamed argument, and will also modify ap so the next use of va_arg\n\nreturns the next argument:    \ntype va_arg(va_list ap, type);   \nthe macro   \n void va_end(va_list ap);\n\nmust be called once after the arguments have been processed but before f is exited.   \nb.8 non-local jumps: <setjmp.h>  \nthe declarations in <setjmp.h> provide a way to avoid the normal function call and \nreturn  \nsequence, typically to permit an immediate return from a deeply nested function call.  \n \nint setjmp(jmp_buf env) \nthe macro setjmp saves state information in env for use by longjmp. the return is  \nzero from a direct call of setjmp, and non-zero from a subsequent call of longjmp. a  \ncall to setjmp can only occur in certain contexts, basically the test of if, s witch, and  \nloops, and only in simple relational expressions.  \n if (setjmp(env) == 0)  \n/* get here on direct call */  \nelse  \n/* get here by calling longjmp */  \nvoid longjmp(jmp_buf env, int val) \nlongjmp restores the state saved by the most recent call to setjmp, using the  \ninformation saved in env, and execution resumes as if the setjmp function had just  \nexecuted and returned the non-zero value val. the function containing the setjmpmust  not \nhave terminated. accessible objects have the values they had at the time  \nlongjmp was called, except that non-volatile automatic variables in the function   \ncalling setjmp become undefined if they were changed after the setjmp call.    \nb.9 signals: <signal.h>   \nthe header <signal.h> provides facilities for handling exceptional conditions that  arise  \nduring execution, such as an interrupt signal from an external source or an error in \nexecution.   \nvoid (*signal(int sig, void (*handler)(int)))(int)  \nsignal determines how subsequent signals will be handled. if handler is sig_dfl, the   \nimplementation-defined default behavior is used, if it is sig_ign, the signal is  ignored;  \notherwise, the function pointed to by handler will be called, with the argument of the  type \nof  \nsignal. valid signals include   \nsigabrt abnormal termination, e.g., from abort  \nsigfpe arithmetic error, e.g., zero divide or overflow  \nsigill illegal function image, e.g., illegal instruction  \nsigint interactive attention, e.g., interrupt  \nsigsegv illegal storage access, e.g., access outside memory limits  \nsigterm termination request sent to this program\n\nsignal returns the previous value of handler for the specific signal, or sig_err if an \nerror   \noccurs.   \nwhen a signal sig subsequently occurs, the signal is restored to its default behavi or; then \nthe  \nsignal-handler function is called, as if by (*handler)(sig). if the handler returns, e xecution  \nwill resume where it was when the signal occurred.   \nthe initial state of signals is implementation-defined.\n\nint raise(int sig)  \nraise sends the signal sig to the program; it returns non-zero if unsuccessful.  \n  \nb.10 date and time functions: <time.h>  \nthe header <time.h> declares types and functions for manipulating date and time. s ome  \nfunctions process local time, which may differ from calendar time, for example  because \nof  \ntime zone. clock_t and time_t are arithmetic types representing times, and str uct tm holds  \nthe components of a calendar time:   \nint tm_sec; seconds after the minute (0,61)  \nint tm_min; minutes after the hour (0,59)  \nint tm_hour; hours since midnight (0,23)  \nint tm_mday; day of the month (1,31)  \nint tm_mon; months since january (0,11)  \nint tm_year; years since 1900  \nint tm_wday; days since sunday (0,6)  \nint tm_yday; days since january 1 (0,365)  \nint tm_isdst; daylight saving time flag   \ntm_isdst is positive if daylight saving time is in effect, zero if not, and negati ve if the  \ninformation is not available.   \nclock_t clock(void)  \nclock returns the processor time used by the program since the beginning of   \nexecution, or -1 if unavailable. clock()/clk_per_sec is a time in seconds.   \ntime_t time(time_t *tp) \ntime returns the current calendar time or -1 if the time is not available. i f tp is not  \nnull, the return value is also assigned to *tp.   \ndouble difftime(time_t time2, time_t time1) \ndifftime returns time2-time1 expressed in seconds.   \ntime_t mktime(struct tm *tp) \nmktime converts the local time in the structure *tp into calendar time in t he same  \nrepresentation used by time. the components will have values in the ranges shown.  \nmktime returns the calendar time or -1 if it cannot be represented.   \nthe next four functions return pointers to static objects that may be overwritten by othe r \ncalls.  \nchar *asctime(const struct tm *tp) \nasctime</tt< converts the time in the structure *tp into a string of\n\nthe form    \n sun jan 3 15:14:13 1988\\n\\0   \nchar *ctime(const time_t *tp) \nctime converts the calendar time *tp to local time; it is equivalent  \nto   \n asctime(localtime(tp))   \nstruct tm *gmtime(const time_t *tp)  \ngmtime converts the calendar time *tp into coordinated universal time(utc). it returns \nnull if utc is not available. the name gmtime hashistorical significanc e.  \n \nstruct tm *localtime(const time_t *tp)  \nlocaltime converts the calendar time *tp into local time.  \nsize_t strftime(char *s, size_t smax, const char *fmt, const struct tm *t p)\n\nstrftime formats date and time information from *tp into s accordingto fmt, which is \nanalogous to a printf format. ordinary characters(including the terminating ''\\0'' ) are \ncopied into s. each %c is  \nreplaced as described below, using values appropriate for the localenvironment . no more \nthan smax characters are placed into s. strftimereturns the number of chara cters, \nexcluding the ''\\0'', or zero if more  \nthan smax characters were produced.   \n%a abbreviated weekday name.   \n%a full weekday name.   \n%b abbreviated month name.   \n%b full month name.   \n%c local date and time representation.   \n%d day of the month (01-31).   \n%h hour (24-hour clock) (00-23).   \n%i hour (12-hour clock) (01-12).   \n%j day of the year (001-366).     \n%m month (01-12).   \n%m minute (00-59) .  \n%p local equivalent of am or pm.  \n%s second (00-61) .    \n%u week number of the year (sunday as 1st day of week) (00-53) .  \n%w weekday (0-6, sunday is 0) .  \n%w week number of the year (monday as 1st day of week) (00-53) .  \n%x local date representation.  \n%x local time representation. \n%y year without century (00-99) .\n\n%y year with century.  \n%z time zone name, if any.   \n%% %\n\nb.11 implementation-defined limits:  \n<limits.h> and <float.h>  \nthe header <limits.h> defines constants for the sizes of integral types. \nthe values below are acceptable minimum magnitudes; larger values may beused.  \n \nchar_bit 8 bits in a char  \nchar_max uchar_max or schar_max maximum value of char  \nchar_min 0 or schar_min maximum value of char  \nint_max 32767 maximum value of int  \nint_min -32767 minimum value of int  \nlong_max 2147483647 maximum value of long  \nlong_min -2147483647 minimum value of long  \nschar_max +127 maximum value of signed char  \nschar_min -127 minimum value of signed char  \nshrt_max +32767 maximum value of short  \nshrt_min -32767 minimum value of short  \nuchar_max 255 maximum value of unsigned char  \nuint_max 65535 maximum value of unsigned int  \nulong_max 4294967295 maximum value of unsigned long  \nushrt_max 65535 maximum value of unsigned short   \nthe names in the table below, a subset of <float.h>, are constants relatedto f loating-point \narithmetic. when a value is given, it represents theminimum magnitude for the \ncorresponding quantity. each implementation  \ndefines appropriate values.     \nflt_radix 2 radix of exponent, representation, e.g., 2, 16  \nflt_rounds floating-point rounding mode for addition  \nflt_dig 6 decimal digits of precision  \nflt_epsilon 1e-5 smallest number x such that 1.0+x != 1.0  \nflt_mant_dig number of base flt_radix in mantissa  \nflt_max 1e+37 maximum floating-point number  \nflt_max_exp maximum n such that flt_radixn-1 is representable  \nflt_min 1e-37 minimum normalized floating-point number  \nflt_min_exp minimum n such that 10n is a normalized number  \ndbl_dig 10 decimal digits of precision  \ndbl_epsilon 1e-9 smallest number x such that 1.0+x != 1.0  \ndbl_mant_dig number of base flt_radix in mantissa  \ndbl_max 1e+37 maximum double floating-point number  \ndbl_max_exp maximum n such that flt_radixn-1 is representable  \ndbl_min 1e-37 minimum normalized double floating-point number  \ndbl_min_exp minimum n such that 10n is a normalized number\n\nappendix c - summary of changes   \nsince the publication of the first edition of this book, the definition of the c language has  \nundergone changes. almost all were extensions of the original language, and were \ncarefully  \ndesigned to remain compatible with existing practice; some repaired ambi guities in the  \noriginal description; and some represent modifications that change existin g practice. \nmany of  \nthe new facilities were announced in the documents accompanying compilers available  \nfrom  \nat&t, and have subsequently been adopted by other suppliers of c compilers. more  \nrecently, the ansi committee standardizing the language incorporated most of  the \nchanges,  \nand also introduced other significant modifications. their report was in part part icipated \nby  \nsome commercial compilers even before issuance of the formal c standard.   \nthis appendix summarizes the differences between the language defined by the firs t \nedition  \nof this book, and that expected to be defined by the final standard. it treats only the \nlanguage  \nitself, not its environment and library; although these are an important part of the \nstandard,  \nthere is little to compare with, because the first edition did not attempt to pr escribe an  \nenvironment or library.     \n•  \npreprocessing is more carefully defined in the standard than in the first editi on, and is  \nextended: it is explicitly token based; there are new operators for concaten ation of  \ntokens (##), and creation of strings (#); there are new control lines like #el if and  \n#pragma; redeclaration of macros by the same token sequence is explicitly permi tted;  \nparameters inside strings are no longer replaced. splicing of lines by \\ is perm itted  \neverywhere, not just in strings and macro definitions. see par.a.12.  \n•  \nthe minimum significance of all internal identifiers increased to 31 chara cters; the  \nsmallest mandated significance of identifiers with external linkage rema ins 6  \nmonocase letters. (many implementations provide more.)  \n•  \ntrigraph sequences introduced by ?? allow representation of characters la cking in  \nsome character sets. escapes for #\\^[]{}|~ are defined, see par.a.12.1. observe tha t  \nthe introduction of trigraphs may change the meaning of strings containing the  \nsequence ??.  \n•  \nnew keywords (void, const, volatile, signed, enum) are introduced. the  \nstillborn entry keyword is withdrawn.\n\n•   \nnew escape sequences, for use within character constants and string literals, are  \ndefined. the effect of following \\ by a character not part of an approved escape  \nsequence is undefined. see par.a.2.5.2.  \n•  \neveryone''s favorite trivial change: 8 and 9 are not octal digits.  \n•  \nthe standard introduces a larger set of suffixes to make the type of constants expl icit:  \nu or l for integers, f or l for floating. it also refines the rules for the type of uns iffixed  \nconstants (par.a.2.5).  \n•  \nadjacent string literals are concatenated.  \n•  \nthere is a notation for wide-character string literals and character cons tants; see  \npar.a.2.6.  \n•  \ncharacters as well as other types, may be explicitly declared to carry, or not  to carry, a  \nsign by using the keywords signed or unsigned. the locution long float as a  \nsynonym for double is withdrawn, but long double may be used to declare an extra- \nprecision floating quantity.  \n•  \nfor some time, type unsigned char has been available. the standard introduces the  \nsigned keyword to make signedness explicit for char and other integral objects.  \n•  \nthe void type has been available in most implementations for some years. the  \nstandard introduces the use of the void * type as a generic pointer type; previously\n\nchar * played this role. at the same time, explicit rules are enacted against mixing  \npointers and integers, and pointers of different type, without the use of casts.   \n•  \nthe standard places explicit minima on the ranges of the arithmetic types, a nd  \nmandates headers (<limits.h> and <float.h>) giving the characteristics of ea ch  \nparticular implementation.  \n•  \nenumerations are new since the first edition of this book.  \n•  \nthe standard adopts from c++ the notion of type qualifier, for example const  \n(par.a.8.2).  \n•  \nstrings are no longer modifiable, and so may be placed in read-only memory.  \n•  \nthe ``usual arithmetic conversions'''' are changed, essentially from ``for i ntegers,  \nunsigned always wins; for floating point, always use double'''' to ``promote to the  \nsmallest capacious-enough type.'''' see par.a.6.5.  \n•  \nthe old assignment operators like =+ are truly gone. also, assignment operators are   \nnow single tokens; in the first edition, they were pairs, and could be separated by  \nwhite space.  \n•  \na compiler''s license to treat mathematically associative operators  as computationally  \nassociative is revoked.   \n•   \na unary + operator is introduced for symmetry with unary -.  \n•  \na pointer to a function may be used as a function designator without an explicit *  \noperator. see par.a.7.3.2.  \n•  \nstructures may be assigned, passed to functions, and returned by functions.  \n•  \napplying the address-of operator to arrays is permitted, and the result is a pointer t o  \nthe array.  \n•  \nthe sizeof operator, in the first edition, yielded type int; subsequently, many  \nimplementations made it unsigned. the standard makes its type explicitly  \nimplementation-dependent, but requires the type, size_t, to be defined in a standard   \nheader (<stddef.h>). a similar change occurs in the type (ptrdiff_t) of the  \ndifference between pointers. see par.a.7.4.8 and par.a.7.7.  \n•  \nthe address-of operator & may not be applied to an object declared register, even if   \nthe implementation chooses not to keep the object in a register.  \n•\n\nthe type of a shift expression is that of the left operand; the right operand can''t   \npromote the result. see par.a.7.8.  \n•  \nthe standard legalizes the creation of a pointer just beyond the end of an array, and  \nallows arithmetic and relations on it; see par.a.7.7.  \n•  \nthe standard introduces (borrowing from c++) the notion of a function prototype  \ndeclaration that incorporates the types of the parameters, and includes an explicit  \nrecognition of variadic functions together with an approved way of dealing with them.  \nsee pars. a.7.3.2, a.8.6.3, b.7. the older style is still accepted, with restrictions.  \n•  \nempty declarations, which have no declarators and don''t declare at least a str ucture,  \nunion, or enumeration, are forbidden by the standard. on the other hand, a declaration  \nwith just a structure or union tag redeclares that tag even if it was decla red in an outer  \nscope.  \n•  \nexternal data declarations without any specifiers or qualifiers (just a naked de clarator)  \nare forbidden.  \n•  \nsome implementations, when presented with an extern declaration in an inner block,   \nwould export the declaration to the rest of the file. the standard makes it clear t hat the  \nscope of such a declaration is just the block.  \n•  \nthe scope of parameters is injected into a function''s compound statement, so that   \nvariable declarations at the top level of the function cannot hide the parameters .  \n•   \nthe name spaces of identifiers are somewhat different. the standard puts all  tags in a  \nsingle name space, and also introduces a separate name space for labels; see\n\npar.a.11.1. also, member names are associated with the structure or union of which  \nthey are a part. (this has been common practice from some time.)   \n•  \nunions may be initialized; the initializer refers to the first member.   \n•  \nautomatic structures, unions, and arrays may be initialized, albeit in a restri cted way.  \n•  \ncharacter arrays with an explicit size may be initialized by a string lite ral with exactly  \nthat many characters (the \\0 is quietly squeezed out).  \n•  \nthe controlling expression, and the case labels, of a switch may have any integral  \ntype.', 60, 'C Language', 10, '2017-02-08', 'letter', 'L', 'P', 7, 12, 0);
INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(6, 2, 'gg2', '2017-02-08', 1, 0, 0, 9, 0, '1486546467.pdf', 46, 'csir-ugc (net) exam for award of junior research \nfellowship and eligibility for lecturership  \nexam scheme for single paper csir-ugc net in engineering sciences \nthe pattern for the single paper mcq test in engineering sciences shall be as given below:-  \n the  mcq  test  paper  in  engineering  science  shall  carry  a  maximum  of  200  marks. the \nduration of exam shall be three hours.   the question paper shall be divided in three parts \npart ‘a’.  this  part  shall carry  20  questions  of  general  aptitude  (logical  reasoning, \ngraphical  analysis,  analytical  and  numerical  ability,  quantitative  comparisons,  series \nformation,  puzzles,  etc).  candidates  shall  be  required  to  answer  any  15  questions.  each \nquestion shall be of 2 marks. total marks allocated to this section shall be 30 out of 200.  \n---------------------------------------------------------------------------------------------------------------- \npart ‘b’:   this  part  shall  contain  25  questions  related  to  mathematics  and  engineering \naptitude. candidates shall be required to answer any 20 questions. each question shall be of \n3.5 marks. total marks allocated to this section shall be 70 out of 200.  \n---------------------------------------------------------------------------------------------------------------- \npart ‘c’ shall contain subject related questions of the following 7 subject areas :   \n 1.  computer science & information technology \n 2  electrical science \n 3.  electronics \n 4.  materials science \n 5.   fluid mechanics \n 6.   solid mechanics \n 7.  thermodynamics \neach  subject area  will  have  10  questions.  candidates  shall  be  required  to  answer  any  20 \nquestions out of a total of 70 questions.  each question shall be of 5 marks.  the total marks \nallocated to this part shall be 100 out of 200.   \n negative marking for wrong answers shall be @ 25%  \nnb:  the actual number of questions in each part and section to be asked and attempted may \n    vary from exam to exam.\n\nsyllabus  part a  \n \ngeneral  aptitude  with  emphasis  on  logical  reasoning,  graphical  analysis,  analytical  and \nnumerical ability, quantitative comparisons, series formation, puzzles, etc. \n \nsyllabus  part b \n \nmathematics and engineering aptitude \n \nlinear algebra \n \n \n \n \n \ncalculus \n \n \n \n \n \n \n \n \n \ncomplex variables \n \n \nvector calculus \n \n \nordinary differential \nalgebra  of  matrices,  inverse,  rank,  system  of  linear  equations, \nsymmetric,  skew-symmetric  and  orthogonal  matrices.  hermitian, \nskew-hermitian  and  unitary  matrices.  eigenvalues  and \neigenvectors, diagonalisation of matrices. \n \nfunctions  of  single  variable,  limit,  continuity  and  differentiability, \nmean  value  theorems,  indeterminate  forms  and  l''hospital  rule, \nmaxima and minima, taylor&#39;s series, newton’s method for finding \nroots  of  polynomials.    fundamental  and  mean  value-theorems  of \nintegral  calculus.  numerical  integration  by  trapezoidal  and \nsimpson’s  rule.    evaluation  of  definite  and  improper  integrals, \nbeta  and  gamma  functions,  functions  of  two  variables,  limit, \ncontinuity,  partial  derivatives,  euler''s  theorem  for  homogeneous \nfunctions, total derivatives, maxima and minima, lagrange method \nof multipliers, double integrals and their applications, sequence and \nseries,  tests  for  convergence,  power  series,  fourier  series,  half \nrange sine and cosine series.  \n \nanalytic  functions,  cauchy-riemann  equations,  line  integral, \ncauchy''s  integral  theorem  and  integral formula  taylor’s and \nlaurent'' series, residue theorem and its applications.  \n \ngradient,  divergence  and  curl,  vector  identities,  directional \nderivatives,  line,  surface  and  volume  integrals,  stokes,  gauss  and \ngreen''s theorems and their applications. \n \nfirst  order  equation  (linear  and  nonlinear),  second  order  linear \ndifferential  equations  with  variable  coefficients,  variation  of\n\nequations \n \n \n \n  \nprobability \n \nparameters  method,  higher  order  linear  differential  equations  with \nconstant  coefficients,  cauchy-euler''s  equations,  power  series \nsolutions,  legendre  polynomials  and  bessel''s  functions  of  the  first \nkind  and  their  properties.  numerical  solutions  of  first  order \nordinary  differential  equations  by  euler’s  and  runge-kutta \nmethods. \n \ndefinitions  of  probability and  simple  theorems,  conditional \nprobability, bayes theorem. \n \n  \nsolid  body  motion  and \nfluid motion: \n \n \n \nenergetics: \n \n  \nelectron transport: \n \n \n \n \nelectromagnetics: \n \n \n \n  \nmaterials: \n \nparticle  dynamics;  projectiles;  rigid  body  dynamics;  lagrangian \nformulation; eularian  formulation;  bernoulli’s  equation; \ncontinuity equation; surface tension; viscosity; brownian motion. \n \nlaws  of  thermodynamics;  concept  of  free  energy;  enthalpy,  and \nentropy; equation of state; thermodynamics relations. \n \nstructure  of  atoms,  concept of  energy  level,  bond  theory; \ndefinition  of  conduction,  semiconductor  and  insulators;  diode; \nhalf  wave  &  full  wave  rectification;  amplifiers  &  oscillators; \ntruth table. \n \ntheory  of  electric  and  magnetic  potential  &  field;  biot  &  savart’s \nlaw;  theory  of  dipole;  theory  of  oscillation  of  electron; \nmaxwell’s  equations;  transmission  theory;  amplitude  & \nfrequency modulation. \n \nperiodic  table;  properties  of  elements;  reaction  of  materials; \nmetals  and  non-metals  (inorganic  materials),  elementary \nknowledge  of  monomeric  and  polymeric  compounds; \norganometallic  compounds;  crystal  structure  and  symmetry, \nstructure-property correlation-metals, ceramics, and polymers.\n\nsyllabus  part c \n \n \n \n1.   computer science and information technology \n \n \nbasic discrete  mathematics:  counting  principles,  linear  recurrence,  mathematical  induction, \nequation sets, relations and function, predicate and propositional logic. \n \ndigital logic: \nlogic  functions,  minimization,  design  and  synthesis  of  combinational  and  sequential  circuits; \nnumber representation and computer arithmetic (fixed and floating point). \n \ncomputer organization and architecture: \nmachine  instructions  and  addressing  modes,  alu  and  data-path,  cpu  control  design,  memory \ninterface,  i/o  interface  (interrupt  and  dma  mode),  instruction  pipelining,  cache  and  main \nmemory, secondary storage. \n \nprogramming and data structures: \nprogramming  in  c;  functions,  recursion,  parameter  passing,  scope,  binding;  abstract  data \ntypes, arrays, stacks, queues, linked lists, trees, binary search trees, binary heaps. \n \nalgorithms: \nanalysis,  asymptotic  notation,  notions  of  space  and  time  complexity,  worst  and  average  case \nanalysis; design: greedy approach, dynamic programming, divide-and conquer; tree and graph \ntraversals,  connected  components,  spanning  trees,  shortest  paths;  hashing,  sorting,  searching. \nasymptotic  analysis  (best,  worst,  average  cases)  of  time  and  space,  upper  and  lower  bounds, \nbasic concepts of complexity classes p, np, np-hard, np-complete. \n \noperating system: \nprocesses,  threads,  inter-process  communication,  concurrency,  synchronization,  deadlock, \ncpu scheduling, memory management and virtual memory, file systems. \n \ndatabases: \ner-model,  relational  model  (relational  algebra,  tuple  calculus),  database  design  (integrity \nconstraints, normal forms), query languages (sql), file structures (sequential files, indexing, b \nand b+ trees), transactions and concurrency control. \n \ninformation systems and software engineering: \ninformation  gathering,  requirement  and  feasibility  analysis,  data  flow  diagrams,  process \nspecifications, input/output design, process life cycle, planning and managing the project, design, \ncoding, testing, implementation, maintenance.\n\n2.   electrical sciences  \n \n \nelectric circuits and fields: \nnode  and  mesh  analysis,  transient  response  of  dc  and  ac  networks,  sinusoidal  steady-state \nanalysis,  resonance,  basic  filter  concepts,  ideal  current  and  voltage  sources,  thevenin’s,  \nnorton’s  and  superposition  and  maximum  power  transfer  theorems,  two  port  networks,  three \nphase  circuits,  measurement  of  power  in  three  phase  circuits,  gauss  theorem,  electric  field  and \npotential due to point, line, plane and spherical charge distributions, ampere’s and biot-savart’s \nlaws, inductance, dielectrics , capacitance. \n \nelectrical machines:  magnetic circuits \nmagnetic circuits, single phase transformer- equivalent  circuit, phasor diagram,  tests,  regulation \nand  efficiency,  three  phase  transformers- connections,  parallel  operation,  auto-transformer; \nenergy  conversion  principles,  dc  machines- types  ,  starting  and  speed  control  of  dc  motors, \nthree  phase  induction  motors- principles,  types,  performance  characteristics,  starting  and  speed \ncontrol  ,  single  phase  induction  motors,  synchronous  machines  performance,  regulation  and \nparallel  operation of synchronous machine operating as generators, starting and speed control of \nsynchronous motors and its applications, servo and stepper motors. \n \npower systems: \nbasic power generation concepts, transmission line models and performance, cable performance, \ninsulation,  corona  and  radio  interference  ,  distribution  systems,  per-unit  quantities,  bus \nimpedance  and  admittance  matrices,  load  flow,  voltage  and  frequency  control,  power  factor \ncorrection;  unbalanced  analysis,  symmetrical  components,  basic  concepts  of  protection  and \nstability; introduction to hvdc systems. \n \ncontrol systems: \nprinciples of feedback control, transfer function, block diagrams,  steady state errors,  routh  and  \nnyquist techniques, bode plots, root loci, lag , lead and lead-lag compensation; proportional, \npi, pid controllers, state space model , state transition matrix, controllability and observability. \n \npower electronics and drives: \nsemiconductor  power  devices - power  diodes,  power  transistors,  thyristors,  triacs,  gtos, \nmosfets,  igbts – their  characteristics  and  basic triggering  circuits;  diode  rectifiers,  thyristor \nbased  line  commutated  ac  to  dc  converters,  dc  to  dc  converters – buck,  boost,  buck-boost,  c`uk, \nflyback,  forward,  push-pull  converters,  single  phase  and  three  phase  dc  to  ac  inverters  and \nrelated pulse width modulation techniques, stability of electric drives; speed control issues of dc \nmotors, induction motors and synchronous motors. \n \n \n3.   electronics  \n \nanalog circuits and systems: \nelectronic  devices:  characteristics  and  small-signal  equivalent circuits  of diodes,  bjts  and \nmosfets. diode circuits: clipping, clamping and rectifier. biasing and bias stability of bjt and \nfet  amplifiers.  amplifiers:  single-and  multi-stage,  differential  and  operational,  feedback,  and \npower.  frequency  response  of  amplifiers. op-amp  circuits: voltage-to-current  and  current-to-\n\nvoltage converters, active filters, sinusoidal oscillators, wave-shaping circuits, effect  of practical \nparameters  (input  bias  current,  input  offset  voltage,  open  loop  gain,  input  resistance,  cmrr). \nelectronic  measurements:  voltage,  current,  impedance, time,  phase,  frequency  measurements, \noscilloscope. \n \ndigital circuits and systems: \nboolean  algebra  and minimization  of  boolean  functions.  logic gates,  ttl  and  cmos  ic \nfamilies. combinatorial  circuits:  arithmetic  circuits, code  converters, multiplexers and decoders. \nsequential  circuits:  latches  and  flip-flops,  counters  and  shift-registers.  sample-and-hold \ncircuits,adcs,  dacs.  microprocessors  and  microcontrollers:  number  systems, 8085 and  8051 \narchitecture, memory, i/o interfacing, serial and parallel communication. \n \nsignals and systems: \nlinear time invariant systems: impulse response, transfer function and frequency response of \nfirst- and second order systems, convolution. random signals and noise: probability, random \nvariables, probability density function, autocorrelation, power spectral density. sampling \ntheorem, discrete-time systems: impulse and frequency response, iir and fir filters. \n \ncommunications: \namplitude and angle modulation and demodulation, frequency and time division multiplexing. \npulse code modulation, amplitude shift keying, frequency shift keying and pulse shift keying for \ndigital modulation. bandwidth and snr calculations. information theory and channel capacity. \n \n \n4.    materials science  \n \n \nstructure: \natomic  structure  and  bonding  in  materials.  crystal  structure  of  materials,  crystal  systems,  unit \ncells  and  space  lattices,  miller  indices  of  planes  and  directions,  packing  geometry  in  metallic, \nionic  and  covalent  solids.  concept  of  amorphous,  single  and polycrystalline  structures  and  their \neffect  on  properties  of  materials.  imperfections  in  crystalline  solids  and  their  role  in  influencing \nvarious properties.  \n \ndiffusion: fick''s laws and application of diffusion. \n \nmetals and alloys: \nsolid  solutions,  solubility  limit,  phase  rule,  binary  phase  diagrams,  intermediate  phases, \nintermetallic  compounds,  iron-iron  carbide  phase  diagram,  heat  treatment  of  steels,  cold,  hot \nworking  of  metals,  recovery,  recrystallization  and  grain  growth.  microstrcture,  properties  and \napplications of ferrous and non-ferrous alloys. \n \nceramics, polymers, & composites: \nstructure,  properties,  processing  and  applications  of  ceramics. classification,  polymerization, \nstructure  and  properties,  processing  and  applications. properties  and  applications  of  various \ncomposites.\n\nmaterials characterization tools: \nx-ray  diffraction,  optical  microscopy,  scanning  electron  microscopy  and transmission  electron \nmicroscopy, differential thermal analysis, differential scanning calorimetry. \n \nmaterials properties: \nstress-strain  diagrams  of  metallic,  ceramic  and  polymeric  materials,  modulus  of  elasticity,  yield \nstrength,  tensile  strength,  toughness,  elongation,  plastic  deformation,  viscoelasticity,  hardness, \nimpact strength, creep, fatigue, ductile and brittle fracture. \n \nheat  capacity,  thermal  conductivity,  thermal  expansion  of  materials.  concept  of  energy  band \ndiagram  for  materials - conductors,  semiconductors  and  insulators,  intrinsic  and  extrinsic \nsemiconductors,  dielectric  properties. origin  of  magnetism  in  metallic  and  ceramic  materials, \nparamagnetism,  diamagnetism,  antiferro  magnetism,  ferromagnetism,  ferrimagnetism,  magnetic \nhysterisis. \n \nenvironmental degradation: \ncorrosion and oxidation of materials, prevention. \n \n \n5.   fluid mechanics  \n \n \nfluid properties:  \nrelation between stress and strain rate for newtonian fluids; buoyancy, manometry, forces on \nsubmerged bodies.  \n \nkinematics \neulerian and lagrangian description of fluid motion, strain rate and vorticity; concept of local \nand convective accelerations, steady and unsteady flows \n \ncontrol volume based analysis \ncontrol volume analysis for mass, momentum and energy.  \ndifferential equations of mass and momentum (euler equation), bernoulli''s equation and its \napplications, concept of fluid rotation. \n \npotential flow:  \nvorticity, stream function and velocity potential function; elementary flow fields and principles \nof superposition, potential flow past a circular cylinder.  \n \ndimensional analysis:  \nconcept of geometric, kinematic and dynamic similarity, non-dimensional numbers and their \nusage. \n \nviscous flows \nnavier-stokes equations; exact solutions; couette flow, fully-developed pipe flow, \nhydrodynamic lubrication, basic ideas of laminar and turbulent flows, prandtl-mixing length, \nfriction factor, darcy-weisbach relation, simple pipe networks.\n\nboundary layer \nqualitative ideas of boundary layer, boundary layer equation; separation, streamlined and \nbluff bodies, drag and lift forces. \n \nmeasurements \nbasic ideas of flow measurement using venturimeter, pitot-static tube and orifice plate. \n \n \n6.   solid mechanics  \n \n \nequivalent  force  systems;  free-body  diagrams;  equilibrium  equations;  analysis  of  determinate \ntrusses  and  frames;  friction; simple  particle  dynamics; plane  kinematics  and  kinetics;  work-\nenergy and impulse-momentum principles;  \n \nstresses  and  strains;  principal  stresses  and  strains;  mohr''s  circle;  generalized  hooke''s  law; \nthermal strain. \n \naxial,  shear  and  bending  moment  diagrams;  axial,  shear  and  bending  stresses; deflection  of \nbeams (symmetric  bending);  torsion  in  circular  shafts; thin walled  pressure  vessels.  energy \nmethods (catigliano’s theorems) for analysis. \n \ncombined axial, bending and torsional action; theories of failure. \n \nbuckling of columns. \n \nfree vibration of single degree of freedom systems. \n \n \n7. thermodynamics  \n \n \n \nbasic concepts: \ncontinuum, macroscopic approach, thermodynamic system (closed and open or control volume); \nthermodynamic  properties  and  equilibrium;  state  of  a  system,  state  diagram,  path  and  process; \ndifferent modes of work; zeroth law of thermodynamics; concept of temperature; heat. \n \nfirst law of thermodynamics: \nenergy,  enthalpy,  specific  heats,  first  law  applied  to closed systems  and open  systems  (control \nvolumes), steady and unsteady flow analysis. \n \nsecond law of thermodynamics: \nkelvin-planck  and clausius  statements,  reversible  and  irreversible  processes,  carnot  theorems, \nthermodynamic  temperature  scale,  clausius  inequality  and  concept  of  entropy,  principle  of \nincrease  of  entropy, entropy  balance  for  closed  and  open  systems,  exergy  (availability) and \nirreversibility, non-flow and flow exergy.\n\nproperties of pure substances: \nthermodynamic properties of pure substances in solid, liquid and vapor phases, p-v-t behaviour \nof  simple  compressible  substances,  phase  rule,  thermodynamic  property  tables  and  charts,  ideal \nand real gases, equations of state, compressibility chart.  \n \nthermodynamic relations: \nt-ds relations, maxwell equations, joule-thomson coefficient,  coefficient of volume expansion, \nadiabatic and isothermal compressibilities, clapeyron equation. \n \nthermodynamic cycles: \ncarnot  vapour  power  cycle;  simple  rankine  cycle,  reheat and  regenerative  rankine  cycle; air \nstandard cycles: otto cycle, diesel cycle, simple brayton cycle, brayton cycle with regeneration, \nreheat and intercooling; vapour-compression refrigeration cycle. \n \nideal gas mixtures: \ndalton''s  and  amagat''s  laws,  calculations  of  properties (internal  energy,  enthalpy,  entropy),  air-\nwater vapour mixtures and simple thermodynamic processes involving them.', 2, 'er', 10, '2017-02-08', 'letter', 'L', 'M', 7, 4, 0),
(7, 3, 'fgf2', '2017-02-08', 1, 4, 0, 9, 0, '1486551052.pdf', 46, 'csir-ugc (net) exam for award of junior research \nfellowship and eligibility for lecturership  \nexam scheme for single paper csir-ugc net in engineering sciences \nthe pattern for the single paper mcq test in engineering sciences shall be as given below:-  \n the  mcq  test  paper  in  engineering  science  shall  carry  a  maximum  of  200  marks. the \nduration of exam shall be three hours.   the question paper shall be divided in three parts \npart ‘a’.  this  part  shall carry  20  questions  of  general  aptitude  (logical  reasoning, \ngraphical  analysis,  analytical  and  numerical  ability,  quantitative  comparisons,  series \nformation,  puzzles,  etc).  candidates  shall  be  required  to  answer  any  15  questions.  each \nquestion shall be of 2 marks. total marks allocated to this section shall be 30 out of 200.  \n---------------------------------------------------------------------------------------------------------------- \npart ‘b’:   this  part  shall  contain  25  questions  related  to  mathematics  and  engineering \naptitude. candidates shall be required to answer any 20 questions. each question shall be of \n3.5 marks. total marks allocated to this section shall be 70 out of 200.  \n---------------------------------------------------------------------------------------------------------------- \npart ‘c’ shall contain subject related questions of the following 7 subject areas :   \n 1.  computer science & information technology \n 2  electrical science \n 3.  electronics \n 4.  materials science \n 5.   fluid mechanics \n 6.   solid mechanics \n 7.  thermodynamics \neach  subject area  will  have  10  questions.  candidates  shall  be  required  to  answer  any  20 \nquestions out of a total of 70 questions.  each question shall be of 5 marks.  the total marks \nallocated to this part shall be 100 out of 200.   \n negative marking for wrong answers shall be @ 25%  \nnb:  the actual number of questions in each part and section to be asked and attempted may \n    vary from exam to exam.\n\nsyllabus  part a  \n \ngeneral  aptitude  with  emphasis  on  logical  reasoning,  graphical  analysis,  analytical  and \nnumerical ability, quantitative comparisons, series formation, puzzles, etc. \n \nsyllabus  part b \n \nmathematics and engineering aptitude \n \nlinear algebra \n \n \n \n \n \ncalculus \n \n \n \n \n \n \n \n \n \ncomplex variables \n \n \nvector calculus \n \n \nordinary differential \nalgebra  of  matrices,  inverse,  rank,  system  of  linear  equations, \nsymmetric,  skew-symmetric  and  orthogonal  matrices.  hermitian, \nskew-hermitian  and  unitary  matrices.  eigenvalues  and \neigenvectors, diagonalisation of matrices. \n \nfunctions  of  single  variable,  limit,  continuity  and  differentiability, \nmean  value  theorems,  indeterminate  forms  and  l''hospital  rule, \nmaxima and minima, taylor&#39;s series, newton’s method for finding \nroots  of  polynomials.    fundamental  and  mean  value-theorems  of \nintegral  calculus.  numerical  integration  by  trapezoidal  and \nsimpson’s  rule.    evaluation  of  definite  and  improper  integrals, \nbeta  and  gamma  functions,  functions  of  two  variables,  limit, \ncontinuity,  partial  derivatives,  euler''s  theorem  for  homogeneous \nfunctions, total derivatives, maxima and minima, lagrange method \nof multipliers, double integrals and their applications, sequence and \nseries,  tests  for  convergence,  power  series,  fourier  series,  half \nrange sine and cosine series.  \n \nanalytic  functions,  cauchy-riemann  equations,  line  integral, \ncauchy''s  integral  theorem  and  integral formula  taylor’s and \nlaurent'' series, residue theorem and its applications.  \n \ngradient,  divergence  and  curl,  vector  identities,  directional \nderivatives,  line,  surface  and  volume  integrals,  stokes,  gauss  and \ngreen''s theorems and their applications. \n \nfirst  order  equation  (linear  and  nonlinear),  second  order  linear \ndifferential  equations  with  variable  coefficients,  variation  of\n\nequations \n \n \n \n  \nprobability \n \nparameters  method,  higher  order  linear  differential  equations  with \nconstant  coefficients,  cauchy-euler''s  equations,  power  series \nsolutions,  legendre  polynomials  and  bessel''s  functions  of  the  first \nkind  and  their  properties.  numerical  solutions  of  first  order \nordinary  differential  equations  by  euler’s  and  runge-kutta \nmethods. \n \ndefinitions  of  probability and  simple  theorems,  conditional \nprobability, bayes theorem. \n \n  \nsolid  body  motion  and \nfluid motion: \n \n \n \nenergetics: \n \n  \nelectron transport: \n \n \n \n \nelectromagnetics: \n \n \n \n  \nmaterials: \n \nparticle  dynamics;  projectiles;  rigid  body  dynamics;  lagrangian \nformulation; eularian  formulation;  bernoulli’s  equation; \ncontinuity equation; surface tension; viscosity; brownian motion. \n \nlaws  of  thermodynamics;  concept  of  free  energy;  enthalpy,  and \nentropy; equation of state; thermodynamics relations. \n \nstructure  of  atoms,  concept of  energy  level,  bond  theory; \ndefinition  of  conduction,  semiconductor  and  insulators;  diode; \nhalf  wave  &  full  wave  rectification;  amplifiers  &  oscillators; \ntruth table. \n \ntheory  of  electric  and  magnetic  potential  &  field;  biot  &  savart’s \nlaw;  theory  of  dipole;  theory  of  oscillation  of  electron; \nmaxwell’s  equations;  transmission  theory;  amplitude  & \nfrequency modulation. \n \nperiodic  table;  properties  of  elements;  reaction  of  materials; \nmetals  and  non-metals  (inorganic  materials),  elementary \nknowledge  of  monomeric  and  polymeric  compounds; \norganometallic  compounds;  crystal  structure  and  symmetry, \nstructure-property correlation-metals, ceramics, and polymers.\n\nsyllabus  part c \n \n \n \n1.   computer science and information technology \n \n \nbasic discrete  mathematics:  counting  principles,  linear  recurrence,  mathematical  induction, \nequation sets, relations and function, predicate and propositional logic. \n \ndigital logic: \nlogic  functions,  minimization,  design  and  synthesis  of  combinational  and  sequential  circuits; \nnumber representation and computer arithmetic (fixed and floating point). \n \ncomputer organization and architecture: \nmachine  instructions  and  addressing  modes,  alu  and  data-path,  cpu  control  design,  memory \ninterface,  i/o  interface  (interrupt  and  dma  mode),  instruction  pipelining,  cache  and  main \nmemory, secondary storage. \n \nprogramming and data structures: \nprogramming  in  c;  functions,  recursion,  parameter  passing,  scope,  binding;  abstract  data \ntypes, arrays, stacks, queues, linked lists, trees, binary search trees, binary heaps. \n \nalgorithms: \nanalysis,  asymptotic  notation,  notions  of  space  and  time  complexity,  worst  and  average  case \nanalysis; design: greedy approach, dynamic programming, divide-and conquer; tree and graph \ntraversals,  connected  components,  spanning  trees,  shortest  paths;  hashing,  sorting,  searching. \nasymptotic  analysis  (best,  worst,  average  cases)  of  time  and  space,  upper  and  lower  bounds, \nbasic concepts of complexity classes p, np, np-hard, np-complete. \n \noperating system: \nprocesses,  threads,  inter-process  communication,  concurrency,  synchronization,  deadlock, \ncpu scheduling, memory management and virtual memory, file systems. \n \ndatabases: \ner-model,  relational  model  (relational  algebra,  tuple  calculus),  database  design  (integrity \nconstraints, normal forms), query languages (sql), file structures (sequential files, indexing, b \nand b+ trees), transactions and concurrency control. \n \ninformation systems and software engineering: \ninformation  gathering,  requirement  and  feasibility  analysis,  data  flow  diagrams,  process \nspecifications, input/output design, process life cycle, planning and managing the project, design, \ncoding, testing, implementation, maintenance.\n\n2.   electrical sciences  \n \n \nelectric circuits and fields: \nnode  and  mesh  analysis,  transient  response  of  dc  and  ac  networks,  sinusoidal  steady-state \nanalysis,  resonance,  basic  filter  concepts,  ideal  current  and  voltage  sources,  thevenin’s,  \nnorton’s  and  superposition  and  maximum  power  transfer  theorems,  two  port  networks,  three \nphase  circuits,  measurement  of  power  in  three  phase  circuits,  gauss  theorem,  electric  field  and \npotential due to point, line, plane and spherical charge distributions, ampere’s and biot-savart’s \nlaws, inductance, dielectrics , capacitance. \n \nelectrical machines:  magnetic circuits \nmagnetic circuits, single phase transformer- equivalent  circuit, phasor diagram,  tests,  regulation \nand  efficiency,  three  phase  transformers- connections,  parallel  operation,  auto-transformer; \nenergy  conversion  principles,  dc  machines- types  ,  starting  and  speed  control  of  dc  motors, \nthree  phase  induction  motors- principles,  types,  performance  characteristics,  starting  and  speed \ncontrol  ,  single  phase  induction  motors,  synchronous  machines  performance,  regulation  and \nparallel  operation of synchronous machine operating as generators, starting and speed control of \nsynchronous motors and its applications, servo and stepper motors. \n \npower systems: \nbasic power generation concepts, transmission line models and performance, cable performance, \ninsulation,  corona  and  radio  interference  ,  distribution  systems,  per-unit  quantities,  bus \nimpedance  and  admittance  matrices,  load  flow,  voltage  and  frequency  control,  power  factor \ncorrection;  unbalanced  analysis,  symmetrical  components,  basic  concepts  of  protection  and \nstability; introduction to hvdc systems. \n \ncontrol systems: \nprinciples of feedback control, transfer function, block diagrams,  steady state errors,  routh  and  \nnyquist techniques, bode plots, root loci, lag , lead and lead-lag compensation; proportional, \npi, pid controllers, state space model , state transition matrix, controllability and observability. \n \npower electronics and drives: \nsemiconductor  power  devices - power  diodes,  power  transistors,  thyristors,  triacs,  gtos, \nmosfets,  igbts – their  characteristics  and  basic triggering  circuits;  diode  rectifiers,  thyristor \nbased  line  commutated  ac  to  dc  converters,  dc  to  dc  converters – buck,  boost,  buck-boost,  c`uk, \nflyback,  forward,  push-pull  converters,  single  phase  and  three  phase  dc  to  ac  inverters  and \nrelated pulse width modulation techniques, stability of electric drives; speed control issues of dc \nmotors, induction motors and synchronous motors. \n \n \n3.   electronics  \n \nanalog circuits and systems: \nelectronic  devices:  characteristics  and  small-signal  equivalent circuits  of diodes,  bjts  and \nmosfets. diode circuits: clipping, clamping and rectifier. biasing and bias stability of bjt and \nfet  amplifiers.  amplifiers:  single-and  multi-stage,  differential  and  operational,  feedback,  and \npower.  frequency  response  of  amplifiers. op-amp  circuits: voltage-to-current  and  current-to-\n\nvoltage converters, active filters, sinusoidal oscillators, wave-shaping circuits, effect  of practical \nparameters  (input  bias  current,  input  offset  voltage,  open  loop  gain,  input  resistance,  cmrr). \nelectronic  measurements:  voltage,  current,  impedance, time,  phase,  frequency  measurements, \noscilloscope. \n \ndigital circuits and systems: \nboolean  algebra  and minimization  of  boolean  functions.  logic gates,  ttl  and  cmos  ic \nfamilies. combinatorial  circuits:  arithmetic  circuits, code  converters, multiplexers and decoders. \nsequential  circuits:  latches  and  flip-flops,  counters  and  shift-registers.  sample-and-hold \ncircuits,adcs,  dacs.  microprocessors  and  microcontrollers:  number  systems, 8085 and  8051 \narchitecture, memory, i/o interfacing, serial and parallel communication. \n \nsignals and systems: \nlinear time invariant systems: impulse response, transfer function and frequency response of \nfirst- and second order systems, convolution. random signals and noise: probability, random \nvariables, probability density function, autocorrelation, power spectral density. sampling \ntheorem, discrete-time systems: impulse and frequency response, iir and fir filters. \n \ncommunications: \namplitude and angle modulation and demodulation, frequency and time division multiplexing. \npulse code modulation, amplitude shift keying, frequency shift keying and pulse shift keying for \ndigital modulation. bandwidth and snr calculations. information theory and channel capacity. \n \n \n4.    materials science  \n \n \nstructure: \natomic  structure  and  bonding  in  materials.  crystal  structure  of  materials,  crystal  systems,  unit \ncells  and  space  lattices,  miller  indices  of  planes  and  directions,  packing  geometry  in  metallic, \nionic  and  covalent  solids.  concept  of  amorphous,  single  and polycrystalline  structures  and  their \neffect  on  properties  of  materials.  imperfections  in  crystalline  solids  and  their  role  in  influencing \nvarious properties.  \n \ndiffusion: fick''s laws and application of diffusion. \n \nmetals and alloys: \nsolid  solutions,  solubility  limit,  phase  rule,  binary  phase  diagrams,  intermediate  phases, \nintermetallic  compounds,  iron-iron  carbide  phase  diagram,  heat  treatment  of  steels,  cold,  hot \nworking  of  metals,  recovery,  recrystallization  and  grain  growth.  microstrcture,  properties  and \napplications of ferrous and non-ferrous alloys. \n \nceramics, polymers, & composites: \nstructure,  properties,  processing  and  applications  of  ceramics. classification,  polymerization, \nstructure  and  properties,  processing  and  applications. properties  and  applications  of  various \ncomposites.\n\nmaterials characterization tools: \nx-ray  diffraction,  optical  microscopy,  scanning  electron  microscopy  and transmission  electron \nmicroscopy, differential thermal analysis, differential scanning calorimetry. \n \nmaterials properties: \nstress-strain  diagrams  of  metallic,  ceramic  and  polymeric  materials,  modulus  of  elasticity,  yield \nstrength,  tensile  strength,  toughness,  elongation,  plastic  deformation,  viscoelasticity,  hardness, \nimpact strength, creep, fatigue, ductile and brittle fracture. \n \nheat  capacity,  thermal  conductivity,  thermal  expansion  of  materials.  concept  of  energy  band \ndiagram  for  materials - conductors,  semiconductors  and  insulators,  intrinsic  and  extrinsic \nsemiconductors,  dielectric  properties. origin  of  magnetism  in  metallic  and  ceramic  materials, \nparamagnetism,  diamagnetism,  antiferro  magnetism,  ferromagnetism,  ferrimagnetism,  magnetic \nhysterisis. \n \nenvironmental degradation: \ncorrosion and oxidation of materials, prevention. \n \n \n5.   fluid mechanics  \n \n \nfluid properties:  \nrelation between stress and strain rate for newtonian fluids; buoyancy, manometry, forces on \nsubmerged bodies.  \n \nkinematics \neulerian and lagrangian description of fluid motion, strain rate and vorticity; concept of local \nand convective accelerations, steady and unsteady flows \n \ncontrol volume based analysis \ncontrol volume analysis for mass, momentum and energy.  \ndifferential equations of mass and momentum (euler equation), bernoulli''s equation and its \napplications, concept of fluid rotation. \n \npotential flow:  \nvorticity, stream function and velocity potential function; elementary flow fields and principles \nof superposition, potential flow past a circular cylinder.  \n \ndimensional analysis:  \nconcept of geometric, kinematic and dynamic similarity, non-dimensional numbers and their \nusage. \n \nviscous flows \nnavier-stokes equations; exact solutions; couette flow, fully-developed pipe flow, \nhydrodynamic lubrication, basic ideas of laminar and turbulent flows, prandtl-mixing length, \nfriction factor, darcy-weisbach relation, simple pipe networks.\n\nboundary layer \nqualitative ideas of boundary layer, boundary layer equation; separation, streamlined and \nbluff bodies, drag and lift forces. \n \nmeasurements \nbasic ideas of flow measurement using venturimeter, pitot-static tube and orifice plate. \n \n \n6.   solid mechanics  \n \n \nequivalent  force  systems;  free-body  diagrams;  equilibrium  equations;  analysis  of  determinate \ntrusses  and  frames;  friction; simple  particle  dynamics; plane  kinematics  and  kinetics;  work-\nenergy and impulse-momentum principles;  \n \nstresses  and  strains;  principal  stresses  and  strains;  mohr''s  circle;  generalized  hooke''s  law; \nthermal strain. \n \naxial,  shear  and  bending  moment  diagrams;  axial,  shear  and  bending  stresses; deflection  of \nbeams (symmetric  bending);  torsion  in  circular  shafts; thin walled  pressure  vessels.  energy \nmethods (catigliano’s theorems) for analysis. \n \ncombined axial, bending and torsional action; theories of failure. \n \nbuckling of columns. \n \nfree vibration of single degree of freedom systems. \n \n \n7. thermodynamics  \n \n \n \nbasic concepts: \ncontinuum, macroscopic approach, thermodynamic system (closed and open or control volume); \nthermodynamic  properties  and  equilibrium;  state  of  a  system,  state  diagram,  path  and  process; \ndifferent modes of work; zeroth law of thermodynamics; concept of temperature; heat. \n \nfirst law of thermodynamics: \nenergy,  enthalpy,  specific  heats,  first  law  applied  to closed systems  and open  systems  (control \nvolumes), steady and unsteady flow analysis. \n \nsecond law of thermodynamics: \nkelvin-planck  and clausius  statements,  reversible  and  irreversible  processes,  carnot  theorems, \nthermodynamic  temperature  scale,  clausius  inequality  and  concept  of  entropy,  principle  of \nincrease  of  entropy, entropy  balance  for  closed  and  open  systems,  exergy  (availability) and \nirreversibility, non-flow and flow exergy.\n\nproperties of pure substances: \nthermodynamic properties of pure substances in solid, liquid and vapor phases, p-v-t behaviour \nof  simple  compressible  substances,  phase  rule,  thermodynamic  property  tables  and  charts,  ideal \nand real gases, equations of state, compressibility chart.  \n \nthermodynamic relations: \nt-ds relations, maxwell equations, joule-thomson coefficient,  coefficient of volume expansion, \nadiabatic and isothermal compressibilities, clapeyron equation. \n \nthermodynamic cycles: \ncarnot  vapour  power  cycle;  simple  rankine  cycle,  reheat and  regenerative  rankine  cycle; air \nstandard cycles: otto cycle, diesel cycle, simple brayton cycle, brayton cycle with regeneration, \nreheat and intercooling; vapour-compression refrigeration cycle. \n \nideal gas mixtures: \ndalton''s  and  amagat''s  laws,  calculations  of  properties (internal  energy,  enthalpy,  entropy),  air-\nwater vapour mixtures and simple thermodynamic processes involving them.', 4, 'w', 3, '2017-02-08', 'letter', 'L', 'P', 60, 4, 0);
INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(8, 1, '987', '2017-02-08', 2, 3, 0, 20, 0, '1486551523.pdf', 91, 'replacethislewith prentcsmacro.sty foryour meeting,\nor with entcsmacro.sty foryour meeting. bothcanbe\nfound atthe entcs macrohomepage .\nan example pap er\nmy name 1\n;2\nmy department\nmy university\nmy city, mycountry\nmy co-author 3\nmy co-author''s department\nmy co-author''s university\nmy co-author''s city,myco-author''s country\nabstract thisisashort example tosho wthe basics ofusing theentcs style macro les.\nample examples ofhowles should look ma ybe found among thepublished volumes\nof the series atthe entcs homepage http://www.elsevier.nl/ locate/ entcs.\nkey words: please listkeyw ords from your paperhere, separated\nb y commas.\n1 intro duction\nthis short noteprovides aguide tousing theentcs macropackage for\npreparing papers forpublication inyour conference proce edings .the pro-\nc eedings maybe prin ted and hard copies distributed toparticipan tsat the\nmeeting; thisisan option toconference organizersmaycho ose toexercise.\nthe proceedings alsowillbe par ofavolume inthe series electronic notes\nin the oretic alcomputer science(entcs), whichis published undertheaus-\npices ofelsevier scienceb.v., the publishers ofthe oretic alcomputer science.\nit''s home pageishttp://www.elsevier.nl/loc ate/entcs\nthe entcs macropackage consists oftw o les:\nentcs.cls ,the basic style le, and\n1\nthanks toevery one who should be thank ed\n2 email: myuserid@mydept. myins t.mye du\n3 email: couserid@codept. coins t.coe du\nc\n\r 2003 published by elsevier scienceb.v.\n\npleaselistyour lastname here\nentcsmacro.sty ,amacro lecontaining thedenitions ofsome ofthe theorem-\nlik een vironmen tsand afew other tidbits.\nthe formatting thesestyle les imposeshould notbe altered {the reason for\nusing themisto attain auniform formatforallpap ersinthe proceedings of\nwhic hyour paperisapart.\nadditional macrolescanbe added using\\usepackage{...} .the le\nentcsmacro.sty mustbe included inthe list, asisdone atthe start ofthe\nsource leforthis paper.\nthe entcs package requires arelativ elyup-to-date la\nt ex\nsystem inorder\nto be successfully used.thisisre\rected intw o other packages thatarecalled\nb y en tcs.cls, whichmust be available onyour machine. these are:\n the hyperref package. this package allowsthe use ofhyp erlinks inles\nprepared usingla\nt e x2e,\noneofthe main features ofadob e''sacrobat c\n\r\nreader software. besure that you have at least version 6.69dofthis pack-\nage.\n the ifpdf package. this isused by hyp erref todieren tiatebet ween the\nuse ofpdfl a\nt ex\nand la\nt e x2e,\nfollowed by dvips andthen ps2pdf.\nthe leinstraut.dvi contains information about theuse ofla\nt e xto\npre-\npare lesforonline publication by elsevier. thislerefers tothe older version\nof la\nt e x\nthat isno longer suppported, andthat isinadequate forpreparing\n.pdf lesforonline publication. readingthisleshould answermost ofthe\nbasic questions about la\nt ex\nthat mightarise.\n2 fron tmatter\nthe biggest dierence bet ween a\\usual" la\nt ex\nstyle suchas article.sty\nand theentcs package isthat theentcs macropackage requires thetitle,\nauthor''s nameornames, abstract, keyw ords and	hanks" alltobe included\nwithin thefrontmatter environmen t.at the beginning ofthe source lefor\nthis paper,you''ll notice this.also, you''ll notice thattheusual \\maketitle\nis absen t;itno longer isneeded. theentcs style package automatically\ngenerates thetitle, author''s nameandaddress, andrelated material atthe\nb eginning ofthe paper.note alsothat hyp erref hasbeen disabled inthis part\nof the entcs.cls le,soreferences tofootnotes aren''tlinkedtothe appropriate\nfo otenotes oraddresses. thisisan old problem withla\nt e x,\ninvolving thefact\nthat thereferences withinthefron tmatter aren''tpassed cleanly tothe linking\nsoft ware.\nf or those whohave used theentcs package before, theone new thing\nto note isthe inclusion ofkeywor ds;these arenow required by elsevier {\nthey''re alsorequired by acm''s computing reviews whichreviews entcs\npublications.\nthe entcs macropackage provides tw o alternativ esto listing authors\nnames andaddresses. thesearedescrib edindetail inthe leinstraut.dvi .\n2\n\npleaselistyour lastname here\nbasically ,listing eachauthor andhisorher address inturn, isthe simplest\nmetho d.but, ifthere areseveral authors andtw o or more share thesame\naddress (butnotallauthors areatthis address), thenthemetho dof listing\nauthors rst,andthen theaddresses, andofreferencing addressestoauthors\nshould be used.\nalso, notice thatackno wledgmen tof supp ort(the contentsof 	hanks )\nshould be done by aseparate listingof	hanks[nsf]{to thensf} withthe\noptional argument{ [nsf] {being used for	hanksref whichis attac hedto\nthose authors ackno wledging suchsupp ort.itisimp ortan tthat the	hanks\nnot be included withinthescop eof \\author{} orof	itle{} ,but itmust\nb e within thescop eof the environmen tfrontmatter .\nmore details about added termssuchas \\collab canbe found ininst.dvi ,\nif they areneeded.\nalso, notice thatthecommand \\lastname{my lastname}hasbeen in-\ncluded befor ethe frontmatter begins. thiscommand shouldcontain the\nlast names ofthe authors ofthe paper. ifthere arenomore thanthree au-\nthors, thentheyshould be listed withtheword \\and" bet ween thelast tw o;\nif more thanthree authors collaborated onthe paper,then therst author\nonly should be listed, together with\\emph{et al}.this command creates\nthe headline foreachpage after page1.\nfinally ,please be sure toinclude anabstract foryour paper.\n3 sectioning andenvironmen ts\nsince entcs ispublished throughtheauspices ofelsevier scienceb.v., their\nst yle les have been used tocreate theentcs macropackage. here''s apro of\nthat thispackage isnot muc hdieren tthan most ofthe ones oneencoun ters:\ndenition 3.1ale isderive dfrom another ifit isobtained withonlyafew\nmo dications fromtheoriginal le.\ntheorem 3.2the leentcs.cls isderive dfrom elsart.sty .\npro of.this isclear fromthesimilarit yof the output tothe output from\nelsevier''s style les. 2\nif one wan ts to start apro ofwith adescriptiv eword, suchas \\sk etch",\nthen onecanusethe\\begin{proof*}...\\end{pro of*}environmen t,as in\npro of(sk etch) this canbe deriv edfrom simple observations. 2\nthe main dierences bet ween theleentcs.cls andtheelsartr.cls le\nused by elsevier arethe more precise formatwe use {elsevier''s genericlesare\nmean tfor preliminary editing,andmore precise formatting isimp osed using\na macro ledesigned forthe specic elsevier journalinwhic hthe paperwill\nev en tually appear. theentcs.cls andentcsmacro.sty lesformat papers\n3\n\npleaselistyour lastname here\nuniformly sothat they allare easily recognizable asbeing from theseries\nele ctronic notes inthe oretic alcomputer science.\nall ofthe usual features ofla\nt e x\nare available withthese style les {\nit is only theformatting thathasbeen rigorously dened.thus, one has\na vailable thesectioning commands \\section,\\subsection, \\paragraphand\n\\subparagraph. thenum bering scheme usedisone under whichtheorem\n1.2.3 isthe third num bered item insecond subsection ofthe rst section of\nthe pap er.inorder tofacilitate cross-references, allofthe named environmen ts\ngiv en belo ware num bered, andalluse thesame num ber scheme.\nthe leentcsmacro.sty contains additional information thatisneeded to\nt yp eset apap er.italso hasthedenitions ofthe ams eulerandblackboard\nbold fontsbuiltin. ifyou wan tto use symbols forthe natural num bers, the\nreals, etc.,then we prefer thatyou use the blackboard bold fonts, and not\nplain bold fonts. this isaccomplished by using the\\mathbb font,as innor\nr .\nthe names oftheorem-lik een vironmen tsare provided inentcsmacro.sty .\nwith theexception ofthe environmen talgorithm, thenames ofall ofthese\nare full name, rather thanashortened version. theenvironmen tspro vided\nand their names are\n \\begin{theorem} ...\\end{theorem} fortheorems,\n \\begin{lemma} ...\\end{lemma} forlemmas,\n \\begin{corollary} ...\\end{corollary} forcorollaries,\n \\begin{proposition} ...\\end{proposition} forprop ositions,\n \\begin{criterion} ...\\end{criterion} forcriteria,\n \\begin{alg} ...\\end{alg} foralgorithms,\n \\begin{definition} ...\\end{definition} fordenitions,\n \\begin{conjecture} ...\\end{conjecture} forconjectures,\n \\begin{example} ...\\end{example} forexamples,\n \\begin{problem} ...\\end{problem} forproblems,\n \\begin{remark} ...\\end{remark} forremarks,\n \\begin{note} ...\\end{note} fornotes,\n \\begin{claim} ...\\end{claim} forclaims,\n \\begin{summary} ...\\end{summary} forsummary ,\n \\begin{case} ...\\end{case} forcases, and\n \\begin{ack} ...\\end{ack} forackno wledgemen ts.\nf or example,\n4\n\npleaselistyour lastname here\nalgorithm 1step 1:write thepap er\nstep 2:format itwith theentcs macropackage\nstep 3:ship thewhole thingtothe guest editors\n4 references andcross-references\nall the cross-referencing facilitiesofla\nt e x\nare supp orted, soone can use\n\ref{} and\\cite{} forcross-references withinthepaperand forreferences\nto bibliographic items.asisdone inthis note, thereferences section6can\nb e comp osed with \\begin{thebibliography}... \\end{thebibliograph y}.\nalternativ ely,bibt\nex\ncan be used tocompile thebibliograph y. whic hever\none isused, thereferences aretobe num bered consecutiv ely,rather thanby\nauthor-dened acronyms. ofcourse you can useyour own acron ymsforeasy\nreference toeac hof the items inthe bibliograph y, as has been done withthe\nlisting forthis short note.\nho wev er, note thatthereferences shouldnotbe started withanew \\section\ncommand.\nthe package hyperref isautomatically loadedby en tcs.cls, andthis makes\nall the cross-references withinthedocumen t\\activ e"when thepdf le ofthe\npap erisview edwith adobe''sacrobat c\n\r\nreader. theformat forincluding\na link issimple: simplyinsert\\href{url} {text}whereurlisthe url\nto whic hyou wan tthe link topoin t,and text isthe text you wan tto be\nhighligh ted,whichwhen clicked upon will bring upthe desired web page.\n4.1 particulars about .pdf les\nw eno w require that.pdf lesbe pro vided forpublication online.a.pdf\nle isview able by adob e''sacrobat c\n\r\nview er,whic hcan be congured toload\nautomatically withinabro wser. viewing aprop erlyformatted .pdflewith\nacrobat c\n\r\nallo wsthe cross-references andlinks tourls tobe activ e.in fact,\nelsevier utilizes.pdflesinorder totak ebetter advantage ofthe web''s ca-\npabilities.\nbut onepoin tw e wan tto emphasize isthat you should be sure touse typ e\n1 fon tswhen you typ eset your la\nt ex\nsource le.these fontsare scalable,\nmeaning thatthey carry information thatallowsthe devise viewing thenal\noutput toscale thefontsto suit theview erbeing used {from anonscreen\nview ersuc has adob e''sacrobat c\n\r\nreader, toprin ting theleonaprin ter.\ny ou can tellifyou have used therightfon tsby viewing thenal output on\ny our machine. itthe fontslook grain y, then you have not used typ e1 fon ts.\nthey canbe lo cated atthe ctan archiv ehttp://www.ctan.org {they are\npublic domain fonts, and don''t costanything toadd them toyour system.\nassuming you have typ e1 fon tsavailable, thenthere arethere metho ds\nfor producing .pdfles.\n5\n\npleaselistyour lastname here\nusing dvipsandps2pdf\nw elist this option rstsince itapp ears tobe the most reliable andthe\neasiest touse, especially ifyou include embedded postscript graphics(.eps\nles) inyour source le.simply runla\nt e x2e\nonyour source le,then apply\ndvips topro duce apostscript le,and nally applyps2pdf toobtain a.pdf\nle. the dvipdfm utility\nanother easymetho dfor producing acceptable .pdflesisvia the utilit y\ndvipdfm .this utilityis included indistributions ofmikt\nex,\nwhic hruns\non windo wsmac hines, butitprobably needstobe added toyour tet\nex\ndistribution, ifyou are running la\nt e x\non aunix machine. theutilit yand\nprecise information about installing iton your system canbe found atthe\nw eb page http://gaspra.kettering. edu/dvi pdfm/. in essence, thisutilit y\ncon verts a.dvi leinto a.pdf le.so,one canrst prepare the.dvi le\nusing la\nt e x,\nand then apply theutilit ydvipdfm topro duce theneeded .pdf\nle. 4\nthis utilitymak esinclusion ofgraphics particularly simple{those that\nare included inthe la\nt ex\nsource leare simply converted tothe .pdf format.\nas we note belo w, things arenot sosimple withthesecond alternativ e,whic h\nis to use pdfl a\nt e x.\np dfl a\nt e x\nan alternativ eto the rst possibilities topro duce .pdf lesisto pro cess\nthe source lewith pdfl a\nt ex.\nthis format isavailable fromthestandard\nct an sites http://www.ctan.org .it app ears that pdfl a\nt ex\nand hyperref\nha ve some problems whenusedtogether. itisnecessary touse pdfl a\nt ex\nv ersion 14dorlater inorder tominimize theseissues. ifyour system has\nan earlier version (mosttet\nex\ndistributions have version 13d),thenyou\ncan update your system by retrieving thelatest version ofpdfl a\nt e x\nfrom\nftp://ftp.cstug.cz/pub/tex/ local/c stug/thanh/pdft ex/.even ifthe\nrecen tversions areused, pdfl a\nt e x\nhas thesame dealing withreferences em-\nb edded withthefrontmatter sectiondescribedabov e for la\nt\ne x.\nbut there isone aspect ofpdfl a\nt ex\nthat creates problems. manyauthors\ninclude eps5\nles within theirpapers. while thisisfairly straigh tforward\nwith la\nt e x,\nthere areacouple ofpoin tsto note when attempting thiswith\np dfl a\nt e x.\nt o include apostscript imageina.pdf leproduced withpdfl a\nt ex,\ny ou rst have to con vert the image toa.pdf le,and then itcan be in-\ncluded usingthesame command sequenceasabov e. the conversion canbe\n4\nbewar e! the utilit ydvipdf does not produce acceptable .pdfles,andshould notbe\nused. onlydvipdfm shouldbe used topro duce .pdf les.\n5 eps stands forembedde dpostscript ,whic haords amec hanism forincluding pre-\nprepared postscript leswithin ala\nt\nex\ndocumen t.\n6\n\npleaselistyour lastname here\naccomplished mosteasily usingghostscript; you can simply viewthelein\nghostview andthen printthe image toa.pdf leusing thepdfwriter option\nwithin ghostview. theresult forastandard chess board thatispart ofthe\nghostview distribution isthe follo wing image:\nhereaswell isacop yof acolor image. whilepdfl a\nt ex\ncan handle imageles\nin other formats, la\nt ex\ncan only handle .epsimages reliably.\nitalso should be noted thatwe ha ve included tw o separate sourcelesfor\nthis example le{one forla\nt e x\nand oneforpdfl a\nt ex\n{because we wan t\n7\n\npleaselistyour lastname here\nto illustrate how to insert graphics imagesinto the le. ifyour paperdoes\nnot include suchimages, thenthesame source lecan be formatted by either\nl a\nt ex\norf by pdfl a\nt e x.\nusing entcs macroswithmacosx\nof course, ifyour ledoesn''t require .epsorother postscript les,then\ny ou can create therequired .pdfleusing anyof the standard t\nex\nimple-\nmen tations forthe macin tosh. ifyou need toinclude postscript les,andif\ny ou are using t\ne xshop,\nthenyou can specify touse dvips andghostview in\npro cessing your le, and then you can apply ps2pdf tocreate theneeded .pdf\nle. alternatib ely,the mac osxoperating systemisbased onunix, soit\nsupp ortstheuse oftet\nex\nas describ edabov e.\n5 summary\nthe entcs macropackage isrelativ elyeasy touse and provides auniform\nla yout forallthe papersthat appear inentcs.\nproblem 5.1finish yourpap er and getitto your progr am chairman on\ntime!\nwhen you have nished preparing your paper,send acop yof the sour ce le ,\ntogether withanymacro lesthat areneeded toyour program chairman. if\nthe les areextensiv e,you can place copies inthe pub/incoming sub-directory\nof the ftpdirectory onthe mac hine indicated by your program chairman using\nanon ymous ftp.ifyou dothis, please sendmeemail toalert methat thele(s)\nare here.\nassigning volume /issue numbers\none additional poin tworth mentioning isthat entcs ismo ving tosci-\nencedirect, elsevier''smainplatform forpublishing electronicseries,because\nsciencedirect must publish entire volumes atthe same time, we ha ve changed\nthe procedure forpreparing nalversions sothat volume num bers will not\nb e assigned until the nal versions areready .guest editors willnow have\nto receiv ethe nal version ofall pap ersintheir proceedings before avolume\nand issue num ber will be assigned forthe proceedings .ev en with themove to\nsciencedirect, thereference scheme already usedforpublications inentcs {\nhttp://www.elsevier/nl/loca te/entc s/nnnn.html remainsthevalid way\nto cite paperspublished inentcs, wherenndenotes thenum ber ofthe vol-\nume, andnndenotes theissue num ber. publications consistingofan entire\nv olume should use1as the issue num ber.\ncop yrigh ttransfer forms\none result ofthe move to sciencedirect isthat thecorresp onding author\nof eac hpap erpublished inentcs must submit asigned copyrigh ttransfer\n8\n\npleaselistyour lastname here\nf orm toelsevier inorder fortheir paperto be published. acop yof this form\nwill be sen tto eac hauthor by the guest editors ofeac hvolume. detailsabout\nthis agreemen tsp ecifying therightsof the authors andtherightsof elsevier\nare available atelsevier''s authorgateway .\npublication offinal versions\nbecause sciencedirect cannoteasilyaccommo datechanges topublished\nmaterial, theproceedings inits entiret ymust be ready before itcan be pub-\nlished. thisisone reason whythe volume andissue num ber isnot assigned\nun til the nal versions ofall pap ershave been sentto the guest editors for\nnal processing.\n6 bibliographical references\nentcs employsthe plain style ofbibliographic referencesinwhic hreferences\nare listed inalphab eticalorder, according thetherst author''s lastname, and\nare sequen tiallynum bered. please utilizethisstyle. weha ve a bibt\nex\nstyle\nle, forthose whowish touse it.itisthe leentcs.bst whichis included in\nthis package. thebasic ruleswe ha ve emplo yed are the follo wing:\n authors'' namesshould be listed inalphab eticalorder, withtherst author''s\nlast name being therst listing, followed by the author''s initialsorrst\nname, andwith theother authors nameslistedasrst name, lastname .\n titles ofarticles injournals shouldbe in emphasize dtyp e.\n titles ofbooks, monographs, etc.should be in quotations.\n journal namesshould be in plain roman typ e.\n journal volume num bers should be in boldface typ e,with theyear ofpub-\nlication immediately following inroman typ e,and enclosed inparen theses.\n references tourls onthe netshould be \\activ e"and theurl itselfshould\nb e in typ ewriter font.\n articles shouldinclude pagenum bers.\nthe criteria areillustrated inthe follo wing.\nreferences [1] civin, p., and b.yood, involutions onbanach algebras,pacic j.math. 9\n(1959), 415{436.\n[2] cliord, a.h., and g.b.preston, \\thealgebraic theoryofsemigroups,"\nmath. surveys7, amer. math.soc., pro vidence, r.i.,1961.\n[3] freyd, peter, peter o''hearn, johnpow er, rob ert tennen tand makoto\nt ak eyama, bire\re ctivity ,electronic notesintheoretical computerscience1\n(1995), url:http://www.elsevier.nl/loc ate/entcs/v olume1.html .\n9\n\npleaselistyour lastname here\n[4] easdo wn,d.,and w.d.munn, trac efunctions oninverse semigroupalgebr as,\nu. ofglasgo w,dept. ofmath., preprint93/52.\n[5] rosco e,a. w., \\the theory andpractice ofconcurrency ,"pren ticehall series\nin computer science,prentice hall publishers, london,newyork (1198),\n565pp. withassociated web site\nhttp://www.comlab.ox.ac. uk/oucl/pub lications/b ooks/concur rency/.\n[6] shehadah, a.a., \\em bedding theorems forsemigroups withinvolution, \\ph.d.\nthesis, purdue university, indiana, 1982.\n[7] weyl, h.,\\the classical groups," 2nded., princeton u.press, princeton, n.j.,\n1946.\n10\n\nreplacethislewith prentcsmacro.sty foryour meeting,\nor with entcsmacro.sty foryour meeting. bothcanbe\nfound atthe entcs macrohomepage .\nan example pap er\nmy name 1\n;2\nmy department\nmy university\nmy city, mycountry\nmy co-author 3\nmy co-author''s department\nmy co-author''s university\nmy co-author''s city,myco-author''s country\nabstract thisisashort example tosho wthe basics ofusing theentcs style macro les.\nample examples ofhowles should look ma ybe found among thepublished volumes\nof the series atthe entcs homepage http://www.elsevier.nl/ locate/ entcs.\nkey words: please listkeyw ords from your paperhere, separated\nb y commas.\n1 intro duction\nthis short noteprovides aguide tousing theentcs macropackage for\npreparing papers forpublication inyour conference proce edings .the pro-\nc eedings maybe prin ted and hard copies distributed toparticipan tsat the\nmeeting; thisisan option toconference organizersmaycho ose toexercise.\nthe proceedings alsowillbe par ofavolume inthe series electronic notes\nin the oretic alcomputer science(entcs), whichis published undertheaus-\npices ofelsevier scienceb.v., the publishers ofthe oretic alcomputer science.\nit''s home pageishttp://www.elsevier.nl/loc ate/entcs\nthe entcs macropackage consists oftw o les:\nentcs.cls ,the basic style le, and\n1\nthanks toevery one who should be thank ed\n2 email: myuserid@mydept. myins t.mye du\n3 email: couserid@codept. coins t.coe du\nc\n\r 2003 published by elsevier scienceb.v.\n\npleaselistyour lastname here\nentcsmacro.sty ,amacro lecontaining thedenitions ofsome ofthe theorem-\nlik een vironmen tsand afew other tidbits.\nthe formatting thesestyle les imposeshould notbe altered {the reason for\nusing themisto attain auniform formatforallpap ersinthe proceedings of\nwhic hyour paperisapart.\nadditional macrolescanbe added using\\usepackage{...} .the le\nentcsmacro.sty mustbe included inthe list, asisdone atthe start ofthe\nsource leforthis paper.\nthe entcs package requires arelativ elyup-to-date la\nt ex\nsystem inorder\nto be successfully used.thisisre\rected intw o other packages thatarecalled\nb y en tcs.cls, whichmust be available onyour machine. these are:\n the hyperref package. this package allowsthe use ofhyp erlinks inles\nprepared usingla\nt e x2e,\noneofthe main features ofadob e''sacrobat c\n\r\nreader software. besure that you have at least version 6.69dofthis pack-\nage.\n the ifpdf package. this isused by hyp erref todieren tiatebet ween the\nuse ofpdfl a\nt ex\nand la\nt e x2e,\nfollowed by dvips andthen ps2pdf.\nthe leinstraut.dvi contains information about theuse ofla\nt e xto\npre-\npare lesforonline publication by elsevier. thislerefers tothe older version\nof la\nt e x\nthat isno longer suppported, andthat isinadequate forpreparing\n.pdf lesforonline publication. readingthisleshould answermost ofthe\nbasic questions about la\nt ex\nthat mightarise.\n2 fron tmatter\nthe biggest dierence bet ween a\\usual" la\nt ex\nstyle suchas article.sty\nand theentcs package isthat theentcs macropackage requires thetitle,\nauthor''s nameornames, abstract, keyw ords and	hanks" alltobe included\nwithin thefrontmatter environmen t.at the beginning ofthe source lefor\nthis paper,you''ll notice this.also, you''ll notice thattheusual \\maketitle\nis absen t;itno longer isneeded. theentcs style package automatically\ngenerates thetitle, author''s nameandaddress, andrelated material atthe\nb eginning ofthe paper.note alsothat hyp erref hasbeen disabled inthis part\nof the entcs.cls le,soreferences tofootnotes aren''tlinkedtothe appropriate\nfo otenotes oraddresses. thisisan old problem withla\nt e x,\ninvolving thefact\nthat thereferences withinthefron tmatter aren''tpassed cleanly tothe linking\nsoft ware.\nf or those whohave used theentcs package before, theone new thing\nto note isthe inclusion ofkeywor ds;these arenow required by elsevier {\nthey''re alsorequired by acm''s computing reviews whichreviews entcs\npublications.\nthe entcs macropackage provides tw o alternativ esto listing authors\nnames andaddresses. thesearedescrib edindetail inthe leinstraut.dvi .\n2\n\npleaselistyour lastname here\nbasically ,listing eachauthor andhisorher address inturn, isthe simplest\nmetho d.but, ifthere areseveral authors andtw o or more share thesame\naddress (butnotallauthors areatthis address), thenthemetho dof listing\nauthors rst,andthen theaddresses, andofreferencing addressestoauthors\nshould be used.\nalso, notice thatackno wledgmen tof supp ort(the contentsof 	hanks )\nshould be done by aseparate listingof	hanks[nsf]{to thensf} withthe\noptional argument{ [nsf] {being used for	hanksref whichis attac hedto\nthose authors ackno wledging suchsupp ort.itisimp ortan tthat the	hanks\nnot be included withinthescop eof \\author{} orof	itle{} ,but itmust\nb e within thescop eof the environmen tfrontmatter .\nmore details about added termssuchas \\collab canbe found ininst.dvi ,\nif they areneeded.\nalso, notice thatthecommand \\lastname{my lastname}hasbeen in-\ncluded befor ethe frontmatter begins. thiscommand shouldcontain the\nlast names ofthe authors ofthe paper. ifthere arenomore thanthree au-\nthors, thentheyshould be listed withtheword \\and" bet ween thelast tw o;\nif more thanthree authors collaborated onthe paper,then therst author\nonly should be listed, together with\\emph{et al}.this command creates\nthe headline foreachpage after page1.\nfinally ,please be sure toinclude anabstract foryour paper.\n3 sectioning andenvironmen ts\nsince entcs ispublished throughtheauspices ofelsevier scienceb.v., their\nst yle les have been used tocreate theentcs macropackage. here''s apro of\nthat thispackage isnot muc hdieren tthan most ofthe ones oneencoun ters:\ndenition 3.1ale isderive dfrom another ifit isobtained withonlyafew\nmo dications fromtheoriginal le.\ntheorem 3.2the leentcs.cls isderive dfrom elsart.sty .\npro of.this isclear fromthesimilarit yof the output tothe output from\nelsevier''s style les. 2\nif one wan ts to start apro ofwith adescriptiv eword, suchas \\sk etch",\nthen onecanusethe\\begin{proof*}...\\end{pro of*}environmen t,as in\npro of(sk etch) this canbe deriv edfrom simple observations. 2\nthe main dierences bet ween theleentcs.cls andtheelsartr.cls le\nused by elsevier arethe more precise formatwe use {elsevier''s genericlesare\nmean tfor preliminary editing,andmore precise formatting isimp osed using\na macro ledesigned forthe specic elsevier journalinwhic hthe paperwill\nev en tually appear. theentcs.cls andentcsmacro.sty lesformat papers\n3\n\npleaselistyour lastname here\nuniformly sothat they allare easily recognizable asbeing from theseries\nele ctronic notes inthe oretic alcomputer science.\nall ofthe usual features ofla\nt e x\nare available withthese style les {\nit is only theformatting thathasbeen rigorously dened.thus, one has\na vailable thesectioning commands \\section,\\subsection, \\paragraphand\n\\subparagraph. thenum bering scheme usedisone under whichtheorem\n1.2.3 isthe third num bered item insecond subsection ofthe rst section of\nthe pap er.inorder tofacilitate cross-references, allofthe named environmen ts\ngiv en belo ware num bered, andalluse thesame num ber scheme.\nthe leentcsmacro.sty contains additional information thatisneeded to\nt yp eset apap er.italso hasthedenitions ofthe ams eulerandblackboard\nbold fontsbuiltin. ifyou wan tto use symbols forthe natural num bers, the\nreals, etc.,then we prefer thatyou use the blackboard bold fonts, and not\nplain bold fonts. this isaccomplished by using the\\mathbb font,as innor\nr .\nthe names oftheorem-lik een vironmen tsare provided inentcsmacro.sty .\nwith theexception ofthe environmen talgorithm, thenames ofall ofthese\nare full name, rather thanashortened version. theenvironmen tspro vided\nand their names are\n \\begin{theorem} ...\\end{theorem} fortheorems,\n \\begin{lemma} ...\\end{lemma} forlemmas,\n \\begin{corollary} ...\\end{corollary} forcorollaries,\n \\begin{proposition} ...\\end{proposition} forprop ositions,\n \\begin{criterion} ...\\end{criterion} forcriteria,\n \\begin{alg} ...\\end{alg} foralgorithms,\n \\begin{definition} ...\\end{definition} fordenitions,\n \\begin{conjecture} ...\\end{conjecture} forconjectures,\n \\begin{example} ...\\end{example} forexamples,\n \\begin{problem} ...\\end{problem} forproblems,\n \\begin{remark} ...\\end{remark} forremarks,\n \\begin{note} ...\\end{note} fornotes,\n \\begin{claim} ...\\end{claim} forclaims,\n \\begin{summary} ...\\end{summary} forsummary ,\n \\begin{case} ...\\end{case} forcases, and\n \\begin{ack} ...\\end{ack} forackno wledgemen ts.\nf or example,\n4\n\npleaselistyour lastname here\nalgorithm 1step 1:write thepap er\nstep 2:format itwith theentcs macropackage\nstep 3:ship thewhole thingtothe guest editors\n4 references andcross-references\nall the cross-referencing facilitiesofla\nt e x\nare supp orted, soone can use\n\ref{} and\\cite{} forcross-references withinthepaperand forreferences\nto bibliographic items.asisdone inthis note, thereferences section6can\nb e comp osed with \\begin{thebibliography}... \\end{thebibliograph y}.\nalternativ ely,bibt\nex\ncan be used tocompile thebibliograph y. whic hever\none isused, thereferences aretobe num bered consecutiv ely,rather thanby\nauthor-dened acronyms. ofcourse you can useyour own acron ymsforeasy\nreference toeac hof the items inthe bibliograph y, as has been done withthe\nlisting forthis short note.\nho wev er, note thatthereferences shouldnotbe started withanew \\section\ncommand.\nthe package hyperref isautomatically loadedby en tcs.cls, andthis makes\nall the cross-references withinthedocumen t\\activ e"when thepdf le ofthe\npap erisview edwith adobe''sacrobat c\n\r\nreader. theformat forincluding\na link issimple: simplyinsert\\href{url} {text}whereurlisthe url\nto whic hyou wan tthe link topoin t,and text isthe text you wan tto be\nhighligh ted,whichwhen clicked upon will bring upthe desired web page.\n4.1 particulars about .pdf les\nw eno w require that.pdf lesbe pro vided forpublication online.a.pdf\nle isview able by adob e''sacrobat c\n\r\nview er,whic hcan be congured toload\nautomatically withinabro wser. viewing aprop erlyformatted .pdflewith\nacrobat c\n\r\nallo wsthe cross-references andlinks tourls tobe activ e.in fact,\nelsevier utilizes.pdflesinorder totak ebetter advantage ofthe web''s ca-\npabilities.\nbut onepoin tw e wan tto emphasize isthat you should be sure touse typ e\n1 fon tswhen you typ eset your la\nt ex\nsource le.these fontsare scalable,\nmeaning thatthey carry information thatallowsthe devise viewing thenal\noutput toscale thefontsto suit theview erbeing used {from anonscreen\nview ersuc has adob e''sacrobat c\n\r\nreader, toprin ting theleonaprin ter.\ny ou can tellifyou have used therightfon tsby viewing thenal output on\ny our machine. itthe fontslook grain y, then you have not used typ e1 fon ts.\nthey canbe lo cated atthe ctan archiv ehttp://www.ctan.org {they are\npublic domain fonts, and don''t costanything toadd them toyour system.\nassuming you have typ e1 fon tsavailable, thenthere arethere metho ds\nfor producing .pdfles.\n5\n\npleaselistyour lastname here\nusing dvipsandps2pdf\nw elist this option rstsince itapp ears tobe the most reliable andthe\neasiest touse, especially ifyou include embedded postscript graphics(.eps\nles) inyour source le.simply runla\nt e x2e\nonyour source le,then apply\ndvips topro duce apostscript le,and nally applyps2pdf toobtain a.pdf\nle. the dvipdfm utility\nanother easymetho dfor producing acceptable .pdflesisvia the utilit y\ndvipdfm .this utilityis included indistributions ofmikt\nex,\nwhic hruns\non windo wsmac hines, butitprobably needstobe added toyour tet\nex\ndistribution, ifyou are running la\nt e x\non aunix machine. theutilit yand\nprecise information about installing iton your system canbe found atthe\nw eb page http://gaspra.kettering. edu/dvi pdfm/. in essence, thisutilit y\ncon verts a.dvi leinto a.pdf le.so,one canrst prepare the.dvi le\nusing la\nt e x,\nand then apply theutilit ydvipdfm topro duce theneeded .pdf\nle. 4\nthis utilitymak esinclusion ofgraphics particularly simple{those that\nare included inthe la\nt ex\nsource leare simply converted tothe .pdf format.\nas we note belo w, things arenot sosimple withthesecond alternativ e,whic h\nis to use pdfl a\nt e x.\np dfl a\nt e x\nan alternativ eto the rst possibilities topro duce .pdf lesisto pro cess\nthe source lewith pdfl a\nt ex.\nthis format isavailable fromthestandard\nct an sites http://www.ctan.org .it app ears that pdfl a\nt ex\nand hyperref\nha ve some problems whenusedtogether. itisnecessary touse pdfl a\nt ex\nv ersion 14dorlater inorder tominimize theseissues. ifyour system has\nan earlier version (mosttet\nex\ndistributions have version 13d),thenyou\ncan update your system by retrieving thelatest version ofpdfl a\nt e x\nfrom\nftp://ftp.cstug.cz/pub/tex/ local/c stug/thanh/pdft ex/.even ifthe\nrecen tversions areused, pdfl a\nt e x\nhas thesame dealing withreferences em-\nb edded withthefrontmatter sectiondescribedabov e for la\nt\ne x.\nbut there isone aspect ofpdfl a\nt ex\nthat creates problems. manyauthors\ninclude eps5\nles within theirpapers. while thisisfairly straigh tforward\nwith la\nt e x,\nthere areacouple ofpoin tsto note when attempting thiswith\np dfl a\nt e x.\nt o include apostscript imageina.pdf leproduced withpdfl a\nt ex,\ny ou rst have to con vert the image toa.pdf le,and then itcan be in-\ncluded usingthesame command sequenceasabov e. the conversion canbe\n4\nbewar e! the utilit ydvipdf does not produce acceptable .pdfles,andshould notbe\nused. onlydvipdfm shouldbe used topro duce .pdf les.\n5 eps stands forembedde dpostscript ,whic haords amec hanism forincluding pre-\nprepared postscript leswithin ala\nt\nex\ndocumen t.\n6\n\npleaselistyour lastname here\naccomplished mosteasily usingghostscript; you can simply viewthelein\nghostview andthen printthe image toa.pdf leusing thepdfwriter option\nwithin ghostview. theresult forastandard chess board thatispart ofthe\nghostview distribution isthe follo wing image:\nhereaswell isacop yof acolor image. whilepdfl a\nt ex\ncan handle imageles\nin other formats, la\nt ex\ncan only handle .epsimages reliably.\nitalso should be noted thatwe ha ve included tw o separate sourcelesfor\nthis example le{one forla\nt e x\nand oneforpdfl a\nt ex\n{because we wan t\n7\n\npleaselistyour lastname here\nto illustrate how to insert graphics imagesinto the le. ifyour paperdoes\nnot include suchimages, thenthesame source lecan be formatted by either\nl a\nt ex\norf by pdfl a\nt e x.\nusing entcs macroswithmacosx\nof course, ifyour ledoesn''t require .epsorother postscript les,then\ny ou can create therequired .pdfleusing anyof the standard t\nex\nimple-\nmen tations forthe macin tosh. ifyou need toinclude postscript les,andif\ny ou are using t\ne xshop,\nthenyou can specify touse dvips andghostview in\npro cessing your le, and then you can apply ps2pdf tocreate theneeded .pdf\nle. alternatib ely,the mac osxoperating systemisbased onunix, soit\nsupp ortstheuse oftet\nex\nas describ edabov e.\n5 summary\nthe entcs macropackage isrelativ elyeasy touse and provides auniform\nla yout forallthe papersthat appear inentcs.\nproblem 5.1finish yourpap er and getitto your progr am chairman on\ntime!\nwhen you have nished preparing your paper,send acop yof the sour ce le ,\ntogether withanymacro lesthat areneeded toyour program chairman. if\nthe les areextensiv e,you can place copies inthe pub/incoming sub-directory\nof the ftpdirectory onthe mac hine indicated by your program chairman using\nanon ymous ftp.ifyou dothis, please sendmeemail toalert methat thele(s)\nare here.\nassigning volume /issue numbers\none additional poin tworth mentioning isthat entcs ismo ving tosci-\nencedirect, elsevier''smainplatform forpublishing electronicseries,because\nsciencedirect must publish entire volumes atthe same time, we ha ve changed\nthe procedure forpreparing nalversions sothat volume num bers will not\nb e assigned until the nal versions areready .guest editors willnow have\nto receiv ethe nal version ofall pap ersintheir proceedings before avolume\nand issue num ber will be assigned forthe proceedings .ev en with themove to\nsciencedirect, thereference scheme already usedforpublications inentcs {\nhttp://www.elsevier/nl/loca te/entc s/nnnn.html remainsthevalid way\nto cite paperspublished inentcs, wherenndenotes thenum ber ofthe vol-\nume, andnndenotes theissue num ber. publications consistingofan entire\nv olume should use1as the issue num ber.\ncop yrigh ttransfer forms\none result ofthe move to sciencedirect isthat thecorresp onding author\nof eac hpap erpublished inentcs must submit asigned copyrigh ttransfer\n8\n\npleaselistyour lastname here\nf orm toelsevier inorder fortheir paperto be published. acop yof this form\nwill be sen tto eac hauthor by the guest editors ofeac hvolume. detailsabout\nthis agreemen tsp ecifying therightsof the authors andtherightsof elsevier\nare available atelsevier''s authorgateway .\npublication offinal versions\nbecause sciencedirect cannoteasilyaccommo datechanges topublished\nmaterial, theproceedings inits entiret ymust be ready before itcan be pub-\nlished. thisisone reason whythe volume andissue num ber isnot assigned\nun til the nal versions ofall pap ershave been sentto the guest editors for\nnal processing.\n6 bibliographical references\nentcs employsthe plain style ofbibliographic referencesinwhic hreferences\nare listed inalphab eticalorder, according thetherst author''s lastname, and\nare sequen tiallynum bered. please utilizethisstyle. weha ve a bibt\nex\nstyle\nle, forthose whowish touse it.itisthe leentcs.bst whichis included in\nthis package. thebasic ruleswe ha ve emplo yed are the follo wing:\n authors'' namesshould be listed inalphab eticalorder, withtherst author''s\nlast name being therst listing, followed by the author''s initialsorrst\nname, andwith theother authors nameslistedasrst name, lastname .\n titles ofarticles injournals shouldbe in emphasize dtyp e.\n titles ofbooks, monographs, etc.should be in quotations.\n journal namesshould be in plain roman typ e.\n journal volume num bers should be in boldface typ e,with theyear ofpub-\nlication immediately following inroman typ e,and enclosed inparen theses.\n references tourls onthe netshould be \\activ e"and theurl itselfshould\nb e in typ ewriter font.\n articles shouldinclude pagenum bers.\nthe criteria areillustrated inthe follo wing.\nreferences [1] civin, p., and b.yood, involutions onbanach algebras,pacic j.math. 9\n(1959), 415{436.\n[2] cliord, a.h., and g.b.preston, \\thealgebraic theoryofsemigroups,"\nmath. surveys7, amer. math.soc., pro vidence, r.i.,1961.\n[3] freyd, peter, peter o''hearn, johnpow er, rob ert tennen tand makoto\nt ak eyama, bire\re ctivity ,electronic notesintheoretical computerscience1\n(1995), url:http://www.elsevier.nl/loc ate/entcs/v olume1.html .\n9\n\npleaselistyour lastname here\n[4] easdo wn,d.,and w.d.munn, trac efunctions oninverse semigroupalgebr as,\nu. ofglasgo w,dept. ofmath., preprint93/52.\n[5] rosco e,a. w., \\the theory andpractice ofconcurrency ,"pren ticehall series\nin computer science,prentice hall publishers, london,newyork (1198),\n565pp. withassociated web site\nhttp://www.comlab.ox.ac. uk/oucl/pub lications/b ooks/concur rency/.\n[6] shehadah, a.a., \\em bedding theorems forsemigroups withinvolution, \\ph.d.\nthesis, purdue university, indiana, 1982.\n[7] weyl, h.,\\the classical groups," 2nded., princeton u.press, princeton, n.j.,\n1946.\n10', 36, 'kolkata', 10, '2017-02-08', 'letter', 'L', 'M', 7, 7, 0);
INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(9, 1, '111', '2017-02-05', 1, 5, 0, 142, 0, '1486551561.pdf', 6, '\nhigher secondary - first year\nprepared as per recommendation of the\ntextbook development committee, this new textbook is\nprepared according to the syllabus published in 2003-04.\na publication under government of\ntamilnadu distribution of\nfree textbook programme\n(not for sale)\nuntouchability is a sin\nuntouchability is a crime\nuntouchability is inhuman\n	\n\r\ncollege road, chennai -  600 006.\n©  government of tamilnadu\nfirst edition - 2007\nchairperson\ndr. c. thiruvenkadam\nreader in history,\npachaiyappa’s college,\nchennai - 600 030.\nreviewer\ndr. k.vijaya\nlecturer in history, (selection grade)\nquaid-e-milleth govt. college for women\nchennai - 600 002.\nauthors\ntmt.\n m.muthumari\nthiru\n v. zafar ahmed\np.g. asst. (history) p.g. asst. headmaster (history)\nperum thalivar kamarajar govt.the muslim hr. sec.school\ngirls higher secondary shcool,triplicane,\nambattur, chennai - 600 053. chennai - 600 005.\nprice : rs.this book has been prepared by the directorate of school education\non behalf of the government of tamil nadu.\nthis book has been printed on 60 gsm paper\n\npreface\nin the curriculum of schools, the subject history forms part\nof the social science up to tenth standard. at that level the main\ntrends and developments in the history of india have been introduced\nto the pupils. when they reach the higher secondary stage, a\nsystematic study of history is required in order to understand the\ncultural heritage of india, to inherit secular values and to develop a\npositive outlook on the future.\ntherefore, this book intends to provide the political, social,\neconomic and cultural aspects of indian history. it is written as per\nthe syllabus prescribed for standard xi. it covers both ancient and\nmedieval india up to the coming of the europeans.\nwhile providing historical facts, much care has been taken\nand standard historical works written by eminent historians have been\nconsulted. latest historical information has also been included in the\nlessons.\nin the process of learning, the pupils will also be benefited by\nthe maps and figures, which illustrate the political geography and\ncultural greatness of our country.\nthe model questions provided at the end of each chapter are\nbased on the public examination question paper pattern. questions\non the same model will be asked in the examination and therefore,\nthe pupils must read the entire text to answer such questions.\ni am thankful to the members of the committee for their\ncooperation in bringing out this book.\nc. thiruvenkadam\nchairperson\nxi history\nforeword\nacademics, parents and the educational media have represented\nto the government of tamil nadu, to reform the plus one and plus two\ntext books, which were introduced in the academic year 2005-06. our\nbeloved chief minister, who has always been evincing keen interest in\neducational development, immediately constituted a “text book\ndevelopment committee” under the chairmanship of the vice-chairman,\nstate planning commission, government of tamil nadu.\nthe text book development committee solicited opinion from\nlecturers and professors from higher secondary schools, colleges and\nuniversities, chairpersons and authors of text books. after perusing the\nopinions, the text book development committee, decided not to change\nths syllabi, but recommended suitable changes in the text books.\nin particular, it was proposed to rewrite the history text book, and\naccepting this proposal, this text book is rewritten by experienced and\nefficient teachers.\nwe are pleased to place on record our sincere gratitude to our\nbeloved chief minister. our thanks are due to hon’ble minister for school\neducation, secretary and director, department of school education,\ngovernment of tamil nadu for their valuable support and suggestions.\nwe thank, lecturers and professors from higher secondary\nschools, colleges and universities, chairpersons and authors of text\nbooks, non-teaching staff of edcuation department and state planning\ncommission for their help at various stages in this endeavor.\nwe wish the students to learn and perform well in the examinations.\nprof. \nm. naganathan\nchairman\ntext book development committee\ngovernment of tamil nadu\niiiiv\n\nstandard xi - history\nsyllabus\nperiods\nunit i\n1. the impact of geography on indian history -\nunity in diversity 5\n2. the stone age - the old stone age\n(paleolithic age) - new stone age\n(neolithic age) - metal age - salient features\nof harappan culture. 5\n3. vedic period - sources - early vedic period\n(rig vedic period) - later vedic period -\nepic age - social, economic and cultural life 5\nunit ii\n4. condition of india in the 6th century b.c.\n- magadhan empire and other kindgoms. 5\n5. rise of jainism - mahavira - principles of jainism -\ndigambaras and swedambaras - spread of jainism -\ncontributions. 5\n6. rise of buddhism - buddha - principles of\nbuddhism - hinayana and mahayana sects -\nspread of buddhism - contributions. the\nsimilarities and dissimilarities of these two religions. 5\nunit iii\n7. india of the pre-mauryan period - nandas -\npersian invasion - alexander’s invasion - results. 58. the mauryan period - sources - chandragupta\nmaurya - asoka - mauryan administration -\nasoka’s dharma - development of art and\narchitecture - decline of mauryas. 10\nunit iv\n9. india after the mauryas - the sungas - kanvas -\nsatavahanas kushnas - kanishka - gandhara art. 10\n10.  sangam age in tamil nadu - sources - brief\nhistory of kingdoms - social, religious and\neconomic life of the people. 5\nunit v\n11. india of gupta period - administration -\nsocial, economic and cultural conditions - hun\ninvasions and decline of the guptas. 10\n12. harshavardhana - sources - social, religious\nand cultural life. 5\nunit vi\n13. south indian empires 15\na. pallavas - sources - administration - social, economic and\n    cultural conditions.\nb. chalukyas - development of arts.\nc. rashtrakutas - contribution to arts.\nd. cholas - social, economic and cultural conditions.\n14. the cultural relations between india and the\nasian countries 5\nvvi\n\ncontents\nindian history\nsub.pageno. no.\n1. india - geographical features and their 1\nimpact on history\n2. pre-historic india and the harappan culture 11\n3. the vedic culture 27\n4. jainism and buddhism 37\n5. the rise of magadha and alexander’s invasion 47\n6. the mauryan empire 59\n7. post - mauryan india 74\n8. sangam age 85\n9. gupta empire 96\n10. harshavardhana (606 - 647 a.d) 113\n11. south indian kingdoms - i\npallavas 122\n12. south indian kingdoms - ii\nchalukyas and rashtrakutas 132\n13. imperial cholas 141\n14. the spread of indian culture in\nother asian countries 154\n15. early medieval india 163\n16. delhi sultanate 172\n17. india under the delhi sultanate 190\n18. bhakti movement in medieval india 200\n19. vijayanagar and bahmani kingdoms 209\n20. the mughal empire 221\n21. india under the mughals 239\n22. the marathas 249\n23. the coming of europeans 258\nunit vii\n15. indian during arab invasions - rajput kingdoms -\narab invasions-mahmud of ghazni-muthammad of ghor. 10\n16. delhi sultans - mameluk, khilji, tughluq, sayyid and\nlodi dynasties. 20\n17.  social, economic and cultural conditions under\nthe sultanate of delhi\nunit viii\n18. bhakti movement in medieaval india - ramananda,\nkabir - vallabhacharya - chaitanya - gurunanak -\nmeerabai - sufism 10\n19. vijayanagar and bahmani kingdoms - social,\neconomic and cultural conditions. 10\nunit ix\n20. mughal empire - brief history of mughal, sur\ndynasty rulers. 15\n21. mughal administration - emperor - central\ngovernment officials - provincial governments -\nofficials - duties - decline of the mughals.\n22. social, economics, religious and cultural conditions\nunder the mughals. 10\nunit x\n23. rise of marathas - administration of shivaji -\npeshwas. 10\n24. coming of the europeans to india - establishment of\nbritish rule in india 10\nviiviii\n\n1\nlesson 1\nindia- geographical features\nand their impact on history\nit is generally said that history has two eyes – one is\nchronology and the other is geography. in other words time and\nspace are significant factors in determining the historical process. in\nparticular, a country’s geography largely determines its historical\nevents. the history of india is also influenced by its geography.\nhence, the study of indian geographical features contributes to the\nbetter understanding of its history.\nthe indian subcontinent is a well-defined geographical unit.\nit may be divided into three major regions: the himalayan mountains,\nthe indo-gangetic plains and the southern peninsula. there are\nfive countries in the subcontinent – india, pakistan, bangladesh,\nnepal and bhutan. india is the largest among them and it comprises\ntwenty-eight states and six union territories. according to the 2001\ncensus, the population of india is over one hundred crores.\nlearning objectivesstudents will acquire knowledge about\n1. the geographical features of india.\n2. the himalayan mountains and their impact on indian\nhistory.\n3. the gangetic plains and their role in indian history.\n4. the southern peninsula and its effects on south indian\nhistory.\n5. india’s unity in diversity\n\n3 2\nthe valley of kashmir is surrounded by high mountains. however,\nit could be reached through several passes. the kashmir valley\nremains unique for its tradition and culture. nepal is also a small\nvalley under the foot of the himalayas and it is accessible from\ngangetic plains through a number of passes.\nin the east, the himalayas extend up to assam. the important\nmountains in this region are pat koi, nagai and lushai ranges. these\nhills are covered with thick forests due to heavy rains and mostly\nremain inhospitable. the mountains of northeast india is difficult to\ncross and many parts of this region had remained in relative isolation.\nthe indo-gangetic plain\nthe indo-gangetic plain is irrigated by three important rivers,\nthe ganges, indus and brahmaputra. this vast plain is most fertile\nand productive because of the alluvial soil brought by the streams\nof the rivers and its tributaries.\nthe indus river rises beyond the himalayas and its major\ntributaries are the jhelum, chenab, ravi, sutlej and beas. the punjab\nplains are benefited by the indus river system. the literal meaning of\nthe term ‘punjab’ is the land of five rivers. sind is situated at the lower\nvalley of the indus. the indus plain is known for its fertile soil.\nthe thar desert and aravalli hills are situated in between the\nindus and gangetic plains. mount abu is the highest point (5650 ft.) in\nthe aravalli hills. the ganges river rises in the himalayas, flows south\nand then towards the east. the river\nyamuna flows almost parallel to the\nganges and then joins it. the area\nbetween these two rivers is called doab\n– meaning the land between two rivers.\nthe important tributaries of the ganges\nare the gomati, sarayu, ghagra and\ngandak.\nthar desert \nthe himalayan mountains\nthe himalayan mountains are situated on the north of india.\nstarting from the pamir in the extreme northwest of india, the mighty\nhimalayan range extends towards northeast. it has a length of nearly\n2560 kilometres with an average breadth of 240 to 320 kilometres.\nthe highest peak of the himalayas is known as mount everest with\nits height being 8869 metres. it acts as a natural wall and protects\nthe country against the cold arctic winds blowing from siberia through\ncentral asia. this keeps the climate of northern india fairly warm\nthroughout the year. the himalayan region is mostly inhospitable in\nwinter and generally covered with snow.\nit was considered for a long time that the himalayas stood as\na natural barrier to protect india against invasions. but, the passes\nin the northwest mountains such as the khyber, bolan, kurram and\ngomal provided easy routes between india and central asia. these\npasses are situated in the hindukush, sulaiman and kirthar ranges.\nfrom prehistoric times, there was a continuous flow of traffic through\nthese passes. many people came to india through these passes as\ninvaders and immigrants. the indo-aryans, the indo-greeks,\nparthians, sakas, kushanas, hunas and turks entered india through\nthese passes. the swat valley in this region formed another\nimportant route. alexander of macedon came to india through this\nroute. apart from invading armies, missionaries and merchants came\nto india using these routes. therefore, these passes in the northwest\nmountains had facilitated trade as well as cultural contacts between\nindia and the central asia.\nin the north of kashmir is karakoram range. the second\nhighest peak in the world, mount godwin austen is situated here.\nthis part of the himalayas and its passes are high and snow-covered\nin the winter. the karakoram highway via gilgit is connected to\ncentral asia but there was little communication through this route.\n\n5 4\nto cut into, we find a number of rock-cut monasteries and temples\nin the deccan.\nthe deccan plateau is flanked by the eastern ghats and\nwestern ghats. the coramandal coast stands between the eastern\nghats and the bay of bengal. the western ghats runs along the\narabian sea and the lands between these are known as konkan up\nto goa and beyond that as kanara. the southernmost part is known\nas malabar coast. the passes in the western ghats like junnar,\nkanheri and karle linked the trade routes to the western ports. the\ndeccan plateau acted as a bridge between the north and south india.\nhowever, the dense forests in the vindhya mountains makes this\nregion isolated from the north. the language and culture in the\nsouthern peninsula are preserved in tact for a long time due to this\ngeographical isolation.\nin the southern end remains the famous palghat pass. it is the\npassage across the ghats from the kaveri valley to the malabar\ncoast. the palghat pass was an important trade route for the indo-\nroman trade in the ancient times. the anaimudi is the highest peak\nin the southern peninsula. doddapetta is another highest peak in the\nwestern ghats. the eastern ghats are not very high and have several\nopenings caused by the eastward flow of the rivers into the bay of\nbengal. the port cities of arikkamedu, mamallapuram and\nkaveripattanam were situated on the coramandal coast.\nthe major rivers of the southern peninsula are almost running\nparallel. mahanadhi is at the eastern end of the peninsula. narmadha\nand tapti run from east to west. other rivers like the godavari,\nkrishna, tungabhadra and kaveri flow from west to east. these\nrivers make the plateau into a fertile rice producing soil. throughout\nhistory, the region between krishna and tungabhadra (raichur\ndoab) remained a bone of contention between the major kingdoms\nof the south. the deltaic plains formed by these two rivers at their in the east of india, the ganges plain merges into the plains of\nbrahmaputra. the river brahmaputra rises beyond the himalayas, flows\nacross tibet and then continues through the plains of northeast india. in\nthe plains, it is a vast but a slow-moving river forming several islands.\nthe indo-gangetic plain has contributed to the rise of urban\ncentres, particularly on the river banks or at the confluence of rivers.\nthe harappan culture flourished in the indus valley. the vedic culture\nprospered in the western gangetic plain. banares, allahabad, agra,\ndelhi and pataliputra are some of the important cities of the gangetic\nplain. the city of pataliputra was situated at the confluence of son\nriver with the ganges. in the ancient period pataliputra had remained\nthe capital for the mauryas, sungas, guptas and other kingdoms.\nthe most important city on the western side of the gangetic plain\nis delhi. most of the decisive battles of indian history such as the\nkurukshetra, tarain and panipat were fought near delhi. also, this\nplain had always been a source of temptation and attraction for the\nforeign invaders due to its fertility and productive wealth. important\npowers fought for the possession of these plains and valleys. especially\nthe ganga-yamuna doab proved to be the most coveted and contested\narea.\nthe rivers in this region served as arteries of commerce and\ncommunication. in ancient times it was difficult to make roads, and\nso men and material were moved by boat. the importance of rivers\nfor communication continued till the days of the east india company.\nthe southern peninsula\nthe vindhya and satpura mountains along with narmada and\nthe tapti rivers form the great dividing line between northern and\nsouthern india. the plateau to the south of the vindhya mountains\nis known as the deccan plateau. it consists of volcanic rock, which\nis different from the northern mountains. as these rocks are easier\n\n7 6\nreligions, and observe different social customs, they follow certain\ncommon styles of life throughout the country. therefore, our country\nshows a deep underlying unity in spite of great diversity.\nin fact, the ancients strove for unity. they looked upon this\nvast subcontinent as one land. the name bharatavarsha or the\nland of bharata was given to the whole country, after the name of\nan ancient tribe called the bharatas. our ancient poets, philosophers\nand writers viewed the country as an integral unit. this kind of political\nunity was attained at least twice during the mauryan and gupta\nempires.\nthe unity of india was also recognized by foreigners. they\nfirst came into contact with the people living on the sindhu or the\nindus, and so they named the whole country after this river. the\nword hind is derived from the sanskrit term sindhu, and in course\nof time the country came to be known as ‘india’ in greek, and\n‘hind’ in persian and arabic languages.\nefforts for the linguistic and cultural unity of the country were\nmade through the ages. in the third century b.c., prakrit language\nserved as the lingua franca of the country. throughout the major\nportion of india, asoka’s inscriptions were written in the prakrit\nlanguage. also, the ancient epics, the ramayana and the\nmahabharata, were studied with the same zeal and devotion\nthroughout the country. originally composed in sanskrit, these epics\ncame to be presented in different local languages. although the indian\ncultural values and ideas were expressed in different forms, the\nsubstance remained the same throughout the country.\nhence, india has emerged a multi-religious and multi-cultural\nsociety. however, the underlying unity and integrity and the plural\ncharacter of indian society remain the real strength for the\ndevelopment of the country. mouths became famous under the satavahanas. a number of towns\nand ports flourished in these plains in the beginning of the christian\nera.\nthe kaveri delta constitutes a distinct geographical zone in\nthe far south. it became the seat of the chola power. the kaveri\nbasin with its rich tradition, language and culture has flourished from\nthe ancient times.\nas the southern peninsula is gifted with a long coastline, the\npeople of this region took keen interest in the maritime activities. a\ngreat deal of trade and commerce went on through the seaways\nfrom the earliest times. in the east, mariners reached countries like\njawa, sumatra, burma and cambodia. apart from trade, they\nspread indian art, religion and culture in these parts of the world.\nthe commercial contacts between south india and the greco-roman\ncountries flourished along with cultural relations.\nindia – a land of unity in diversity\nthe history of ancient india is interesting because india proved\nto be a melting pot of numerous races. the pre-aryans, the indo-\naryans, the greeks, the scythians, the hunas, the turks, etc., made\nindia their home. each ethnic group contributed its might to the\nmaking of indian culture. all these peoples mixed up so inextricably\nwith one another that at present none of them can be identified in\ntheir original form. different cultures mingled with one another\nthrough the ages. many pre-aryan or dravidian terms occur in the\nvedic texts. similarly, many pali and sanskritic terms appear in the\nsangam literature.\nsince ancient times, india has been the land of several religions.\nancient india witnessed the birth of hinduism, jainism and buddhism.\nbut all these cultures and religions intermingled with one another.\nalthough indians people speak different languages, practice different\n\n9 8\nmodel questions\ni. choose the correct answer.\n1. alexander of macedon came to india through\n(a) deccan plateau (b) kharakoram range\n(c) swat valley(d) aravalli hills\n2. the region between two rivers is called\n(a) plateau(b) peninsula\n(c) doab (d) peak\nii. fill in the blanks.\n1. the river ganges rises in …….\n2. the highest peak in the southern peninsula is ……\niii. match the following.\n1. mount everest a) aravalli hills\n2. mount abu b) kharakoram\n3. doddabetta c) himalayas\n4. godwin austin d) western ghats\niv. find out the correct statement. one statement alone is\nright.\na) narmada river runs from east to west.\nb) kaveri river runs from south to north.\nc) yamuna river merges with tapti.\nd) maha nadhi river irrigates the punjab region.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. the geographical features of india.\n2. the details of the himalayan mountains, the passes in\nthe northwest and how they were used by the foreign\ninvaders, traders and migrants.\n3. the river systems of the indo-gangetic gangetic valley\nand their impact on the historical events such as battles\nand emergence of urban centres.\n4. the southern peninsula, the long coasts which\ncontributed to a lot of maritime activities.\n5. how india emerged as a multicultural society and the\nsame is successfully sustained over the centuries.\n\n11 10\nthe history of human settlements in india goes back to\nprehistoric times. no written records are available for the pre-\nhistoric period. however, plenty of archaeological remains are found\nin different parts of india to reconstruct the history of this period.\nthey include the stone tools, pottery, artifacts and metal implements\nused by pre-historic people. the development of archaeology helps\nmuch to understand the life and culture of the people who lived in\nthis period.\nin india, the prehistoric period is divided into the paleolithic\n(old stone age), mesolithic (middle stone age), neolithic (new\nstone age) and the metal age. however, these periods were not\nuniform throughout the indian subcontinent. the dating of the pre-\nhistoric period is done scientifically.  the technique of radio-carbon\ndating is commonly used for this purpose. it is based on measuring\nthe loss of carbon in organic materials over a period of time. another\ndating method is known as dendro-chronology. it refers to the\nlesson 2\npre-historic india and\nthe harappan culture\nlearning objectives\nstudents will acquire knowledge about\n1. the pre-historic period.\n2. origin and evolution of the harappan civilization.\n3. socio-economic condition of the harappan people.\n4. cultural life of the harappans.\n5. the decline of the harappan civilization.\nv. state whether the following statements are true or false.\n1. the city of pataliputra was situated at the confluence of ganges\nwith brahmaputra.\n2. the long coast line in the southern peninsula contributed to\nthe growth of maritime trade.\n3. the palghat pass is situated on the western ghats.\n4. india is a multi-cultural society.\nvi. write short notes (any three points).\n1. himalayan mountains.\n2. deccan plateau.\n3. rivers of  southern peninsula\n4. multi-cultural society.\nvii. answer briefly (100 words).\n1. write a note on the impact of the indo-gangetic plains on the\nhistory of india.\n2. briefly describe the geography of south india.\nviii. answer in detail (200 words).\n1. assess the impact of geography on the history of india.\n2. ‘india is a land of unity in diversity’ – elucidate.\n\n13 12\nnumber of tree rings in wood. by counting the number of tree rings\nin the wood, the date of the wood is arrived at.\npaleolithic or old stone age\nthe old stone age sites are widely found in various parts of\nthe indian subcontinent. these sites are generally located near water\nsources. several rock shelters and caves used by the paleolithic\npeople are scattered across the subcontinent. they also lived rarely\nin huts made of leaves. some of the famous sites of old stone age\nin india are:\na. the soan valley and potwar plateau on the northwest india.\nb. the siwalik hills on the north india.\nc. bhimpetka in madhya pradesh.\nd. adamgarh hill in narmada valley.\ne. kurnool in andhra pradesh and\nf. attirampakkam near chennai.\nin the old stone age, food was obtained by hunting animals\nand gathering edible plants and tubers. therefore, these people are\ncalled as hunter-gatherers. they used stone tools, hand-sized and\nflaked-off large pebbles for hunting\nanimals. stone implements are made of a\nhard rock known as quartzite. large\npebbles are often found in river terraces.\nthe hunting of large animals would have\nrequired the combined effort of a group\nof people with large stone axes. we have\nlittle knowledge about their language and\ncommunication. their way of life became modified with the passage\nof time since they made attempts to domesticate animals, make crude\npots and grow some plants. a few old stone age paintings have\nold stone age tools\npre history\nindia\nindian ocean aribian sea\nbay of bengal\nadichanallurpallavaram anandapur\nprahmagirimaskisisupalgarh lothal mohenjadarokalibanganrubar\nindus\n\n15 14\nuttar pradesh and in several places of the deccan. the important\nneolithic sites excavated in south india are maski, brahmagiri, hallur\nand kodekal in karnataka, paiyampalli in tamil nadu and utnur in\nandhra pradesh.\nthe chief characteristic features of the neolithic culture are\nthe practice of agriculture, domestication of animals, polishing of\nstone tools and the manufacture of pottery. in fact, the cultivation of\nplants and domestication of animals led to the emergence of village\ncommunities based on sedentary life.\nthere was a great improvement in technology of making tools\nand other equipments used by man. stone tools were now polished.\nthe polished axes were found to be more effective tools for hunting\nand cutting trees. mud brick houses were built instead of grass huts.\nwheels were used to make pottery. pottery was used for cooking\nas well as storage of food grains. large urns were used as coffins\nfor the burial of the dead. there was also improvement in agriculture.\nwheat, barely, rice, millet were cultivated in different areas at\ndifferent points of time. rice cultivation was extensive in eastern\nindia. domestication of sheep, goats and cattle was widely prevalent.\ncattle were used for cultivation and for transport. the people of\nneolithic age used clothes made of cotton and wool.\nmetal age\nthe neolithic period is followed by chalcolithic (copper-stone)\nperiod when copper and bronze came to be used. the new\ntechnology of smelting metal ore and crafting metal artifacts is an\nimportant development in human civilization. but the use of stone\ntools was not given up. some of the micro-lithic tools continued to\nbe essential items. people began to travel for a long distance to\nobtain metal ores. this led to a network of chalcolithic cultures\nand the chalcolithic cultures were found in many parts of india. also been found on rocks at bhimbetka and other places. the period\nbefore 10000 b.c. is assigned to the old stone age.\nmesolithic or middle stone age\nthe next stage of human life is called mesolithic or middle\nstone age which falls roughly from 10000 b.c. to 6000 b.c. it\nwas the transitional phase between the paleolithic age and neolithic\nage. mesolithic remains are found in langhanj in gujarat, adamgarh\nin madhya pradesh and also in some places of rajasthan, utter\npradesh and bihar. the paintings and engravings found at the rock\nshelters give an idea about the social life and economic activities of\nmesolithic people. in the sites of mesolithic age, a different type of\nstone tools is found. these are tiny stone artifacts, often not more\nthan five centimeters in size, and therefore called microliths. the\nhunting-gathering pattern of life continued during this period.\nhowever, there seems to have been a shift from big animal hunting\nto small animal hunting and fishing. the use of bow and arrow also\nbegan during this period. also, there began a tendency to settle for\nlonger periods in an area. therefore, domestication of animals,\nhorticulture and primitive cultivation started. animal bones are found\nin these sites and these include dog, deer, boar and ostrich.\noccasionally, burials of the dead along with some microliths and\nshells seem to have been practiced.\nneolithic age\na remarkable progress is\nnoticed in human civilization in the\nneolithic age. it is approximately\ndated from 6000 b.c to 4000\nb.c. neolithic remains are found\nin various parts of india. these\ninclude the kashmir valley,\nchirand in bihar, belan valley in\nnew stone age tools\n\n17 16\nharappan  culture\ngenerally, chalcolithic cultures had grown in river valleys.\nmost importantly, the harappan culture is considered as a part of\nchalcolithic culture. in south india the river valleys of the godavari,\nkrishna, tungabhadra, pennar and kaveri were settled by farming\ncommunities during this period. although they were not using metals\nin the beginning of the metal age, there is evidence of copper and\nbronze artifacts by the end of second millennium b.c. several bronze\nand copper objects, beads, terracotta figurines and pottery were\nfound at paiyampalli in tamil nadu.\nthe chalcolithic age is followed by iron age. iron is frequently\nreferred to in the vedas. the iron age of the southern peninsula is\noften related to megalithic burials. megalith means large stone.\nthe burial pits were covered with these stones. such graves are\nextensively found in south india. some of the important megalithic\nsites are hallur and maski in karnataka, nagarjunakonda in andhra\npradesh and adichchanallur in tamil nadu. black and red pottery,\niron artifacts such as hoes and sickles and small weapons were\nfound in the burial pits.\nthe harappan civilization\nthe earliest excavations in the indus valley were done at\nharappa in the west punjab and mohenjodaro in sind. both places\nare now in pakistan. the findings in these two cities brought to light\na civilization. it was first called the ‘the indus valley civilization’.\nbut this civilization was later named as the ‘indus civilization’ due\nto the discovery of more and more sites far away from the indus\nvalley. also, it has come to be called the ‘harappan civilization’\nafter the name of its first discovered site.\nimportant sites\namong the many other sites excavated, the most important\nare kot diji in sind, kalibangan in rajasthan, rupar in the punjab,lothal\naribian seachanhudromohenjadarokalipangan harappa\nrupar\ninduszhelum\nravi\n\n19 18\ndate of the harappan culture\nin 1931, sir john marshall estimated the duration of the\noccupation of mohenjodaro between 3250 and 2750 b.c.\nsubsequently, as and when new sites were discovered, the dating\nof the harappan culture is modified. the advent of the radiocarbon\nmethod paves way for fixing almost accurate dates. by 1956,\nfairservis brought down the dating of the harappan culture to\nbetween 2000 and 1500 b.c. on the basis of radiocarbon dates of\nhis findings. in 1964, d.p. agarwal came to the conclusion that the\ntotal span of this culture should be between 2300 and 1750 b.c.\nyet, there is further scope of modification of these dates.\nsalient features of the harappan culture\ntown planning\nthe harappan culture was distinguished by its system of town-\nplanning on the lines of the grid system – that is streets and lanes\ncutting across one another almost at right angles thus dividing the\ncity into several rectangular\nblocks. harappa, mohenjodaro\nand kalibangan each had its own\ncitadel built on a high podium of\nmud brick. below the citadel in\neach city lay a lower town\ncontaining brick houses, which\nwere inhabited by the common\npeople. the large-scale use of burnt bricks in almost all kinds of\nconstructions and the absence of stone buildings are the important\ncharacteristics of the harappan culture. another remarkable feature\nwas the underground drainage system connecting all houses to the\nstreet drains which were covered by stone slabs or bricks. \ngreat bath at mohenjodaro\nbanawali in haryana, lothal, surkotada and dholavira, all the three\nin gujarat. the larger cities are approximately a hundred hectares\nin size. mohenjodara is the largest of all the indus cities and it is\nestimated to have spread over an area of 200 hectares.\norigin and evolution\nthe archaeological findings excavated for the last eight\ndecades reveal the gradual development of the harappan culture.\nthere are four important stages or phases of evolution and they are\nnamed as pre-harappan, early-harappan, mature-harappan and\nlate harappan.\nthe pre-harappan stage is located in eastern baluchistan.\nthe excavations at mehrgarh 150 miles to the northwest of\nmohenjodaro reveal the existence of pre-harappan culture. in this\nstage, the nomadic people began to lead a settled agricultural life.\nin the early-harappan stage, the people lived in large villages\nin the plains. there was a gradual growth of towns in the indus\nvalley. also, the transition from rural to urban life took place during\nthis period.  the sites of amri and kot diji remain the evidence for\nearly-harappan stage.\nin the mature-harappan stage, great cities emerged. the\nexcavations at kalibangan with its elaborate town planning and urban\nfeatures prove this phase of evolution.\nin the late-harappan stage, the decline of the indus culture\nstarted. the excavations at lothal reveal this stage of evolution.\nlothal with its port was founded much later. it was surrounded by a\nmassive brick wall as flood protection.  lothal remained an\nemporium of trade between the harappan civilization and the\nremaining part of india as well as mesopotamia.\n\n21 20\niran  gold, copper, tin and several semi-precious stones were\nimported. main exports were several agricultural products such as\nwheat, barely, peas, oil seeds and a variety of finished products\nincluding cotton goods, pottery, beads, terracotta figures and ivory\nproducts. there is much evidence to prove the trade links between\nthe indus and sumerian people. many seals of indus valley have\nbeen found in mesopotamia. trade was of the barter type. the\nseals and the terracotta models of the indus valley reveal the use of\nbullock carts and oxen for land transport and boats and ships for\nriver and sea transport.\nsocial life\nmuch evidence is available to understand the social life of the\nharappans. the dress of both men and women consisted of two\npieces of cloth, one upper garment and\nthe other lower garment. beads were\nworn by men and women. jewelleries\nsuch as bangles, bracelets, fillets,\ngirdles, anklets, ear-rings and finger-\nrings were worn by women. these\nornaments were made of gold, silver,\ncopper, bronze and semi precious\nstones. the use of cosmetics was\ncommon. various household articles\nmade of pottery, stone, shells, ivory and metal have been found at\nmohenjodaro. spindles, needles, combs, fishhooks, knives are made\nof copper. children’s toys include little clay carts. marbles, balls\nand dice were used for games. fishing was a regular occupation\nwhile hunting and bull fighting were other pastimes. there were\nnumerous specimens of weapons of war such as axes, spearheads,\ndaggers, bows, arrows made of copper and bronze.\nthe most important public place of mohenjodaro is the great\nbath measuring 39 feet length, 23 feet breadth and 8 feet depth.\nflights of steps at either end lead to the surface. there are side\nrooms for changing clothes. the floor of the bath was made of\nburnt bricks. water was drawn from a large well in an adjacent\nroom, and an outlet from one corner of the bath led to a drain. it\nmust have served as a ritual bathing site. the largest building in\nmohenjodaro is a granary measuring 150 feet length and 50 feet\nbreadth. but in the citadel of harappa we find as many as six\ngranaries.\neconomic life\nthere was a great progress in all spheres of economic activity\nsuch as agriculture, industry and crafts and trade.  wheat and barley\nwere the main crops grown besides sesame, mustard and cotton.\nsurplus grain is stored in granaries. animals like sheep, goats and\nbuffalo were domesticated. the use of horse is not yet firmly\nestablished. a number of other animals were hunted for food\nincluding deer.\nspecialized groups of artisans include goldsmiths, brick\nmakers, stone cutters, weavers, boat-builders and terracotta\nmanufacturers. bronze and copper vessels are the outstanding\nexamples of the harappan metal craft.\ngold and silver ornaments are found in\nmany places. pottery remains plain and\nin some places red and black painted\npottery is found. beads were\nmanufactured from a wide variety of\nsemi-precious stones.\ninternal trade was extensive with\nother parts of india. foreign trade was\nmainly conducted with mesopotamia, afghanistan andharappan  sealornaments used by the\nharappans\n\n23 22\nexists and there is no doubt that the decipherment of harappan\nscript will throw much light on this culture.\nreligion\nfrom the seals, terracotta figurines and copper tablets we\nget an idea on the religious life of the harappans. the chief male\ndeity was pasupati, (proto-siva) represented in seals as sitting in a\nyogic posture with three faces and two horns. he is surrounded by\nfour animals (elephant, tiger, rhino, and buffalo each facing a different\ndirection). two deer appear on his feet. the chief female deity was\nthe mother goddess represented in terracotta figurines. in latter\ntimes, linga worship was prevalent. trees and animals were also\nworshipped by the harappans. they believed in ghosts and evil\nforces and used amulets as protection against them.\nburial methods\nthe cemeteries discovered around the cities like mohenjodaro,\nharappa, kalibangan, lothal and rupar throw light on the burial\npractices of the harappans. complete burial and post-cremation\nburial were popular at mohenjodaro. at lothal the burial pit was\nlined with burnt bricks indicating the use of coffins. wooden coffins\nwere also found at harappa. the practice of pot burials is found at\nlothal sometimes with pairs of skeletons. however, there is no clear\nevidence for the practice of sati.\ndecline of the harappan culture\nthere is no unanimous view pertaining to the cause for the\ndecline of the harappan culture. various theories have been\npostulated. natural calamities like recurring floods, drying up of\nrivers, decreasing fertility of the soil due to excessive exploitation\nand occasional earthquakes might have caused the decline of the\nharappan cities. according to some scholars the final blow was arts\nthe harappan sculpture revealed a high degree of\nworkmanship. figures of men and women, animals and birds made\nof terracotta and the carvings on the seals show\nthe degree of proficiency attained by the sculptor.\nthe figure of a dancing girl from mohenjodaro made\nof bronze is remarkable for its workmanship. its\nright hand rests on the hip, while the left arm,\ncovered with bangles, hangs loosely in a relaxed\nposture. two stone statues from harappa, one\nrepresenting the back view of a man and the other\nof a dancer are also specimens of their sculpture.\nthe pottery from harappa is another specimen of\nthe fine arts of the indus people. the pots and jars were painted\nwith various designs and colours.  painted pottery is of better quality.\nthe pictorial motifs consisted of geometrical patterns like horizontal\nlines, circles, leaves, plants and trees. on some pottery pieces we\nfind figures of fish or peacock.\nscript\nthe harappan script has still to be fully deciphered. the\nnumber of signs is between 400 and 600 of which 40 or 60 are\nbasic and the rest are their variants. the script\nwas mostly written from right to left. in a few\nlong seals the boustrophedon method – writing\nin the reverse direction in alternative lines - was\nadopted. parpola and his scandinavian\ncolleagues came to the conclusion that the\nlanguage of the harappans was dravidian. a\ngroup of soviet scholars accepts this view.\nother scholars provide different view connecting the harappan\nscript with that of brahmi. the mystery of the harappan script still\nharappan script \n \nterracotta\nfigurine\n\n25 24\nmodel questions\ni. choose the correct answer.\n1. the chalcolithic age was followed by\n(a) old stone age (b) new stone age\n(c) iron age(d) mesolithic age\n2. the port city of the harappan culture\n(a) kalibangan (b) lothal\n(c) banawali(d) rupar\nii. fill in the blanks.\n1. the most important megalithic site in tamil nadu is …..\n2. the chief female deity of the harappan culture was ……\niii. match the following.\n1. kot dijia) haryana\n2. dholavira b) rajasthan\n3. kalibangan c) sind\n4. banawali d) gujarat\niv. find out the correct statement. one statement alone is\nright.\na) there are three stages in the evolution of harappan culture.\nb) parpola concluded that the language of harappan people is\nsanskrit.\nc) sir john marshal used the radio-carbon dating method.\nd) the harappan people believed in ghosts and used amulets as\nprotection against them.\nlearning outcome\nafter learning this lesson the students will be to explain\n1. the findings of the paleolithic, neolithic and metal age\nand the socio-economic life of the people during these\nperiods.\n2. the origin and evolution of the harappan culture and\nthe important sites of excavations.\n3. the salient features of the harappan civilization such as\ntown planning, social life and economic condition of the\nharappans.\n4. the date of the harappan culture as well as the religious\nbeliefs and the art of the harappans.\n5. different views on the decline of the harappan\ncivilization.\ndelivered by the invasion of aryans. the destruction of forts is\nmentioned in the rig veda. also, the discovery of human skeletons\nhuddled together at mohenjodaro indicates that the city was invaded\nby foreigners. the aryans had superior weapons as well as swift\nhorses which might have enabled them to become masters of this\nregion.\n\n27 26\nthe cities of the harappan culture had declined by 1500 b.c.\nconsequently, their economic and administrative system had slowly\ndeclined. around this period, the speakers of indo-aryan language,\nsanskrit, entered the north-west india from the indo-iranian region.\ninitially they would have come in small numbers through the passes\nin the northwestern mountains. their initial settlements were in the\nvalleys of the north-west and the plains of the punjab. later, they\nmoved into indo-gangetic plains. as they were mainly a cattle-\nkeeping people, they were mainly in search of pastures. by 6\nth\ncentury b.c., they occupied the whole of north india, which was\nreferred to as aryavarta. this period between 1500 b.c and 600\nb.c may be divided into the early vedic period or rig vedic period\n(1500 b.c -1000 b.c) and the later vedic period (1000b.c -\n600 b.c).\noriginal home of the aryans\nthe original home of the aryans is a debatable question and\nthere are several views.  different scholars have identified different\nlesson 3\nthe vedic culture\nlearning objectives\nstudents will acquire knowledge about\n1. the original home of the aryans.\n2. the vedic literature and their importance.\n3. the rig vedic age and its culture.\n4. the later vedic age and its culture.\nv. state whether the following statements are true or false.\n1. the old stone age people practiced agriculture.\n2. microliths were used by the mesolithic people.\n3. trade links existed between the indus and sumerian people.\n4. the harappan people did not know the art of writing.\nvi. write short notes (any three points).\n1. chalcolithic age\n2. megaliths.\n3. great bath.\n4. date of the harappan culture.\nvii. answer briefly (100 words).\n1. write a note on the old stone age.\n2. trace the origin and evolution of the harappan culture.\n3. name the important sites of the harappan culture.\n4. mention the probable causes for the decline of the harappan\nculture.\nviii. answer in detail (200 words).\n1. write a brief essay on the pre-historic period in india.\n2. describe the socio-economic condition of the harappan\ncivilization.\n\n29 28\nof seven rivers. this includes the five rivers of punjab, namely\njhelum, chenab, ravi, beas and sutlej along with the indus and\nsaraswathi. the political, social and cultural life of the rig vedic\npeople can be traced from the hymns of the rig veda.\npolitical organization\nthe basic unit of political organization was kula or family.\nseveral families joined together on the basis of their kinship to form\na village or grama. the leader of grama was known as gramani. a\ngroup of villages constituted a larger unit called visu. it was headed\nby vishayapati. the highest political unit was called jana or tribe.\nthere were several tribal kingdoms during the rig vedic period\nsuch as bharatas, matsyas, yadus and purus. the head of the\nkingdom was called as rajan or king. the rig vedic polity was\nnormally monarchical and the succession was hereditary. the king\nwas assisted by purohita or priest and senani or commander of\nthe army in his administration. there were two popular bodies called\nthe sabha and samiti. the former seems to have been a council of\nelders and the latter, a general assembly of the entire people.\nsocial life\nthe rig vedic society was patriarchal. the basic unit of society\nwas family or graham. the head of the family was known as\ngrahapathi. monogamy was generally practiced while polygamy\nwas prevalent among the royal and noble families. the wife took\ncare of the household and participated in all the major ceremonies.\nwomen were given equal opportunities as men for their spiritual\nand intellectual development. there were women poets like apala,\nviswavara, ghosa and lopamudra during the rig vedic period.\nwomen could even attend the popular assemblies. there was no\nchild marriage and the practice of sati was absent. regions as the original home of the aryans. they include the arctic\nregion, germany, central asia and southern russia. bala\ngangadhara tilak argues that the aryans came from the arctic region\non astronomical calculations. however, the theory of southern russia\nappears to be more probable and widely accepted by historians.\nfrom there, the aryans moved to different parts of asia and europe.\nthey entered india in about 1500 b.c. and came to be known as\nindo-aryans. they spoke the indo-aryan language, sanskrit.\nvedic literature\nthe word ‘veda’ is derived from the root ‘vid’, which means\nto know. in other words, the term ‘veda’ signifies ‘superior\nknowledge’. the vedic literature consists of the four vedas – rig,\nyajur, sama and atharva. the rig veda is the earliest of the four\nvedas and it consists of 1028 hymns. the hymns were sung in praise\nof various gods. the yajur veda consists of various details of rules\nto be observed at the time of sacrifice. the sama veda is set to\ntune for the purpose of chanting during sacrifice. it is called the\nbook of chants and the origins of indian music are traced in it. the\natharva veda contains details of rituals.\nbesides the vedas, there are other sacred works like the\nbrahmanas, the upanishads, the aranyakas and the epics ramayana\nand mahabharata. the brahmanas are the treatises relating to prayer\nand sacrificial ceremony. the upanishads are philosophical texts\ndealing with topic like the soul, the absolute, the origin of the world\nand the mysteries of nature. the aranyakas are called forest books\nand they deal with mysticism, rites, rituals and sacrifices. the author\nof ramayana was valmiki and that of mahabharata was vedavyas.\nrig vedic age or early vedic period (1500 - 1000 b.c.)\nduring the rig vedic period, the aryans were mostly confined\nto the indus region. the rig veda refers to saptasindhu or the land\n\n31 30\nand indra (thunder).  indra was the most popular among them during\nthe early vedic period. next in importance to indra was agni who\nwas regarded as an intermediary between the gods and people.\nvaruna was supposed to be the upholder of the natural order. there\nwere also female gods like aditi and ushas. there were no temples\nand no idol worship during the early vedic period. prayers were\noffered to the gods in the expectation of rewards. ghee, milk and\ngrain were given as offerings.  elaborate rituals were followed during\nthe worship.\nlater vedic period (1000 – 600 b.c.)\nthe aryans further moved towards east in the later vedic\nperiod. the satapatha brahmana refers to the expansion of aryans\nto the eastern gangetic plains. several tribal groups and kingdoms\nare mentioned in the later vedic literature. one important\ndevelopment during this period is the growth of large kingdoms.\nkuru and panchala kingdoms flourished in the beginning. parikshat\nand janamejaya were the famous rulers of kuru kingdom. pravahana\njaivali was a popular king of the panchalas. he was a patron of\nlearning. after the fall of kurus and panchalas, other kingdoms like\nkosala, kasi and videha came into prominence. the famous ruler\nof kasi was ajatasatru. janaka was the king of videha with its\ncapital at mithila. his court was adorned by scholar yajnavalkya.\nmagadha, anga and vanga seem to be the easternmost tribal\nkingdoms. the later vedic texts also refer to the three divisions of\nindia – aryavarta (northern india), madhyadesa (central india) and\ndakshinapatha (southern india).\npolitical organization\nlarger kingdoms were formed during the later vedic period.\nmany jana or tribes were amalgamated to form janapadas or\nrashtras in the later vedic period. hence the royal power had both men and women wore upper and lower garments made\nof cotton and wool.  a variety of ornaments were used by both men\nand women.  wheat and barley, milk and its products like curd and\nghee, vegetables and fruits were the chief articles of food. the eating\nof cow’s meat was prohibited since it was a sacred animal. chariot\nracing, horse racing, dicing, music and dance were the favourite\npastimes. the social divisions were not rigid during the rig vedic\nperiod as it was in the later vedic period.\neconomic condition\nthe rig vedic aryans were pastoral people and their main\noccupation was cattle rearing. their wealth was estimated in terms\nof their cattle. when they permanently settled in north india they\nbegan to practice agriculture. with the knowledge and use of iron\nthey were able to clean forests and bring more lands under\ncultivation. carpentry was another important profession and the\navailability of wood from the forests cleared made the profession\nprofitable. carpenters produced chariots and ploughs. workers in\nmetal made a variety of articles with copper, bronze and iron.\nspinning was another important occupation and cotton and woolen\nfabrics were made. goldsmiths were active in making ornaments.\nthe potters made various kinds of vessels for domestic use.\ntrade was another important economic activity and rivers\nserved as important means of transport. trade was conducted on\nbarter system. in the later times, gold coins called nishka were used\nas media of exchange in large transactions.\nreligion\nthe rig vedic aryans worshiped the natural forces like earth,\nfire, wind, rain and thunder. they personified these natural forces\ninto many gods and worshipped them. the important rig vedic\ngods were prithvi (earth), agni (fire), vayu (wind), varuna (rain)\n\n33 32\nthe later vedic period. the two higher classes - brahmana, and\nkshatriya enjoyed privileges that were denied to the vaisya and\nsudra. a brahmin occupied a higher position than a kshatriya but\nsometimes kshatriyas claimed a higher status over the brahmins.\nmany sub-castes on the basis of their occupation appeared in this\nperiod.\nin the family, the power of the father increased during the\nlater vedic period. there was no improvement in the status of\nwomen. they were still considered inferior and subordinate to men.\nwomen also lost their political rights of attending assemblies. child\nmarriages had become common. according the aitreya brahmana\na daughter has been described as a source of misery. however, the\nwomen in the royal household enjoyed certain privileges.\nreligion\ngods of the early vedic period like indra and agni lost their\nimportance.  prajapathi (the creator), vishnu (the protector) and\nrudra (the destroyer) became prominent during the later vedic\nperiod. sacrifices were still important and the rituals connected with\nthem became more elaborate. the importance of prayers declined\nand that of sacrifices increased. priesthood became a profession\nand a hereditary one. the formulae for sacrifices were invented and\nelaborated by the priestly class. therefore, towards the end of this\nperiod there was a strong reaction against priestly domination and\nagainst sacrifices and rituals. the rise of buddhism and jainism was\nthe direct result of these elaborate sacrifices. also, the authors of\nthe upanishads, which is the essence of hindu philosophy, turned\naway from the useless rituals and insisted on true knowledge (jnana)\nfor peace and salvation. increased along with the increase in the size of kingdom. the king\nperformed various rituals and sacrifices to strengthen his position.\nthey include rajasuya (consecration ceremony), asvamedha\n(horse sacrifice) and vajpeya (chariot race). the kings also assumed\ntitles like rajavisvajanan, ahilabhuvanapathi, (lord of all earth),\nekrat and samrat (sole ruler).\nin the later vedic period, a large number of new officials were\ninvolved in the administration in addition to the existing purohita,\nsenani and gramani. they include the treasury officer, tax collector\nand royal messenger. at the lower levels, the administration was\ncarried on by the village assemblies.  the importance of the samiti\nand the sabha had diminished during the later vedic period.\neconomic condition\niron was used extensively in this period and this enabled the\npeople to clear forests and to bring more land under cultivation.\nagriculture became the chief occupation. improved types of\nimplements were used for cultivation. besides barley, rice and wheat\nwere grown. knowledge of manure was another improvement.\nindustrial activity became more varied and there was greater\nspecialization. metal work, leather work, carpentry and pottery\nmade great progress. in addition to internal trade, foreign trade\nbecame extensive. the later vedic people were familiar with the\nsea and they traded with countries like babylon. a class of hereditary\nmerchants (vaniya) came into existence. vaisyas also carried on\ntrade and commerce. they organized themselves into guilds known\nas ganas. besides nishka of the rig vedic period, gold and silver\ncoins like satamana and krishnala were used as media of exchange.\nsocial life\nthe four divisions of society (brahmins, kshatriyas, vaisyas\nand sudras) or the varna system was thoroughly established during\n\n35 34\nmodel questions\ni. choose the correct answer.\n1. the earliest of the vedas\n(a) rig(b) yajur\n(c) sama (d) atharva\n2. pravahana jaivali was a popular king of\n(a) videha(b) kasi\n(c) kurus(d) panchalas\nii. fill in the blanks.\n1. the author of ramayana was ……\n2. the arctic home for the aryans was suggested by\niii. match the following.\n1. nishkaa) later vedic coin\n2. ushas b) rig vedic coin\n3. apala c) goddess\n4. krishnala d) woman poet\niv. find out the correct statement. one statement alone is\nright.\na) indra and varuna were the important gods during the later\nvedic period.\nb) the position of women improved during the later vedic\nperiod.\nc) the caste system was not rigid during the later vedic period.\nd) the importance of samiti and sabha declined during the later\nvedic period.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. the vedic literature such as the four vedas and the\nbrahmanas and other later vedic literature.\n2. the rig vedic polity, society and economy.\n3. religious life of the rig vedic people.\n4. the changes during the later vedic period in the sphere\nof polity and society.\n5. the increasing rites and rituals in the religious life of\nthe later vedic people.\n\n37 36\nthe sixth century b.c. is considered a wonderful century in\nhistory. great thinkers like buddha, mahavira, heraclitus, zoroaster,\nconfucius and lao tse lived and preached their ideas in this century.\nin india, the republican institutions were strong in the 6\nth century\nb.c. this enabled rise of heterodox sects against the orthodox\nreligion dominated by rites and rituals. among them the most\nsuccessful were jainism and buddhism whose impact on the indian\nsociety was remarkable.\ncauses for the rise of jainism and buddhism\nthe primary cause for the rise of jainism and buddhism was\nthe religious unrest in india in the 6\nth century b.c. the complex\nrituals and sacrifices advocated in the later vedic period were not\nacceptable to the common people. the sacrificial ceremonies were\nalso found to be too expensive. the superstitious beliefs and mantras\nconfused the people. the teachings of upanishads, an alternative\nto the system of sacrifices, were highly philosophical in nature and\nlesson 4\njainism and buddhism\nlearning objectives\nstudents will acquire knowledge about\n1. the causes for the rise of buddhism and jainism.\n2. early life of mahavira and his teachings.\n3. early life of buddha and his teachings.\n4. the spread of buddhism.\n5. causes for the decline of buddhism in india,\nv. state whether the following statements are true or false.\n1. the aranyakas constitute the essence of hindu philosophy.\n2. the power of the kings had increased during the later vedic\nperiod.\n3. iron was not known to the rig vedic people.\n4. the varna system was thoroughly established during the rig\nvedic period.\nvi. write short notes (any three points).\n1. vedic literature.\n2. original home of the aryans.\n3. position of women during the rig vedic period.\n4. religion of rig vedic period.\nvii. answer briefly (100 words).\n1. write a note on the rig vedic polity.\n2. mention the religious life of later vedic people.\nviii.answer in detail (200 words).\n1. give a brief account of the socio-economic life of the rig\nvedic aryans.\n2. assess the political and social conditions during the later vedic\nperiod.\n\n39 38\nteachings of mahavira\nthe three principles of jainism, also known as triratnas (three\ngems), are:\n- right faith\n- right knowledge\n- right conduct.\nright faith is the belief in the teachings and wisdom of\nmahavira. right knowledge is the acceptance of the theory that\nthere is no god and that the world has been existing without a creator\nand that all objects possess a soul.  right conduct refers to the\nobservance of the five great vows:\n- not to injure life\n- not to lie\n- not to steal\n- not to acquire property\n- not to lead immoral life.\nboth the clergy and laymen had to strictly\nfollow the doctrine of ahimsa. mahavira regarded all objects, both\nanimate and inanimate, have souls and various degrees of\nconsciousness. they possess life and feel pain when they are injured.\nmahavira rejected the authority of the vedas and objected to the\nvedic rituals. he advocated a very holy and ethical code of life.\neven the practice of agriculture was considered sinful as it causes\ninjury to the earth, worms and animals. similarly the doctrine of\nasceticism and renunciation was also carried to extreme lengths by\nthe practice of starvation, nudity and other forms of self-torture.\ntherefore not easily understood by all. therefore, what was needed\nin the larger interests of the people was a simple, short and intelligible\nway to salvation for all people. such religious teaching should also\nbe in a language known to them. this need was fulfilled by the\nteachings of buddha and mahavira.\nother than the religious factor, social and economic factors\nalso contributed to the rise of these two religions. the rigid caste\nsystem prevalent in india generated tensions in the society. higher\nclasses enjoyed certain privileges which were denied to the lower\nclasses. also, the kshatriyas had resented the domination of the\npriestly class. it should also to be noted that both buddha and\nmahavira belonged to kshatriya origin. the growth of trade led to\nthe improvement in the economic conditions of the vaisyas. as a\nresult, they wanted to enhance their social status but the orthodox\nvarna system did not allow this. therefore, they began to extend\nsupport to buddhism and jainism. it was this merchant class that\nextended the chief support to these new religions.\njainism\nlife of vardhamana mahavira (539- 467 b.c.)\nvardhamana mahavira was the 24th tirthankara of the jain\ntradition. he was born at kundagrama near vaisali to kshatriya\nparents siddhartha and trisala. he married yasoda and gave birth\nto a daughter. at the age of thirty he became an ascetic and wandered\nfor twelve years. in the 13\nth year of his penance, he attained the\nhighest spiritual knowledge called kevala gnana. thereafter, he was\ncalled mahavira and jina. his followers were called jains and his\nreligion jainism. he preached his doctrines for 30 years and died at\nthe age of 72 at pava near rajagriha.\nmahavira\n\n41 40\nyasodhara and gave birth to a son, rahula. the sight of an old man,\na diseased man, a corpse and an ascetic turned him away from\nworldly life. he left home at the age of twenty nine in search of\ntruth. he wandered for seven years and met several teachers but\ncould not get enlightenment. at last, he sat under a bodhi tree at\nbodh gaya and did intense penance, after which he got\nenlightenment (nirvana) at the age of thirty five. since then he\nbecame known as the buddha or ‘the enlightened one’.  he\ndelivered his first sermon at sarnath near benares and for the next\nforty five years he led the life of a preacher. he died at the age of\neighty at kusinagara.\nthe most important disciples of buddha were sariputta,\nmoggallanna, ananda, kassapa and upali. kings like prasenajit of\nkosala and bimbisara and ajatasatru of magadha accepted his\ndoctrines and became his disciples. buddha in his lifetime spread\nhis message far and wide in north india and visited places like\nbenares, rajagriha, sravasti, vaisali, nalanda and pataligrama. it\nshould be noted that he did not involve himself in fruitless\ncontroversies regarding metaphysical questions like god, soul, karma,\nrebirth, etc., and concerned himself with the practical problems\nconfronting man.\nteachings of buddha\nthe four noble truths of buddha are:\n- the world is full of suffering.\n- the cause of suffering is desire.\n- if desires are get rid off, suffering can be removed.\n- this can be done by following the eightfold path.\nthe eightfold path consists of right view, right resolve, right\nspeech, right conduct, right livelihood, right effort, right mindfulness spread of jainism\nmahavira organised the sangha to spread his teachings. he\nadmitted both men and women in the sangha, which consisted of\nboth monks and lay followers.  the rapid spread of jainism was\ndue to the dedicated work of the members of the sangha.  it spread\nrapidly in western india and karnataka. chandragupta maurya,\nkharavela of kalinga and the royal dynasties of south india such as\nthe gangas, the kadambas, the chalukyas and the rashtrakutas\npatronized jainism.\nby the end of the fourth century b.c., there was a serious\nfamine in the ganges valley. many jain monks led by bhadrabagu\nand chandragupta maurya came to sravana belgola in karnataka.\nthose who stayed back in north india were led by a monk named\nsthulabahu who changed the code of conduct for the monks. this\nled to the division of jainism into two sects svetambaras (white-\nclad) and digambaras (sky-clad or naked).\nthe first jain council was convened at pataliputra by\nsthulabahu, the leader of the digambaras, in the beginning of the 3\nrd\ncentury b.c. the second jain council was held at valabhi in 5\nth\ncentury a.d. the final compilation of jain literature called twelve\nangas was completed in this council.\nbuddhism\nlife of gautama buddha (567- 487 b.c.)\ngautama or siddhartha, the founder\nof buddhism, was born in 567 b.c. in\nlumbini garden near kapilavastu. his father\nwas suddodhana of the sakya clan and\nmother mayadevi. as his mother died at child\nbirth, he was brought up by his aunt prajapati\ngautami. at the age of sixteen he married\ngautama buddha\n\n43 42\nbuddhist councils\nthe first buddhist council was held at rajagraha under the\nchairmanship of mahakasapa immediately after the death of buddha.\nits purpose was to maintain the purity of the teachings of the buddha.\nthe second buddhist council was convened at vaisali around 383\nb.c. the third buddhist council was held at pataliputra under the\npatronage of asoka. moggaliputta tissa presided over it. the final\nversion of tripitakas was completed in this council. the fourth\nbuddhist council was convened in kashmir by kanishka under the\nchairmanship of vasumitra. asvagosha participated in this council.\nthe new school of buddhism called mahayana buddhism came into\nexistence during this council. the buddhism preached by the buddha\nand propagated by asoka was known as hinayana.\nthe buddhist texts were collected and compiled some five\nhundred years after the death of the buddha. they are known as\nthe tripitakas, namely the sutta, the vinaya and the abhidhamma\npitakas. they are written in the pali language.\ncauses for the decline of buddhism in india\nthe revival of brahmanism and the rise of bhagavatism led to\nthe fall of popularity of buddhism. the use of pali, the language of\nthe masses as the language of buddhism was given up from the 1\nst\ncentury a.d. the buddhists began to adopt sanskrit, the language\nof the elite. after the birth of mahayana buddhism, the practice of\nidol worship and making offerings led to the deterioration of moral\nstandards. moreover, the attack of the huns in 5\nth and 6\nth centuries\nand the turkish invaders in 12\nth century destroyed the monasteries.\nall these factors contributed to the decline of buddhism in india.\ncontribution of buddhism to indian culture\nbuddhism has made a remarkable contribution to the\ndevelopment of indian culture. and right concentration. buddha neither accepts god nor rejects the\nexistence of god. he laid great emphasis on the law of karma. he\nargued that the condition of man in this life depends upon his own\ndeeds. he taught that the soul does not exist. however, he\nemphasized ahimsa. by his love for human beings and all living\ncreatures, he endeared himself to all.  even under the gravest\nprovocation he did not show the least anger or hatred and instead\nconquered everyone by his love and compassion. his religion was\nidentical with morality and it emphasized purity of thought, word\nand deed.  he was a rationalist who tried to explain things in the\nlight of reason and not on the basis of blind faith. though he did not\nmake a direct attack on the caste system, he was against any social\ndistinctions and threw open his order to all. therefore, buddhism\nwas more a social than religious revolution. it taught the code of\npractical ethics and laid down the principle of social equality.\nspread of buddhism\nbuddha had two kinds of disciples – monks (bhikshus) and\nlay worshippers (upasikas). the monks were organized into the\nsangha for the purpose of spreading his teachings. the membership\nwas open to all persons, male or female and without any caste\nrestrictions. there was a special code for nuns restricting their\nresidence and movement. sariputta, moggallana and ananda were\nsome of the famous monks. the sangha was governed on\ndemocratic lines and was empowered to enforce discipline among\nits members. owing to the organised efforts made by the sangha,\nbuddhism made rapid progress in north india even during buddha’s\nlife time.  magadha, kosala, kausambi and several republican states\nof north india embraced this religion. about two hundred years\nafter the death of buddha, the famous mauryan emperor asoka\nembraced buddhism. through his missionary effort asoka spread\nbuddhism into west asia and ceylon. thus a local religious sect\nwas transformed into a world religion.\n\n45 44\nmodel questions\ni. choose the correct answer.\n1. vardhamana mahavira was born at\n(a) kapilavastu (b) pataliputra\n(c) kundagrama (d) kusumapura\n2. the tripitakas  are written in the language of\n(a) sanskrit (b) prakrit\n(c) pali (d) hindi\nii. fill in the blanks.\n1. the first jain council was convened at …… by …….\n2. the final compilation of jain literature was called ……\n3. the buddhism preached by asoka was known as …….\niii. match the following.\n1. first buddhist councila) vaisali\n2. second buddhist council b) kashmir\n3. third buddhist council c) rajagriha\n4. fourth buddhist council d) pataliputra\niv.  find out the correct statement. one statement alone is\nright.\n1. the four noble truths were the teachings of mahavira.\n2. the adoption of pali language led to the decline of buddhism.\n3. idol worship was followed by the followers of mahayana\nbuddhism. - the concept of ahimsa was its chief contribution. later, it\nbecame one of the cherished values of our nation.\n- its contribution to the art and architecture of india was\nnotable. the stupas at sanchi, bharhut and gaya are wonderful\npieces of architecture. buddhism takes the credit for the chaityas\nand viharas in different parts of india.\n- it promoted education through residential universities like\nthose at taxila, nalanda and vikramasila.\n- the language of pali and other local languages developed\nthrough the teachings of buddhism.\n- it had also promoted the spread of indian culture to other\nparts of asia.\nlearning outcome\nafter learning this lesson the students will be to explain\n1. the religious and other causes for the rise of buddhism\nand jainism.\n2. early life of mahavira and his principles of triratna.\n3. early life of gautama buddha and his important\nprinciples like the four truths and eightfold path.\n4. the patrons of buddhism and the formation of the sangha\nas well as the spread of buddhism.\n5. causes for the decline of buddhism in india and its\ncontribution to indian culture.\n\n47 46\nin the beginning of the 6\nth century b.c., the northern india\nconsisted of a large number of independent kingdoms.  some of\nthem had monarchical forms of government, while some others were\nrepublics. while there was a concentration of monarchies on the\ngangetic plain, the republics were scattered in the foothills of the\nhimalayas and in northwestern india.  some of the republics\nconsisted of only one tribe like the sakyas, licchavis and mallas.\nin the republics, the power of decision in all matters of state vested\nwith the public assembly which was composed of the tribal\nrepresentatives or heads of families.  all decisions were by a\nmajority vote.\nthe buddhist literature anguttara nikaya gives a list of sixteen\ngreat kingdoms called ‘sixteen mahajanapadas’. they were anga,\nmagadha, kasi, kosala, vajji, malla, chedi, vatsa, kuru, panchala,\nmatsya, surasena, asmaka, avanti, gandhara and kambhoja. the\nlesson 5\nthe rise of magadha and\nalexander’s invasion\nlearning objectives\nstudents will acquire knowledge about\n1. the rise of magatha under the haryanka, saisunaga and\nnanda dynasties.\n2. the achievements of bimbisara and ajatasatru.\n3. the persian invasions and their impact.\n4. causes and course of alexander ’s invasion.\n5. effects of alexander’s invasion.\n4. buddha involved himself into controversial philosophical\narguments.\nv. state whether the following statements are true or\nfalse.\n1. buddha neither accepts nor rejects the existence of god.\n2. mahavira asked his followers to strictly observe four great\nvows.\n3. the first buddhist council was convened by kanishka at\nkashmir.\n4. buddhism contributed to the spread of indian culture to other\nparts of the world.\nvi. write short notes (any three points).\n1. triratnas\n2. split in jainism\n3. tripitakas\n4. third buddhist council\nvii. answer briefly (100 words).\n1. discuss the spread of jainism in various parts india.\n2. account for the decline of buddhism in india.\nviii.answer in detail (200 words).\n1. sketch the life and teachings of mahavira.\n2. give a brief account of the life and teachings of buddha.\n3. how did buddhism become a world religion?\n\n49 48\nmagadha\nof all the kingdoms of north india, magadha emerged\npowerful and prosperous. it became the nerve centre of political\nactivity in north india. magadha was endowed by nature with certain\ngeographical and strategic advantages. these made her to rise to\nimperial greatness. her strategic position between the upper and\nlower part of the gangetic valley was a great advantage. it had a\nfertile soil. the iron ores in the hills near rajgir and copper and iron\ndeposits near gaya added to its natural assets. her location at the\ncentre of the highways of trade of those days contributed to her\nwealth. rajagriha was the capital of magadha. during the reign of\nbimbisara and ajatasatru, the prosperity of magadha reached its\nzenith.\nbimbisara (546 - 494 b.c.)\nbimbisara belonged to the haryanka dynasty. he consolidated\nhis position by matrimonial alliances. his first matrimonial alliance\nwas with the ruling family of kosala. he married kosaladevi, sister\nof prasenajit. he was given the kasi region as dowry which yielded\nlarge revenue. bimbisara married chellana, a princess of the licchavi\nfamily of vaisali. this matrimonial alliance secured for him the safety\nof the northern frontier. moreover, it facilitated the expansion of\nmagadha northwards to the borders of nepal.  he also married\nkhema of the royal house of madra in central punjab. bimbisara\nalso undertook many expeditions and added more territories to his\nempire. he defeated brahmadatta of anga and annexed that\nkingdom. he maintained friendly relations with avanti. he had also\nefficiently reorganized the administration of his kingdom.\nbimbisara was a contemporary of both vardhamana mahavira\nand gautama buddha. however, both religions claim him as their\nsupporter and devotee. he seems to have made numerous gifts to\nthe buddhist sangha. jain texts also contain references to the existence of sixteen\nkingdoms. in course of time, the small and weak kingdoms either\nsubmitted to the stronger rulers or gradually got eliminated. finally\nin the mid 6\nth century b.c., only four kingdoms – vatsa, avanti,\nkosala and magadha survived.\nvatsa\nthe vatsa kingdom was situated on the banks of the river\nyamuna. its capital was kausambi near modern allahabad. its most\npopular ruler was udayana. he strengthened his position by entering\ninto matrimonial alliances with avanti, anga and magadha. after\nhis death, vatsa was annexed to the avanti kingdom.\navanti\nthe capital of avanti was ujjain. the most important ruler of\nthis kingdom was pradyota. he became powerful by marrying\nvasavadatta, the daughter of udayana. he patronized buddhism.\nthe successors of pradyota were weak and later this kingdom was\ntaken over by the rulers of magadha.\nkosala\nayodhya was the capital of kosala. king prasenajit was its\nfamous ruler. he was highly educated. his position was further\nstrengthened by the matrimonial alliance with magadha. his sister\nwas married to bimbisara and kasi was given to her as dowry.\nsubsequently there was a dispute with ajatasatru. after the end of\nthe conflict, prasenajit married the daughter of bimbisara. after the\ndeath of this powerful king, kosala became part of the magadha.\n\n51 50\nnandas\nthe fame of magadha scaled new heights under the nanda\ndynasty. their conquests went beyond the boundaries of the gangetic\nbasin and in north india they carved a well-knit and vast empire.\nmahapadma nanda was a powerful ruler of the nanda\ndynasty. he uprooted the kshatriya dynasties in north india and\nassumed the title ekarat. the puranas speak of the extensive\nconquests made by mahapadma. the hathigumpha inscription of\nkharavela of kalinga refers to the conquest of kalinga by the\nnandas. many historians believe that a considerable portion of the\ndeccan was also under the control of the nandas. therefore,\nmahapadma nanda may be regarded as a great empire builder.\naccording to the buddhist tradition, mahapadma nanda ruled\nabout ten years. he was succeeded by his eight sons, who ruled\nsuccessively. the last nanda ruler was dhana nanda. he kept the\nmagadhan empire intact and possessed a powerful army and\nenormous wealth. the fabulous wealth of the nandas is also\nmentioned by several sources. the enormous wealth of the nandas\nis also referred to in the tamil sangam work ahananuru by the\npoet mamulanar. the flourishing state of agriculture in the nanda\ndominions and the general prosperity of the country must have\nbrought to the royal treasury enormous revenue. the oppressive\nway of tax collection by dhana nanda was resented by the people.\ntaking advantage of this, chandragupta maurya and kautilya\ninitiated a popular movement against the nanda rule. it was during\nthis time that alexander invaded india. ajatasatru (494 - 462 b.c.)\nthe reign of ajatasatru was remarkable for his military conquests.\nhe fought against kosala and vaisali. his won a great success against\na formidable confederacy led by the lichchavis of vaisali. this had\nincreased his power and prestige. this war lasted for about sixteen\nyears. it was at this time that ajatasatru realised the strategic importance\nof the small village, pataligrama (future pataliputra). he fortified it to\nserve as a convenient base of operations against vaisali.\nbuddhists and jains both claim that ajatasatru was a follower\nof their religion.  but it is generally believed that in the beginning he\nwas a follower of jainism and subsequently embraced buddhism.\nhe is said to have met gautama buddha. this scene is also depicted\nin the sculptures of barhut. according to the mahavamsa, he\nconstructed several chaityas and viharas. he was also instrumental\nin convening the first buddhist council at rajagriha soon after the\ndeath of the buddha.\nthe immediate successor of ajatasatru was udayin. he laid\nthe foundation of the new capital at pataliputra situated at the\nconfluence of the two rivers, the ganges and the son. later it became\nfamous as the imperial capital of the mauryas. udayin’s successors\nwere weak rulers and hence magadha was captured by saisunaga.\nthus the haryanka dynasty came to an end and the saisunaga\ndynasty came to power.\nsaisunaga dynasty\nthe genealogy and chronology of the saisunagas are not clear.\nsaisunaga defeated the king of avanti which was made part of the\nmagadhan empire. after saisunaga, the mighty empire began to\ncollapse. his successor was kakavarman or kalasoka. during his\nreign the second buddhist council was held at vaisali. kalasoka\nwas killed by the founder of the nanda dynasty.\n\n53 52\nasoka’s edicts were written in that script.  we are able to see the\ninfluence of persian art on the art of the mauryas, particularly the\nmonolithic pillars of asoka and the sculptures found on them.  the\nvery idea of issuing edicts by asoka and the wording used in the\nedicts are traced to iranian influence. in short, the iranian connection\nwith india proved more fruitful than the short-lived indo-\nmacedonian contact.\nalexander’s invasion of india (327-325 b.c.)\npolitical condition on the eve of alexander’s invasion\nafter two centuries of the persian invasion, alexander from\nmacedonia invaded india. on the eve of his invasion, there were a\nnumber of small kingdoms in northwestern india. the leading kings\nwere ambhi of taxila, the ruler of abhisara and porus who ruled\nthe region between the rivers of jhelum and chenab. there were\nmany republican states like nysa. in short, the northwestern india\nremained the most disunited part of india and the rulers were fighting\nwith one another. they never come together against common enemy.\nyet, it was not easy for alexander to overcome so many sources of\nopposition.\ncauses of the invasion\nalexander ascended the throne of macedonia after the death\nof his father philip in 334 b.c. he conquered the whole of persia\nby defeating darius iii in the battle of arbela in 330 b.c. he also\naimed at further conquest eastwards and wanted to recover the lost\npersian satrapy of india. the writings of greek authors like\nherodotus about the fabulous wealth of india attracted alexander.\nmoreover, his interest in geographical enquiry and love of natural\nhistory urged him to undertake an invasion of india. he believed\nthat on the eastern side of india there was the continuation of the\nsea, according the geographical knowledge of his period. so, he persian and greek invasions\npersian invasions\ncyrus (558 – 530 b.c)\ncyrus the great was the greatest conqueror of the\nachaemenian empire. he was the first conqueror who led an\nexpedition and entered into india. he captured the gandhara region.\nall indian tribes to the west of the indus river submitted to him and\npaid tribute. his son cambyses had no time to pay attention towards\nindia.\ndarius i (522 – 486 b.c.)\ndarius i, the grandson of cyrus, conquered the indus valley\nin 518 b.c. and annexed the punjab and sindh. this region became\nthe 20\nth satrapy of his empire. it was the most fertile and populous\nprovince of the achaemenian empire. darius sent a naval expedition\nunder skylas to explore the indus.\nxerxes (465-456 b.c.)\nxerxes utilized his indian province to strengthen his position.\nhe deployed indian infantry and cavalry to greece to fight his\nopponents. but they retreated after xerxes faced a defeat in greece.\nafter this failure, the achaemenians could not follow a forward policy\nin india. however, the indian province was still under their control.\ndarius iii enlisted indian soldiers to fight against alexander in 330\nb.c. it is evident that the control of persians slackened on the eve\nof alexander’s invasion of india.\neffects of the persian invasion\nthe persian invasion provided an impetus to the growth of\nindo-iranian commerce. also, it prepared the ground for\nalexander’s invasion. the use of the kharoshti script, a form of\niranian writing became popular in northwestern india and some of\n\n55 54\nthought that by conquering india, he would also conquer the eastern\nboundary of the world.\nbattle of hydaspes\nin 327 b.c. alexander crossed the hindukush mountains\nand spent nearly ten months in fighting with the tribes. he crossed\nthe indus in february 326 b.c. with the help of the bridge of boats.\nhe was warmly received by ambhi, the ruler of taxila. from there\nalexander sent a message to porus to submit. but porus refused\nand decided to fight against alexander. then alexander marched\nfrom taxila to the banks of the river hydaspes (jhelum). on the\nother side of the river he saw the vast army of porus. as there were\nheavy floods in the river, alexander was not able to cross it. after a\nfew days, he crossed the river and the famous battle of hydaspes\nwas fought on the plains of karri. it was a well-contested battle.\nalthough porus had a strong army, he lost the battle. alexander\nwas impressed by the courage and heroism of this indian prince,\ntreated him generously and reinstated him on his throne.\nalexander continued his march as far as the river beas\nencountering opposition from the local tribes.  he wanted to proceed\nstill further eastwards towards the gangetic valley. but he could not\ndo so because his soldiers refused to fight. hardships of prolonged\nwarfare made them tired and they wanted to return home. alexander\ncould not persuade them and therefore decided to return. he made\narrangements to look after his conquered territories in india. he\ndivided the whole territory from the indus to the beas into three\nprovinces and put them under his governors. his retreat began in\noctober 326 b.c. and the return journey was not free from ordeals.\nmany republican tribes attacked his army. anyhow he managed to\nreach beyond the indus. on his way he reached babylon where he\nfell seriously ill and died in 323 b.c.\nmediterranean\nsea\ngreece\nmacedonia\nblack sea\narmenia\nmesopatomia\negyptsyriya\nbabylon\nindia\ndrangianamarkanda\nbactria\npushkalavathi\nalexander’s campaigns\n\n57 56\nmodel questions\ni. choose the correct answer.\n1. the capital of magadha was\n(a) rajagriha (b) ujjain\n(c) kosala(d) kausambi\n2. nanda dynasty was preceded by\n(a) mauryas(b) sisunagas\n(c) haryankas (d) guptas\nii. fill in the blanks.\n1. ajatasatru belonged to ……. dynasty.\n2. the last ruler of nanda dynasty was …..\n3. the second buddhist council was held at …..\n4. alexander died at …… in the year …..\niii. match the following.\n1. udayana a) kosala\n2. pradyota b) avanti\n3. prasenajit c) magadha\n4. bimbisara d) vatsa\niv. find out the correct statement. one statement alone is\nright.\na) alexander defeated porus and annexed his kingdom.\nb) alexander defeated porus and treated him generously.\nc) alexander could not win the army of porus.\nd) alexander defeated ambhi of taxila with the help of porus. effects of alexander’s invasion\nthe immediate effect of alexander’s invasion was that it\nencouraged political unification of north india under the mauryas.\nthe system of small independent states came to an end. alexander’s\ninvasion had also paved the way for direct contact between india\nand greece. the routes opened by him and his naval explorations\nincreased the existing facilities for trade between india and west\nasia. however, his aim of annexing the northwestern india to his\nempire was not fulfilled due his premature death. his authority in\nthe indus valley was a short-lived one because of the expansion of\nmauryan empire under chandragupta maurya.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. the rise of magatha and the different dynasties ruled\nover it.\n2. the achievements of bimbisara, mahapadma nanda and\nother kings.\n3. persian invasions and their occupation of northwest\nindia.\n4. effects of persian invasion and occupation.\n5. causes and course of alexander ’s invasion of india.\n6. effects of alexander’s invasion.\n\n59 58\nthe foundation of the mauryan empire opens a new era in\nthe history of india. for the first time, the political unity was achieved\nin india. moreover, the history writing has also become clear from\nthis period due to accuracy in chronology and sources. besides\nplenty of indigenous and foreign literary sources, a number of\nepigraphical records are also available to write the history of this\nperiod.\nliterary sources\nkautilya’s arthasastra\nthis book in sanskrit was written by kautilya, a contemporary\nof chandragupta maurya. kautilya was also called ‘indian\nmachiavelli’. the manuscript of arthasastra was first discovered\nby r. shama sastri in 1904. the arthasastra contains 15 books\nlesson 6\nthe mauryan empire\nlearning objectives\nstudents will acquire knowledge about\n1. the sources for the study of the mauryas.\n2. chandragupta maurya and his achievements.\n3. asoka and his achievements and the spread of asoka’s\ndhamma.\n4. the salient features of the mauryan administration.\n5. art and architecture of the mauryas.\n6. causes for the decline of the mauryan empire.\nv. state whether the following statements are true or false.\n1. xerxes was the first greek conqueror to enter into india.\n2. the battle of hydaspes was fought on the karri plain.\n3.  alexander annexed some portions of gangetic valley before\nhis departure.\nvi. write short notes (any three points).\n1. sixteen mahajanapadas.\n2. cyrus\n3. battle of hydaspes.\n4. effects of alexander’s invasion.\nvii. answer briefly (100 words).\n1. write briefly the achievements of bimbisara.\n2. assess the impact of persian invasions on india.\nviii.answer in detail (200 words).\n1. describe the rise of magadha and the achievements of its\nrulers.\n2. give an account of alexander ’s invasion of india.\n\n61 60\nplaces prakrit was used. the brahmi script was employed for writing.\nin the northwestern india asokan inscriptions were found in karoshti\nscript. there are fourteen major rock edicts. the two kalinga\nedicts are found in the newly conquered territory. the major pillar\nedicts were erected in important cities. there are minor rock edicts\nand minor pillar edicts. these edicts of asoka deal with asoka’s\ndhamma and also instructions given to his officials. the xiii rock\nedict gives details about his war with kalinga. the pillar edict vii\ngives a summary of his efforts to promote the dhamma within his\nkingdom. thus the asokan inscriptions remain valuable sources for\nthe study of asoka and the mauryan empire.\npolitical history of the mauryas\nchandragupta maurya (322 – 298 b.c.)\nchandragupta maurya was the founder of the mauryan\nempire. he, at the young age of 25, captured pataliputra from the\nlast ruler of the nanda dynasty, dhanananda. in this task he was\nassisted by kautilya, who was also known as chanakya or\nvishnugupta. after firmly establishing his power in the gangetic\nvalley, he marched to the northwest and subdued the territories up\nto the indus. then he moved to central india and occupied the region\nnorth of narmada river.\nin 305 b.c., he marched against selukas niketar, who was\nalexander’s general controlling the northwestern india.\nchandragupta maurya defeated him and a treaty was signed. by\nthis treaty, selukas niketar ceded the trans-indus territories – namely\naria, arakosia and gedrosia – to the mauryan empire. he also\ngave his daughter in marriage to the mauryan prince. chandragupta\nmade a gift of 500 elephants to selukas. megasthenes was sent to\nthe mauryan court as greek ambassador. and 180 chapters but it can be divided into three parts: the first\ndeals with the king and his council and the departments of\ngovernment; the second with civil and criminal law; and the third\nwith diplomacy and war. it is the most important literary source for\nthe history of the mauryas.\nvisakadatta’s mudrarakshasa\nthe mudrarakshasa written by visakadatta is a drama in\nsanskrit. although written during the gupta period, it describes how\nchandragupta with the assistance of kautilya overthrew the nandas.\nit also gives a picture on the socio-economic condition under the\nmauryas.\nmegasthenes’ indica\nmegasthenes was the greek ambassador in the court of\nchandragupta maurya. his book indica has survived only in\nfragments. yet, his account gives details about the mauryan\nadministration, particularly the administration of the capital city of\npataliputra and also the military organization. his picture on\ncontemporary social life is notable. certain unbelievable information\nprovided by him has to be treated with caution.\nother literature\napart from these three important works, the puranas and the\nbuddhist literature such as jatakas provide information on the\nmauryas. the ceylonese chronicles dipavamsa and mahavamsa\nthrow light on the role asoka in spreading buddhism in sri lanka.\narchaeological sources\nedicts of asoka\nthe inscriptions of asoka were first deciphered by james\nprincep in 1837. they are written in pali language and in some\n\n63 62\nchandragupta embraced jainism towards the end of his life\nand stepped down from the throne in favour of his son bindusara.\nthen he went to sravana belgola, near mysore along with jain\nmonks led by bhadrabhagu and starved himself to death.\nbindusara (298 – 273 b.c.)\nbindusara was called by the greeks as “amitragatha” meaning\nslayer of enemies. he is said to have conquered the deccan up to\nmysore. taranatha, the tibetan monk states that bindusara\nconquered 16 states comprising ‘the land between the two seas’.\nthe sangam tamil literature also confirms the mauryan invasion of\nthe far south. therefore, it can be said that the mauryan empire\nunder bindusara extended up to mysore.\nbindusara received deimachus as ambassador from the syrian\nking antiochus i. bindusara wrote to antiochus i asking for sweet\nwine, dried figs and a sophist. the latter sent all but a sophist\nbecause the greek law prohibited sending a sophist. bindusara\nsupported the ajivikas, a religious sect. bindusara appointed his\nson asoka as the governor of ujjain.\nasoka the great (273 – 232 b.c.)\nthere is little information regarding the early life of asoka.\nhe acted as governor of ujjain and also suppressed a revolt in\ntaxila during his father bindusara’s reign. there was an interval of\nfour years between asoka’s accession to the throne (273 b.c.)\nand his actual coronation (269 b.c.). therefore, it appears from\nthe available evidence that there was a struggle for the throne after\nbindusara’s death. the ceylonese chronicles, dipavamsa and\nmahavamsa state that asoka captured power after killing his ninety\nnine brothers including the his elder brother susima. the youngest\nbrother tissa was spared. but according to taranatha of tibet,\nasoka killed only six of his brothers. asoka’s edict also refers to\n\n65 64\nnorthwestern frontier was already demarcated by chandragupta\nmaurya.\nasoka’s dhamma\nalthough asoka embraced buddhism and took efforts to\nspread buddhism, his policy of dhamma was a still broad concept.\nit was a way of life, a code of conduct and a set of principles to be\nadopted and practiced by the people at large. his principles of\ndhamma were clearly stated in his edicts. the main features of\nasoka’s dhamma as mentioned in his various edicts may be summed\nas follows:\n1. service to father and mother, practice of ahimsa, love of truth,\nreverence to teachers and good treatment of relatives.\n2. prohibition of animal sacrifices and festive gatherings and\navoiding expensive and meaningless ceremonies and rituals.\n3. efficient organization of administration in the direction of social\nwelfare and maintenance of constant contact with people\nthrough the system of dhammayatras.\n4. humane treatment of servants by masters and prisoners by\ngovernment officials.\n5. consideration and non-violence to animals and courtesy to\nrelations and liberality to brahmins.\n6. tolerance among all the religious sects.\n7. conquest through dhamma instead of through war.\nthe concept of non-violence and other similar ideas of\nasoka’s dhamma are identical with the teachings of buddha. but\nhe did not equate dhamma with buddhist teachings. buddhism\nremained his personal belief. his dhamma signifies a general code\nof conduct. asoka wished that his dhamma should spread through\nall social levels. his brothers acting as officers in his administration. however, it is\nclear that the succession of asoka was a disputed one.\nthe most important event of asoka’s reign was his victorious\nwar with kalinga in 261 b.c. although there is no detail about the\ncause and course of the war, the effects of the war were described\nby asoka himself in the rock edict xiii: “a hundred and fifty\nthousand were killed and many times that number perished…” after\nthe war he annexed kalinga to the mauryan empire. another most\nimportant effect of the kalinga war was that asoka embraced\nbuddhism under the influence of buddhist monk, upagupta.\nasoka and buddhism\naccording some scholars, his conversion to buddhism was\ngradual and not immediate. about 261 b.c. asoka became a sakya\nupasaka (lay dsicple) and two and a half years later, a bikshu\n(monk). then he gave up hunting, visited bodh-gaya, and organized\nmissions. he appointed special officers called dharma mahamatras\nto speed up the progress of dhamma. in 241 b.c., he visited the\nbirth place of buddha, the lumbini garden, near kapilavastu. he\nalso visited other holy places of buddhism like sarnath, sravasti\nand kusinagara. he sent a mission to sri lanka under his son\nmahendra and daughter sangamitra who planted there the branch\nof the original bodhi tree. asoka convened the third buddhist\ncouncil at pataliputra in 240 b.c. in order to strengthen the sangha.\nit was presided over by moggaliputta tissa.\nextent of asoka’s empire\nasoka’s inscriptions mention the southernmost kingdoms –\ncholas, pandyas, satyaputras and keralaputras – as border-states.\ntherefore these states remained outside the mauryan empire.\naccording to rajatarangini, kashmir was a part of the mauryan\nempire. nepal was also within the mauryan empire. the\n\n67 66\nmatters. it consisted of purohita, mahamantri, senapati and\nyuvaraja. there were civil servants called amatyas to look after\nthe day-to-day administration. these officers were similar to the\nias officers of independent india. the method of selection of\namatyas was elaborately given by kautilya. asoka appointed\ndhamma mahamatras to supervise the spread of dhamma. thus\nthe mauryan state had a well organized civil service.\nrevenue department\nsamharta, the chief of the revenue department, was in charge\nof the collection of all revenues of the empire. the revenues came from\nland, irrigation, customs, shop tax, ferry tax, forests, mines and pastures,\nlicense fee from craftsmen, and fines collected in the law courts. the\nland revenue was normally fixed as one sixth of the produce. the main\nitems of expenditure of the state related to king and his household,\narmy, government servants, public works, poor relief, religion, etc.\narmy\nthe mauryan army was well organized and it was under the\ncontrol of senapati. the salaries were paid in cash. kautilya refers\nto the salaries of different ranks of military officers. according to\ngreek author pliny, the mauryan army consisted of six lakh infantry,\nthirty thousand cavalry, nine thousand elephants and eight thousand\nchariots. in addition to these four wings, there were the navy and\ntransport and supply wings. each wing was under the control of\nadyakshas or superintendents. megasthenes mentions six boards\nof five members each to control the six wings of the military.\ndepartment of commerce and industry\nthis department had controlled the retail and wholesale prices\nof goods and tried to ensure their steady supply through its officers\ncalled adyakshas. it also controlled weights and measures, levied\ncustom duties and regulated foreign trade. estimate of asoka\nasoka was “the greatest of kings” surpassing alexander the\ngreat and julius caesar and other renowned emperors of the world.\naccording to h.g. wells “amidst the tens and thousands of names\nof monarchs that crowd the columns of history, the name of asoka\nshines and shines almost alone, a star”. asoka was true to his ideals.\nhe was not a dreamer but a man of practical genius. his dhamma is\nso universal that it appeals to humanity even today. he was an\nexample in history for his benevolent administration and also for\nfollowing the policy of non-aggression even after his victory in the\nwar. his central ideal was to promote the welfare of humanity.\nlater mauryas\nasoka’s death in 232 b.c. was followed by the division of\nthe mauryan empire into two parts – western and eastern. the\nwestern part was ruled by kunala, son of asoka and the eastern\npart by dasaratha, one of the grand sons of asoka. due to the\nbactrian invasions, the western part of the empire collapsed. the\neastern part was intact under samprati successor of dasaratha. the\nlast mauryan king was brihatratha, who was assassinated by\npushyamitra sunga.\nmauryan administration\ncentral government\nthe ascendancy of the mauryas had resulted in the triumph\nof monarchy in india. other systems like republics and oligarchies\nthat were prevalent in the pre-mauryan india had collapsed. although\nkautilya the foremost political theorist of ancient india supported\nthe monarchial form of government, he did not stand for royal\nabsolutism. he advocated that the king should take the advice of\nhis ministry in running the administration. therefore, a council of\nministers called mantriparishad assisted the king in administrative\n\n69 68\nhands of gramani and his official superior was called gopa who\nwas in charge of ten or fifteen villages.\nboth kautilya and megasthanes provided the system of\nmunicipal administration. arthasastra contains a full chapter on the\nrole of nagarika or city superintendent. his chief duty was to\nmaintain law and order. megasthenes refers to the six committees\nof five members each to look after the administration of pataliputra.\nthese committees looked after: 1. industries 2. foreigners 3.\nregistration of birth and deaths 4. trade 5. manufacture and sale\nof goods 6. collection of sales tax.\nmauryan art and architecture\nthe monuments before the period of asoka were mostly made\nof wood and therefore perished. the use of stone started from the\ntime of asoka. even of the numerous monuments of asoka, only a\nfew have remained. his palace and monasteries and most of his\nstupas have disappeared. the only remaining stupa is at sanchi.\nthe artistic remains of the mauryan period can be seen in the\nfollowing heads:\npillars\nthe pillars erected by asoka furnish the\nfinest specimen of the mauryan art. asokan\npillars with inscriptions were found in places like\ndelhi, allahabad, rummindai, sanchi and\nsaranath. their tops were crowned with figures\nof animals like lion, elephant and bull. the\nsaranath pillar with four lions standing back to\nback is the most magnificent. the indian\ngovernment adopted this capital with some\nmodifications as its state emblem.\n saranath pillar\njudicial and police departments\nkautilya mentions the existence of both civil and criminal\ncourts. the chief justice of the supreme court at the capital was\ncalled dharmathikarin. there were also subordinate courts at the\nprovincial capitals and districts under amatyas. different kinds of\npunishment such as fines, imprisonment, mutilation and death were\ngiven to the offenders. torture was employed to extract truth. police\nstations were found in all principal centres. both kautilya and asokan\nedicts mention about jails and jail officials. the dhamma\nmahamatras were asked by asoka to take steps against unjust\nimprisonment. remission of sentences is also mentioned in asoka’s\ninscriptions.\ncensus\nthe taking of census was regular during the mauryan period.\nthe village officials were to number the people along with other\ndetails like their caste and occupation. they were also to count the\nanimals in each house. the census in the towns was taken by\nmunicipal officials to track the movement of population both foreign\nand indigenous. the data collected were cross checked by the spies.\nthe census appears to be a permanent institution in the mauryan\nadministration.\nprovincial and local administration\nthe mauryan empire was divided into four provinces with\ntheir capitals at taxila, ujjain, suvarnagiri and kalinga. the\nprovincial governors were mostly appointed from the members of\nroyal family. they were responsible the maintenance of law and\norder and collection of taxes for the empire. the district\nadministration was under the charge of rajukas, whose position\nand functions are similar to modern collectors. he was assisted by\nyuktas or subordinate officials. village administration was in the\n\n71 70\nsolely blaming asoka for the decline of the mauryan empire may\nnot be correct because asoka was more a pragmatist than an idealist.\nthere are multiple causes for the decline of the mauryan empire\nsuch as weak successors, partition of empire and administrative\nabuses after asoka’s reign. the combination of these factors\nspeeded up the breakup of the mauryan empire and facilitated\npushyamitra sunga to drive away the mauryan power and establish\nthe sunga dynasty.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. the literary and epigraphical sources for the study of\nthe mauryas.\n2. the accession of chandragupta maurya and his\nachievements.\n3. bindusara’s military achievements.\n4. asoka’s spread of dhamma through various means such\nas issuing edicts and appointing officers like dhamma\nmahamatras.\n5. the salient features of the mauryan art such as pillars,\ncaves and stupas.\n6. causes for the decline of the mauryan empire.\nstupas\nasoka built a number of stupas\nthroughout his empire but majority of them\nwere destroyed during foreign invasions.\nonly a few have survived. the best example\nis the famous sanchi stupa with massive\ndimensions. it was originally\nbuilt with bricks but later\nenlarged after the time of asoka.\ncaves\nthe caves presented to the ajivikas by asoka\nand his son dasaratha remain important heritage of\nthe mauryas. their interior walls are polished like\nmirror. these were meant to be residences of monks.\nthe caves at barabar hills near bodh gaya are\nwonderful pieces of mauryan architecture.\ncauses for the decline of the mauryas\nthe causes for the decline of the mauryan empire have been\nwidely debated by scholars. the traditional approach attributes the\ndecline to asoka’s policies and his weak successors. another\napproach holds the inadequate political and economic institutions\nto sustain such a vast empire.\nit was said that asoka’s pro-buddhist policies antagonized\nthe brahmins who brought about a revolution led by pushyamitra\nsunga. but asoka was never acted against brahmins. that asoka’s\npolicy of non-violence reduced the fighting spirit of his army was\nanother charge against him. but asoka had never slackened his\ncontrol over his empire despite following a pacifist policy. therefore\nsanchi stupa \nfour lions\n\n73 72\nc) the indika written by megasthenes gives details about the\nkalinga war.\nd) asoka’s edicts provide information on the decline of the\nmauryan empire.\nv. state whether the following statements are true or false.\n1. chandragupta maurya became a follower of buddhism at the\nend of his reign.\n2. tamil nadu was included in the mauryan empire.\n3. asoka presented caves to the ajivikas.\n4. pushyamitra sunga put an end to the mauryan rule.\nvi. write short notes (any three points).\n1. kautilya’s arthasastra.\n2. kalinga war.\n3. megasthanes.\n4. bindusara.\nvii. answer briefly (100 words).\n1. write a note on the achievements of chandragupta maurya.\n2. mention the efforts taken by asoka for the spread of\nbuddhism.\n3. assess the significance of the mauryan art.\n4. analyse the causes for the decline of the mauryan empire.\nviii. answer in detail (200 words).\n1. give an account of asoka’s achievements and his policy of\ndhamma.\n2. write in detail the salient features of the mauryan\nadministration. model questions\ni. choose the correct answer.\n1. the details of asoka’s war with kalinga is given in the\n(a) kalinga edict(b) xiii rock edict\n(c) saranath pillar(d) arthasastra\n2. the language mostly employed in the edicts of asoka is\n(a) pali(b) sanskrit\n(c) karoshti (d) brahmi\nii. fill in the blanks.\n1. the asokan edicts were first deciphered by …….\n2. the last mauryan king was …….\n3. asoka embraced buddhism under the influence of …….\n4. the state emblem of india was adopted from …… pillar.\niii. match the following.\n1. dharmamahamatras a) village administration\n2. gopa b) revenue administration\n3. nagarika c) spread of dhamma\n4. samharta d) city administration\niv. find out the correct statement. one statement alone is\nright.\na) the first part of kautilya’s arthasastra tells about war and\ndiplomacy.\nb) visakadatta’s mudrarakshasa was written in the style of\ndrama.\n\n75 74\nterritory. he also fought a campaign against kharavela of kalinga\nwho invaded north india.\npushyamitra was a staunch follower of brahmanism. he\nperformed two asvamedha sacrifices. buddhist sources refer him\nas a persecutor of buddhism. but there is enough evidence to show\nthat pushyamitra patronised buddhist art. during his reign the\nbuddhist monuments at bharhut and sanchi were renovated and\nfurther improved.\nafter the death of pushyamitra, his son agnimitra became the\nruler. the last sunga ruler was devabhuti, who was murdered by\nhis minister vasudeva kanva, the founder of the kanva dynasty.\nthe kanva dynasty ruled for 45 years. after the fall of the kanvas,\nthe history of magatha was a blank until the establishment of the\ngupta dynasty.\nthe rule of the sungas was important because they defended the\ngangetic valley from foreign invasions. in the cultural sphere, the sungas\nrevived brahmanism and horse sacrifice. they also promoted the growth\nof vaishnavism and the sanskrit language. in short, the sunga rule was\na brilliant anticipation of the golden age of the guptas.\nsatavahanas\nin the deccan, the satavahanas\nestablished their independent rule after the\ndecline of the mauryas. their rule lasted\nfor about 450 years. they were also known\nas the andhras. the puranas and\ninscriptions remain important sources for\nthe history of satavahanas. among the inscriptions, the nasik and\nnanaghad inscriptions throw much light on the reign of gautamiputra\nsatakarni. the coins issued by the satavahanas are also helpful in\nknowing the economic conditions of that period.\ncoins of satavahanas\n \nlesson 7\npost-mauryan india\nlearning objectives\nstudents will acquire knowledge about\n1. the sunga rule and its importance.\n2. the satavahana rule and their contributions to culture.\n3. the sakas and bactrians.\n4. kanishka and his achievements.\n5. gandhara art and its salient features.after the death of asoka, his successors were not able to\nkeep the vast mauryan empire intact. the provinces started declaring\ntheir independence. the northwest india slipped out of the control\nof the mauryas and a series of foreign invasions affected this region.\nkalinga declared its independence and in the further south the\nsatavahanas established their independent rule. as a result, the\nmauryan rule was confined to the gangetic valley and it was soon\nreplaced by the sunga dynasty.\nsungas\nthe founder of the sunga dynasty was pushyamitra sunga,\nwho was the commander-in-chief under the mauryas. he\nassassinated the last mauryan ruler and usurped the throne. the\nmost important challenge to the sunga rule was to protect north\nindia against the invasions of the bactrian greeks from the northwest.\nthe greeks advanced up to pataliputra and occupied it for\nsometime. however, pushyamitra succeeded in regaining the lost\n\n77 76\ncultural contributions\nthe satavahanas patronized buddhism and brahmanism. they\nbuilt chaityas and viharas. they also made grants of villages and\nlands to buddhist monks. vashishtaputra pulamayi repaired the old\namaravathi stupa. their architecture in nagarjunakonda was also\nnotable. brahmanism was revived by the satavahanas along with\nthe performance of asvamedha and rajasuya sacrifices. they also\npatronized the prakrit language and literature. hala’s sattasai is an\nexcellent piece of prakrit literature.\nforeign invasions of northwest india\nbactrians\nbactria and parthia became independent from the syrian\nempire in the middle of the third century b.c. demetrius, the greek\nruler of bactria invaded afghanistan and punjab and occupied them.\nfrom taxila, he sent two of his commanders, appolodotus and\nmenander for further conquests. appolodotus conquered the sindh\nand marched up to ujjain. menander extended his rule up to mathura\nand from there he made attempts to capture pataliputra. but he\nwas stopped by the army of vasumitra, the grandson of pushyamitra\nsunga.\nmenander was also known as milinda and the capital of his\nkingdom was sakala (sialcot). he evinced much interest in\nbuddhism and his dialogues with the buddhist monk nagasena was\ncompiled in the pali work, milindapanho (questions of milinda).\nhe also embraced buddhism. a greek ambassador heliodorus\nbecame a vaishnavite and erected the garuda pillar at besnagar.\nthe greek influence in india lasted for more than a century after the\ndeath menander. the founder of the satavahana dynasty was simuka. he was\nsucceeded by krishna, who extended the kingdom up to nasik in\nthe west. the third king was sri satakarni. he conquered western\nmalwa and berar. he also performed asvamedha sacrifices. the\nseventeenth king of the satavahana dynasty was hala. he reigned\nfor a period of five years. hala became famous for his book\ngathasaptasati, also called sattasai. it contains 700 verses in prakrit\nlanguage.\nthe greatest ruler of the satavahana dynasty was gautamiputra\nsatakarni. he ruled for a period of 24 years from 106 to 130 a.d.\nhis achievements were recorded in the nasik inscription by his\nmother gautami balasri. gautamiputra satakarni captured the whole\nof deccan and expanded his empire. his victory over nagapana,\nthe ruler of malwa was remarkable. he patronized brahmanism.\nyet, he also gave donations to buddhists.\ngautamiputra satakarni was succeeded by his son\nvashishtaputra pulamayi. he extended the satavahana power up to\nthe mouth of the krishna river. he issued coins on which the image\nof ships was inscribed. they reveal the naval power and maritime\ntrade of the satavahanas. the last great ruler of satavahanas was\nyajna sri satakarni.\neconomic condition\nthere was a remarkable progress in the fields of trade and\nindustry during the satavahana rule. merchants organized guilds to\nincrease their activities. the craft guilds organized by different\ncraftsmen such as potters, weavers and oil pressers also came into\nexistence. silver coins called karshapanas were used for trade.\nthe satavahana period also witnessed overseas commercial activity.\nptolemy mentions many ports in the deccan. the greatest port of\nthe satavahanas was kalyani on the west deccan. gandakasela\nand ganjam on the east coast were the other important seaports.\n\n79 78\nkanishka’s conquests\nat the time of his accession his empire\nincluded afghanistan, gandhara, sind and\npunjab. subsequently he conquered\nmagadha and extended his power as far as\npataliputra and bodh gaya. according to\nkalhana, kanishka invaded kashmir and\noccupied it. his coins are found in many\nplaces like mathura, sravasti, kausambi and\nbenares and therefore, he must have con-\nquered the greater part of the gangetic plain.\nhe also fought against the chinese and acquired some\nterritories from them. during the first expedition he was defeated\nby the chinese general pancho. he undertook a second expedition\nin which he was successful and he scored a victory over panyang,\nthe son of pancho. kanishka annexed the territories of  kashgar,\nyarkand and khotan into his empire.\nthe empire of kanishka was a vast one extending from\ngandhara in the west to benares in the east, and from kashmir in\nthe north to malwa in the south. his capital was purushapura or\nmodern day peshawar. mathura was another important city in his\nempire.\nkanishka and buddhism\nkanishka embraced buddhism in the early part of his reign.\nhowever, his coins exhibit the images of not only buddha but also\ngreek and hindu gods. it reflects the kanishka’s toleration towards\nother religions. in the age of kanishka the mahayana buddhism\ncame into vogue. it is different in many respects from the religion\ntaught by the buddha and propagated by asoka. the buddha came\nto be worshipped with flowers, garments, perfumes and lamps. thus\n \nheadless statue\nof kanishka\nsakas\nthe sakas or the scythians attacked bactria and parthia and\ncaptured them from the greek rulers. following the footsteps of\nthe greeks, the sakas gradually extended their rule over\nnorthwestern india. there were two different groups of sakas –\nthe northern satraps ruling from taxila and the western satraps\nruling over maharashtra.\nthe founder the saka rule in india in the first century b.c.\nwas maues. his son and successor was azes i, who was considered\nto be the founder of the vikrama era.\nsakas rulers of taxila were overthrown by the parthians.\nkushanas\nthe kushanas were a branch of yuchi tribe, whose original\nhome was central asia. they first came to bactria displacing the\nsakas. then they gradually moved to\nthe kabul valley and seized the\ngandhara region. the founder of the\nkushana dynasty was kujula\nkadphises or kadphises i. he\noccupied the kabul valley and issued\ncoins in his name. his son wima\nkadphises or kadphises ii conquered the whole of northwestern\nindia as far as mathura. he issued gold coins with high-sounding\ntitles like the ‘lord of the whole world’. he was a devotee of\nlord siva.\nkanishka (78 – 120 a.d.)\nkanishka was the most important ruler of the kushana\ndynasty. he was the founder of the saka era which starts from 78\na.d. he was not only a great conqueror but also a patron of religion\nand art.\ngold conins of\nkushanas\n\n81 80\n- moulding human body in a realistic manner with minute\nattention to physical features like muscles, moustache and\ncurtly hair.\n- thick drapery with large and bold fold lines.\n- rich carving, elaborate ornamentation and symbolic\nexpressions.\n- the main theme was the new form of buddhism – mahayanism\n– and the evolution of an image of buddha.\na large number of monasteries were also built from first to\nfourth centuries a.d. ruins of about fifteen monasteries were found\nin and around peshawar and rawalpindi. the buddhist stupas\nerected during this period had graeco-roman architectural impact.\nthe height of the stupa was raised and ornamentation was added to\nthe structure of the stupa. these changes made the stupa more\nattractive.\nmathura school of art\nthe school of art that developed at mathura in modern uttar\npradesh is called the mathura art. it flourished in the first century\na.d. in its early phase, the mathura school of art developed on\nindigenous lines. the buddha images exhibit the spiritual feeling in\nhis face which was largely absent in the gandhara school. the\nmathura school also carved out the images of siva and vishnu along\nwith their consorts parvathi and lakshmi. the female figures of\nyakshinis and apsaras of the mathura school were beautifully carved.\nsuccessors of kanishka and end of kushana rule\nthe successors of kanishka ruled for another one hundred\nand fifty years. huvishka was the son of kanishka and he kept the\nempire intact. mathura became an important city under his rule. image worship and rituals developed in mahayana buddhism.\nkanishka also sent missionaries to central asia and china\nfor the propagation of the new faith. buddhist chaityas and viharas\nwere built in different places. he patronised buddhist scholars like\nvasumitra, asvagosha and nagarjuna. he also convened the fourth\nbuddhist council to discuss matters relating to buddhist theology\nand doctrine. it was held at the kundalavana monastery near srinagar\nin kashmir under the presidentship of vasumitra. about 500 monks\nattended the council. the council prepared an authoritative\ncommentary on the tripitakas and the mahayana doctrine was given\nfinal shape. asvagosha was a great philosopher, poet and dramatist.\nhe was the author of buddhacharita. nagarjuna from south india\nadorned the court of kanishka. the famous physician of ancient\nindia charaka was also patronized by him.\ngandhara art\nthe home of the gandhara school of art is the territory in and\naround peshawar in northwestern india. the best of the gandhara\nsculpture was produced during the first and\nsecond centuries a.d. it originated during the\nreign of indo-greek rulers but the real patrons\nof this school of art were the sakas and the\nkushanas, particularly kanishka. gandhara art\nwas a blend of indian and graeco-roman\nelements. specimens of gandhara sculpture have\nbeen found in taxila, peshawar and in several\nplaces of northwest india. the gandhara school\nmade sculptures of the buddha in various sizes,\nshapes and postures. the reliefs depict buddha’s\nbirth, his renunciation and his preaching. the\nsalient features of gandhara art are:\nrepresentation of\n \nthe buddha in \ngandhara art\n\n83 82\nmodel questions\ni. choose the correct answer.\n1. the sungas were succeeded by\n(a) mauryas (b) kushanas\n(c) kanvas(d) satavahanas\n2. nasik inscription describes the achievements of\n(a) pushyamitra sunga (b) gautamiputra satakarni\n(c) kanishka (d) menander\n3. the author of buddhacharita was\n(a) nagarjuna (b) asvagosha\n(c) vasumitra(d) nagasena\nii. fill in the blanks.\n1. the founder of the satavahana dynasty was …….\n2. the famous prakrit book sattasai was written by …..\n3. …… was considered to be the founder of the vikrama era.\n4. saka era was founded by ……. in the year…..\n5. the garuda pillar at besnagar was erected by …..\n6. the chinese general who was defeated by kanishka was\n…..\niii. match the following.\n1. sakala a) azes i\n2. purushapura b) pushyamitra sunga\n3. pataliputra c) menander\n4. taxila d) kanishka like kanishka he was also a patron of buddhism. the last important\nkushana ruler was vasudeva. the kushana empire was very much\nreduced in his rule. most of his inscriptions are found in and around\nmathura. he seems to have been a worshipper of siva. after\nvasudeva, petty kushan princes ruled for sometime in northwestern\nindia.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. the reign of pushyamitra and the importance of sunga\nrule.\n2. the satavahana rule and gautami putra satakarni’s\nachievements.\n3. the socio-economic conditions of the satavahana period\nand also their cultural contributions.\n4. kanishka and his military achievements.\n5. the role of kanishka in the spread of mahayana\nbuddhism.\n6. the salient features of the gandhara art and also\nmathura art.\n\n85 84\nthe sangam age constitutes an important chapter in the history\nof south india. according to tamil legends, there existed three\nsangams (academy of tamil poets) in ancient tamil nadu popularly\ncalled muchchangam. these sangams flourished under the royal\npatronage of the pandyas. the first sangam, held at then madurai,\nwas attended by gods and legendary sages but no literary work of\nthis sangam was available. the second sangam was held at\nkapadapuram but the all the literary works had perished except\ntolkappiyam. the third sangam at madurai was founded by\nmudathirumaran. it was attended by a large number of poets who\nproduced voluminous literature but only a few had survived. these\ntamil literary works remain useful sources to reconstruct the history\nof the sangam age.\nsangam literature\nthe corpus of sangam literature includes tolkappiyam,\nettutogai, pattuppattu, pathinenkilkanakku, and the two epics\nlesson 8sangam age\nlearning objectives\nstudents will acquire knowledge about\n1. the sangam literature and other sources for the sangam\nperiod.\n2. the political history of the sangam period.\n3. the sangam polity and society.\n4. religion and the position of women in the sangam period.\n5. the economic condition of the sangam age.\niv. find out the correct statement. one statement alone is\nright.\na) the sungas promoted the sanskrit language.\nb) the satavahanas patronized telugu language.\nc) the mahayana buddhism adopted pali as its language.\nd) the mathura school of art developed on indo-greek style.\nv. state whether the following statements are true or\nfalse.\n1. the sungas revived brahmanism and horse sacrifice.\n2. menander was a bactrian ruler.\n3. nasik was a great port on the east coast during the rule of\nsatavahanas.\n4. gandhara art was a blend of indian and graeco-roman\nelements.\nvi. write short notes (any three points).\n1. gautamiputra satakarni.\n2. menander.\n3. asvagosha.\n4. mathura school of art.\nvii. answer briefly (100 words).\n1. assess the importance of the rule of sungas.\n2. mention the cultural contributions of satavahanas.\n3. examine the salient features of the gandhara art.\nviii.answer in detail (200 words).\n1. give an account of the history of the satavahanas.\n2. assess the achievements of kanishka.\n\n87 86\nsenguttuvan of the chera dynasty were contemporaries. this is\nconfirmed by silappathigaram as well as the dipavamsa and\nmahavamsa. also the roman coins issued by roman emperors of\nthe first century a.d were found in plenty in various places of tamil\nnadu. therefore, the most probable date of the sangam literature\nhas been fixed between the third century b.c. to third century a.d.\non the basis of literary, archaeological and numismatic evidences.\npolitical history\nthe tamil country was ruled by three dynasties namely the\nchera, chola and pandyas during the sangam age. the political\nhistory of these dynasties can be traced from the literary references.\ncheras\nthe cheras ruled over parts of modern kerala. their capital\nwas vanji and their important seaports were tondi and musiri. they\nhad the palmyra flowers as their garland. the pugalur inscription of\nthe first century a.d refers to three generations of chera rulers.\npadirruppattu also provides information on chera kings. perum\nsorru udhiyan cheralathan, imayavaramban nedum cheralathan\nand cheran senguttuvan were the famous rulers of this dynasty.\ncheran senguttuvan belonged to 2\nnd century a.d. his younger\nbrother was elango adigal, the author of silappathigaram. among\nhis military achievements, his expedition to the himalayas was\nremarkable. he defeated many north indian monarchs. senguttuvan\nintroduced the pattini cult or the worship of kannagi as the ideal\nwife in tamil nadu. the stone for making the idol of kannagi was\nbrought by him after his himalayan expedition. the consecration\nceremony was attended by many princes including gajabhagu ii\nfrom sri lanka. – silappathigaram and manimegalai. tolkappiyam authored by\ntolkappiyar is the earliest of the tamil literature. it is a work on\ntamil grammar but it provides information on the political and socio-\neconomic conditions of the sangam period. the ettutogai or eight\nanthologies consist of eight works – aingurunooru, narrinai,\naganaooru, purananooru, kuruntogai, kalittogai, paripadal\nand padirruppattu. the pattuppattu or ten idylls consist of ten\nworks – thirumurugarruppadai, porunararruppadai,\nsirupanarruppadai, perumpanarruppadai, mullaippattu,\nnedunalvadai, maduraikkanji, kurinjippatttu, pattinappalai\nand malaipadukadam. both ettutogai and pattuppattu were divided\ninto two main groups – aham (love) and puram (valour).\npathinenkilkanakku contains eighteen works mostly dealing with\nethics and morals. the most important among them is tirukkural\nauthored by thiruvalluvar. silappathigaram written by elango\nadigal and manimegalai by sittalai sattanar also provides valuable\ninformation on the sangam polity and society.\nother sources\nin addition to the sangam literature, the greek authors like\nmegasthenes, strabo, pliny and ptolemy mention the commercial\ncontacts between the west and south india. the asokan inscriptions\nmention the chera, chola and pandya rulers on the south of the\nmauryan empire. the hathikumbha inscription of kharavela of\nkalinga also mentions about tamil kingdoms. the excavations at\narikkamedu, poompuhar, kodumanal and other places reveal the\noverseas commercial activities of the tamils.\nperiod of sangam literature\nthe chronology of the sangam literature is still a disputed\ntopic among the scholars. the sheet anchor of sangam chronology\nlies in the fact that gajabhagu ii of sri lanka and cheran\n\n89 88\nincluding the flourishing seaport of korkai. the last famous pandyan\nking was uggira peruvaludhi. the pandyan rule during the sangam\nage began to decline due to the invasion of the kalabhras.\nminor chieftains\nthe minor chieftains played a significant role in the sangam\nperiod. among them pari, kari, ori, nalli, pegan, ay and adiyaman\nwere popular for their philanthropy and patronage of tamil poets.\ntherefore, they were known as kadai yelu vallalgal. although they\nwere subordinate to the chera, chola and pandya rulers, they were\npowerful and popular in their respective regions.\nsangam polity\nhereditary monarchy was the form of government during the\nsangam period. the king had also taken the advice of his minister,\ncourt-poet and the imperial court or avai. the chera kings assumed\ntitles like vanavaramban, vanavan, kuttuvan, irumporai and villavar,\nthe chola kings like senni, valavan and killi and the pandya kings\nthennavar and minavar. each of the sangam dynasties had a royal\nemblem – carp for the pandyas, tiger for the cholas and bow for\nthe cheras. the imperial court or avai was attended by a number of\nchiefs and officials. the king was assisted by a large body of officials\nwho were divided into five councils. they were ministers (amaichar),\npriests (anthanar), military commanders (senapathi), envoys (thuthar)\nand spies (orrar). the military administration was also efficiently\norganized during the sangam age. each ruler had a regular army\nand their respective kodimaram (tutelary tree).\nland revenue was the chief source of state’s income while\ncustom duty was also imposed on foreign trade. the pattinappalai\nrefers to the custom officials employed in the seaport of puhar. booty\ncaptured in wars was also a major income to the royal treasury. cholas\nthe chola kingdom of the sangam period extended from\nmodern tiruchi district to southern andhra pradesh. their capital\nwas first located at uraiyur and then shifted to puhar. karikala was\na famous king of the sangam cholas. pattinappalai portrays his\nearly life and his military conquests. in the battle of venni he defeated\nthe mighty confederacy consisting of the cheras, pandyas and eleven\nminor chieftains. this event is mentioned in many sangam poems.\nvahaipparandalai was another important battle fought by him in which\nnine enemy chieftains submitted before him. karikala’s military\nachievements made him the overlord of the whole tamil country.\ntrade and commerce flourished during his reign period. he was\nresponsible for the reclamation of forest lands and brought them\nunder cultivation thus adding prosperity to the people. he also built\nkallanai across the river kaveri and also constructed many irrigation\ntanks.\npandyas\nthe pandyas ruled over the present day southern tamil nadu.\ntheir capital was madurai. the earliest kings of the pandyan dynasty\nwere nediyon, palyagasalai mudukudumi peruvaludhi and\nmudathirumaran. there were two neduncheliyans. the first one\nwas known as aryappadai kadantha neduncheliyan (one who won\nvictories over the aryan forces). he was responsible for the\nexecution of kovalan for which kannagi burnt madurai. the other\nwas talaiyalanganattu cheruvenra (he who won the battle at\ntalaiyalanganam) neduncheliyan.  he was praised by nakkirar and\nmangudi maruthanar. he wore this title after defeating his enemies\nat the battle of talaiyalanganam, which is located in the tanjore\ndistrict. by this victory neduncheliyan gained control over the entire\ntamil nadu. maduraikkanji written by mangudi maruthanar\ndescribes the socio-economic condition of the pandya country\n\n91 90\nthe sangam period were mayon (vishnu), vendan (indiran), varunan\nand korravai. the hero stone or nadu kal worship was significant\nin the sangam period. the hero stone was erected in memory of\nthe bravery shown by the warrior in battle. many hero stones with\nlegends inscribed on them were found in different parts of tamil\nnadu. this kind of worshipping the deceased has a great antiquity.\nposition of women\nthere is a plenty of information in the sangam literature to\ntrace the position of women during the sangam age. women poets\nlike avvaiyar, nachchellaiyar, and kakkaipadiniyar flourished in this\nperiod and contributed to tamil literature. the courage of women\nwas also appreciated in many poems. karpu or chaste life was\nconsidered the highest virtue of women. love marriage was a\ncommon practice. women were allowed to choose their life partners.\nhowever, the life of widows was miserable. the practice of sati\nwas also prevalent in the higher strata of society. the class of dancers\nwas patronized by the kings and nobles.\nfine arts\npoetry, music and dancing were popular among the people of\nthe sangam age. liberal donations were given to poets by the kings,\nchieftains and nobles. the royal courts were crowded with singing\nbards called panar and viraliyar. they were experts in folk songs\nand folk dances. the arts of music and dancing were highly\ndeveloped. a variety of yazhs and drums are referred to in the\nsangam literature. dancing was performed by kanigaiyar. koothu\nwas the most popular entertainment of the people.\neconomy of the sangam age\nagriculture was the chief occupation. rice was the common\ncrop. ragi, sugarcane, cotton, pepper, ginger, turmeric, cinnamon\nand a variety of fruits were the other crops. jack fruit and pepper roads and highways were well maintained and guarded night and\nday to prevent robbery and smuggling.\nsangam society\ntolkappiyam refers to the five-fold division of lands -  kurinji\n(hilly tracks), mullai (pastoral), marudam (agricultural), neydal\n(coastal) and palai (desert). the people living in these five divisions\nhad their respective chief occupations as well as gods for worship.\n·kurinji – chief deity was murugan – chief occupation,\nhunting and honey collection.\n·mullai – chief deity mayon (vishnu) –   chief occupation,\ncattle-rearing and dealing with dairy products.\n·marudam – chief deity indira – chief occupation, agriculture.\n·neydal – chief deity varunan – chief occupation fishing and\nsalt manufacturing.\n·palai – chief deity korravai – chief occupation robbery.\ntolkappiyam also refers to four castes namely arasar, anthanar,\nvanigar and vellalar. the ruling class was called arasar. anthanars played\na significant role in the sangam polity and religion. vanigars carried on\ntrade and commerce. the vellalas were agriculturists. other tribal groups\nlike parathavar, panar, eyinar, kadambar, maravar and pulaiyar were\nalso found in the sangam society. ancient primitive tribes like thodas,\nirulas, nagas and vedars lived in this period.\nreligion\nthe primary deity of the sangam period was seyon or\nmurugan, who is hailed as tamil god. the worship of murugan\nwas having an ancient origin and the festivals relating to god murugan\nwas mentioned in the sangam literature. he was honoured with six\nabodes known as arupadai veedu. other gods worshipped during\n\n93 92learning outcome\nafter learning this lesson the students will be able to explain\n1. the sources for the study of the sangam period including\nthe sangam literature.\n2. the chera, chola and pandya rulers of the sangam\nperiod and their achievements.\n3. the sangam polity including the administrative system\nand other details.\n4. the sangam society, the five divisions of landscape, their\nreligious life and the position of women.\n5. the economy during the sangam period, particularly the\noverseas commercial contacts during the sangam period.\nend of the sangam age\ntowards the end of the third century a.d., the sangam period\nslowly witnessed its decline. the kalabhras occupied the tamil\ncountry for about two and a half centuries. we have little information\nabout the kalabhra rule. jainism and buddhism became prominent\nduring this period. the pallavas in the northern tamil nadu and\npandyas in southern tamil nadu drove the kalabhras out of the\ntamil country and established their rule. were famous in the chera country. paddy was the chief crop in the\nchola and pandya country.\nthe handicrafts of the sangam period were popular. they\ninclude weaving, metal works and carpentry, ship building and\nmaking of ornaments using beads, stones and ivory. there was a\ngreat demand for these products, as the internal and external trade\nwas at its peak during the sangam period. spinning and weaving of\ncotton and silk clothes attained a high quality. the poems mention\nthe cotton clothes as thin as a cloud of steam or a slough of a snake.\nthere was a great demand in the western world for the cotton clothes\nwoven at uraiyur.\nboth internal and foreign trade was well organized and briskly\ncarried on in the sangam age. the sangam literature, greek and\nroman accounts and the archaeological evidences provide detailed\ninformation on this subject. merchants carried the goods on the\ncarts and on animal-back from place to place. internal trade was\nmostly based on the barter system.\nexternal trade was carried between south india and the greek\nkingdoms. after the ascendancy of the roman empire, the roman\ntrade assumed importance. the port city of puhar became an\nemporium of foreign trade, as big ships entered this port with\nprecious goods. other ports of commercial activity include tondi,\nmusiri, korkai, arikkamedu and marakkanam. the author of\nperiplus provides the most valuable information on foreign trade.\nplenty of gold and silver coins issued by the roman emperors like\naugustus, tiberius and nero were found in all parts of tamil nadu.\nthey reveal the extent of the trade and the presence of roman\ntraders in the tamil country. the main exports of the sangam age\nwere cotton fabrics, spices like pepper, ginger, cardamom, cinnamon\nand turmeric, ivory products, pearls and precious stones. gold,\nhorses and sweet wine were the chief imports.\n\n95 94\nc) horses and wine were the chief exports from tamil nadu.\nd) madurai was the port-city of the sangam pandyas.\nv. state whether the following statements are true or false.\n1. arikkamedu was a seaport during the sangam period.\n2. lord murugan was the primary deity of the sangam age.\n3. uraiyur was famous for pearls.\n4. the singing bards of the sangam age were called as irular.\nvi. write short notes (any three points).\n1. pattupattu.\n2. ettutogai.\n3. kadaiyelu vallalgal\n4. women poets of the sangam period.\n5. muchchangam.\nvii. answer briefly (100 words).\n1. assess the achievements of cheran senguttuvan.\n2. give an estimate of karikala.\n3. write a note on the pandya rulers of the sangam period.\nviii.answer in detail (200 words).\n1. give an account of the political administration of the sangam\nperiod.\n2. discuss the socio-economic condition of ancient tamil nadu.\n3. assess the significance of the overseas commerce during the\nsangam age. model questions\ni. choose the correct answer.\n1. pattini cult in tamil nadu was introduced by\n(a) pandyan neduncheliyan (b) cheran senguttuvan\n(c) elango adigal (d) mudathirumaran\n2. the pandyan rule of the sangam age declined due to the\ninvasion of\n(a) satavahanas(b) cholas\n(c) kalabhras(d) pallavas\nii. fill in the blanks.\n1. the battle of venni was won by ……\n2. the earliest tamil grammar work of the sangam period was\n……\n3. the two tamil epics of the sangam period are …… and ……\niii. match the following.\n1. thennavar a) cheras\n2. vanavar b) cholas\n3. senni c) tribes\n4. eyinar d) pandyas\niv. find out the correct statement. one statement alone is\nright.\na) coins issued by ancient chinese kings are found in several\nparts of tamil nadu.\nb) cotton textiles constitute the chief export to the roman empire.\n\n97 96\nachievements. this inscription is engraved on an asokan pillar. it is\nwritten in classical sanskrit, using the nagari script. it consists of\n33 lines composed by harisena. it\ndescribes the circumstances of\nsamudragupta’s accession, his military\ncampaigns in north india and the\ndeccan, his relationship with other\ncontemporary rulers, and his\naccomplishments as a poet and\nscholar.\nthe coins issued by gupta kings\ncontain legends and figures. these coins provide interesting details\nabout the titles and sacrifices performed by the gupta monarchs.\nchandragupta i (320 – 330 a.d.)\nthe founder of the gupta dynasty was sri gupta. he was\nsucceeded by ghatotkacha. these two were called maharajas.\nmuch information was not available about their rule. the next ruler\nwas chandragupta i and he was the first to be called\nmaharajadhiraja (the great king of kings). this title indicates his\nextensive conquests. he strengthened his position by a matrimonial\nalliance with the licchavis. he married kumaradevi, a princess of\nthat family. this added to the power and prestige of the gupta family.\nthe meherauli iron pillar inscription mentions his extensive\nconquests. chandragupta i is considered to be the founder of the\ngupta era which starts with his accession in a.d. 320.\nsamudragupta (330-380 a.d.)\nsamudragupta was the greatest of the rulers of the gupta\ndynasty. the allahabad pillar inscription provides a detailed account\nof his reign. it refers to three stages in his military campaign: sources\nthere are plenty of source materials to reconstruct the history\nof the gupta period. they include literary, epigraphical and\nnumismatic sources. the puranas throw light on the royal genealogy\nof the gupta kings. contemporary literary works like the\ndevichandraguptam and the mudhrakshasam written by\nvisakadatta provide information regarding the rise of the guptas.\nthe chinese traveler fahien, who visited india during the reign of\nchandragupta ii, has left a valuable account of the social, economic\nand religious conditions of the gupta empire.\napart from these literary sources, there are inscriptions like\nthe meherauli iron pillar inscription and the allahabad pillar\ninscription. the first refers to the achievements of chandragupta i.\nthe most important source for the reign of samudragupta is the\nallahabad pillar inscription. it describes his personality and\nlesson 9\ngupta empire\nlearning objectives\nstudents will acquire knowledge about\n1. the sources for the study of guptas.\n2. samudragupta’s achievements.\n3. the achievements of chandragupta ii.\n4. the importance of fahien’s visit to india.\n5. gupta administration, society and economy.\n6. literature, art, architecture and scientific development\nduring the gupta period.\nallahabad  pillar\ninscription\n\n99 98\n1. against some rulers of north india\n2. his famous dakshinapatha expedition against south indian\nrulers\n3. a second campaign against some other rulers of north india.\nin the first campaign samudragupta defeated achyuta and\nnagasena. achyuta was probably a naga ruler. nagasena belonged\nto the kota family which was ruling over the upper gangetic valley.\nthey were defeated and their states were annexed. as a result of\nthis short campaign, samudragupta had gained complete mastery\nover the upper gangetic valley.\nthen samudragupta marched against the south indian\nmonarchs. the allahabad pillar inscription mentions that\nsamudragupta defeated twelve rulers in his south indian expedition.\nthey were mahendra of kosala, vyaghraraja of mahakanthara,\nmantaraja of kaurala, mahendragiri of pishtapura, swamidatta of\nkottura, damana of erandapalla, vishnugupta of kanchi, nilaraja\nof avamukta, hastivarman of vengi, ugrasena of palakka, kubera\nof devarashtra and dhananjaya of kushtalapura. samudragupta’s\npolicy in south india was different. he did not destroy and annex\nthose kingdoms. instead, he defeated the rulers but gave them back\ntheir kingdoms. he only insisted on them to acknowledge his\nsuzerainty.\nthe third stage of samudragupta’s campaign was to eliminate\nhis remaining north indian rivals. he fought against nine kings,\nuprooted them and annexed their territories. they were rudradeva,\nmatila, nagadatta, chandravarman, ganapathinaga, nagasena,\nachyuta, nandin and balavarman. most of these rulers were\nmembers of the naga family, then ruling over different parts of north\nindia.\n\n101 100\nchandragupta ii (380-415 a.d.)\nsamudragupta was succeeded by his son chandragupta ii\nvikramaditya. but according to some scholars, the immediate\nsuccessor of samudragupta was ramagupta, the elder brother of\nchandragupta ii. but there is little historical proof for this.\nchandragupta ii inherited the military genius of his father and\nextended the gupta empire by his own conquests.\nhe achieved this by a judicious combination of the policy of\ndiplomacy and warfare. through matrimonial alliances he\nstrengthened his political power. he married kuberanaga, a naga\nprincess of central india. he gave his daughter prabhavati in marriage\nto the vakataka prince rudrasena ii. the political importance of\nthis marriage lies in the fact that the vakatakas occupied a\ngeographically strategic position in the deccan. this alliance served\na useful purpose when chandragupta-ii undertook his campaign in\nwestern india against the sakas.\nconquest of western india\nthe greatest of the military achievements of chandragupta ii\nwas his war against the saka satraps of western india. rudrasimha\niii, the last ruler of the saka satrap was defeated, dethroned and\nkilled. his territories in western malwa and the kathiawar peninsula\nwere annexed into the gupta empire. after this victory he performed\nthe horse sacrifice and assumed the title sakari, meaning, ‘destroyer\nof sakas’. he also called himself vikramaditya\nas a result of the conquest of western india, the western\nboundary of the empire reached to the arabian sea gaining access\nto broach, sopara, cambay and other sea ports. this enabled the\ngupta empire to control trade with the western countries. ujjain\nbecame an important commercial city and soon became the\nalternative capital of the guptas. the fine cotton clothes of bengal, after these military victories,\nsamudragupta performed the\nasvamedha sacrifice. he issued gold\nand silver coins with the legend\n‘restorer of the asvamedha’. it is\nbecause of his military achievements\nsamudragupta was hailed as ‘indian napoleon’.\nextant of samudragupta’s empire\nafter these conquests, samudragupta’s rule extended over\nthe upper gangetic valley, the greater part of modern u.p., a portion\nof central india and the southwestern part of bengal. these terri-\ntories were directly administered by him. in the south there were\ntributary states. the saka and kushana principalities on the west\nand northwest were within the sphere of his influence. the kingdoms\non the east coast of the deccan, as far as the pallava kingdom,\nacknowledged his suzerainty.\nestimate of samudragupta\nsamudragupta’s military achievements remain remarkable in\nthe annals of history. he was equally great in his other personal\naccomplishments. the allahabad pillar inscription speaks of his\nmagnanimity to his foes, his polished intellect, his poetic skill and\nhis proficiency in music. it calls him kaviraja because of his ability\nin composing verses. his image depicting him with veena is found\nin the coins issued by him. it is the proof of his proficiency and\ninterest in music. he was also a patron of many poets and scholars,\none of whom was harisena. thus he must be credited with a share\nin the promotion of sanskrit literature and learning, characteristic of\nhis dynasty. he was an ardent follower of vaishnavism but was\ntolerant of other creeds. he evinced keen interest in buddhism and\nwas the patron of the great buddhist scholar vasubandu.\ngold coins of samudragupta\n\n103 102\nthe unsatisfactory state of some of the buddhist holy places like\nkapilavastu and kusinagara. according to him the economic\ncondition of the empire was prosperous.\nalthough his account is valuable in many respects, he did not\nmention the name of chandragupta ii. he was not interested in\npolitical affairs. his interest was primarily religion. he assessed\neverything from the buddhist angle. his observations on social\nconditions are found to be exaggerated. yet, his accounts are useful\nto know the general condition of the country.\nestimate of chandragupta ii\nthe power and glory of gupta empire reached its peak under\nthe rule chandragupta ii vikramaditya. he also contributed to the\ngeneral cultural progress of the age and patronized great literary\nfigures like kalidasa. he promoted artistic activity. because of the\nhigh level of cultural progress that was achieved during this period,\nthe gupta period is generally referred to as a golden age. a detailed\naccount of the cultural progress in the gupta age is given below.\nsuccessors of chandragupta ii\nkumaragupta was the son and successor of chandragupta\nii. his reign was marked by general peace and prosperity. he issued\na number of coins and his inscriptions are found all over the gupta\nempire. he also performed an asvamedha sacrifice. most\nimportantly, he laid the foundation of the nalanda university which\nemerged an institution of international reputation. at the end of his\nreign, a powerful wealthy tribe called the ‘pushyamitras’ defeated\nthe gupta army. a branch of the huns from central asia made\nattempts to cross the hindukush mountains and invade india.\nbut it was his successor skandagupta who really faced the\nhun invasion. he fought successfully against the huns and saved\nthe empire. this war must have been a great strain on the indigo from bihar, silk from banares, the scents of the himalayas\nand the sandal and species from the south were brought to these\nports without any interference. the western traders poured roman\ngold into india in return for indian products. the great wealth of the\ngupta empire was manifest in the variety of gold coins issued by\nchandragupta ii.\nother conquests\nchandragupta ii defeated a confederacy of enemy chiefs in\nvanga. he also crossed the river sindh and conquered bactria. the\nkushanas ruling in this region were subdued by him. with these\nconquests, the gupta empire extended in the west as far as western\nmalwa, gujarat and kathiawar. in the northwest it extended beyond\nthe hindukush up to bactria. in the east, it included even eastern\nbengal and in the south the narmada river formed the boundary.\nfahien’s visit\nthe famous chinese pilgrim, fahien visited india during the\nreign of chandragupta ii. out of his nine years stay in india, he\nspent six years in the gupta empire. he came to india by the land\nroute through khotan, kashgar, gandhara and punjab. he visited\npeshawar, mathura, kanauj, sravasti, kapilavastu, kusinagara,\npataliputra, kasi and bodh gaya among other places. he returned\nby the sea route, visiting on the way ceylon and java. the main\npurpose of his visit was to see the land of the buddha and to collect\nbuddhist manuscripts from india. he stayed in pataliputra for three\nyears studying sanskrit and copying buddhist texts.\nfahien provides valuable information on the religious, social\nand economic condition of the gupta empire. according to him,\nbuddhism was in a flourishing condition in the northwestern india\nbut in the gangetic valley it was in a state of neglect. he refers to\nthe gangetic valley as the ‘land of brahmanism’. fahien mentions\n\n105 104\nadministration as he was able to travel without any fear throughout\nthe gangetic valley. on the whole the administration was more liberal\nthan that of the mauryas.\nsocial life\nthe pre-gupta period in india witnessed a series of foreign\ninvasions. indian society had given way to those foreigners who\nhad become permanent residents here. but during the gupta period,\nthe caste system became rigid. the brahmins occupied the top ladder\nof the society. they were given enormous gifts by the rulers as well\nas other wealthy people. the practice of untouchability had slowly\nbegun during this period. fahien mentions that chandalas were\nsegregated from the society. their miserable condition was\nelaborated by the chinese traveler.\nthe position of women had also become miserable during the\ngupta period. they were prohibited from studying the religious texts\nlike the puranas. the subjection of women to men was thoroughly\nregularized. but it was insisted that they should be protected and\ngenerously treated by men. the practice of swyamvara was given\nup and the manusmriti suggested the early marriage for girls.\nin the sphere of religion, brahmanism reigned supreme during\nthe gupta period. it had two branches - vaishnavism and saivism.\nmost of the gupta kings were vaishnavaites. they performed\naswamedha sacrifices. the worship of images and celebration of\nreligious festivals with elaborate rituals made these two religions\npopular. religious literature like the puranas was composed during\nthis period. the progress of brahmanism led to the neglect of\nbuddhism and jainism. fahien refers to the decline of buddhism in\nthe gangetic valley. but a few buddhist scholars like vasubandhu\nwere patronized by gupta kings. in western and southern india\njainism flourished. the great jain council was held at valabhi during\nthis period and the jain canon of the swetambras was written. government’s resources. after skandagupta’s death, many of his\nsuccessors like purugupta, narasimhagupta, buddhagupta and\nbaladitya could not save the gupta empire from the huns. ultimately,\nthe gupta power totally disappeared due to the hun invasions and\nlater by the rise of yasodharman in malwa.\ngupta administration\naccording inscriptions, the gupta kings assumed titles like\nparamabhattaraka, maharajadhiraja, parameswara, samrat\nand chakravartin. the king was assisted in his administration by\na council consisting of a chief minister, a senapati or commander-\nin-chief of the army and other important officials. a high official\ncalled sandivigraha was mentioned in the gupta inscriptions, most\nprobably minister for foreign affairs.\nthe king maintained a close contact with the provincial\nadministration through a class of officials called kumaramatyas\nand ayuktas. provinces in the gupta empire were known as bhuktis\nand provincial governors as uparikas. they were mostly chosen\nfrom among the princes. bhuktis were subdivided into vishyas or\ndistricts. they were governed by vishyapatis. nagara sreshtis\nwere the officers looking after the city administration. the villages\nin the district were under the control of gramikas.\nfahien’s account on the gupta administration provides useful\ninformation. he characterises the gupta administration as mild and\nbenevolent. there were no restrictions on people’s movements and\nthey enjoyed a large degree of personal freedom. there was no\nstate interference in the individual’s life. punishments were not severe.\nimposing a fine was a common punishment. there was no spy system.\nthe administration was so efficient that the roads were kept safe\nfor travelers, and there was no fear of thieves. he mentioned that\npeople were generally prosperous and the crimes were negligible.\nfahien had also appreciated the efficiency of the gupta\n\n107 106\nstatue of buddha, originally found at sultanganj now kept at\nbirmingham museum, was about seven and a half feet height and\nnearly a ton weight. the delhi iron pillar of the gupta period is still\nfree from rust though completely exposed to sun and rain for so\nmany centuries.\nthe paintings of the gupta period are seen at bagh caves\nnear gwalior. the mural paintings of ajantha mostly illustrate the\nlife of the buddha as depicted in the jataka stories. the paintings at\nsigiriya in sri lanka were highly influenced by the ajantha style.\n the gupta coinage was also remarkable. samudragupta\nissued eight types of gold coins. the legends on them throw much\nlight on the achievements of that marvelous king. the figures inscribed\non them are illustrative of the skill and greatness of gupta numismatic\nart. chandragupta ii and his successors had also issued gold, silver\nand copper coins of different varieties.\nliterature\nthe sanskrit language became prominent during the gupta\nperiod. nagari script had evolved from the brahmi script. numerous\nworks in classical sanskrit came to be written in the forms of epic,\nlyrics, drama and prose. the best of the sanskrit literature belonged\nto the gupta age.\nhimself a great poet, samudragupta patronized a number of\nscholars including harisena. the court of chandragupta ii was\nadorned by the celebrated navratnas. kalidasa remain the foremost\namong them. his master-piece was the sanskrit drama shakuntala.\nit is considered one among the ‘hundred best books of the world’.\nhe wrote two other plays - the malavikagnimitra and\nvikramorvasiya. his two well-known epics are raghuvamsa and\nkumarasambhava. ritusamhara and meghaduta are his two\nlyrics. art and culture\nthe gupta period witnessed a tremendous progress in the\nfield of art, science and literature and on account of this it has been\ncalled “a golden age”. a few scholars even call this period a period\nof renaissance. but it should be remembered that there was no dark\nperiod before the gupta rule. therefore the cultural progress\nwitnessed during the gupta period may be called the culmination of\nindian intellectual activities.\nart and architecture\nin the history of indian art and architecture, the gupta period\noccupies an important place. both the nagara and dravidian styles\nof art evolved during this period. but most of the architecture of this\nperiod had been lost due to foreign invasions\nlike that of huns. yet, the remaining temples,\nsculptures and cave paintings provide an\nidea about the grandeur of the gupta art.\nthe temple at deogarh near jhansi\nand the sculptures in the temple at garhwas\nnear allahabad remain important specimen\nof the gupta art. there was no influence of\ngandhara style. but the beautiful statue of\nstanding buddha at mathura reveals a little\ngreek style. the buddha statue unearthed\nat saranath was unique piece of gupta art.\nthe bhitari monolithic pillar of skandagupta\nis also remarkable.\nmetallurgy had also made a wonderful\nprogress during the gupta period. the\ncraftsmen were efficient in the art of casting\nmetal statues and pillars. the gigantic copper\ntemple at deogarh\n \na painting at bagh cave\n\n109 108\nin the field of medicine, vagbhata lived during this period. he\nwas the last of the great medical trio of ancient india. the other two\nscholars charaka and susruta lived before the gupta age. vagbhata\nwas the author ashtangasamgraha (summary of the eight branches\nof medicine).learning outcome\nafter learning this lesson the students will be able to explain\n1. the sources for the history of guptas like the allahabad\npillar inscription and their importance.\n2. samudragupta’s military achievements as well as his\npersonal accomplishments.\n3. the conquests of chandragupta ii and his other qualities\nincluding patron of art and literature.\n4. gupta administration, society and economic progress as\ndescribed by fahien, who visited india during this period.\n5. the growth of sanskrit literature and the contribution of\nscholars like kalidasa and visakadatta.\n6. the art and architecture of the gupta period as well as\nthe progress in science including the contribution of\naryabhatta and others.\nvisakadatta was another celebrated author of this period. he\nwas the author of two sanskrit dramas, mudrarakshasa and\ndevichandraguptam. sudraka was a renowned poet of this age\nand his book mrichchakatika is rich in humour and pathos.\nbharavi’s kritarjuniya is the story of the conflict between arjuna\nand siva. dandin was the author of kavyadarsa and\ndasakumaracharita. another important work of this period was\nvasavadatta written by subhandhu. the panchatantra stories\nwere composed by vishnusarma during the gupta period. the\nbuddhist author amarasimha compiled a lexicon called amarakosa.\nthe puranas in their present form were composed during this\nperiod. there are eighteen puranas. the most important among them\nare the bhagavatha, vishnu, vayu and matsya puranas. the\nmahabharatha and the ramayana were given final touches and\nwritten in the present form during this period.\nscience\nthe gupta period witnessed a brilliant activity in the sphere\nof mathematics, astronomy, astrology and medicine. aryabhatta was\na great mathematician and astronomer. he wrote the book\naryabhatiya in 499 a.d. it deals with mathematics and astronomy.\nit explains scientifically the occurrence of solar and lunar eclipses.\naryabhatta was the first to declare that the earth was spherical in\nshape and that it rotates on its own axis. however, these views\nwere rejected by later astronomers like varahamihira and\nbrahmagupta.\nvarahamihira composed pancha siddhantika, the five\nastronomical systems. he was also a great authority on astrology.\nhis work brihadsamhita is a great work in sanskrit literature. it\ndeals with a variety of subjects like astronomy, astrology, geography,\narchitecture, weather, animals, marriage and omens. his\nbrihadjataka is considered to be a standard work on astrology.\n\n111 110\niv. find out the correct statement. one statement alone is\nright.\na) samudragupta annexed all his conquered territories of south\nindia.\nb) the dakshinapatha expedition of samudragupta was\nmentioned by fahien.\nc) samudragupta defeated the south indian kings but gave them\nback their kingdoms.\nd) the north indian conquests of samudragupta did not result\nin the expansion of the gupta empire.\nv. state whether the following statements are true or false.\n1. the scholars known as navratnas lived during the reign of\nsamudragupta.\n2. the gupta empire declined due to the invasion of the huns.\n3. the gupta art adopted both the nagara and dravidian styles.\n4. the guptas patronized the sanskrit language.\nvi. write short notes (any three points).\n1. allahabad pillar inscription.\n2. dakshinapatha expedition of samudragupta.\n3. aryabhatta.\n4. metal artifacts under the guptas.\nvii. answer briefly (100 words).\n1. evaluate the impact of the conquest of western india by\nchandragupta ii. model questions\ni. choose the correct answer.\n1. the gupta era starts from the year\n(a) 310 a.d. (b) 320 a.d.\n(c) 330 a.d. (d) 300 a.d.\n2. the founder of the nalanda university\n(a) samudragupta(b) chandragupta ii\n(c) kumaragupta(d) skandagupta\n3. the physician who lived during the gupta age\n(a) varahamihira(b) vagbatha\n(c) charaka(d) susruta\nii. fill in the blanks.\n1. the founder of the gupta dynasty was …….\n2. the buddhist scholar vasubandhu was patronized by …….\n3. the title ‘sakari’ was assumed by …..\n4. the epics written by kalidasa are ……. and …….\n5. the author of brihatsamhita was …..\niii. match the following.\n1. meghadutaa) dandin\n2. devichandraguptamb) sudraka\n3. dasakumaracharitac) kalidasa\n4. mrichchakatikad) visakadatta\n\n113 112\nthe decline of the gupta empire was followed by a period of\npolitical disorder and disunity in north india. it was only in the\nbeginning of the seventh century a.d. that harshvardhana\nsucceeded in establishing a larger kingdom in north india.\nthe chief sources for tracing the history of harsha and his\ntimes are the harshacharita written by bana and the travel accounts\nof hiuen tsang. bana was the court poet of harsha. hiuen tsang\nwas the chinese traveler who visited india in the seventh century\na.d. besides these two sources, the dramas written by harsha,\nnamely ratnavali, nagananda and priyardarsika also provide\nuseful information. the madhuben plate inscription and the sonpat\ninscription are also helpful to know the chronology of harsha. the\nbanskhera inscription contains the signature of harsha.\nearly life of harsha\nthe founder of the family of harsha was pushyabhuti.\npushyabhutis were the feudatories of the guptas. they called\nlesson 10\nharshavardhana (606 – 647 a.d.)\nlearning objectives\nstudents will acquire knowledge about\n1. sources for the study of harsha.\n2. the early life of harsha.\n3. the military activities of harsha.\n4. harsha’s contribution to buddhism.\n5. nalanda university.\n2. write a brief account of fahien’s visit to india and his\nobservation on india.\n3. examine the salient features of the gupta administration.\nviii.answer in detail (200 words).\n1. give an account of the achievements of samudragupta.\n2. describe the socio-economic life under the rule of guptas.\n3. examine the cultural contributions of the guptas.\n\n115 114\nharsha led another campaign against the ruler of sindh, which\nwas an independent kingdom. but, it is doubtful whether his sind\ncampaign was a successful one. nepal had accepted harsha’s\noverlordship. harsha established his control over kashmir and its\nruler sent tributes to him. he also maintained cordial relations with\nbhaskaravarman, the ruler of assam. harsha’s last military campaign\nwas against the kingdom of kalinga in orissa and it was a success.\nthus harsha established his hold over the whole of north\nindia. the regions modern rajasthan, punjab, uttar pradesh, bihar\nand orissa were under his direct control. but his sphere of influence\nwas much more extensive. the peripheral states such as kashmir,\nsind, valabhi and kamarupa acknowledged his sovereignty.\nharsha and buddhism\nin his early life, harsha was a devout\nsaiva but later he became an ardent hinayana\nbuddhist. hiuen tsang converted him to\nmahayana buddhism. harsha prohibited the\nuse of animal food in his kingdom and punished\nthose who kill any living being. he erected\nthousands of stupas and established travellers’\nrests all over his kingdom. he also erected\nmonasteries at the sacred places of buddhists.\nonce in five years he convened a gathering of\nrepresentatives of all religions and honoured\nthem with gifts and costly presents. he brought the buddhist monks\ntogether frequently to discuss and examine the buddhist doctrine.\nkanauj assembly\nharsha organized a religious assembly at kanauj to honour\nthe chinese pilgrim hiuen tsang towards the close of his reign. he\ninvited representatives of all religious sects. it was attended by 20\nhiuen tsang \nthemselves vardhanas. after the hun invasions they assumed\nindependence. the first important king of pushyabhuti dynasty was\nprabhakaravardhana. his capital was thaneswar, north of delhi.\nhe assumed the title maharajadhiraja and paramabhattaraka.\nafter prabhakaravardhana’s death, his elder son\nrajyavardhana came to the throne. he had to face problems right\nfrom the time of his accession. his sister, rajyasri had married the\nmaukhari ruler called grihavarman. the ruler of malwa, devagupta\nin league with sasanka, the ruler of bengal had killed grihavarman.\nimmediately on hearing this news, rajyavardhana marched against\nthe king of malwa and routed his army. but before he could return\nto his capital, he was treacherously murdered by sasanka. in the\nmeantime, rajyasri escaped into forests. harsha now succeeded\nhis brother at thaneswar. his first responsibility was to rescue his\nsister and to avenge the killings of his brother and brother-in-law.\nhe first rescued his sister when she was about to immolate herself.\nharsha’s military conquests\nin his first expedition, harsha drove out sasanka from kanauj.\nhe made kanauj his new capital. this made him the most powerful\nruler of north india. harsha fought against dhuruvasena ii of valabhi\nand defeated him. dhuruvasena ii became a vassal.\nthe most important military campaign of harsha was against\nthe western chalukya ruler pulakesin ii. both the accounts of hiuen\ntsang and the inscriptions of pulakesin ii provide the details of this\ncampaign. harsha with an ambition to extend his kingdom south of\nthe narmada river marched against the chalukya ruler. but the aihole\ninscription of pulakesin ii mentions the defeat of harsha by\npulakesin, who after this achievement assumed the title\nparamesvara. hiuen tsang’s accounts also confirm the victory of\npulakesin.\n\n117 116\nknown as nilopitu and it was under the control of special officers.\nboth good and bad events happened during his time had been\nrecorded.\nsociety and economy under harsha\nboth bana and hiuen tsang portray the social life in the times\nof harsha. the fourfold division of the society – brahmin, kshatriya,\nvysya and sudra – was prevalent. the brahmins were the privileged\nsection of the society and they were given land grants by the kings.\nthe kshatriyas were the ruling class. the vysyas were mainly traders.\nhiuen tsang mentions that the sudras practiced agriculture. there\nexisted many sub castes. the position of women was not satisfactory.\nthe institution of swyamvara (the choice of choosing her husband)\nhad declined. remarriage of widows was not permitted, particularly\namong the higher castes. the system of dowry had also become\ncommon. the practice of sati was also prevalent. hiuen tsang\nmentions three ways of disposal of the dead – cremation, water\nburial and exposure in the woods.\nthe trade and commerce had declined during harsha’s period.\nthis is evident from the decline of trade centres, less number of\ncoins, and slow activities of merchant guilds. the decline of trade in\nturn affected the handicrafts industry and agriculture. since there\nwas no large scale demand for goods, the farmers began to produce\nonly in a limited way. this led to the rise of self-sufficient village\neconomy. in short, there was a sharp economic decline as compared\nto the economy of the gupta period.\ncultural progress\nthe art and architecture of harsha’s period are very few and\nmostly followed the gupta style. hiuen tsang describes the glory of\nthe monastery with many storeys built by harsha at nalanda. he\nalso speaks of a copper statue of buddha with eight feet in height. kings, 1000 scholars from the nalanda university, 3000 hinayanists\nand mahayanists, 3000 brahmins and jains. the assembly went\non continuously for 23 days. hiuen tsang explained the values of\nmahayana doctrine and established its superiority over others.\nhowever, violence broke out and there were acts of arson. there\nwas also an attempt on the life of harsha. soon, it was brought\nunder control and the guilty were punished. on the final day of the\nassembly, hiuen tsang was honoured with costly presents.\nallahabad conference\nhiuen tsang mentions in his account about the conference\nheld at allahabad, known as prayag. it was the one among the\nconferences routinely convened by harsha once in five years. harsha\ngave away his enormous wealth as gifts to the members of all religious\nsects. according to hiuen tsang, harsha was so lavish that he\nemptied the treasury and even gave away the clothes and jewels he\nwas wearing. his statement might be one of admiring exaggeration.\nharsha’s administration\nthe administration of harsha was organized on the same lines\nas the guptas did. hiuen tsang gives a detailed picture about this.\nthe king was just in his administration and punctual in discharging\nhis duties. he made frequent visits of inspection throughout his\ndominion. the day was too short for him. taxation was also light\nand forced labour was also rare. one sixth of the produce was\ncollected as land tax. cruel punishments of the mauryan period\ncontinued in the times of harsha. hiuen tsang condemned the trials\nas barbarous and superstitious. harsha’s army consisted of the\ntraditional four divisions – foot, horse, chariot and elephant. the\nnumber of cavalry was more than one lakh and the elephants more\nthan sixty thousands. this was much more than that of the mauryan\narmy. the maintenance of public records was the salient feature of\nharsha’s administration. the archive of the harsha period was\n\n119 118\nrulers. though it was a mahayana university, different religious\nsubjects like the vedas, hinayana doctrine, sankhya and yoga\nphilosophies were also taught. in addition to that, general subjects\nlike logic, grammar, astronomy, medicine and art were in the syllabus.\nit attracted students not only from different parts of india but from\ndifferent countries of the east. admission was made by means of an\nentrance examination. the entrance test was so difficult that not\nmore than thirty percent of the candidates were successful. discipline\nwas very strict. more than lectures, discussion played an important\npart and the medium of instruction was sanskrit.\nrecent archeological excavations have brought to light the ruins\nof the nalanda university. it shows the grandeur of this centre of learning\nand confirms the account given by the chinese pilgrims. it had numerous\nclassrooms and a hostel attached to it. according to itsing, the chinese\npilgrim, there were 3000 students on its rolls. it had an observatory\nand a great library housed in three buildings. its fame rests on the fact\nthat it attracted scholars from various parts of the world. it was an\ninstitution of advanced learning and research.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. the sources for the study of harsha such as harshacharita\nand the travel accounts of hiuen tsang.\n2. harsha’s early life and his military adventures.\n3. harsha and his services to buddhism like the kanauj\nassembly and allahabad conference.\n4. socio-economic condition and cultural development\nunder the rule of harsha.\n5. the nalanda university and its international reputation.\nthe brick temple of lakshmana at sirpur with its rich architecture\nis assigned to the period of harsha.\nharsha was a great patron of learning. his biographer\nbanabhatta adorned his royal court. besides harshacharita, he\nwrote kadambari. other literary figures in harsha’s court were\nmatanga divakara and the famous barthrihari, who was the poet,\nphilosopher and grammarian. harsha himself authored three plays -\nratnavali, priyadarsika and nagananda. harsha patronised the\nnalanda university by his liberal endowments. it attained\ninternational reputation as a centre of learning during his reign. hiuen\ntsang visited the nalanda university and remained as a student for\nsome time.\nnalanda university\nthe chinese travelers of ancient india mentioned a number of\neducational institutions. the most famous among them were the\nhinayana university of valabhi and the mahayana university of\nnalanda. hiuen tsang gives a very\nvaluable account of the nalanda\nuniversity. the term nalanda means\n“giver of knowledge”. it was founded\nby kumaragupta i during the gupta\nperiod. it was patronised by his\nsuccessors and later by harsha. the\nprofessors of the university were\ncalled panditas. some of its\nrenowned professors were dingnaga, dharmapala, sthiramati and\nsilabadhra. dharmapala was a native of kanchipuram and he\nbecame the head of the nalanda university.\nnalanda university was a residential university and education\nwas free including the boarding and lodging. it was maintained with\nthe revenue derived from 100 to 200 villages endowed by different\nruins of nalanda university\n\n121 120\nc) kanauj assembly was an assembly convened by harsha once\nin five years.\nd) the kanauj assembly went on peacefully without any religious\nstrife.\nv. state whether the following statements are true or\nfalse.\n1. baskaravarman was the ruler of kashmir.\n2. harsha patronized the hinayana sect of buddhism.\n3. there was all-round economic prosperity during the reign of\nharsha.\nvi. write short notes (any three points).\n1. sources for the study of harsha.\n2. travel accounts of hiuen tsang.\n3. kanuaj assembly.\n4. allahabad conference.\nvii. answer briefly (100 words).\n1. bring out the cultural progress under the rule of harsha.\n2. write a brief account of the nalanda university.\nviii.answer in detail (200 words).\n1. give an account of the life and achievements of\nharshavardhana.\n2. estimate the contributions of harsha to buddhism.\n3. describe the administration and society under harsha as\nexplained by hiuen tsang. model questions\ni. choose the correct answer.\n1. the original capital of harshavardhana was\n(a) pataliputra(b) peshavar\n(c) thaneshwar (d) delhi\n2. the banskhera inscription contains the signature of\n(a) hiuen tsang(b) bana\n(c) harsha (d) pulakesin ii\nii.  fill in the blanks.\n1. the new capital established by harsha was ……\n2. the archive of the harsha period was known as ……\n3. dhuruvasena ii was the ruler of …..\niii. match the following.\n1. bana a) author of three plays\n2. dharmapala b) poet and philosopher\n3. bharthrihari c) biographer of harsha\n4. harsha d) head of the nalanda university\niv. find out the correct statement. one statement alone is\nright.\na) the kanauj assembly was organized by harsha to honour\nhiuen tsang.\nb) representatives of mahayana buddhism were alone invited\nto the kanauj assembly.\n\n123 122\ntherefore, the view that the pallavas were the natives of\ntondaimandalam itself was widely accepted by scholars. they are\nalso identical with the pulindas mentioned in the inscriptions of\nasoka. when tondaimandalam was conquered by the satavahanas,\nthe pallavas became their feudatories. after the fall of the\nsatavahanas in the third century a.d., they became independent.\nthe pallavas issued their earlier inscriptions in prakrit and sanskrit\nbecause of their satavahana connections, and also patronised\nbrahmanism.\npolitical history\nthe early pallava rulers from 250 a.d. to 350 a.d. issued\ntheir charters in prakrit. important among them were\nsivaskandavarman and vijayaskandavarman. the second line of\npallava rulers who ruled between 350 a.d. and 550 a.d. issued\ntheir charters in sanskrit. the most important ruler of this line was\nvishnugopa who was defeated by samudragupta during his south\nindian expedition. the rulers of the third line who ruled from 575\na.d. to their ultimate fall in the ninth century issued their charters\nboth in sanskrit and tamil. simhavishnu was the first ruler of this\nline. he destroyed the kalabhras and firmly established the pallava\nrule in tondaimandalam. he also defeated the cholas and extended\nthe pallava territory up to the river kaveri. other great pallava rulers\nof this line were mahendravarman i, narasimhavarman i, and\nnarasimhavarman ii.\nmahendravarman i (600 – 630 a.d.)\nthe long-drawn pallava – chalukya conflict began during\nhis period. pulakesin ii marched against the pallavas and captured\nthe northern part of their kingdom. although a pallava inscription\nrefers to the victory of mahendravarman i at pullalur, he was not\nable to recover the lost territory.\nlesson 11\nsouth indian kingdoms – i\npallavas\nafter the decline of the sangam age in the tamil country, the\nkalabhra rule lasted for about 250 years. thereafter, the pallavas\nestablished their kingdom in tondaimandalam with its capital at\nkanchipuram. their rule continued till tondaimandalam was captured\nand annexed by the imperial cholas in the beginning of the tenth\ncentury a.d.\norigin of the pallavas\nthere are different views on the origin of the pallavas. they\nwere equated with the parthians, the foreigners who ruled western\nindia. another view was that the pallavas were a branch of the\nbrahmin royal dynasty of the vakatakas of the deccan. the third\nview relates the pallavas with the descendents of the chola prince\nand a naga princess whose native was the island of manipallavam.\nbut these theories on the origin of the pallavas were not supported\nby adequate evidences.learning objectives\nstudents will acquire knowledge about\n1. origin of the pallavas.\n2. achievements of  mahendravarman i, narasimhavarman i\nand rajasimha.\n3. administration of the pallavas.\n4. education and literature under the pallavas.\n5. art and architecture of the pallavas.\n\n125 124\nmonasteries in which about 10,000 buddhist monks lived. according\nto his account the people of kanchi esteemed great learning and\nthe ghatika at kanchi served as a great centre of learning.\nnarasimhavarman i was the founder of mamallapuram and the\nmonolithic rathas were erected during his reign.\nnarasimhavarman ii or rajasimha (695 -722 a.d.)\nnarasimhavarman i was succeeded by mahendravarman ii\nand parameswarvarman i and the pallava – chalukya conflict\ncontinued during their reign. thereafter, narasimhavarman ii\nbecame the ruler of the pallava kingdom. he was also known as\nrajasimha. his regime was peaceful and he evinced more interest\nin developing the art and architecture. the shore temple at\nmamallapuram and the kailasanatha temple at kanchipuram were\nbuilt in this period. he was also a great patron of art and letters.\nthe famous sanskrit scholar dandin is said to have adorned his\ncourt. he sent embassies to china and the maritime trade flourished\nduring his reign. rajasimha assumed titles like sankarabhakta,\nvadhyavidyadhara and agamapriya.\nhe was succeeded by parameswaravarman ii and\nnandivarman ii. the pallava rule lasted till the end of the ninth\ncentury a.d. the chola king aditya i defeated the last pallava\nruler aparajita and seized the kanchi region. with this, the rule of\npallava dynasty came to an end.\nadministration of the pallavas\nthe pallavas had a well organized administrative system. the\npallava state was divided into kottams. the kottam was\nadministered by officers appointed by the king. the king was at the\ncentre of administration in which he was assisted by able ministers.\nhe was the fountain of justice. he maintained a well-trained army.\nhe provided land-grants to the temples known as devadhana and mahendravarman i was a follower of jainism in the early part\nof his career. he was converted to saivism by the influence of the\nsaiva saint, thirunavukkarasar alias appar. he built a siva temple\nat tiruvadi. he assumed a number of titles like gunabhara,\nsatyasandha, chettakari (builder of temples) chitrakarapuli,\nvichitrachitta and  mattavilasa.\nhe was a great builder of cave temples. the mandagappattu\ninscription hails him as vichitrachitta who constructed a temple for\nbrahma, vishnu and siva without the use of bricks, timber, metal\nand mortar. his rock-cut temples are found in a number of places\nlike vallam, mahendravadi, dalavanur, pallavaram, mandagappattu\nand tiruchirappalli. he had also authored the sanskrit work\nmattavilasa prahasanam. his title chitrakarapuli reveals his talents\nin painting. he is also regarded as an expert in music. the music\ninscription at kudumianmalai is ascribed to him.\nnarasimhavarman i (630-668 a.d.)\nnarasimhavarman i was also known as mamalla, which means\n‘great wrestler’. he wanted to take avenge the defeat of his father\nat the hands of chalukyan ruler pulakesin ii. his victory over\npulakesin ii in the battle of manimangalam near kanchi is mentioned\nin kuram copper plates. the pallava army under general paranjothi\npursued the retreating chalukya army, entered chalukya territory,\ncaptured and destroyed the capital city of vatapi. narasimhavarman\ni assumed the title ‘vatapikonda’. he regained the lost territory.\nanother notable achievement of narasimhavarman i was his naval\nexpedition to sri lanka. he restored the throne to his friend and\nsri lankan prince manavarma.\nduring his reign, hiuen tsang visited the pallava capital\nkanchipuram. his description of kanchi is vivid. he calls it a big\nand beautiful city, six miles in circumference. it had 100 buddhist\n\n127 126\nabroad. the founder of the kadamba dynasty, mayurasarman\nstudied vedas at kanchi. dinganaga, a buddhist writer came to\nstudy at kanchi. dharmapala, who later became the head of the\nnalanada university, belonged to kanchi. bharavi, the great sanskrit\nscholar lived in the time of simhavishnu. dandin, another sanskrit\nwriter adorned the court of narasimhavarman ii. mahendravaraman\ni composed the sanskrit play mattavilasaprahasanam. tamil\nliterature had also developed. the nayanmars and alwars composed\nreligious hymns in tamil. the devaram composed by nayanmars\nand the nalayradivyaprabandam composed by alwars represent\nthe religious literature of the pallava period. perundevanar was\npatronized by nandivarman ii and he translated the mahabharata\nas bharathavenba in tamil. nandikkalambagam was another\nimportant work but the name of the author of this work is not known.\nmusic and dance also developed during this period.\npallava art and architecture\nit was a great age of temple building. the pallavas introduced\nthe art of excavating temples from the rock. in fact, the dravidian\nstyle of temple architecture began with\nthe pallava rule. it was a gradual\nevolution starting from the cave\ntemples to monolithic rathas and\nculminated in structural temples. the\ndevelopment of temple architecture\nunder the pallavas can be seen in four\nstages.\nmahendravarman i introduced the rock-cut temples. this style\nof pallava temples are seen at places like mandagappattu,\nmahendravadi, mamandur, dalavanur, tiruchirappalli, vallam,\nsiyamangalam and tirukalukkunram.\nalso to the brahmans known as brahmadeya. it was also the\nresponsibility of the central government to provide irrigation facilities\nto the lands. a number of irrigation tanks were dug by the pallava\nkings. the irrigation tanks at mahendravadi and mamandoor were\ndug during the reign of mahendravarman i. detailed information on\nthe tax system could also be traced from the pallava inscriptions.\nland tax was the primary source of the government revenue. the\nbrahmadeya and devadhana lands were exempted from tax.\ntraders and artisans such as carpenters, goldsmiths, washer-men,\noil-pressers and weavers paid taxes to the government. the pallava\ninscriptions throw much light on the village assemblies called sabhas\nand their committees. they maintained records of all village lands,\nlooked after local affairs and managed temples.\nsociety under the pallavas\nthe tamil society witnessed a great change during the pallava\nperiod. the caste system became rigid. the brahmins occupied a\nhigh place in the society. they were given land-grants by the kings\nand nobles. they were also given the responsibility of looking after\nthe temples. the pallava period also witnessed the rise of saivism\nand vaishnavism and also the decline of buddhism and jainism. the\nsaiva nayanmars and the vaishnava alwars contributed to the\ngrowth of saivism and vaishnavism. this is known as the bakthi\nmovement. they composed their hymns in the tamil language. these\nhymns revealed the importance of devotion or bakthi. the\nconstruction of temples by the pallava kings paved the way for the\nspread of these two religions.\neducation and literature\nthe pallavas were great patrons of learning. their capital\nkanchi was an ancient centre of learning. the ghatika at kanchi\nwas popular and it attracted students from all parts of india and\nrathas at mamallapuram\n\n129 128\nas the theme of these sculptures such\nas the figures of lice-picking monkey,\nelephants of huge size and the figure\nof the ‘ascetic cat’ standing erect\nremain the proof for the talent of the\nsculptor.\nfine arts\nmusic, dance and painting had also developed under the\npatronage of the pallavas. the mamandur inscription contains a\nnote on the notation of vocal music. the kudumianmalai inscription\nreferred to musical notes and instruments. the alwars and\nnayanmars composed their hymns in various musical notes. dance\nand drama also developed during this period. the sculptures of this\nperiod depict many dancing postures. the sittannavasal paintings\nbelonged to this period. the commentary called dakshinchitra was\ncompiled during the reign of mahendravarman i, who had the title\nchittirakkarapuli.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. the different theories about the origin of the pallavas.\n2. the political history of the pallavas and their military\naccomplishments\n3. administrative system under the pallavas.\n4. their cultural contributions.\n5. architectural achievements of the pallavas.\nthe fall of ganges\nthe second stage of pallava architecture is represented by\nthe monolithic rathas and mandapas found at mamallapuram.\nnarasimhavarman i took the credit for these wonderful architectural\nmonuments. the five rathas, popularly called as the\npanchapanadava rathas, signifies five different styles of temple\narchitecture. the mandapas contain beautiful sculptures on its walls.\nthe most popular of these mandapas are mahishasuramardhini\nmandapa, tirumurthi mandapam and varaha madapam.\nin the next stage, rajasimha\nintroduced the structural temples.\nthese temples were built by using\nthe soft sand rocks. the\nkailasanatha temple at kanchi and\nthe shore temple at mamallapuram\nremain the finest examples of the\nearly structural temples of the\npallavas. the kailasanatha temple\nat kanchi is the greatest\narchitectural master piece of the pallava art.\nthe last stage of the pallava art is also represented by structural\ntemples built by the later pallavas. the vaikundaperumal temple,\nmuktheeswara temple and matagenswara temples at kanchipuram\nbelong to this stage of architecture.\nthe pallavas had also contributed to the development of\nsculpture. apart from the sculptures found\nin the temples, the ‘open art gallery’ at\nmamallapuram remains an important\nmonument bearing the sculptural beauty of\nthis period. the descent of the ganges or\nthe penance of arjuna is called a fresco\npainting in stone. the minute details as well\n \nkailasanatha temple at\nkanchipuram\n \nshore temple at\nmamallapuram\n\n131 130\nd) both vaishnavism and saivism flourished during pallava\nperiod.\nv. state whether the following statements are true or\nfalse.\n1. the sangam age was followed by the pallava rule.\n2. mahendravarman i was a follower of jainism in the early part\nof his career.\n3. monolithic rathas were erected at kanchipuram by\nnarasimhavarman i.\nvi. write short notes (any three points).\n1. origin of the pallavas.\n2. ghatika at kanchi.\n3. pallava chalukya conflict.\n4. bakthi movement.\n5. fine arts under the pallavas.\nvii. answer briefly (100 words).\n1. give an account of the reign of mahendravarman i.\n2. write a brief account on the military accomplishments of\nnarasimhavarman i.\n3. examine the administration system of the pallavas.\n4. write a note on the social life under the pallavas.\nviii.answer in detail (200 words).\n1. give an account of the political history of the pallavas.\n2. assess the cultural contributions of the pallavas.\n3. mention the salient features of the pallava art. model questions\ni. choose the correct answer.\n1. the pallava ruler who destroyed the kalabhras\n(a) vishnugopa(b) simhavishnu\n(c) mahendravarman i(d) rajasimha\n2. hiuen tsang visited kanchi during the reign of\n(a) mahendravarman i(b) narasimhavarman i\n(c) rajasimha(d) nandivarman iii\nii. fill in the blanks.\n1. the saiva saint who converted mahendravarman i to saivism\nwas ……\n2. the commander of the pallava army who destroyed vatapi\n……\n3. the title mamalla was assumed by ……\niii. match the following.\n1. perundevanar a) nalayiradivyaprabandam\n2. alwars b) devaram\n3. nayanmars c) mattavilasaprakasanam\n4. mahendravarman i d) bharathavenba\niv. find out the correct statement. one statement alone is\nright.\na) pallava period witnessed the decline of the sanskrit language.\nb) rajasimha destroyed vatapi and assumed the title\nvatapikondan.\nc) mahendravarman introduced the style of building structural\ntemples.\n\n133 132\nhe fought with the kadambas of banavasi and the gangas of\nmysore and established his suzerainty. durvinita, the ganga ruler\naccepted his overlordship and even gave his daughter in marriage\nto pulakesin ii. another notable achievement of pulakesin ii was\nthe defeat of harshavardhana on the banks of the river narmada.\nhe put a check to the ambition of harsha to conquer the south. in\nhis first expedition against the pallavas, pulakesin ii emerged\nvictorious. but he suffered a humiliating defeat at the hands of\nnarasimhavarman i near kanchi. subsequently, the chalukya capital\nvatapi was captured and destroyed by the pallavas. the most\nimportant event in the reign of pulakesin ii was the visit of hiuen\ntsang to his kingdom.\nthe successor of pulakesin ii was vikramaditya. he once again\nconsolidated the chalukya kingdom and plundered the pallava capital,\nkanchi. thus he had avenged his father ’s defeat and death at the hands\nof the pallavas. kirtivarman ii was the last of the rulers of the chalukyas.\nhe was defeated by dantidurga, the founder of the rashtrakuta dynasty.\nadministration and social life under the chalukyas\nthe chalukya administration was highly centralized unlike that\nof the pallavas and the cholas. village autonomy was absent under\nthe chalukyas. the chalukyas had a great maritime power. pulakesin\nii had 100 ships in his navy. they also had a small standing army.\nthe badami chalukyas were brahmanical hindus but they\ngave respect to other religions. importance was given to vedic rites\nand rituals. the founder of the dynasty pulakesin i performed the\nasvamedha sacrifice. a number of temples in honour of vishnu,\nsiva and other gods were also built during this period. hiuen tsang\nmentioned about the decline of buddhism in western deccan. but\njainism was steadily on the path of progress in this region. ravikirti,\nthe court poet of pulakesin ii who composed the aihole inscription\nwas a jain. besides the pallavas, the western chalukyas and the\nrashtrakutas in the deccan constitute important political forces.\nboth these kingdoms had their rivals in the far south, namely the\npallavas and later the cholas. their period has also been important\nin the history of india for their cultural contributions.\nchalukyas (543 – 755 a.d.)\nthe western chalukyas ruled over an extensive area in the\ndeccan for about two centuries after which the rashtrakutas became\npowerful. the family of western chalukyas had its offshoots like\nthe eastern chalukyas of vengi and the chalukyas of kalyani.\npulakesin i was the founder of the chalukya dynasty. he established\na small kingdom with vatapi or badami as its capital.\npulakesin ii (608-642 a.d.)\nthe most important ruler of this dynasty was pulakesin ii.\nthe aihole inscription issued by him gives the details of his reign.\nlesson 12\nsouth indian kingdoms – ii\nchalukyas and rashtrakutaslearning objectives\nstudents will acquire knowledge about\n1. the achievements of chalukya ruler pulakesin ii.\n2. administration, social life and art and architecture under\nthe chalukyas.\n3. political history of the rashtrakutas.\n4. administration and society under the rashtrakutas.\n5. art and architecture of the rashtrakutas.\n\n135 134\nthe second stage is\nrepresented by the temples at\npattadakal. there are ten temples\nhere, four in the northern style and\nthe remaining six in the dravidian\nstyle. the papanatha temple is the\nmost notable in the northern style.\nthe sangamesvara temple and the\nvirupaksha temple are famous for their dravidian style. the\nvirupaksha temple is built on the model of the kailasanatha temple\nat kanchipuram. it was built by one of the queens of vikramaditya\nii. sculptors brought from kanchi were employed in its construction.\nrashtrakutas (755 – 975 a.d.)\nthe rashtrakutas were of kannada origin and kannada\nlanguage was their mother tongue. dantidurga was the founder of\nthe rashtrakuta dynasty. he defeated the gurjaras and captured\nmalwa from them. then he annexed the chalukya kingdom by\ndefeating kirtivarman ii. thus, the rashtrakutas became a\nparamount power in the deccan.\nhis successor krishna i was also a great conqueror. he\ndefeated the gangas and the eastern chalukyas of vengi. he built\nthe magnificent rock-cut monolithic kailasa temple at ellora. the\nnext important king of this dynasty was govinda iii. he achieved\nvictories over north indian kingdoms.\nhis successor amoghavarsha i (815- 880 a.d.) ruled for a\nlong period of 64 years. he had lost control over malwa and\ngangavadi. yet, his reign was popular for the cultural development.\nhe was a follower of jainism. jinasena was his chief preceptor. he\nwas also a patron of letters and he himself wrote the famous kannada\nwork, kavirajamarga. he had also built the rashtrakuta capital,\nthe city of malkhed or manyakheda.\n \nvirupaksha temple at\npattadakkal\nart and architecture\nthe chalukyas were great patrons\nof art. they developed the vesara style\nin the building of structural temples.\nhowever, the vesara style reached its\nculmination only under the rashtrakutas\nand the hoysalas. the structural temples\nof the chalukyas exist at aihole, badami\nand pattadakal. cave temple architecture was also famous under the\nchalukyas. their cave temples are found in ajanta, ellora and nasik.\nthe best specimens of chalukya paintings can be seen in the badami\ncave temple and in the ajanta caves. the reception given to a persian\nembassy by pulakesin ii is depicted in a painting at ajantha.\nthe chalukya temples may be divided into two stages. the\nfirst stage is represented by the temples at aihole and badami.\namong the seventy temples found at aihole, four are important.\n1. ladh khan temple is a low, flat-roofed structure\nconsisting of a pillared hall.\n2. durga temple resembles a buddha chaitya.\n3. huchimalligudi temple.\n4. the jain temple at meguti.\namong the temples at badami,\nthe muktheeswara temple and the\nmelagutti sivalaya are notable for\ntheir architectural beauty. a group of\nfour rock-cut temples at badami are\nmarked by high workmanship. the\nwalls and pillared halls are adorned\nby beautiful images of gods and\nhuman beings.\ncave temple at ajanta \n \ncave temple at badami\n\n137 136\ncultural contributions\nthe rashtrakutas widely patronized the sanskrit literature.\nthere were many scholars in the rashtrakuta court. trivikrama wrote\nnalachampu and the kavirahasya was composed by halayudha\nduring the reign of krishna iii. the jain literature flourished under\nthe patronage of the rashtrakutas. amogavarsha i, who was a jain\npatronized many jain scholars. his teacher jinasena composed\nparsvabhudaya, a biography of parsva in verses. another scholar\ngunabhadra wrote the adipurana, the life stories of various jain\nsaints. sakatayana wrote the grammer work called amogavritti.\nthe great mathematician of this period, viracharya was the author\nof ganitasaram.\nthe kannada literature saw its beginning during the period of\nthe rashtrakutas. amogavarsha’s kavirajamarga was the first\npoetic work in kannada language. pampa was the greatest of the\nkannada poets. his famous work was\nvikramasenavijaya. ponna was another\nfamous kannada poet and he wrote\nsantipurana.\nart and architecture\nthe art and architecture of the\nrashtrakutas were found at ellora and\nelephanta. at ellora, the most remarkable\ntemple is the kailasa temple. it was excavated\nduring the reign of krishna i. it is carved out of\na massive block of rock 200 feet long, and 100\nfeet in breadth and height. the temple consists\nof four parts - the main shrine, the entrance gateway, an intermediate\nshrine for nandi and mandapa surrounding the courtyard. the temple\nstands on a lofty plinth 25 feet high. the central face of the plinth has\nkailasa temple\nat ellora\namong the successors of amoghavarsha i, krishna iii (936-\n968 a.d.) was famous for his expeditions. he marched against the\ncholas and defeated them at takkolam. he marched further south\nand captured tanjore. he went as far as rameswaram and occupied\nit for sometime. he built several temples in the conquered territories\nincluding the krishneswara temple at rameswaram. throughout his\nreign he possessed the tondaimandalam region including the capital\nkanchi. after his death, the power of the rashtrakutas declined.\nadministration\nthe rashtrakuta empire was divided into several provinces called\nrashtras under the control of rashtrapatis. they were further divided\ninto vishayas or districts governed by vishayapatis. the next\nsubdivision was bhukti consisting of 50 to 70 villages under the control\nof bhogapatis. these officers were directly appointed by the central\ngovernment. the village administration was carried on by the village\nheadmen. however, the village assemblies played a significant role in\nthe village administration.\nsociety and economy\nthe hindu sects of vaishnavism and saivism flourished during\nthe period of rashtrakutas. yet, they did not affect the progress of\njainism under the patronage of rashtrakuta kings and officers. almost\none third of the population of the deccan were jains. there were some\nprosperous buddhist settlements at places like kanheri, sholapur and\ndharwar. there was harmony among various religions. there was a\ncollege at salatogi, situated in modern bijapur district. an inscription\ngives details of this educational centre. it was run by the income from\nthe endowments made by the rich as well as by all the villagers on\noccasions of functions and festivals.\nthe economy was also in a flourishing condition. there was an\nactive commerce between the deccan and the arabs. the rashtrakuta\nkings promoted the arab trade by maintaining friendship with them.\n\n139 138\nmodel questions\ni. choose the correct answer.\n1. aihole inscription was issued by\n(a) amoghavarsha i(b) pulakesin ii\n(c) govinda iii (d) dantidurga\n2. who among the following defeated the cholas at takkolam?\n(a) pulakesin ii(b) amoghavarsha i\n(c) vikramaditya i(d) krishna iii\nii. fill in the blanks.\n1. …… was the capital of rashtrakutas.\n2. the founder of the rashtrakuta dynasty was …..\n3. sripuri was renamed as elephanta by ……\niii. match the following.\n1. ravikirti a) vikramasenavijaya\n2. amoghavarsha ib) ganitasaram\n3. pampa c) aihole inscription\n4. viracharya d) kavirajamarga\niv. find out the correct statement. one statement alone is\nright.\na) ellora is an island near bombay.\nb) the kailasa temple is at ellora.\nc) the temples at ellora were built during the chalukya rule.\nd) the kailasa temple at ellora was built by pulakesin ii. imposing figures of elephants and lions giving the impression that the\nentire structure rests on their back. it has a three-tiered sikhara or\ntower resembling the sikhara of the mamallapuram rathas. in the\ninterior of the temple there is a pillared hall which has sixteen square\npillars. the kailasa temple is an architectural marvel with it beautiful\nsculptures. the sculpture of the goddess durga is shown as slaying the\nbuffalo demon. in another sculpture ravana was making attempts to\nlift mount kailasa, the abode of siva. the scenes of ramayana were\nalso depicted on the walls. the general characteristics of the kailasa\ntemple are more dravidian.\nelephanta is an island near bombay. it was originally called\nsripuri. the portuguese after seeing the large figure of an elephant named\nit elephanta. the sculptural art of the rashtrakutas reached its zenith in\nthis place. there is a close similarity between the sculptures at ellora\nand those in elephanta. they might have been carved by the same\ncraftsmen. at the entrance to the sanctum there are huge figures of\ndwara-palakas. in the walls of the prakara around the sanctum there\nare niches containing the images of shiva in various forms - nataraja,\ngangadhara, ardhanareesvara and  somaskanda. the most imposing\nfigure of this temple is trimurthi. the sculpture is six metre high. it is\nsaid to represent the three aspects of shiva as creator, preserver and\ndestroyer.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. the political history of the chalukyas of badami.\n2. art and architecture of the chalukyas.\n3. achievements of the rashtrakuta rulers.\n4. cultural contributions of the rashtrakutas.\n5. literary developments during the rashtrakuta rule.\n\n141 140\nafter the decline of the sangam period, the cholas became\nfeudatories in uraiyur. they became prominent in the ninth century\nand established an empire comprising the major portion of south\nindia. their capital was tanjore. they also extended their sway in\nsri lanka and the malay peninsula. therefore, they are called as\nthe imperial cholas. thousands of inscriptions found in the temples\nprovide detailed information regarding the administration, society,\neconomy and culture of the chola period.\nthe founder of the imperial chola line was vijayalaya. he\ncaptured tanjore from muttaraiyars in 815 a.d. and built a temple\nfor durga. his son aditya put an end to the pallava kingdom by\ndefeating aparajita and annexed tondaimandalam. parantaka i was\none of the important early chola rulers. he defeated the pandyas\nand the ruler of ceylon. but he suffered a defeat at the hands of the\nrashtrakutas in the famous battle of takkolam. parantaka i was a\ngreat builder of temples. he also provided the vimana of the famous\nlesson 13\nimperial cholas\nlearning objectives\nstudents will acquire knowledge about\n1. a brief history of early cholas.\n2. military conquests and other achievements of rajaraja i.\n3. campaigns of rajendra i and his accomplishments.\n4. salient features of the chola administration.\n5. literature, art and architecture of the cholas.\nv. state whether the following statements are true or\nfalse.\n1. iuen tsang visited the deccan during the reign of\namoghavarsha i.\n2. the beginning of kannada literature commenced during the\nrashtrakuta rule.\n3. dantidurga was the last ruler of the chalukyas.\nvi. write short notes (any three points).\n1. aihole inscription\n2. pattadakal\n3. ellora\n4. elephanta\nvii. answer briefly (100 words).\n1. give a brief account of the achievements of pulakesin ii.\n2. give an estimate of amoghavarsha i.\nviii.answer in detail (200 words).\n1. give an account of the development of art and architecture\nunder the chalukyas of badami.\n2. evaluate the cultural contributions of the rashtrakutas.\n\n143 142\n7. rajaraja’s last military achievement was a naval expedition\nagainst the maldive islands which were conquered.\nby these conquests, the extent of the chola empire under\nrajaraja i included the pandya, chera and the tondaimandalam\nregions of tamil nadu and the gangavadi, nolambapadi and the\ntelugu choda territories in the deccan and the northern part of\nceylon and the maldive islands beyond india. rajaraja assumed a\nnumber of titles like mummidi chola, jayankonda and\nsivapadasekara. he was a devout follower of saivism. he\ncompleted the construction of the famous rajarajeswara temple or\nbrihadeeswara temple at tanjore in 1010 a.d. he also helped in\nthe construction of a buddhist monastery at nagapattinam.\nrajendra i (1012-1044 a.d.)\nrajendra had demonstrated his military ability by participating\nin his father’s campaigns. he continued his father’s policy of\naggressive conquests and expansion. his important wars were:\n1. mahinda v, the king of sri lanka attempted to recover from\nthe cholas the northern part of ceylon. rajendra defeated\nhim and seized the southern sri lanka. thus the whole of sri\nlanka was made part of the chola empire.\n2. he reasserted the chola authority over the chera and pandya\ncountries.\n3. he defeated jayasimha ii, the western chalukya king and\nthe river tungabadhra was recognised as the boundary bet-\nween the cholas and chalukyas.\n4. his most famous military enterprise was his expedition to north\nindia. the chola army crossed the ganges by defeating a\nnumber of rulers on its way. rajendra defeated mahipala i of\nbengal. to commemorate this successful north-indian nataraja temple at chidambaram with a golden roof. the two famous\nuttiramerur inscriptions that give a detailed account of the village\nadministration under the cholas belong to his reign. after a gap of\nthirty years, the cholas regained their supremacy under rajaraja i.\nrajaraja i (985 – 1014 a.d.)\nit was under rajaraja i and his son rajendra\ni that the chola power reached its highest point of\nglory. his military conquests were:\n1. the defeat of the chera ruler\nbhaskararavivarman in the naval battle of\nkandalursalai and the destruction of the\nchera navy.\n2. the defeat of the pandya ruler, amarabhujanga and\nestablishment of chola authority in the pandya country.\n3. the conquest of gangavadi, tadigaipadi and nolambapadi\nlocated in the mysore region.\n4. the invasion of sri lanka which was entrusted to his son\nrajendra i. as the sri lankan king mahinda v fled away\nfrom his country, the cholas annexed the northern sri lanka.\nthe capital was shifted from anuradhapura to polanaruva\nwhere a shiva temple was built\n5. the chola victory over the growing power of the western\nchalukyas of kalyani. satyasraya was defeated and rajaraja\ni captured the raichur doab, banavasi and other places.\nhence the chola power extended up to the river tungabadhra.\n6. the restoration of vengi throne to its rulers saktivarman and\nvimaladitya by defeating the telugu chodas. rajaraja gave\nhis daughter kundavai in marriage to vimaladitya.\nstatute of \nrajaraja\n\n145 144\ncampaign rajendra founded the city of\ngangaikondacholapuram and constructed the famous\nrajesvaram temple in that city. he also excavated a large\nirrigation tank called cholagangam on the western side of the\ncity.\n5. another famous venture of rajendra was his naval expedition\nto kadaram or sri vijaya. it is difficult to pin point the real\nobject of the expedition. whatever its objects were, the naval\nexpedition was a complete success. a number of places were\noccupied by chola forces. but it was only temporary and no\npermanent annexation of these places was contemplated. he\nassumed the title kadaramkondan.\n6. rajendra i had put down all rebellions and kept his empire in\ntact.\nat the death of rajendra i the extent of the chola empire\nwas at its peak. the river tungabadhra was the northern boundary.\nthe pandya, kerala and mysore regions and also sri lanka formed\npart of the empire. he gave his daughter ammangadevi to the vengi\nchalukya prince and further continued the matrimonial alliance\ninitiated by his father. rajendra i assumed a number of titles, the\nmost famous being mudikondan, gangaikondan, kadaram kondan\nand pandita cholan. like his father he was also a devout saiva and\nbuilt a temple for that god at the new capital gangaikondacholapuram.\nhe made liberal endowments to this temple and to the lord nataraja\ntemple at chidambaram. he was also tolerant towards the vaishnava\nand buddhist sects.\nafter rajendra i, the greatness of the chola power was\npreserved by rulers like kulottunga i and kulottunga iii. kulottunga\ni was the grandson of rajendra i through his daughter ammangadevi.\nhe succeeded the chola throne and thus united the vengi kingdom\nwith the chola empire. during his reign sri lanka became\nbay of bengal\nindian ocean aribian sea\nkorki maduraiuraiyurthanjavur gangaikondacholapuramutiramerur kanchitakkolam nellorerajahmundrysakkarakkottam\nkalyani yadavas\nw. chalukyas\nmalkhed\nkakatiyas\nkadanbas\nbavanasi\ngangavadi\ncholas\n\n147 146\nthe hard times, there were remission of taxes and kulottunga i\nbecame famous by abolishing tolls and earned the title – sungam\ntavirtta cholan. the main items of government expenditure were\nthe king and his court, army and navy, roads, irrigation tanks and\ncanals.\nmilitary administration\nthe cholas maintained a regular standing army consisting of\nelephants, cavalry, infantry and navy. about seventy regiments were\nmentioned in the inscriptions. the royal troops were called\nkaikkolaperumpadai. within this there was a personal troop to\ndefend the king known as velaikkarar. attention was given to the\ntraining of the army and military cantonments called kadagams\nexisted. the cholas paid special attention to their navy. the naval\nachievements of the tamils reached its climax under the cholas.\nthey controlled the malabar and coromandal coasts. in fact, the\nbay of bengal became a chola lake for sometime.\nprovincial administration\nthe chola empire was divided into mandalams and each\nmandalam into valanadus and nadus. in each nadu there were a\nnumber of autonomous villages. the royal princes or officers were\nin charge of mandalams. the valanadu was under periyanattar\nand nadu under nattar. the town was known as nagaram and it\nwas under the administration of a council called nagarattar.\nvillage assemblies\nthe system of village autonomy with sabhas and their\ncommittees developed through the ages and reached its culmination\nduring the chola rule. two inscriptions belonging to the period of\nparantaka i found at uttiramerur provide details of the formation\nand functions of village councils. that village was divided into thirty independent. subsequently, vengi and the mysore region were\ncaptured by the western chalukyas. kulottunga i sent a large\nembassy of 72 merchants to china and maintained cordial relations\nwith the kingdom of sri vijaya. under kulottunga iii the central\nauthority became weak. the rise of the feudatories like the\nkadavarayas and the emergence of the pandya power as a challenge\nto chola supremacy contributed to the ultimate downfall of the chola\nempire. rajendra iii was the last chola king who was defeated by\njatavarman sundarapandya ii. the chola country was absorbed\ninto the pandya empire.\nchola administration\ncentral government\nthe cholas had an excellent system of administration. the\nemperor or king was at the top of the administration. the extent\nand resources of the chola empire increased the power and prestige\nof monarchy. the big capital cities like tanjore and\ngangaikondacholapuram, the large royal courts and extensive grants\nto the temples reveal the authority of the king. they undertook royal\ntours to increase the efficiency of the administration. there was\nelaborate administrative machinery comprising various officials called\nperundanam and sirudanam.\nrevenue\nthe land revenue department was well organized. it was called\nas puravuvarithinaikkalam. all lands were carefully surveyed and\nclassified for assessment of revenue. the residential portion of the\nvillage was called ur nattam. these and other lands such as the\nlands belonging to temples were exempted from tax. besides land\nrevenue, there were tolls and customs on goods taken from one\nplace to another, various kinds of professional taxes, dues levied\non ceremonial occasions like marriages and judicial fines. during\n\n149 148\nbrahmins and kshatriyas enjoyed special privileges. the inscriptions\nof the later period of the chola rule mention about two major\ndivisions among the castes – valangai and idangai castes. however,\nthere was cooperation among various castes and sub-castes in social\nand religious life. the position of women did not improve. the\npractice of ‘sati’ was prevalent among the royal families. the\ndevadasi system or dancing girls attached to temples emerged during\nthis period.\nboth saivism and vaishnavism continued to flourish during\nthe chola period. a number of temples were built with the patronage\nof chola kings and queens. the temples remained centres of\neconomic activity during this period. the mathas had great influence\nduring this period. both agriculture and industry flourished.\nreclamation of forest lands and the construction\nand maintenance of irrigation tanks led to\nagricultural prosperity. the weaving industry,\nparticularly the silk-weaving at kanchi\nflourished. the metal works developed owing\nto great demand of images for temples and\nutensils. commerce and trade were brisk with\ntrunk roads or peruvazhis and merchant guilds.\ngold, silver and copper coins were issued in\nplenty at various denominations. commercial\ncontacts between the chola empire and china, sumatra, java and\narabia were extensively prevalent. arabian horses were imported\nin large numbers to strengthen the cavalry.\neducation and literature\neducation was also given importance. besides the temples\nand mathas as educational centres, several educational institutions\nalso flourished. the inscription at ennayiram, thirumukkudal and\nthirubhuvanai provide details of the colleges existed in these places.\ngold coin of \nrajaraja chola \nwards and each was to nominate its members to the village council.\nthe qualifications to become a ward member were:\na. ownership of at least one fourth veli of land.\nb. own residence.\nc. above thirty years and below seventy years of age.\nd. knowledge of vedas.\nhowever, certain norms of disqualification were also\nmentioned in the inscriptions. they were:\na. those who had been members of the committees for\nthe past three years.\nb. those who had failed to submit accounts as committee\nmembers.\nc. those who had committed sins.\nd. those who had stolen the property of others.\nfrom the persons duly nominated, one was to be chosen for\neach ward by kudavolai system for a year. the names of eligible\npersons were written on palm-leaves and put into a pot. a young\nboy or girl would take out thirty names each for one ward. they\nwere divided into six variyams such as samvatsaravariyam,\nerivariyam, thotta variyam, pancha variyam, pon variyam and\npuravuvari variyam to take up six different functions of the village\nadministration. the committee members were called\nvariyapperumakkal. they usually met in the temple or under a\ntree and passed resolutions. the number of committees and ward\nmembers varied from village to village.\nsocio-economic life\ncaste system was widely prevalent during the chola period.\n\n151 150learning outcome\nafter learning this lesson the students will be able to explain\n1. the rise of the imperial cholas.\n2. the military accomplishments of rajaraja i and his\npersonality.\n3. rajendra i and his military conquests.\n4. village administration of the cholas and its significance.\n5. cultural achievements of the imperial cholas.\narchitecture is the siva temple at\ngangaikondacholapuram built by\nrajendra i. the airavathesvara temple\nat darasuram in tanjore district and the\nkampaharesvara\ntemple at\ntribhuvanam are\nexamples of later chola temples.\nthe cholas also made rich contributions\nto the art of sculpture. the walls of the chola\ntemples such as the tanjore and\ngangaikondacholapuram temples contain\nnumerous icons of large size with fine\nexecution. the bronzes of the chola period\nare world-famous. the bronze statues of\nnataraja or dancing siva are master pieces.\nthe chola paintings were found on the walls\nof narthamalai and tanjore temples.\n \n \ndarasuram sculptures\ngangaikonda\ncholapuram temple\napart from the vedas and epics, subjects like mathematics and\nmedicine were taught in these institutions. endowment of lands was\nmade to run these institutions.\nthe development of tamil literature reached its peak during the\nchola period. sivakasintamani written by thiruthakkadevar and\nkundalakesi belonged to 10\nth century. the ramayana composed by\nkamban and the periyapuranam or tiruttondarpuranam by sekkilar\nare the two master-pieces of this age. jayankondar’s\nkalingattupparani describes the kalinga war fought by kulotunga i.\nthe moovarula written by ottakuthar depicts the life of three chola\nkings. the nalavenba was written by pugalendi. the works on tamil\ngrammar like kalladam by kalladanar, yapperungalam by\namirthasagarar, a jain, nannul by pavanandhi and virasoliyam by\nbuddhamitra were the products of the chola age.\nart and architecture\nthe dravidian style of art and\narchitecture reached its perfection under\nthe cholas. they built enormous\ntemples. the chief feature of the chola\ntemple is the\nvimana. the early\nchola temples\nwere found at\nnarthamalai and kodumbalur in pudukottai district\nand at srinivasanallur in tiruchirappalli district. the\nbig temple at tanjore built by rajaraja i is a\nmaster-piece of south indian art and architecture.\nit consists of the vimana, ardhamandapa,\nmahamandapa and a large pavilion in the front\nknown as the nandimandapa. another notable\ncontribution made by the cholas to temple\nchola bronze\nnatarajapragadeeswara temple,\ntanjore\n\n153 152\nc) southern part of sri lanka was annexed by rajaraja i.\nd) sri lanka declared its independence during the reign of\nrajendra i.\nv. state whether the following statements are true or\nfalse.\n1. rajaraja i helped to construct a buddhist monastery at\ntanjore.\n2. rajendra i captured the kingdom of sri vijaya.\n3. jayankondar ’s kalingattupparani describes the kalinga war\nfought by kulotunga i\nvi. write short notes (any three points).\n1. brihadeeswaram.\n2. gangaikondacholapuram.\n3. kudavolai system.\n4. development of educational institutions under the cholas.\nvii. answer briefly (100 words).\n1. describe the society and economy under the imperial cholas.\n2. write the development of tamil literature under the cholas.\nviii.answer in detail (200 words).\n1. examine the achievements of rajaraja i.\n2. assess the military conquests of rajendra i.\n3. describe the salient features of the chola’s administration. model questions\ni. choose the correct answer.\n1. the chola ruler who faced a defeat at the battle of takkolam\n(a) aditya i (b) rajaraja ii\n(c) vijayalaya(d) parantaka i\n2. author of the book virasoliyam\n(a) bhavanandhi (b) buddhamitra\n(c) pugalendi(d) ottakuttar\nii. fill in the blanks.\n1. the naval battle of kandalursalai took place during the reign\nof ……\n2. the irrigation tank cholagangam was constructed at …… by\n…..\n3. kudavolai system was described in the inscriptions found at\n……\niii. match the following.\n1. uttiramerur inscriptions a) rajaraja i\n2. sungam tavirtta chola b) rajendra i\n3. mudikondanc) kulottunga i\n4. jayankondan d) parantaka i\niv. find out the correct statement. one statement alone is\nright.\na) rajaraja i took an expedition to sri vijaya.\nb) rajaraja i shifted his capital to gangaikondacholapuram.\n\n155 154\nsanskrit texts and buddhist monasteries were found in these places.\nindian cultural influence continued in this region till eighth century.\nindian culture had also spread to tibet and china through central\nasia.\nindia and china\nchina was influenced both by land route passing through\ncentral asia and the sea route through burma. buddhism reached\nchina in the beginning of the first century a.d. a number of chinese\npilgrims like fahien and hiuen tsang visited india. on the other\nside, hundreds of buddhist monks like gunabhadra, vajrabothi,\ndharmadeva and dharmagupta visited china. indian scholars\ntranslated many sanskrit works at the request of chinese emperors.\nthis contact with china continued even in the thirteenth century\nwhen the mongols established their empire in china. chinese art\nhad also been influenced by indian art.\nindia and tibet\ntibet was influenced by india from the seventh century. the\nfamous buddhist king gampo founded the city of lhasa and\nintroduced buddhism. the tibetan alphabet was devised with the\nhelp of indian scholars. later, the indian scholars helped for the\nestablishment of lamaism in tibet. in the eleventh century the pala\ndynasty of bengal had close contacts with tibet. when bengal was\nattacked by the muslim rulers, many buddhist\nmonks sought shelter in tibet.\nindia and sri lanka\ndespite having different political history,\nsri lanka experienced a great cultural influence\nfrom india. buddhist missionaries had spread\nnot only the religious faith but also cultural\ntraditions. the art of stone carving went to sri\nsigiriya painting\n \nthe spread of indian culture and civilization to the other parts\nof asia constitutes an important chapter in the history of india. india\nhad established commercial contacts with other countries from the\nearliest times. it had inevitably resulted in the spread of indian\nlanguages, religions, art and architecture, philosophy, beliefs, customs\nand manners. indian political adventurers even established hindu\nkingdoms in some parts of south east asia. however, this did not\nlead to any kind of colonialism or imperialism in the modern sense.\non the other hand these colonies in the new lands were free from\nthe control of the mother country. but they were brought under her\ncultural influence.\ncentral asia\ncentral asia was a great centre of indian culture in the early\ncenturies of the christian era. several monuments have been\nunearthed in the eastern part of afghanistan. khotan and kashkar\nremained the most important centres of indian culture. several\nlesson 14\nthe spread of indian culture in other\nasian countrieslearning objectives\nstudents will acquire knowledge about\n1. the spread of indian culture in central asia.\n2. indian cultural influence in china, tibet and sri lanka.\n3. indian cultural influence over the south east asia.\n4. cultural contacts between india and myanmar.\n5. art and architecture in the countries of south east asia.\n\n157 156\npeninsula. numerous sanskrit inscriptions give us a detailed history\nof its kings. a number of hindu literary works like the vedas, the\nramayana, the mahabharata, panini’s grammar, hindu\nphilosophical treatises were all known to the people of cambodia.\nlike the pallava kings, they were called varmans. yasovarman\nand suryavarman ii were two well-known rulers. temples were\nbuilt in south indian style. there are plenty of sanskrit inscriptions.\nthe most famous of these temples was the temple (wat) of vishnu\nbuilt by suryavarman ii in his capital city angkor. it was popularly\ncalled as the angkorwat temple. it is standing on top of a terraced\nstructure. each terrace is a sort of a covered gallery which contains\nnumerous relief sculptures. the temple is constructed on the\ndravidian style and the sculptures depict episodes from the\nramayana and the mahabharata. the kambhoja kingdom declined\nonly in fifteenth century.\nchampa\nchampa or south annam is situated to the east of cambodia.\nthe first hindu dynasty was established by sri mara in the second\ncentury a.d. a number of sanskrit inscriptions throw light on the\nhistory of champa. twelve indian dynasties ruled over champa\nand by the thirteenth century champa was annexed to cambodia.\nunder its hindu rulers the hindu religion and culture, customs and\nmanners were introduced in champa. saivism and vaishnavism\nflourished. buddhism also existed side by side. various works on\nhindu philosophy, grammar, fine arts and astrology were written.\nsiam or thailand\nthere were several states in siam following indian culture.\nthai script was developed with the help of indian scholars. the\ntraditional laws of that country were composed on the model of\ndharmasastras. the temples at bangkok contain many sculptures\ndepicting the ramayana. lanka from india. in the fifth century, buddha ghosha visited sri\nlanka and consolidated there the hinayana buddhism. the famous\npaintings of sigiriya were modeled on the ajantha paintings.\nindian culture in south east asia\nindian culture had extended its mighty influence in the south\neast asian region consisting of the malay archipelago and indo-\nchina. they are located across the bay of bengal. being fertile and\nrich in minerals, these lands attracted the attention of the indians.\nmoreover, the east coast of india is studded with numerous ports\nand indians undertook frequent voyages to these lands. the ancient\ntraditions refer to traders’ voyages to suvarnabhumi, (the land of\ngold) a name generally given to all the countries of the east asia.\nindians began to colonize the east asia in the gupta period. it was\nfurther encouraged by the pallavas. the indian colonists established\ngreat kingdoms and some of them lasted for more than a thousand\nyears. a number of dynasties with indian names ruled in various\nparts. till the arrival of islam in the fifteenth century, indian culture\ndominated this region.\ncambodia (kambhoja)\ncambodia was colonised by indians in the first century a.d.\nthey influenced the\nnative people called the\nkhemers. the ruling\ndynasty was known as\nkambojas and their\ncountry was kamboja\nor modern cambodia.\nunder the early rulers\nsaivism and\nvaishnavism made steady progress. the kamboja empire at its\ngreatest extent included laos, siam, part of burma and the malay\nangkorwat temple\n\n159 158\nbas-reliefs (small  carved stone figures) illustrating various incidents\nin the life of the buddha. the lower parts are rich in decoration\nwhile the upper portions are plain and unadorned. borobudur is\ndescribed as an epic in stone, the most wonderful buddhist stupa in\nthe world.\nin the twelfth century, eastern java with kadiri as its capital\ndeveloped into the leading kingdom of java. in the thirteenth and\nfourteenth centuries which marked the golden age of javanese\nculture, majapahit became the capital of the far-flung javanese\nempire which included the neighbouring islands. indian art and\nliterature flourished in java to an extent unknown elsewhere. still,\nruins of hundreds of temples and manuscripts based on the sanskrit\nlanguage are found in java. the ramayana and the mahabharata\nwere popular and even today furnish the theme for their popular\nshadow-play. the fall of majapahit brought to an end all artistic\nactivity in java.\nbali\nbali came under the rule of hindu dynasties as early as the\nsixth century. i-tsing refers to the prevalence of buddhism there in\nthe seventh century. the stone and copper plate inscriptions from\nthat island show that it was colonised directly from india. later it\nbecame subordinate to java. its people continue to be hindus and\neven today we find the prevalence of the caste system there.\nmyanmar\nthe cultural contacts between india and burma (now\nmyanmar) dates back to the period of asoka, who sent his\nmissionaries there to preach buddhism. many hindu kingdoms\nexisted in burma. pali and sanskrit were the languages of burma till\nthirteenth century. both hinayana and mahayana buddhism were\nfollowed by the burmese. sumatra and java\nthe malay archipelago had remained an important link\nbetween india and the far east. several hindu kingdoms existed\nhere between fifth to fifteenth centuries a.d. the most important\nhindu kingdom in the big island of sumatra was sri vijaya. it was a\ngreat centre of trade and culture in the seventh century. subsequently,\nthe sri vijaya kingdom developed into a powerful maritime and\ncommercial power known as the sailendra empire extending its sway\nover the neighbouring islands of java, bali, borneo and over cam-\nbodia. the sailendra rulers were mahayana buddhists and\nmaintained cordial relations with the indian kingdoms of the palas\nof bengal and the cholas of tamil nadu. rajaraja chola allowed\nthe sailendra king maravijayottungavarman to build a buddhist\nmonastery at nagapattinam. his son rajendra conquered the\nsailendra kingdom for sometime. later they became independent.\nthe sailendra empire continued intact till the eleventh century a.d.\na hindu kingdom was established in java as early as the fourth\ncentury a.d. in central java arose the kingdom of mataram which\nbecame a strong centre of hindu religion and culture. it was\nconquered by the sailendras of sumatra. till the ninth century java\ncontinued to be a part of the sailendra empire. later it regained its\nindependence. java attained greatness and splendour in art under\nsailendra rule.\nthe greatest monument of indo-\njava art is the borobudur which was\nbuilt during a.d. 750-850 under the\npatronage of the sailendras. it is\nsituated on the top of a hill. it consists\nof nine successive terraces, crowned\nby a bell-shaped stupa at the centre of\nthe topmost terrace. the open galleries in the terraces contain 2000\nborobudur\nmonument\n\n161 160\nmodel questions\ni. choose the correct answer.\n1. the chola king who permitted the sailendras to build\nmonastery in nagapattinam\n(a) vijayalaya(b) rajaraja\n(c) kulottunga(d) rajendra\n2. the hindu kingdom in sumatra island was\n(a) khamboja(b) sri vijaya\n(c) champa(d) annam\nii. fill in the blanks.\n1. the city of lhasa was founded by ……\n2. the capital of eastern java ……\niii. match the following.\n1. angkorwat templea) sailendras\n2. borobudur b) sri lanka\n3. sigiriya c) south annam\n4. champa d) suryavarman ii\niv. find out the correct statement. one statement alone is\nright.\na) borobudur is the greatest monument of indo-java art.\nb) borobudur was a vashnavite temple.\nc) sailendra rulers were saivites.\nd) the scenes from ramayana are carved in borobudur. thus for nearly fifteen hundred years hindu kings were ruling\nover numerous islands of the malay archipelago and over the indo-\nchina peninsula. indian religions and indian culture moulded the\nlives of the primitive inhabitants of these regions who were elevated\nto a higher plan of civilization.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. india’s influence over central asia.\n2. cultural contacts between india and china.\n3. india and sri lanka through the ages.\n4. spread of indian culture in the countries of south east\nasia such as indo-china, malay archipelago and\nmyanmar.\n5. hindu temples in south east asia and their architecture.\n\n163 162\nafter the death of harsha, there was no political unity in north\nindia for about five centuries. the country was split up into a number\nof states which were constantly fighting and changing their frontiers.\nthe important kingdoms in north india were kashmir, gandhara,\nsind, gujarat, kanauj, ajmir, malwa, bengal and assam. in the\nearly eighth century kashmir was dominant. then, the palas of\nbengal reigned supreme till the pratiharas became the most powerful\nrulers of north india. but in the tenth century, the rashtrakutas of\ndeccan tried to extend their power in north india but ultimately\nfailed in their attempt.\nrajput kingdoms\nthe dominance of rajputs began from the seventh and eighth\ncenturies and lasted till the muslim conquest in the twelfth century.\neven after that, many rajput states continued to survive for a long\ntime. in the period of muslim aggression, the rajputs were the main\ndefenders of the hindu religion and culture.\nlesson 15\nearly medieval india\nlearning objectives\nstudents will acquire knowledge about\n1. a brief history of the rajput kingdoms.\n2. causes and results of the arab conquest of sind.\n3. mahmud of ghazni and his invasions.\n4. mahmud of ghori’s invasions.\n5. causes for the failure of hindu states.\nv. state whether the following statements are true or\nfalse.\n1. the first hindu dynasty of champa was established by sri\nmara.\n2. the kingdom of bali was influenced by buddhism.\nvi. write short notes (any three points).\n1. angkorwat\n2. borobudur\n3. cultural contacts between india and myanmar\n4. india and bali.\nvii. answer briefly (100 words).\n1. trace the cultural contacts between india and china.\n2. write a short note on indo-java art.\nviii.answer in detail (200 words).\n1. give an account of the spread of indian culture in south east\nasia.\n2. assess the impact of indian cultural influence in other parts of\nasia\n\n165 164\na.d., which was the starting point of the muslim calendar and the\nmuslim era called hijra. after eight years he returned to mecca\nwith his followers. he died in 632 a.d.\nthe followers of muhammad set up an empire called the\ncaliphate. the umayyads and the abbasids were called the caliphs.\nthey expanded their rule by conquests and spread their religion\nislam. in 712 a.d., muhammad bin qasim invaded sind. he was\nthe commander of the umayyad kingdom. qasim defeated dahir,\nthe ruler of sind and killed him in a well-contested battle. his capital\naror was captured. qasim extended his conquest further into multan.\nqasim organized the administration of sind. the people of sind\nwere given the status of zimmis (protected subjects). there was no\ninterference in the lives and property of the people. soon, qasim\nwas recalled by the caliph.\nhowever, sind continued to be under the arabs. but the\nmuslims could not expand their authority further into india due to\nthe presence of the powerful pratihara kingdom in western india.\nalthough the conquest of sind did not lead to further conquests\nimmediately, it had resulted in the diffusion of indian culture abroad.\nmany arab travelers visited sind. indian medicine and astronomy\nwere carried to far off lands through the arabs. the indian numerals\nin the arabic form went to europe through them.\nsince sind was a part of the arab empire, the\ninflow of indian knowledge was great.\nmahmud of ghazni and his invasions\nby the end of the ninth century a.d., the\nabbasid caliphate declined. the turkish\ngovernors established independent kingdoms and\nthe caliph became only a ritual authority. one\namong them was alptigin whose capital was\nghazni. his successor and son-in-law sabuktigin\nportrait of  \nmahmud of ghazni \nthere are several theories about the origin of rajputs. they\nwere considered as the descendents of the foreign invaders and the\nindian kshatriyas. the foreign invaders were indianized and\nabsorbed into indian society. many legends of rajputs support this\ntheory. therefore, it can be said that diverse elements constitute in\nthe shaping of the rajput clan. they became homogenous by constant\nintermarriage and by adopting common customs. they made war\nas their chief occupation. however, trade and agriculture also\nprospered. the arab travellers refer to the prosperity of the land\nand the great trade of the cities. they built strong forts.\nthe gurjara-pratiharas were the earliest of the rajput rulers.\nits first great leader was harischandra. he conquered extensive\nterritory in rajaputana and ruled with his capital at bhinmal. the\ngurjaras were in different branches. one branch ruled gujarat and\nanother at avanthi. the pratiharas involved themselves in a three-\ncornered contest with the palas of bengal and the rashtrakutas of\ndeccan. later the pratiharas became weak. the chauhans, the most\nvaliant of the rajput races, ruled ajmir. vigraharaj was their most\nimportant king, who occupied delhi. therefore the chauhans faced\nthe onslaught of the muslims under muhammad of ghori. the\nparamaras were also important rajput rulers of this period. the\nmost important king was bhoja. his military conquests as well as\ncultural contributions remain notable in the history of rajputs.\nconstant fighting weakened the rajputs. also, they never\nunited against a common enemy. their lack of political foresight\nand constant rivalries prevented any combined opposition to the\nmuslim invaders.\narab conquest of sind (712 a.d.)\nthe religion islam was born at mecca in arabia. its founder\nwas prophet muhammad. but his teachings made the wealthy people\nof mecca his enemies. therefore, he migrated to medina in 622\n\n167 166\nthe west and from samarkand in the north to gujarat in the south. the\nghaznavid empire roughly included persia, trans-oxyana, afghanistan\nand punjab. his achievements were due to his leadership and restless\nactivity. mahmud was considered a hero of islam by medieval historians.\nhe also patronized art and literature. firdausi was the poet-laureate in\nthe court of mahmud. he was the author of shah namah. alberuni\nstayed in mahmud’s court and wrote the famous kitab-i-hind, an\naccount on india. his conquest of punjab and multan completely\nchanged the political situation in india. he paved the way for the turks\nand afghans for further conquests and make deeper incursions into the\ngangetic valley at any time. he drained the resources of india by his\nrepeated raids and deprived india of her manpower. the exhaustion of\nindia’s economic resources and man power had its adverse effect on\nthe political future of india. the hindu shahi kingdom was guarding the\ngates of india against foreign invaders. mahmud destroyed it and thus\nindia’s frontiers became defenceless. the inclusion of punjab and\nafghanistan in ghazni’s kingdom made the subsequent muslim conquests\nof india comparatively easy.\nmuhammad ghori\nthe ghoris started as vassals of ghazni but became\nindependent after the death of mahmud. taking advantage of the\ndecline of the ghaznavid empire, muizzuddin muhammad popularly\nknown as muhammad ghori brought ghazni under their control.\nhaving made his position strong and secure at ghazni, muhammad\nghori turned his attention to india. unlike mahmud of ghazni, he\nwanted to conquer india and extend his empire in this direction.\nin 1175, muhammad ghori captured multan and occupied\nwhole of sind in his subsequent expeditions. in 1186 he attacked\npunjab, captured it from khusru malik and annexed it to his domin-\nions. the annexation of punjab carried his dominion eastward to\nthe sutlej and led his invasion of the chauhan kingdom. wanted to conquer india from the north-west. he succeeded in\ncapturing peshawar from jayapala. but his raids did not produce a\nlasting effect. he was succeeded by his son, mahmud\nmahmud of ghazni (a.d. 997-1030).\nmahmud is said to have made seventeen raids into india. at\nthat time, north india was divided into a number of hindu states.\non the frontier of india, there existed the hindu shahi kingdom\nwhich extended from the punjab to kabul. the other important\nkingdoms of north india were kanauj, gujarat, kashmir, nepal,\nmalwa and bundelkhand. the initial raids were against the hindu\nshahi kingdom in which its king jayapala was defeated in 1001.\nafter this defeat, jayapala immolated himself because he thought\nthat his defeat was a disgrace. his successor anandapala fought\nagainst mahmud but he was also defeated in the battle of waihind,\nthe hind shahi capital near peshawar in 1008. in this battle,\nanandapala was supported by the rulers of kanauj and rajasthan.\nas a result of his victory at waihind, mahmud extended his rule\nover most of the punjab.\nthe subsequent raids of mahmud into india were aimed at\nplundering the rich temples and cities of northern india. in 1011, he\nraided nagarkot in the punjab hills and thaneshwar near delhi. in\n1018, mahmud plundered the holy city of mathura and also attacked\nkanauj. the ruler of kanauj, rajyapala abandoned kanauj and\nlater died. mahmud returned via kalinjar with fabulous riches. his\nnext important raid was against gujarat. in 1024, mahmud marched\nfrom multan across rajaputana, defeated the solanki king\nbhimadeva i, plundered anhilwad and sacked the famous temple\nof somanatha. then, he returned through the sind desert. this was\nhis last campaign in india. mahmud died in 1030 a.d.\nmahmud was not a mere raider and plunderer of wealth. he\nbuilt a wide empire from the punjab in the east to the caspian sea on\n\n169 168\nof tarain and chandawar contributed to the establishment of turkish\nrule in india.\ncauses for the failure of hindu kingdoms\nthe causes for the downfall of hindu states have to be analysed\nhistorically. the most important cause was that they lacked unity.\nthey were divided by factions. the rajput princes exhausted one\nanother by their mutual conflicts. secondly, many hindu states were\ndeclining in power. their military methods were out of date and far\ninferior to those of muslims. indians continued to rely on elephants\nwhile the muslims possessed quick-moving cavalry. the muslims\nsoldiers had better organization and able leaders. their religious\nzeal and their greed for the greater wealth of india provided stimulus\nto them. among the hindus, the duty of fighting was confined to a\nparticular class, the kshatriyas. moreover, the hindus were always\non the defensive, which was always a weak position.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. a brief history of the rajput kingdoms in northern india.\n2. arab conquest of sind and its results.\n3. causes and results of the mahmud of ghazni’s invasion\nof india.\n4. mahmud of ghori and his capture of indian territories.\n5. causes for the failure of the hindu states against muslim\ninvasions.\nthe battle of tarain (1191-1192)\nrealising their grave situation, the hindu\nprinces of north india formed a confederacy\nunder the command of prithiviraj chauhan.\nprithviraj rose to the occasion, and defeated\nghori in the battle of tarain near delhi in 1191\na.d. muhammad ghori felt greatly humiliated\nby this defeat. to avenge this defeat he made\nserious preparations and gathered an army of 1,20,000 men. he\ncame with this large force to lahore via peshawar and multan. he\nsent a message to prithviraj asking him to acknowledge his\nsupremacy and become a muslim. prithviraj rejected this proposal\nand prepared to meet the invader. he gathered a large force\nconsisting of 3,00,000 horses, 3000 elephants and a large body of\nfoot soldiers. many hindu rajas and chieftains also joined him. in\nthe ensuing second battle of tarain in 1192, muhammad ghori\nthoroughly routed the army of prithiviraj, who was captured and\nkilled.\nthe second battle of tarain was a decisive battle. it was a\nmajor disaster for the rajputs. their political prestige suffered a\nserious setback. the whole chauhan kingdom now lay at the feet\nof the invader. the first muslim kingdom was thus firmly established\nin india at ajmer and a new era in the history of india began. after\nhis brilliant victory over prithiviraj at tarain, muhammad ghori\nreturned to ghazni leaving behind his favourite general qutb-ud-\ndin aibak to make further conquests in india. aibak consolidated\nhis position in india by occupying places like delhi and meerut. in\n1193 he prepared the ground for another invasion by muhammad\nghori. this invasion was directed against the gahadavala ruler\njayachandra. muhammad routed jayachandra’s forces. kanauj was\noccupied by the muslims after the battle of chandawar. the battles\nportrait of prithiviraj\nchauhan\n\n171 170\nc) rajputs stood united against the muslim invasions.\nd) mahmud of gahzni handed over the indian possessions to\naibak.\nv. state whether the following statements are true or\nfalse.\n1. the ghoris originally remained vassals under the ghazni rulers.\n2. prithiviraj chauhun defeated mahmud of ghori in the first\nbattle of tarain.\nvi. write short notes (any three points).\n1. muhammad bin qasim.\n2. second battle of tarain.\n3. gurjarapratiharas\n4. alberuni\nvii. answer briefly (100 words).\n1. assess the impact of the arab conquest of sind.\n2. bring out the causes for the decline of rajput kingdoms.\n3. analyse the causes for the failure of hindu states against the\nmuslim invasions.\nviii.answer in detail (200 words).\n1. give an account of the invasions of mahmud of ghazni.\n2. examine the military conquests of mahmud of ghori. model questions\ni. choose the correct answer.\n1. the second battle of tarain was fought in the year\n(a) 1190 (b) 1191\n(c) 1192 (d) 1292\n2. the author of kitab-i-hind\n(a) firdausi (b) barani\n(c) mahmud (d) alberuni\nii. fill in the blanks.\n1. the ruler of sind during the invasion of muhammad bin qasim\n…..\n2. the first muslim kingdom in india was firmly established at\n……\niii. match the following.\n1. gurjarapratiharas a) kanauj\n2. rajyapala b) bhinmal\n3. solankis c) aror\n4. dahir d) anhilwad\niv. find out the correct statement. one statement alone is\nright.\na) the important cause for the defeat of hindu states was lack\nof unity among them.\nb) indians possessed efficient cavalry to fight against the\nmuslims.\n\n173 172\n3. second ilbari dynasty (1266-1290) founded by balban.\nqutbuddin aibak (1206-1210)\nqutbuddin aibak was a slave of\nmuhammad ghori, who made him the governor\nof his indian possessions. he set up his military\nheadquarters at indraprasta, near delhi. he raised\na standing army and established his hold over north\nindia even during the life time of ghori. after the\ndeath of ghori in 1206, aibak declared his\nindependence. he severed all connections with\nthe kingdom of ghori and thus founded the slave dynasty as well as the\ndelhi sultanate. he assumed the title sultan and made lahore his capital.\nhis rule lasted for a short period of four years. muslim writers call\naibak lakh baksh or giver of lakhs because he gave liberal donations\nto them. aibak patronized the great scholar hasan nizami. he also\nstarted the construction of  after the name of a famous sufi saint khwaja\nqutbuddin bakthiyar. it was later completed by iltutmish. aibak died\nsuddenly while playing chaugan (horse polo) in 1210. he was\nsucceeded by his son aram baksh, who was replaced by iltutmish\nafter eight months.\niltutmish (1211-1236)\niltutmish belonged to the ilbari tribe and\nhence his dynasty was named as ilbari dynasty.\nhis half brothers sold him as a slave to aibak,\nwho made him his-son-in law by giving his\ndaughter in marriage to him. later aibak\nappointed him as iqtadar of gwalior. in 1211\niltutmish defeated aram baksh and became\nsultan. he shifted his capital from lahore to\ndelhi. during the first ten years of his reign he\nconcentrated on securing his throne from his\nqutb minar \nthe muslim invasions into india had ultimately resulted in the\nestablishment of delhi sultanate which existed from a.d. 1206 to\n1526. five different dynasties – the slave, khalji, tughlaq, sayyids\nand lodis – ruled under the delhi sultanate. not only they extended\ntheir rule over north india, but also they penetrated into the deccan\nand south india. their rule in india resulted in far-reaching changes\nin society, administration and cultural life.\nslave dynasty\nthe slave dynasty was also called mamluk dynasty. mamluk\nwas the quranic term for slave. the slave dynasty ruled delhi from\na.d. 1206 to 1290. in fact, three dynasties were established during\nthis period. they were\n1. qutbi dynasty (1206-1211) founded by qutbuddin aibak.\n2. first ilbari dynasty (1211- 1266) founded by iltutmish.\nlesson 16\ndelhi sultanate\nlearning objectives\nstudents will acquire knowledge about\n1. political history of delhi sultanate.\n2. slave dynasty – aibak, iltutmish, raziya, balban.\n3. khaljis – alauddin khalji’s achievements.\n4. tughlaqs – mahmud-bin-tughlaq and his experiments.\n5. firoz tughlaq and his administration.\n6. sayyids and lodis.\nqutbuddin aibak\n\n175 174\niltutmish introduced the arabic coinage into india and the silver tanka\nweighing 175 grams became a standard coin in medieval india. the\nsilver tanka remained the basis of the modern rupee. iltutmish had also\ncreated a new class of ruling elite of forty powerful military leaders, the\nforty.\nraziya (1236-1240)\nalthough iltutmish nominated his daughter raziya as his\nsuccessor, the qazi of delhi and wazir put ruknuddin feroz on the\nthrone. when the governor of multan revolted, ruknuddin marched\nto suppress that revolt. using this opportunity, raziya with the\nsupport of amirs of delhi seized the throne of delhi sultanate. she\nappointed an abyssinian slave yakuth as master of the royal\nhorses. also, raziya discarded the female apparel and held the\ncourt with her face unveiled. she even went for hunting and led the\narmy. this aroused resentment among the turkish nobles. in 1240,\naltunia, the governor of bhatinda revolted against her. she went in\nperson to suppress the revolt but altunia killed yakuth and took\nraziya prisoner. in the meantime, the turkish nobles put bahram,\nanother son of iltutmish on the throne. however, raziya won over\nher captor, altunia, and after marrying him proceeded to delhi. but\nshe was defeated and killed.\nthe fall of raziya paved the way for the ascendancy of the\nforty. in the next six years, bahram and masud ruled delhi. there\nensued a struggle for supremacy between the sultans and the nobles.\nin 1246 balban succeeded in putting nasiruddin mahmud, a\nyounger son of iltutmish, as sultan.\nera of balban (1246-1287)\nghiyasuddin balban, who was also known as ulugh khan,\nserved as naib or regent to sultan nasiruddin mahmud. he also\nstrengthened his position by marrying his daughter to the sultan.\nbalban was all powerful in the administration but he had to face the rivals. in the meantime, temujin popularly known\nas chengiz khan, the leader of the mongols,\nstarted invading central asia. he defeated\njalaluddin mangabarni, the ruler of kwarizam.\nmangabarni crossed the river indus and sought\nasylum from iltutmish. iltutmish refused to give him\nshelter in order to save his empire from the\nonslaught of the mongols. fortunately for\niltutmish, chengiz khan retuned home without\nentering into india. in fact, the mongol policy of\niltutmish saved india from the wrath of chengiz\nkhan.\niltutmish marched against bengal and bihar and reasserted\nhis control over them. he also annexed sind and multan into the\ndelhi sultanate. he suppressed the rajput revolts and recovered\nranthampur, jalor, ajmir and gwalior. he led an expedition against\nthe paramaras of malwa but it was not successful.\niltutmish was a great statesman. he received the mansur, the\nletter of recognition, from the\nabbasid caliph in 1229 by which he\nbecame the legal sovereign ruler of\nindia. later he nominated his\ndaughter raziya as his successor.\nthus the hereditary succession to\ndelhi sultanate was initiated by\niltutmish. he patronized many scholars and a number sufi saints came\nto india during his reign. minhaj-us-siraj, taj-ud-din., nizam-ul-mulk\nmuhammad janaidi, malik qutb-ud-din hasan and fakhrul-mulk isami\nwere his contemporary scholars who added grandeur to his court. apart\nfrom completing the construction of qutb minar at delhi, the tallest\nstone tower in india (238 ft.), he built a magnificent mosque at ajmir.\nsilver tanka of iltutmish \nportrait of\nchengiz khan\n\n177 176\nin 1279, tughril khan, the governor of bengal revolted against\nbalban. it was suppressed and he was beheaded. in the northwest\nthe mongols reappeared and balban sent his son prince mahmud\nagainst them. but the prince was killed in the battle and it was a\nmoral blow to the sultan. balban died in 1287. he was undoubtedly\none of the main architects of the delhi sultanate. he enhanced the\npower of the monarchy. however, he could not fully safeguard india\nfrom the mongol invasions.\nwhen balban died, one of his grandsons kaiqubad was made\nthe sultan of delhi. after four years of incompetent rule, jalaluddin\nkhalji captured the throne of delhi in 1290.\nthe khalji dynasty (1290-1320)\nthe advent of the khalji dynasty marked the zenith of muslim\nimperialism in india. the founder of the khalji dynasty was jalaluddin\nkhalji. he was seventy years old when he came to power. he was\ngenerous and lenient. malik chhajju, nephew of balban was allowed\nto remain the governor of kara. his leniency was misunderstood as\nweakness. when chhajju revolted, it was suppressed but he was\npardoned. when the thugs (robbers) looted the country, they were\nallowed to go after a severe warning. in 1292 when malik chhajju\nrevolted for the second time, he was replaced by his son-in-law,\nalauddin khalji. in 1296 alauddin khalji took\nan expedition to devagiri and returned to kara.\nduring the reception there, alauddin khalji\ntreacherously murdered his father-in-law\njalaluddin khalji and usurped the throne of\ndelhi.\nalauddin khalji (1296-1316)\nalauddin khalji made enormous gifts to\nthe hostile nobles and amirs of delhi to win\nintrigues of his rivals in the royal court. he had overcome all the\ndifficulties. in 1266 nasiruddin mahmud died without issues and\nbalban ascended the throne.\nbalban’s experience as the regent made him to understand\nthe problems of delhi sultanate. he knew that the real threat to the\nmonarchy was from the nobles called the forty. he was convinced\nthat only by enhancing the power and authority of the monarchy he\ncould face the problems. according to balban the sultan was god’s\nshadow on earth and the recipient of divine grace. balban introduced\nrigorous court discipline and new customs such as prostration and\nkissing the sultan’s feet to prove his superiority over the nobles. he\nalso introduced the persian festival of nauroz to impress the nobles\nand people with his wealth and power. he stood forth as the\nchampion of turkish nobility. at the same time he did not share\npower with other nobles. indian muslims were not given important\npost in the government. he appointed spies to monitor the activities\nof the nobles.\nbalban was determined to break the power of the forty, the\nturkish nobles. he spared only the most obedient nobles and\neliminated all others by fair or foul means. malik baqbaq, the\ngovernor of badaun, was publicly flogged for his cruelty towards\nhis servants. haybat khan, the governor of oudh, was also punished\nfor killing a man who was drunk. sher khan, the governor of\nbhatinda was poisoned. instead of expanding his kingdom, balban\npaid more attention to the restoration of law and order. he\nestablished a separate military department - diwan-i-arz – and\nreorganized the army. the outskirts of delhi were often plundered\nby the mewatis. balban took severe action against them and\nprevented such robberies. robbers were mercilessly pursued and\nput to death. as a result, the roads became safe for travel.\nalauddin khalji\n\n179 178\nover them to his side. those who still opposed him accession were\npunished severely. he framed regulations to control the nobles. he\nwas convinced that the general prosperity of the nobles, inter-\nmarriages between noble families, inefficient spy-system and drinking\nliquor were the basic reasons for the rebellions. therefore, he passed\nfour ordinances. he confiscated the properties of the nobles. the\nintelligence system was reorganized and all the secret activities of\nthe nobles were immediately reported to the sultan. the public sale\nof liquor and drugs was totally stopped. social gatherings and\nfestivities without the permission of sultan were forbidden. by such\nharsh measures his reign was free from rebellions.\nreforms of alauddin khalji\nalauddin khalji maintained a large permanent standing army\nand paid them in cash from the royal treasury. according the ferishta,\nhe recruited 4,75,000 cavalrymen. he introduced the system of\ndagh (branding of horses) and prepared huliya (descriptive list of\nsoldiers). in order to ensure maximum efficiency, a strict review of\narmy from time to time was carried out.\nthe introduction of paying salaries in cash to the soldiers led\nto price regulations popularly called as market reforms. alauddin\nkhalji established four separate markets in delhi, one for grain;\nanother for cloth, sugar, dried fruits, butter and oil; a third for horses,\nslaves and cattle; and a fourth for miscellaneous commodities. each\nmarket was under the control of a high officer called shahna-i-\nmandi. the supply of grain was ensured by holding stocks in\ngovernment store-houses. regulations were issued to fix the price\nof all commodities. a separate department called diwani riyasat\nwas created under an officer called naib-i-riyasat. every merchant\nwas registered under the market department. there were secret\nagents called munhiyans who sent reports to the sultan regarding\nthe functioning of these markets. the sultan also sent slave boys to\nindian ocean aribian sea\nbay of bengal kabul\npeshavar\nmultan\ndelhi\noudh\nchitore\nanhilvaraprayaggaur\nbengal\nwarangal dauladabad\nmaduraidwarasamudra\nempire of\nalauddin khilji\n\n181 180\nalauddin next turned against chittor. it was the powerful state in\nrajasthan. the siege lasted for several months. in 1303 alauddin\nstormed the chittor fort. raja ratan singh and his soldiers fought\nvaliantly but submitted. the rajput women including rani padmini\nperformed jauhar. this padmini episode was graphically mentioned\nin the book padmavath written by jayasi.\nalauddin khalji’s greatest achievement was the conquest of\ndeccan and the far south. this region was ruled by four important\ndynasties – yadavas of devagiri, kakatiyas of warangal, hoysalas of\ndwarasamudra and the pandyas of\nmadurai. in alauddin sent malik kafur\nagainst the ruler of devagiri,\nramachandra deva, who submitted and\npaid rich tributes. in 1309 malik kafur\nlaunched his campaign against warangal.\nits ruler pratabarudra deva was defeated\nand enormous booty was collected from\nhim. malik kafur’s next target was the\nhoysala ruler vira ballala iii. he was defeated and a vast quantity of\nbooty was seized and sent to delhi. kafur next marched against the\npandyas. vira pandya fled the capital madurai and kafur seized\nenormous wealth from the pandya kingdom and returned to delhi.\nalauddin khalji died in 1316. although the sultan was illiterate,\nhe patronized poets like amir khusrau and amir hasan. he also\nbuilt a famous gateway known as alai darwaza and constructed a\nnew capital at siri.\nmubarak shah and khusru shah were the successors of\nalauddin khalji. ghazi malik, the governor of dipalpur, killed the\nsultan khusru shah and ascended the throne of delhi under the\ntitle of ghiyasuddin tughlaq in 1320.\nalai darwaza \nbuy various commodities to check prices. violation of regulations\nwas severely punished. harsh punishment was given if any shop-\nkeeper charged a higher price, or tried to cheat by using false weights\nand measures. even during the famine the same price was maintained.\nwe are not sure whether the market regulations in delhi were also\napplied in the provincial capitals and towns.\napart from market reforms, alauddin khalji took important\nsteps in the land revenue administration. he was the first sultan of\ndelhi who ordered for the measurement of land. even the big\nlandlords could not escape from paying land tax. land revenue was\ncollected in cash in order to enable the sultan to pay the soldiers in\ncash. his land revenue reforms provided a basis for the future\nreforms of sher shah and akbar.\nmilitary campaigns\nalauddin khalji sent his army six times against the mongols. the\nfirst two was successful. but the third mongol invader khwaja came\nup to delhi but they were prevented from entering into the capital city.\nthe next three mongol invasions were also dealt with\nseverely. thousands of mongols were killed. the\nnorthwestern frontier was fortified and gazi malik\nwas appointed to as the warden of marches to protect\nthe frontier.\nthe military conquests of alauddin khalji\ninclude his expedition against gujarat, mewar and\nthe deccan. he sent nusrat khan and ulugh khan\nto capture gujarat in 1299. the king and his\ndaughter escaped while the queen was caught and\nsent to delhi. kafur, an eunuch, was also taken to delhi and later\nhe was made the malik naib – military commander. then in 1301,\nalauddin marched against ranthampur and after a three month’s\nsiege it fell. the rajput women committed jauhar or self-immolation.rani  padmini\n\n183 182\ntoken currency\nin 1329-30 muhammad bin\ntughlaq introduced a token currency.\nthere was a shortage of silver through\nout the world in the fourteenth\ncentury. kublai khan issued paper\nmoney in china. in the same manner, muhammad bin tughlaq issued\ncopper coins at par with the value of the silver tanka coins. but he\nwas not able to prevent forging the new coins. the goldsmiths began\nto forge the token coins on a large scale. soon the new coins were\nnot accepted in the markets. finally, muhammad bin tughlaq\nstopped the circulation of token currency and promised to exchange\nsilver coins for the copper coins. many people exchanged the new\ncoins but the treasury became empty. according the barani, the\nheap of copper coins remained lying on roadside in tughlaqabad.\ntaxation in doab\nthe failure of these two experiments affected the prestige of\nthe sultan and enormous money was wasted. in order to overcome\nfinancial difficulties, muhammad bin tughlaq increased the land\nrevenue on the farmers of doab (land between ganges and yamuna\nrivers). it was an excessive and arbitrary step on the farmers. a\nsevere famine was also ravaging that region at that time. it had\nresulted in a serious peasant revolts. they fled from the villages but\nmuhammad bin tughlaq took harsh measures to capture and punish\nthem. the revolts were crushed.\nagricultural reforms\nhowever, the sultan realized later that adequate relief measures\nand the promotion of agriculture were the real solution to the\nproblem. he launched a scheme by which takkavi loans (loans for\ncultivation) were given to the farmers to buy seed and to extend\ncopper coins of \nmuhammad bin tughlaq \nthe tughlaq dynasty (1320-1414)\nthe founder of the tughlaq dynasty was ghiyasuddin tughlaq.\nghiyasuddin tughlaq sent his son juna khan to fight against\nwarangal. he defeated pratabarudra and returned with rich booty.\nghiyasuddin laid the foundation for tughlaqabad near delhi. ulugh\nkhan was said to have treacherously killed his father and ascended\nthe throne with the title muhammad bin tughlaq in 1325.\nmuhammad bin tughlaq (1325-1351)\nhe was a very attractive character in the history of medieval\nindia owing to his ambitious schemes and novel experiments. his\nenterprises and novel experiments ended in miserable failures\nbecause they were all far ahead of their time. he was very tolerant\nin religious matters. he maintained diplomatic relations with far off\ncountries like egypt, china and iran. he also introduced many liberal\nand beneficial reforms. but all his reforms failed. contemporary\nwriters like isami, barani and ibn battutah were unable to give a\ncorrect picture about his personality. but, muhammad bin tughlaq\nwas the only delhi sultan who had received a comprehensive literary,\nreligious and philosophical education.\ntransfer of capital\nmuhammad bin tughlaq wanted to make devagiri his second\ncapital so that he might be able to control south india better. in\n1327 he made extensive preparations for the transfer of royal\nhousehold and the ulemas and sufis from delhi to devagiri, which\nwas renamed as daulatabad. when they resisted the sultan enforced\nhis orders ruthlessly and caused great hardship of the population of\ndelhi. the distance between these two places was more than 1500\nkilometres. many people died during the rigorous journey in the\nsummer. after two years, the sultan abandoned daulatabad and\nasked them to return to delhi.\n\n185 184\ndelhi sultanate. firoz led a campaign against jajnagar (modern\norissa). he returned with rich booty acquired from the temples. he\nmarched against nagarkot and made its ruler to pay tributes. during\nthis campaign the sultan collected 1300 sanskrit manuscripts from\nthe jawalamukhi temple library and got them translated into persian.\nfiroz next marched against thatta in the sind region and crushed a\nrebellion there.\nadministrative reforms\nthe reign of firoz tughlaq was more notable for his\nadministration. he strictly followed the advice of the ulemas in\nrunning the administration. he pleased the nobles and assured\nhereditary succession to their properties. thus the iqta system was\nnot only revived but also it was made hereditary. as per the islamic\nlaw he levied the taxes. jiziya was strictly imposed on non-muslims.\nhe was the first sultan to impose irrigation tax. but at the same time\nhe dug irrigation canals and wells. the longest canal was about 200\nkilometres from sutlej to hansi. another canal was between yamuna\nand hissar. there were about 1200 fruit gardens in and around\ndelhi yielding more revenue. the special tax on 28 items was\nabolished by him since they were against the islamic law. he also\ndeveloped royal factories called karkhanas in which thousands of\nslaves were employed. about 300 new towns were built during his\nreign. the famous among them was firozabad near red fort in\ndelhi, now called firoz shah kotla. old monuments like jama\nmasjid and qutb-minar were also repaired.\na new department called diwan-i-khairat was created to\ntake care of orphans and widows. free hospitals and marriage\nbureaus for poor muslims were also established. firoz patronized\nscholars like barani and afif. as he was guided by the ulemas, he\nwas intolerant towards shia muslims and sufis. he treated hindus\nas second grade citizens and imposed jiziya. in this respect he was cultivation. a separate department for agriculture, diwan- i- kohi\nwas established. model farm under the state was created in an area\nof 64 square miles for which the government spent seventy lakh\ntankas. this experiment was further continued by firoz tughlaq.\nrebellions\nthe latter part of muhammad bin tughlaq’s reign witnessed a\nspate of rebellions by the nobles and provincial governors. the\nrebellion of hasan shah resulted in the establishment of the madurai\nsultanate. in 1336 the vijayanagar kingdom was founded. in 1347\nbhamini kingdom was established. the governors of oudh, multan\nand sind revolted against the authority of muhammad bin tughlaq.\nin gujarat taghi rose in revolt against the sultan who spent nearly\nthree years in chasing him. muhammad bin tughlaq’s health became\nworse and he died in 1351. according to baduani, the sultan was\nfreed from his people and the people from the sultan. according to\nbarani, muhammad bin tughlaq was a mixture of opposites. his\nreign marked the beginning of the process of its decline.\nfiroz tughlaq (1351-1388)\nafter the death of muhammad-bin-tughlaq in 1351 firoz\ntughlaq had the unique distinction of being chosen as sultan by the\nnobles. he appointed khan-i-jahan maqbal, a telugu brahmin\nconvert as wazir (prime minister). the wazir helped the sultan in his\nadministration and maintained the prestige of the sultanate during\nthis period.\nmilitary campaigns\nafter his accession firoz had to face the problem of preventing\nthe disintegration of the delhi sultanate. he tried to safeguard his\nauthority over north india instead of reasserting his authority over\nthe deccan and south india. he led two expeditions to bengal but\nthey were not successful. bengal became free from the control of\n\n187 186\nto conclude a treaty with him, and extended his empire from the punjab\nto bihar. he was a good administrator. roads were laid and many\nirrigational facilities were provided for the benefit of the peasantry.\ndespite certain laudable qualities, he was a bigot. he destroyed many\nhindu temples and imposed many restrictions on the hindus. yet, he\nwas one of the great lodi sultans who made the sultanate strong and\npowerful.\nsikandar lodi was succeeded by his eldest son ibrahim lodi\nwho was arrogant. he insulted his nobles openly in court and humiliated\nthem. those nobles who revolted were put to death. his own uncle,\nalauddin revolted. daulat khan lodi, the governor of the punjab was\ninsulted and disaffection between king and courtier became very\ncommon. greatly displeased by the arrogance of ibrahim, daulat khan\nlodi invited babur to invade india. babur marched against delhi and\ndefeated and killed ibrahim lodi in the first battle of panipat (1526).\nthe afghan kingdom lasted for only seventy-five years.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. political history of delhi sultanate from 1206 to 1526\na.d.\n2. the rulers of slave dynasty – aibak, iltutmish, raziya,\nbalban – and their achievements.\n3. khalji dynasty – alauddin khalji’s military achievements\nand reforms.\n4. tughlaq dynasty – mahmud-bin-tughlaq’s achievements\nand his administrative experiments.\n5. firoz tughlaq and his administration.\n6. sayyids and lodis and the decline of delhi sultanate.\nthe precursor of sikandar lodi and aurangazeb. also he increased\nthe number of slaves by capturing the defeated soldiers and young\npersons. in his regime the number of slaves had increased to one\nlakh eighty thousand. when firoz died in 1388 the struggle for power\nbetween the sultan and the nobles started once again. his successors\nhad to face the rebellion of the slaves created by firoz.\nin the following years, the delhi sultanate had disintegrated\nfurther. many provinces like malwa and gujarat declared their\nindependence. the invasion of timur in 1398 had worsened the\nsituation. when timur entered delhi there was no opposition and\nhe sacked delhi for three days murdering thousands of people and\nlooting enormous wealth. he withdrew from india in 1399 and his\ninvasion in fact delivered a death blow to the tughlaq dynasty.\nsayyids (1414-1451)\nbefore his departure from india, timur appointed khizr khan as\ngovernor of multan. he captured delhi and founded the sayyid dynasty\nin 1414. he tried to consolidate the delhi sultanate but in vain. he died\nin 1421 and was succeeded by his son, mubarak shah. muhammad\nshah who succeeded him was always busy against conspirators and\ngradually lost control over his nobles. buhlul khan lodi dominated\neverything. muhammad shah died in 1445 and was succeeded by his\nson alam shah (1445-1451) the weakest of the sayyid princes. he\nhanded over the throne to buhlul lodi and retired to badaun.\nlodis (1451-1526)\nthe lodis, who succeeded sayyids, were afghans. buhlul\nlodi was the first afghan ruler while his predecessors were all turks.\nhe died in 1489 and was succeeded by his son, sikandar lodi.\nsikandar lodi (1489-1517) was the greatest of the three lodi\nsovereigns. he brought the whole of bihar under his control, many\nrajput chiefs were defeated. he attacked bengal and forced its ruler\n\n189 188\nb) alai darwaza was built by mahmud-bin-tughlaq.\nc) the department called diwan-i-khairat was created by firoz\ntughlaq to take care of orphans and widows.\nd) iltutmish introduced the persian festival of nauroz to impress\nthe nobles and people.\nv. state whether the following statements are true or\nfalse.\n1. tughril khan, the governor of bengal revolted against balban.\n2. firoz tughlaq patronized poets like amir khusrau.\n3. daulat khan lodi invited babur to invade india.\nvi. write short notes (any three points).\n1. raziya\n2. the forty\n3. token currency\n4. sayyids\n5. lodis\nvii. answer briefly (100 words).\n1. assess the achievements of qutbuddin aibak.\n2. examine the market reforms of alauddin khalji.\n3. write a note on the south indian expedition of malik kafur.\nviii.answer in detail (200 words).\n1. give an estimate of the achievements of iltutmish.\n2. examine the rule of balban and his theory of kingship.\n3. evaluate the personality of muhammad-bin-tughlaq.\n4. write an essay on the reforms of firoz tughlaq. model questions\ni. choose the correct answer.\n1. arabic coinage of tanka was introduced in india by\n(a) alauddin khalji(b) iltutmish\n(c) mahmud-bin tughlaq (d) firoz tughlaq\n2. the commander of the south indian expedition under alauddin\nkhalji\n(a) alauddin khalji(b) qutbuddin aibak\n(c) malik kafur (d) jalaluddin khalji\nii. fill in the blanks.\n1. ramachandra deva was the ruler of ……\n2. author of the book padmavathi was …..\n3. …… collected sanskrit manuscripts from the library at\njawalamukhi temple.\n4. the last ruler of the delhi sultanate was ……\niii. match the following.\n1. mahmud-bin-tughlaq a) theory of kingship\n2. alauddin khalji b) hasan nizami\n3. balban c) market reforms\n4. qutbuddin aibak d) token currency\niv. find out the correct statement. one statement alone is\nright.\na) the agricultural department, diwan-i-kohi was established\nby alauddin khalji.\n\n191 190\nlegal and political activities. there was no clear law of succession\nduring this period. all the sons had equal claim to the throne. iltutmish\neven nominated his daughter in preference to his sons. but such\nnominations or successions were to be accepted by the nobles.\nsometimes ulemas played crucial role in accepting the succession\nto the throne. however, the military superiority remained the main\nfactor in matters of succession.\ncentral government\nthe sultan was assisted by a number of departments and\nofficials in his administration. the post of naib was the most powerful\none. the naib practically enjoyed all the powers of the sultan and\nexercised general control over all the departments. next to him was\nthe wazir who was heading the finance department called diwani\nwizarat.\nthe military department was called diwani ariz. it was\nheaded by ariz-i-mumalik. he was responsible for recruiting the\nsoldiers and administering the military department. he was not the\ncommander-in-chief of the army. the sultan himself was the\ncommander-in-chief of the army. the military department was first\nset up by balban and it was further improved by alauddin khalji\nunder whom the strength of the army crossed three lakh soldiers.\nalauddin introduced the system of branding of the horses and\npayment of salary in cash. cavalry was given importance under the\ndelhi sultanate.\ndiwani rasalat was the department of religious affairs. it\nwas headed by chief sadr. grants were made by this department\nfor the construction and maintenance of mosques, tombs and\nmadrasas. the head of the judicial department was the chief qazi.\nother judges or qazis were appointed in various parts of the\nsultanate. muslim personal law or sharia was followed in civil administration\nthe establishment and expansion of the delhi sultanate led to\nthe evolution of a powerful and efficient administrative system. at\nits zenith the authority of delhi sultan had extended as far south as\nmadurai. although the delhi sultanate had disintegrated, their\nadministrative system made a powerful impact on the indian\nprovincial kingdoms and later on the mughal system of administration.\nthe delhi sultanate was an islamic state with its religion islam.\nthe sultans considered themselves as representatives of the caliph.\nthey included the name of the caliph in the khutba or prayer and\ninscribed it on their coins. although balban called himself the shadow\nof god, he continued to practice of including the name of caliph in\nthe khutba and coins. iltutmish, muhammad bin tughlaq and firoz\ntughlaq obtained mansur or letter of permission from the caliph.\nthe office of the sultan was the most important in the\nadministrative system. he was the ultimate authority for the military,\nlesson 17\nindia under the delhi sultanate\nlearning objectives\nstudents will acquire knowledge about\n1. administration under the delhi sultanate.\n2. economic condition under the delhi sultanate.\n3. social life under the delhi sultanate.\n4. art and architecture of the delhi sultanate.\n5. literary development.\n\n193 192\ntaxes and always led a hand-to-mouth living. frequent famines made\ntheir lives more miserable.\nhowever, sultans like muhammad bi tughlaq and firoz\ntughlaq took efforts to enhance agricultural production by providing\nirrigational facilities and by providing takkavi loans. they also\nencouraged the farmers to cultivate superior crop like wheat instead\nof barley. firoz encouraged the growth of horticulture. muhammad\nbin tughlaq created a separate agricultural department, diwani\nkohi.\nduring the sultanate period, the process of urbanization gained\nmomentum. a number of cities and towns had grown during this\nperiod. lahore, multan, broach, anhilwara, laknauti, daulatabad,\ndelhi and jaunpur were important among them. delhi remained the\nlargest city in the east. the growth of trade and commerce was\ndescribed by contemporary writers. india exported a large number\nof commodities to the countries on the persian gulf and west asia\nand also to south east asian countries. overseas trade was under\nthe control of multanis and afghan muslims. inland trade was\ndominated by the gujarat marwari merchants and muslim bohra\nmerchants. construction of roads and their maintenance facilitated\nfor smooth transport and communication. particularly the royal roads\nwere kept in good shape. sarais or rest houses on the highways\nwere maintained for the convenience of the travelers.\ncotton textile and silk industry flourished in this period.\nsericulture was introduced on a large scale which made india less\ndependent on other countries for the import of raw silk. paper\nindustry had grown and there was an extensive use of paper from\n14\nth and 15\nth centuries. other crafts like leather-making, metal-crafts\nand carpet-weaving flourished due to the increasing demand. the\nroyal karkhanas supplied the goods needed to the sultan and his\nhousehold. they manufactured costly articles made of gold, silver matters. the hindus were governed by their own personal law and\ntheir cases were dispensed by the village panchayats. the criminal\nlaw was based on the rules and regulations made by the sultans.\nthe department of correspondence was called diwani insha. all\nthe correspondence between the ruler and the officials was dealt\nwith by this department.\nlocal administration\nthe provinces under the delhi sultanate were called iqtas.\nthey were initially under the control of the nobles. but the governors\nof the provinces were called the muqtis or walis. they were to\nmaintain law and order and collect the land revenue. the provinces\nwere divided into shiqs and the next division was pargana. the\nshiq was under the control of shiqdar. the pargana comprising a\nnumber of villages was headed by amil. the village remained the\nbasic unit of the administration. the village headman was known as\nmuqaddam or chaudhri. the village accountant was called patwari.\neconomy\nafter consolidating their position in india, the delhi sultans\nintroduced reforms in the land revenue administration. the lands\nwere classified into three categories:\n1. iqta land – lands assigned to officials as iqtas instead of\npayment for their services.\n2. khalisa land – land under the direct control of the sultan and\nthe revenues collected were spent for the maintenance of royal\ncourt and royal household.\n3. inam land – land assigned or granted to religious leaders or\nreligious institutions.\nthe peasantry paid one third of their produce as land revenue,\nand sometimes even one half of the produce. they also paid other\n\n195 194\nor protected people for which they were forced to pay a tax called\njiziya. in the beginning jiziya was collected as part of land tax.\nfiroz tughlaq separated it from the land revenue and collected jiziya\nas a separate tax. sometimes brahmins were exempted from paying\njiziya.\nart and architecture\nthe art and architecture of the delhi sultanate period was\ndistinct from the indian style. the turks\nintroduced arches, domes, lofty towers\nor minarets and decorations using the\narabic script. they used the skill of the\nindian stone cutters. they also added\ncolour to their buildings by using\nmarbles, red and yellow sand stones.\nin the beginning, they converted temples and other structures\ndemolished into mosques. for example, the quwwat-ul-islam\nmosque near qutub minar in delhi was built by using the materials\nobtained from destroying many hindu and jain temples. but later,\nthey began to construct new structures. the most magnificent building\nof the 13\nth century was the qutub minar which was founded by\naibek and completed by iltutmish. this seventy one metre tower\nwas dedicated to the sufi saint qutbuddin bakthiyar kaki. the\nbalconies of this tower were projected from the main building and it\nwas the proof of the architectural skills of that period. later, alauddin\nkhalji added an entrance to the qutub minar called alai darwaza.\nthe dome of this arch was built on scientific lines.\nthe buildings of the tughlaq period were constructed by\ncombining arch and dome. they also used the cheaper and easily\navailable grey colour stones. the palace complex called tughlaqabad\nwith its beautiful lake was built during the period of ghyasuddin\nquwwat-ul-islam mosque \nand gold ware. the nobles also aped the life style of sultans and\nindulged in luxurious life. they were well paid and accumulated\nenormous wealth.\nthe system of coinage had also developed during the delhi\nsultanate. iltutmish issued several types of silver tankas. one silver\ntanka was divided into 48 jitals during the khalji rule and 50 jitals\nduring the tughlaq rule. gold coins or dinars became popular during\nthe reign of alauddin khalji after his south indian conquests. copper\ncoins were less in number and dateless. muhammad bin tughlaq\nhad not only experimented token currency but also issued several\ntypes of gold and silver coins. they were minted at eight different\nplaces. at least twenty five varieties of gold coins were issued by\nhim.\nsocial life\nthere was little change in the structure of the hindu society\nduring this period. traditional caste system with the brahmins on\nthe upper strata of the society was prevalent. the subservient position\nof women also continued and the practice of sati was widely\nprevalent. the seclusion of women and the wearing of purdah\nbecame common among the upper class women. the arabs and\nturks brought the purdah system into india and it became\nwidespread among the hindu women in the upper classes of north\nindia.\nduring the sultanate period, the muslim society remained\ndivided into several ethnic and racial groups. the turks, iranians,\nafghans and indian muslims developed exclusively and there were\nno intermarriages between these groups. hindu converts from lower\ncastes were also not given equal respect. the muslim nobles\noccupied high offices and very rarely the hindu nobles were given\nhigh position in the government. the hindus were considered zimmis\n\n197 196\namir khusrau (1252-1325) was the famous persian writer of\nthis period. he wrote a number of poems. he experimented with several\npoetical forms and created a new style of persian poetry called sabaq-\ni-hind or the indian style. he also wrote some hindi verses. amir\nkhusrau’s khazain-ul-futuh speaks about alauddin’s conquests. his\nfamous work tughlaq nama deals with the rise of ghyiasuddin tughlaq.\nsanskrit and persian functioned as link languages in the delhi\nsultanate. zia nakshabi was the first to translate sanskrit stories into\npersian. the book tutu nama or book of the parrot became popular\nand translated into turkish and later into many european languages.\nthe famous rajatarangini written by kalhana belonged to the period\nof zain-ul-abidin, the ruler of kashmir. many sanskrit works on\nmedicine and music were translated into persian.\nin arabic, alberuni’s kitab-ul-hind is the most famous work.\nregional languages also developed during this period. chand baradi\nwas the famous hindi poet of this period. bengali literature had also\ndeveloped and nusrat shah patronized the translation of mahabaratha\ninto bengali. the bakthi cult led to development of gujarati and marathi\nlanguages. the vijayanagar empire patronized telugu and kannada\nliterature.learning outcome\nafter learning this lesson the students will be able to explain\n1. central government and local administration under the\ndelhi sultanate.\n2. economic life of the people of india under the delhi\nsultanate.\n3. social condition and the impact of muslim rule on indian\nsociety.\n4. architectural contributions of the delhi sultanate.\n5. persian and other scholars lived during the delhi\nsultanate and their contribution.\ntughlaq. muhammad bin tughlaq built the tomb of ghyasuddin on\na high platform. the kotla fort at delhi was the creation of firoz\ntughlaq. the lodi garden in delhi was the example for the\narchitecture of the lodis.\nmusic\nnew musical instruments such as sarangi and rabab were\nintroduced during this period. amir khusrau introduced many new\nragas such as ghora and sanam. he evolved a new style of light\nmusic known as qwalis by blending the hindu and iranian systems.\nthe invention of sitar was also attributed to him. the indian classical\nwork ragadarpan was translated into persian during the reign of\nfiroz tughlaq. pir bhodan, a sufi saint was one of the great\nmusicians of this period. raja man singh of gwalior was a great\nlover of music. he encouraged the composition of a great musical\nwork called man kautuhal.\nliterature\nthe delhi sultans patronized learning and literature. many of\nthem had great love for arabic and persian literature. learned men\ncame from persia and persian language got encouragement from\nthe rulers. besides theology and poetry, the\nwriting of history was also encouraged. some\nof the sultans had their own court historians.\nthe most famous historians of this period were\nhasan nizami, minhaj-us-siraj, ziauddin\nbarani, and shams-siraj afif. barani’s tarikh-\ni-firoz shahi contains the history of tughlaq\ndynasty. minhaj-us-siraj wrote tabaqat-i-\nnasari, a general history of muslim dynasties\nup to 1260.\namir khusrau\n\n199 198\nc) inam land is the land assigned to soldiers for their services in\nwars.\nd) diwan-i-kohi was the department of land revenue.\nv. state whether the following statements are true or\nfalse.\n1. the finance department under the delhi sultanate was called\ndiwani wizarat.\n2. the indian classical work ragadarpan was translated into\nsanskrit.\n3. the hindus were considered zimmis and they were forced to\npay a tax called jiziya.\nvi. write short notes (any three points).\n1. diwani wizarat\n2. coinage under the delhi sultanate.\n3. amir khusrau\n4. qutub minar\nvii. answer briefly (100 words).\n1. give a brief account of local administration under the delhi\nsultanate.\n2. trace the economic condition under the delhi sultanate.\nviii.answer in detail (200 words).\n1. examine the administration of the delhi sultanate.\n2. evaluate the cultural contributions of the sultans of delhi. model questions\ni. choose the correct answer.\n1. the governors of the provinces in delhi sultanate were called\nthe\n(a) shikdars(b) muqtis\n(c) patwaris (d) chaudris\n2. the kotla fort at delhi was the creation of\n(a) firoz tughlaq (b) iltutmish\n(c) alauddin khalji(d) sikkandar lodi\nii. fill in the blanks.\n1. the military department under the delhi sultanate was called\n……\n2. new ragas such as ghora and sanam were introduced by …….\niii. match the following.\n1. minhaj-us-siraj a) rajatarangini\n2. amir khusrau b) tabaqat-i-nasari\n3. kalhana c) kitab-ul-hind\n4. alberuni d) sabaq-i-hind\niv. find out the correct statement. one statement alone is\nright.\na) iqta land is the land assigned to officials instead of payment\nfor their services.\nb) khalisa land is the land under the direct control of village\ncouncils.\n\n201 200\nsufism\nsufism was a liberal reform movement within islam. it had its\norigin in persia and spread into india in the eleventh century. the\nfirst sufi saint shaikh ismail of lahore started preaching his ideas.\nthe most famous of the sufi saints of india was khwaja muinuddin\nchishti, who settled in ajmer which became the centre of his\nactivities. he had a number of disciples who are called sufis of the\nchishti order. another well known sufi saint was bahauddin\nzakariya who came under the influence of another famous mystic\nshihabuddin suhrawardi. his branch of sufi saints was known as\nthe sufis of the suhrawardi order. yet another famous sufi saint\nwas nizamuddin auliya who belonged to the chishti order and who\nwas a mighty spiritual force. these sufi saints are revered even\ntoday by not only muslims but by a large number of hindus. their\ntombs have become popular places of pilgrimage for both\ncommunities.\nsufism stressed the elements of love and devotion as effective\nmeans of the realisation of god. love of god meant love of humanity\nand so the sufis believed service to humanity was tantamount to\nservice to god. in sufism, self discipline was considered an essential\ncondition to gain knowledge of god by sense of perception. while\northodox muslims emphasise external conduct, the sufis lay stress\non inner purity. while the orthodox believe in blind observance of\nrituals, the sufis consider love and devotion as the only means of\nattaining salvation. according to them one must have the guidance\nof a pir  or guru, without which spiritual development is impossible.\nsufism also inculcated a spirit of tolerance among its followers. other\nideas emphasised by sufism are meditation, good actions,\nrepentance for sins, performance of prayers and pilgrimages, fasting,\ncharity and suppression of passions by ascetic practices. we have already studied the rise of bhakti cult in tamil nadu\nduring the seventh and eight centuries. the saivaite nayanmars and\nvashnavaite alwars preached the bhakti cult under the pallavas,\npandyas and cholas. but, the spread of bhakti movement in\nmedieval india is a different kind. this medieval\nbhakti movement was the direct result of the\ninfluence of the spread of islam in india.\nmonotheism or belief in one god, equality and\nbrotherhood of man and rejection of rituals and\nclass divisions are the distinctive characteristics\nof islam. these islamic ideas created a profound\nimpact on the religious leaders of this period.\nmoreover, the preaching of sufi teachers shaped\nthe thinking of bhakti reformers like ramananda,\nkabir and nanak.\nlesson 18\nbhakti movement in medieval indialearning objectives\nstudents will acquire knowledge about\n1. rise and spread of bhakti movement in india.\n2. sufism and its development in india.\n3. bhakti saints like sankara, ramanuja and others.\n4. ramananda, kabir and guru nanak and their teachings.\n5. bhakti movement in bengal and maharashtra.\n6. importance of bhakti movement.\nkhwaja\nmuinuddin chishti\n\n203 202\nin the thirteenth century, madhava from kannada region\npropagated dvaita or dualism of jivatma and paramatma.\naccording to his philosophy, the world is not an illusion but a reality.\ngod, soul, matter are unique in nature. nimbarka and\nvallabhacharya were also other preachers of vaishnavite bhakti\nin the telungana region. surdas was the disciple of vallabhacharya\nand he popularized krishna cult in north india. mirabai was a great\ndevotee of krishna and she became popular in rajasthan for her\nbhajans. tulsidas was a worshipper of rama and composed the\nfamous ramcharitmanas, the hindi version of ramayana.\nin the fourteenth and fifteenth centuries, ramananda, kabir\nand nanak remained great apostles of the bhakti cult. they drew\ninspiration from old masters but showed a new path. they helped\nthe common people to shed age-old superstitions and attain salvation\nthrough bhakti or pure devotion. unlike the early reformers, they\nwere not linked with any particular religious creed and did not believe\nin rituals and ceremonies. they condemned polytheism and believed\nin one god. they also denounced all forms of idolatry. they strongly\nbelieved in bhakti as the only means of salvation. they also\nemphasised the fundamental unity of all religions.\nramananda\nramananda was born at allahabad. he was originally a\nfollower of ramanuja. later he founded his own sect and preached\nhis principles in hindi at banaras and agra. he was a worshipper\nof rama. he was the first to employ the vernacular medium to\npropagate his ideas. simplification of worship and emancipation of\npeople from the traditional caste rules were his two important\ncontributions to the bhakti movement. he opposed the caste system\nand chose his disciples from all sections of society disregarding caste.\nhis disciples were: a) kabir, a muslim weaver b) raidasa, a cobbler\nc) sena, a barber d) sadhana, a butcher e) dhanna, a jat farmer\nf) naraharai, a goldsmith and g) pipa, a rajput prince. these liberal and unorthodox features of sufism had a\nprofound influence on medieval bhakti saints. in the later period,\nakbar, the mughal emperor, appreciated sufi doctrines which\nshaped his religious outlook and religious policies. when the sufi\nmovement was becoming popular in india, about the same time the\nbhakti cult was gaining strength among the hindus. the two parallel\nmovements based on the doctrines of love and selfless devotion\ncontributed a great deal to bringing the two communities closer\ntogether. however, this trend did not last long.\nbhakti movement\nin the ninth century sankara started a\nhindu revivalist movement giving a new\norientation to hinduism. he was born in kaladi\nin kerala. his doctrine of advaita or monism\nwas too abstract to appeal to the common man.\nmoreover, there was a reaction against the\nadvaita concept of nirgunabrahman (god\nwithout attributes) with the emergence of the\nidea of sagunabrahman (god with attributes).\nin the twelfth century, ramanuja, who was born at\nsriperumbudur near modern chennai, preached visishtadvaita.\naccording to him god is sagunabrahman. the\ncreative process and all the objects in creation\nare real but not illusory as was held by\nsankaracharya. therefore, god, soul, matter are\nreal. but god is inner substance and the rest are\nhis attributes. he also advocated prabattimarga\nor path of self-surrender to god. he invited the\ndowntrodden to vaishnavism.\n \nramanuja\nsankara\n\n205 204\nand kindness. ‘abide pure amidst the impurities of the world’ was\none of his famous sayings. his life was dedicated to establishing\nharmony between hindus and muslims. his followers were known\nas sikhs.\nchaitanya was another well-known saint and reformer of\nbengal who popularised the krishna cult. he renounced the world,\nbecame an ascetic and wandered all over the country preaching his\nideas. he proclaimed the universal brotherhood of man and con-\ndemned all distinction based on religion and caste. he emphasised\nlove and peace and showed great sympathy to the sufferings of\nother people, especially that of the poor and the weak. he believed\nthat through love and devotion, song and dance, a devotee can feel\nthe presence of god. he accepted disciples from all classes and\ncastes and his teachings are widely followed in bengal even today.\ngnanadeva was the founder of the bhakti movement in\nmaharashtra in the thirteenth century. it was called maharashtra\ndharma. he wrote a commentary of bhagavat gita called\ngnaneswari. namadeva preached the gospel of love. he opposed\nidol worship and priestly domination. he also opposed the caste\nsystem. in the sixteenth century, ekanatha opposed caste\ndistinctions and sympathetic towards the lower castes. he composed\nmany lyrics and his bhajans and kirtans were famous. another bhakti\nsaint of maharashtra was tukaram, a contemporary of sivaji. he\nwas responsible for creating a background for maratha nationalism.\nhe opposed all social distinctions.\nimportance of the bhakti movement\nthe importance of the bhakti movement was very great.\nvarious preachers spoke and wrote in the regional languages. so,\nthe bhakti movement provided an impetus for the development of\nregional languages such as hindi, marathi, bengali, kannada, etc.\nthrough these languages they made direct appeal to the masses. as kabir\namong the disciples of ramananda the most famous was\nkabir. he was born near banaras to a brahmin widow. but he was\nbrought up by a muslim couple who were weavers by profession.\nhe possessed an inquiring mind and while in\nbenares learnt much about hinduism. he\nbecame familiar with islamic teachings also and\nramananda initiated him into the higher\nknowledge of hindu and muslim religious and\nphilosophical ideas. kabir’s object was to\nreconcile hindus and muslims and establish\nharmony between the two sects. he denounced\nidolatry and rituals and laid great emphasis on\nthe equality of man before god. he emphasised\nthe essential oneness of all religions by describing\nhindus and muslims ‘as pots of the same clay’. to him rama and\nallah, temple and mosque were the same. he regarded devotion to\ngod as an effective means of salvation and urged that to achieve this\none must have a pure heart, free from cruelty, dishonesty, hypocrisy\nand insincerity. he is regarded as the greatest of the mystic saints\nand his followers are called kabirpanthis.\nguru nanak\nanother well-known saint-preacher of\nthe medieval period was guru nanak, founder\nof the sikh religion and a disciple of kabir.\nhe was born in talwandi near lahore. he\ndenounced caste distinctions and rituals like\nbathing in holy rivers. his conception of\nreligion was highly practical and sternly\nethical. he exhorted people to give up selfish-\nness, falsehood and hypocrisy and to lead a life of truth, honesty\nkabir\nguru nanak\n\n207 206\nmodel questions\ni. choose the correct answer.\n1. the most famous disciple of ramananda\n(a) kabir(b) ramadas\n(c) namadeva(d) chaitanya\n2. madhva preached his principles in\n(a) tamil (b) bengali\n(c) kannada(d) marathi\nii. fill in the blanks.\n1. ajmer was the centre of the activities of the sufi saint …….\n2. nimbarka and vallabhacharya preached their teachings in\n…… region.\n3. tukaram was a contemporary of ……\niii. match the following.\n1. sankara a) allahabad\n2. ramanuja b) kaladi\n3. nanakc) sriperumbudur\n4. ramananda d) talwandi\niv. find out the correct statement. one statement alone is\nright.\na) gnanadeva was the founder of bhakti movement in bengal.\nb) he wrote a commentary of bhagavat gita called\ngnaneswari.\nc) he was a contemporary of sivaji.\nd) he was a disciple of guru nanak. the caste system was condemned by the bhakti saints, the lower\nclasses were raised to a position of great importance. the\nimportance of women in society was also increased because the\nbhakti movement gave equal importance to them. moreover, the\nbhakti movement gave to the people a simple religion, without\ncomplicated rituals. they were required to show sincere devotion\nto god. the new idea of a life of charity and service to fellow people\ndeveloped.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. origin and spread of bhakti movement in medieval india.\n2. sufism and its different orders such as chishti and\nsuhrwardi orders.\n3. early bhakti saints like sankara, ramanuja and others.\n4. the teachings of ramananda, kabir and guru nanak.\n5. bhakti movement in bengal and maharashtra.\n6. importance of bhakti movement.\n\n209 208\nvijayanagar empire\nsources\nthe history of vijayanagar empire constitutes an important\nchapter in the history of india. four dynasties – sangama, saluva,\ntuluva and aravidu – ruled vijayanagar from a.d. 1336 to 1672.\nthe sources for the study of vijayanagar are varied such as literary,\narchaeological and numismatics. krishnadevaraya’s\namukthamalyada, gangadevi’s maduravijayam and allasani\npeddanna’s manucharitam are some of the indigenous literature of\nthis period.\nmany foreign travelers visited the vijayanagar empire and\ntheir accounts are also valuable. the moroccan traveler, ibn battuta,\nvenetian traveler nicolo de conti, persian traveler abdur razzak\nand the portuguese traveler domingo paes were among them who\nleft valuable accounts on the socio-economic conditions of the\nvijayanagar empire.\nlesson 19\nvijayanagar and bahmani kingdomslearning objectives\nstudents will acquire knowledge about\n1. sources for the study of vijayanagar empire.\n2. political history of the vijayanagar empire.\n3. administration and social life.\n4. economic condition and cultural contributions.\n5. a brief history of the bahmani kingdom.\nv. state whether the following statements are true or\nfalse.\n1. nizamuddin auliya belonged to the chishti order.\n2. chaitanya was a well-known bhakti saint and reformer of\nmaharashtra.\n3. ramanuja’s philosophy was known as vishistadvaida.\nvi. write short notes (any three points).\n1. chishti order\n2. ramanuja\n3. guru nanak\n4. kabir\nvii. answer briefly (100 words).\n1. trace the spread of sufism in india.\n2. bring out the importance of bhakti movement in medieval\nindia.\nviii.answer in detail (200 words).\n1. give an account of the rise and spread of bhakti movement\nin medieval india.\n\n211 210\ndrawn conflict. the greatest ruler of the sangama dynasty was deva\nraya ii. but he could not win any clear victory over the bahmani\nsultans. after his death, sangama dynasty became weak. the next\ndynasty, saluva dynasty founded by saluva narasimha reigned only\nfor a brief period (1486-1509).\nkrishna deva raya (1509 – 1530)\nthe tuluva dynasty was founded by vira narasimha. the\ngreatest of the vijayanagar rulers, krishna deva raya belonged to\nthe tuluva dynasty. he possessed great military ability. his imposing\npersonality was accompanied by high intellectual quality. his first\ntask was to check the invading bahmani forces.\nby that time the bahmani kingdom was replaced\nby deccan sultanates. the muslim armies were\ndecisively defeated in the battle of diwani by\nkrishna deva raya. then he invaded raichur\ndoab which had resulted in the confrontation with\nthe sultan of bijapur, ismail adil shah. but,\nkrishna deva raya defeated him and captured\nthe city of raichur in 1520. from there he marched\non bidar and captured it.\nkrishna deva raya’s orissa campaign was also successful.\nhe defeated the gajapathi ruler prataparudra and conquered the\nwhole of telungana. he maintained friendly relations with the\nportuguese. albuquerque sent his ambassadors to krishna deva\nraya.\nthough a vaishnavaite, he respected all religions. he was a\ngreat patron of literature and art and he was known as andhra bhoja.\neight eminent scholars known as ashtadiggajas were at his royal\ncourt. allasani peddanna was the greatest and he was called the copper plate inscriptions such as the\nsrirangam copper plates of devaraya ii provide\nthe genealogy and achievements of vijayanagar\nrulers. the hampi ruins and other monuments of\nvijayanagar provide information on the cultural\ncontributions of the vijayanagar rulers. the\nnumerous coins issued by the vijayanagar rulers\ncontain figures and legends explaining their tittles\nand achievements.\npolitical history\nvijayanagar was founded in 1336 by harihara and bukka of\nthe sangama dynasty. they were originally served under the kakatiya\nrulers of warangal. then they went to kampili where they were\nimprisoned and converted to islam. later, they returned to the hindu\nfold at the initiative of the saint vidyaranya. they also proclaimed\ntheir independence and founded a new city on the south bank of the\ntungabhadra river. it was called vijayanagar meaning city of victory.\nthe decline of the hoysala kingdom enabled harihara and\nbukka to expand their newly founded kingdom. by 1346, they\nbrought the whole of the hoysala kingdom under their control. the\nstruggle between vijayanagar and sultanate of madurai lasted for\nabout four decades. kumarakampana’s expedition to madurai was\ndescribed in the maduravijayam. he destroyed the madurai sultans\nand as a result, the vijayanagar empire comprised the whole of\nsouth india up to rameswaram.\nthe conflict between vijayanagar empire and the bahmani\nkingdom lasted for many years. the dispute over raichur doab,\nthe region between the rivers krishna and tungabhadra and also\nover the fertile areas of krishna-godavari delta led to this long-\nibn battuta\n \nkrishna\ndeva raya\n\n213 212\nthe empire was divided into different administrative units\ncalled mandalams, nadus, sthalas and finally into gramas. the\ngovernor of mandalam was called mandaleswara or nayak.\nvijayanagar rulers gave full powers to the local authorities in the\nadministration.\nbesides land revenue, tributes and gifts from vassals and feudal\nchiefs, customs collected at the ports, taxes on various professions\nwere other sources of income to the government. land revenue\nwas fixed generally one sixth of the produce. the expenditure of\nthe government includes personal expenses of king and the charities\ngiven by him and military expenditure. in the matter of justice, harsh\npunishments such as mutilation and throwing to elephants were\nfollowed.\nthe vijayanagar army was well-organized and efficient. it\nconsisted of the cavalry, infantry, artillery and elephants. high-breed\nhorses were procured from foreign traders. the top-grade officers\nof the army were known as nayaks or poligars. they were granted\nland in lieu of their services. these lands were called amaram.\nsoldiers were usually paid in cash.\nsocial life\nallasani peddanna in his manucharitam refers the existence\nof four castes – brahmins, kshatriyas, vaisyas and sudras - in the\nvijayanagar society. foreign travelers left vivid accounts on the\nsplendour of buildings and luxurious social life in the city of\nvijayanagar. silk and cotton clothes were mainly used for dress.\nperfumes, flowers and ornaments were used by the people. paes\nmentions of the beautiful houses of the rich and the large number of\ntheir household servants. nicolo conti refers to the prevalence of\nslavery. dancing, music, wrestling, gambling and cock-fighting were\nsome of the amusements. andhrakavita pitamaga. his important works include\nmanucharitam and harikathasaram. pingali suranna and tenali\nramakrishna were other important scholars. krishna deva raya\nhimself authored a telugu work, amukthamalyadha and sanskrit\nworks, jambavati kalyanam and ushaparinayam.\nhe repaired most of the temples of south india. he also built\nthe famous vittalaswamy and hazara ramaswamy temples at\nvijayanagar. he also built a new city called nagalapuram in memory\nof his queen nagaladevi. besides, he built a large number of\nrayagopurams.\nafter his death, achutadeva and venkata succeeded the\nthrone. during the reign of rama raya, the combined forces of\nbijapur, ahmadnagar, golkonda and bidar defeated him at the battle\nof talaikotta in 1565. this battle is also known as raksasa\nthangadi. rama raya was imprisoned and executed. the city of\nvijayanagar was destroyed. this battle was generally considered\nto mark the end of the vijayanagar empire. however, the\nvijayanagar kingdom existed under the aravidu dynasty for about\nanother century. thirumala, sri ranga and venkata ii were the\nimportant rulers of this dynasty. the last ruler of vijayanagar kingdom\nwas sri ranga iii.\nadministration\nthe administration under the vijayanagar empire was well\norganized. the king enjoyed absolute authority in executive, judicial\nand legislative matters. he was the highest court of appeal. the\nsuccession to the throne was on the principle of hereditary.\nsometimes usurpation to the throne took place as saluva narasimha\ncame to power by ending the sangama dynasty. the king was\nassisted by a council of ministers in his day to day administration.\n\n215 214\ncoin was the varaha but weights and measures varied from place\nto place. inland, coastal and overseas trade led to the general\nprosperity. there were a number of seaports on the malabar coast,\nthe chief being cannanore. commercial contacts with arabia, persia,\nsouth africa and portugal on the west and with burma, malay\npeninsula and china on the east flourished. the chief items of exports\nwere cotton and silk clothes, spices, rice, iron, saltpeter and sugar.\nthe imports consisted of horses, pearls, copper, coral, mercury,\nchina silk and velvet clothes. the art of shipbuilding had developed.\ncultural contributions\nthe temple building activity further gained momentum during\nthe vijayanagar rule. the chief characteristics of the vijayanagara\narchitecture were the construction of tall raya gopurams or\ngateways and the kalyanamandapam with carved pillars in the\ntemple premises. the sculptures on the pillars were carved with\ndistinctive features. the horse was the most common animal found\nin these pillars. large mandapams contain one hundred pillars as\nwell as one thousand pillars in some big temples. these mandapams\nwere used for seating the deity on festival occasions. also, many\namman shrines were added to the already existing temples during\nthis period.\nthe most important temples of the\nvijayanagar style were found in the hampi\nruins or the city of vijayanagar.\nvittalaswamy and hazara ramaswamy\ntemples were the best examples of this style.\nthe varadharaja and ekamparanatha\ntemples at kanchipuram stand as examples\nfor the magnificence of the vijayanagara\nstyle of temple architecture. the raya\ngopurams at thiruvannamalai and\neastern gopuram of  \nvaradharaja perumal temple \nthe sangama rulers were chiefly saivaites and virupaksha\nwas their family deity. but other dynasties were vaishnavites.\nsrivaishnavism of ramanuja was very popular. but all kings were\ntolerant towards other religions. borbosa referred to the religious\nfreedom enjoyed by everyone. muslims were employed in the\nadministration and they were freely allowed to build mosques and\nworship. a large number of temples were built during this period\nand numerous festivals were celebrated. the epics and the puranas\nwere popular among the masses.\nthe position of women had not improved. however, some of\nthem were learned. gangadevi, wife of kumarakampana authored\nthe famous work maduravijayam. hannamma and thirumalamma\nwere famous poets of this period. according to nuniz, a large number\nof women were employed in royal palaces as dancers, domestic\nservants and palanquin bearers. the attachment of dancing girls to\ntemples was in practice. paes refers to the flourishing devadasi\nsystem. polygamy was prevalent among the royal families. sati was\nhonoured and nuniz gives a description of it.\neconomic condition\naccording to the accounts of the foreign travelers, the\nvijayanagar empire was one of the wealthiest parts of the world at\nthat time. agriculture continued to be the chief occupation of the\npeople. the vijayanagar rulers provided a stimulus to its further\ngrowth by providing irrigation facilities. new tanks were built and\ndams were constructed across the rivers like tunghabadra. nuniz\nrefers to the excavation of canals.\nthere were numerous industries and they were organized into\nguilds. metal workers and other craftsmen flourished during this\nperiod. diamond mines were located in kurnool and anantapur\ndistrict. vijayanagar was also a great centre of trade. the chief gold\n\n217 216\nmahmud gawan\nthe bahmani kingdom reached its peak under the guidance of\nmahmud gawan. he was a persian merchant. he came to india at the\nage of forty two and joined the services of bahmani kingdom. slowly\nhe became the chief minister due to his personal qualities. he remained\nloyal to the kingdom. he lived a simple life and was magnanimous. he\nwas also a learned person. he possessed a great knowledge of\nmathematics. he made endowments to build a college at bidar which\nwas built in the persian style of architecture. he was also a military\ngenius. he waged successful wars against vijayanagar, orissa and the\nsea pirates on the arabian sea. his conquests include konkan, goa\nand krishna-godavari delta. thus he expanded the bahmani empire\nthrough his conquests.\nhis administrative reforms were also important. they were aimed\nto increase the control of sultan over the nobles and provinces. royal\nofficers were appointed in each province for this purpose. most of the\nforts were under the control of\nthese officers. allowances were\nreduced to the nobles who shirked\ntheir responsibility. this was\ndisliked by the nobles. so, the\ndeccani nobles organised a plot\nagainst gawan. they induced the\nsultan to punish him with death\nsentence. after the execution of\ngawan, the bahmani kingdom\nbegan to decline. muhammad shah was succeeded by weak sultans.\nduring this period the provincial governors declared their independence.\nby the year 1526, the bahmani kingdom had disintegrated into five\nindependent sultanates. they were ahmadnagar, bijapur, berar,\ngolkonda and bidar and known as deccan sultanates. chidambaram speak the glorious\nepoch of vijayanagar. they were\ncontinued by the nayak rulers in\nthe later period. the metal images\nof krishna deva raya and his\nqueens at tirupati are examples\nfor casting of metal images. music\nand dancing were also patronized\nby the rulers of vijayanagar.\ndifferent languages such as sanskrit, telugu, kannada and\ntamil flourished in the regions. there was a great development in\nsanskrit and telugu literature. the peak of literary achievement was\nreached during the reign of krishna deva raya. he himself was a\nscholar in sanskrit and telugu. his famous court poet allasani\npeddanna was distinguished in telugu literature. thus the cultural\ncontributions of the vijayanagar rulers were many-sided and\nremarkable.\nbahmani kingdom\nthe founder of the bahmani kingdom was alauddin bahman\nshah also known as hasan gangu in 1347. its capital was gulbarga.\nthere were a total of fourteen sultans ruling over this kingdom.\namong them, alauddin bahman shah, muhammad shah i and firoz\nshah were important. ahmad wali shah shifted the capital from\ngulbarga to bidar. the power of the bahmani kingdom reached its\npeak under the rule of muhammad shah iii. it extended from the\narabian sea to the bay of bengal. on the west it extended from\ngoat to bombay. on the east, it extended from kakinada to the\nmouth of the river krishna. the success of muhammad shah was\ndue to the advice and services of his minister mahmud gawan.\n \n \nelephant chariot – hampi ruins\nruins of golkonda fort\n\n219 218\nmodel questions\ni. choose the correct answer.\n1. the family deity of sangama rulers was\n(a) durga(b) vittala\n(c) virupaksha (d) rama\n2. mahmud gawan was a trader from\n(a) arabia(b) morocco\n(c) portugal(d) persia\nii. fill in the blanks.\n1. krishna deva raya belonged to ….. dynasty.\n2. hazara ramaswamy temple was built at …..\n3. the founder of the bahmani kingdom …..\niii. match the following.\n1. abdur razzak a) venice\n2. ibn battuta b) persia\n3. domingo paes c) morocco\n4. nicolo de conti d) portugal\niv. find out the correct statement. one statement alone is\nright.\na) the bahmani capital was shifted from gulbarga to berar.\nb) the bahmani capital was shifted from gulbarga to bidar.\nc) the bahmani capital was shifted from bidar to gulbarga.\nd) the bahmani capital was shifted from berar to gulbarga.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. literary and other sources for the study of vijayanagar\nempire.\n2. four dynasties of vijayanagar and krishna deva raya’s\naccomplishments.\n3. administrative system and social life under the\nvijayanagar empire.\n4. economic conditions under the vijayanagar empire.\n5. literature, art and architecture of the vijayanagar\nempire.\n6. bahmani kingdom and mahmud gawan’s achievements.\n\n221 220\npolitical history\nbabur (1526-1530)\nbabur was the founder of the mughal empire in india. his\noriginal name was zahiruddin muhammad. he\nwas related to timur from his father’s side and\nto chengiz khan through his mother. babur\nsucceeded his father umar shaikh mirza as the\nruler of farghana. but he was soon defeated by\nhis distant relative and as a result lost his\nkingdom. he became a wanderer for sometime\ntill he captured kabul from one of his uncles.\nthen, babur took interest in conquering india\nand launched four expeditions between 1519 and 1523.lesson 20\nthe mughal empire\nlearning objectives\nstudents will acquire knowledge about\n1. political history of the mughal empire.\n2. babur and his achievements.\n3. humayuns’ difficulties and the sur interregnum.\n4. akbar and his achievements – religious policy.\n5. jahangir and shah jahan.\n6. aurangazeb and his religious policy.\n7. causes for the decline of the mughal empire.\nbabur \nv. state whether the following statements are true or\nfalse.\n1. kumarakamapana wrote maduravijayam.\n2. allasani peddanna was a kannada scholar.\n3.amukthamalyadha was written by krishna deva raya in\ntelugu language.\nvi. write short notes (any three points).\n1. sangama dynasty\n2. provincial administration under the vijayanagar.\n3. hasan gangu.\n4. position of women in vijayanagar empire.\nvii. answer briefly (100 words).\n1. write a note on the foreign travelers who visited the\nvijayanagar empire.\n2. examine the growth of literature under the vijayanagar rule.\nviii. answer in detail (200 words).\n1. estimate the achievements of krishna deva raya.\n2. examine the cultural contributions of the vijayanagar rulers.\n3. give an estimate of mahmud gawan.\n\n223 222\nhumayun (1530-1540)\nhumayun was the eldest son of babur.\nhumayun means “fortune” but he remained the\nmost unfortunate ruler of the mughal empire.\nhumayun had three brothers, kamran, askari\nand hindal. humayun divided the empire among\nhis brothers but this proved to be a great blunder\non his part. kamran was given kabul and\nkandahar. sambhal and alwar were given to\naskari and hindal.\nwhen humayun was busy with fighting the afghans in the\neast, he got the news that bahadur shah of gujarat was advancing\ntowards delhi. therefore, he hastily concluded a treaty with the\nafghan leader sher khan (later sher shah) and proceeded towards\ngujarat.\nhumayun captured gujarat from bahadur shah and appointed\naskari as its governor. but soon bahadur shah recovered gujarat\nfrom askari who fled from there. in the meantime sher khan became\npowerful in the east. humayun marched against him and in the battle\nof chausa, held in 1539, sher khan destroyed the mughal army\nand humayun escaped from there. humayun reached agra to\nnegotiate with his brothers. but as they were not cooperative,\nhumayun was forced to fight with sher khan alone in the battle of\nbilgram in 1540. this battle was also known as battle of kanauj.\nhumayun was thoroughly defeated by sher khan. after losing his\nkingdom, humayun became an exile for the next fifteen years.\nsur interregnum (1540-1555)\nthe founder of the sur dynasty was sher shah, whose original\nname was farid. he was the son of hasan khan, a jagirdar of\nsasaram in bihar. later, farid served under the afghan ruler of\nhumayun\n \nmilitary conquests\non the eve of babur’s invasion of india, there were five\nprominent muslim rulers – the sultans of delhi, gujarat, malwa,\nbengal and the deccan – and two prominent hindu rulers – rana\nsangha of mewar and the vijayanagar empire. once again by the\nend of 1525, babur started from kabul to conquer india. he\noccupied lahore easily by defeating its governor, daulat khan lodi.\nthen he proceeded against delhi where ibrahim lodi was the sultan.\non 21\nst april 1526 the first battle of panipat took place between\nbabur and ibrahim lodi, who was killed in the battle. babur’s\nsuccess was due his cavalry and artillery. babur occupied delhi\nand sent his son humayun to seize agra. babur proclaimed himself\nas “emperor of hindustan”.\nhis subsequent victories over rana sangha and the afghans\nsecured his position as the ruler of india. rana sangha of mewar\nwas a great rajput warrior. he marched against babur and in the\nbattle of khanua (near agra) held in 1527 babur won a decisive\nvictory over him. babur assumed the title ghazi.\nin 1528, babur captured chanderi from another rajput ruler\nmedini rai. in the next year, babur defeated the afghans in the\nbattle of gogra in bihar. by these victories, babur consolidated his\npower in india. babur died at agra in 1530 at the age of forty\nseven.\nestimate of babur\nbabur was a great statesman and a man of solid achievements.\nhe was also a great scholar in arabic and persian languages. turki\nwas his mother tongue. he wrote his memoirs, tuzuk-i-baburi in\nturki language. it provides a vivid account of india. he frankly\nconfesses his own failures without suppressing any facts. he was\nalso a naturalist and described the flora and fauna of india.\n\n225 224\nthe land revenue administration was well organized under\nsher shah. land survey was carefully done. all cultivable lands\nwere classified into three classes – good, middle and bad. the state’s\nshare was one third of the average produce and it was paid in cash\nor crop. his revenue reforms increased the revenue of the state.\nsher shah introduced new silver coins called “dam” and they were\nin circulation till 1835.\nsher shah had also improved the communications by laying\nfour important highways. they were: 1. sonargaon to sind 2. agra\nto burhampur 3. jodhpur to chittor and 4. lahore to multan. rest\nhouses were built on the highways for the convenience of the\ntravelers. police was efficiently reorganized and crime was less during\nhis regime.\nthe military administration was also efficiently reorganized\nand sher shah borrowed many ideas like the branding of horses\nfrom alauddin khalji.\nestimate of sher shah\nsher shah remained a pious muslim and generally tolerant\ntowards other religions. he employed hindus in important offices.\nhe was also a patron of art and architecture. he built a new city on\nthe banks of the river yamuna near delhi. now the old fort called\npurana qila and its mosque is alone surviving. he also built a\nmausoleum at sasaram, which is considered as one of the master\npieces of indian architecture. sher shah also patronized the learned\nmen. malik muhammad jayasi wrote the famous hindi work\npadmavat during his reign.\nafter sher shah’s death in 1545 his successors ruled till 1555\nwhen humayun reconquered india. bihar, who gave him the title sher khan for his bravery. we have\nalready seen how he defeated humayun at the battle of chausa\nand became the ruler of delhi in 1540.\nsher shah sur (1540-1545)\nsher shah waged extensive wars with the\nrajputs and expanded his empire. his conquests\ninclude punjab, malwa, sind, multan and\nbundelkhand. his empire consisted of the whole of\nnorth india except assam, nepal, kashmir and\ngujarat.\nsher shah’s administration\nalthough his rule lasted for five years, he\norganized a brilliant administrative system. the central government\nconsisted of several departments. the king was assisted by four\nimportant ministers:\n1. diwan –i- wizarat – also called as wazir - in charge\nof revenue and finance.\n2. diwan-i-ariz – in charge of army.\n3. diwan-i-rasalat- foreign minister.\n4. diwan-i-insha- minister for communications.\nsher shah’s empire was divided into forty seven sarkars.\nchief shiqdar (law and order) and chief munsif (judge) were the\ntwo officers in charge of the administration in each sarkar. each\nsarkar was divided into several parganas. shiqdar (military\nofficer), amin (land revenue), fotedar (treasurer) karkuns\n(accountants) were in charge of the administration of each pargana.\nthere were also many administrative units called iqtas.\nsher  shah\nsur\n\n227 226\nhumayun (1555-1556)\nwhen humayun left india in 1540, he married hamida banu\nbegum on his way to sind. when they stayed in amorkot, a hindu\nkingdom ruled by rana prasad, akbar was born in 1542. humayun\nthen proceeded to iran and sought help from its ruler. he later defeated\nhis brothers, kamran and askari. in the meantime the sur dynasty in\nindia was declining rapidly. in 1555, humayun defeated the afghans\nand recovered the mughal throne. after six months, he died in 1556\ndue to his fall from the staircase of his library. although humayun was\nnot a good general and warrior, he was kind and generous. he was\nalso learned and a student of mathematics, astronomy and astrology.\nhe also loved painting and wrote poetry in persian language.\nakbar (1556-1605)\nakbar was one of the greatest monarchs of india. he\nsucceeded the throne after his father humayun’s death. but his\nposition was dangerous because delhi was seized\nby the afghans. their commander-in-chief, hemu,\nwas in charge of it. in the second battle of panipat\nin 1556, hemu was almost on the point of victory.\nbut an arrow pierced his eye and he became\nunconscious. his army fled and the fortune\nfavoured akbar. the mughal victory was decisive.\nduring the first five years of akbar’s reign,\nbairam khan acted as his regent. he consolidated the mughal\nempire. after five years he was removed by akbar due to court\nintrigues and sent to mecca. but on his way bairam was killed by\nan afghan.\nakbar’s military conquests were extensive. he conquered\nnorthern india from agra to gujarat and then from agra to bengal.\nhe strengthened the northwest frontier. later, he went to the deccan.\nakbar\n\n229 228\nin 1562, he abolished jiziya. he allowed his hindu wives to worship\ntheir own gods. later, he became a skeptical muslim. in 1575, he\nordered for the construction of ibadat khana (house of worship)\nat his new capital fatepur sikri. akbar invited learned scholars from\nall religions like hinduism, jainism, christianity and zoroastrianism.\nhe disliked the interference of the muslim ulemas in political\nmatters. in 1579, he issued the “infallibility decree” by which he\nasserted his religious powers.\nin 1582, he promulgated a new religion called din ilahi or\ndivine faith. it believes in one god. it contained good points of all\nreligions. its basis was rational. it upholds no dogma. it was aimed\nat bridging the gulf that separated different religions. however, his\nnew faith proved to be a failure. it fizzled out after his death. even\nduring his life time, it had only fifteen followers including birbal.\nakbar did not compel anyone to his new faith.\nland revenue administration\nakbar made some experiments in the land revenue\nadministration with the help of raja todar mal. the land revenue\nsystem of akbar was called zabti or bandobast system. it was\nfurther improved by raja todar mal. it was known as dahsala\nsystem which was completed in 1580. by this system, todar mal\nintroduced a uniform system of land measurement. the revenue was\nfixed on the average yield of land assessed on the basis of past ten\nyears. the land was also divided into four categories – polaj\n(cultivated every year), parauti (once in two years), chachar (once\nin three or four years) and banjar (once in five or more years).\npayment of revenue was made generally in cash.\nmansabdari system\nakbar introduced the mansabdari system in his administration.\nunder this system every officer was assigned a rank (mansab). the relations with rajputs\nthe rajput policy of akbar was notable. he married the\nrajput princess, the daughter of raja bharamal. it was a turning\npoint in the history of mughals. rajputs served the mughals for four\ngenerations. many of them rose to the positions of military generals.\nraja bhagawan das and raja man singh were given senior positions\nin the administration by akbar. one by one, all rajput states\nsubmitted to akbar.\nbut the ranas of mewar continued to defy despite several\ndefeats. in the battle of haldighati, rana pratap singh was severely\ndefeated by the mughal army led by man singh in 1576. following\nthe defeat of mewar, most of the leading rajput rulers had accepted\nakbar’s suzerainty.\nakbar’s rajput policy was combined with a broad religious\ntoleration. he abolished the pilgrim tax and later the jiziya. the rajput\npolicy of akbar proved to be beneficial to the mughal state as well\nas to the rajputs. the alliance secured to the mughals the services\nof the bravest warriors. on the other hand it ensured peace in\nrajasthan and a number of rajputs who joined the mughal service\nrose to important positions.\nreligious policy\nakbar rose to fame in the pages of history due to his religious\npolicy. various factors were responsible for his religious ideas. the\nmost important among them were his early contacts with the sufi\nsaints, the teachings of his tutor abdul latif, his marriage with rajput\nwomen, his association with intellectual giants like shaikh mubarak\nand his two illustrious sons – abul faizi and abul fazl – and his\nambition to establish an empire in hindustan.\nin the beginning of his life, akbar was a pious muslim. soon\nafter marrying jodh bai of amber, he abolished the pilgrim tax and\n\n231 230\nthis drove shah jahan into rebellion against his father in 1622, since\nhe felt that jahangir was completely under nur jahan’s influence.\nhowever, this view is not accepted by some other historians. till\njahangir became weak due to ill health, he only took important\npolitical decisions. it is revealed from his autobiography.\nhowever, it is clear that nur jahan dominated the royal\nhousehold and set new fashions based on persian traditions. she\nencouraged persian art and culture in the court. she was a constant\ncompanion of jahangir and even joined him in his hunting.\nthe rise of shah jahan was due to his personal ambitions. he\nrose in revolt against his father who ordered him to go to kandahar.\nthis rebellion distracted the activities of the empire for four years.\nafter jahangir’s death in 1627, shah jahan reached agra with the\nsupport of the nobles and the army. nur jahan was given a pension\nand lived a retired life till her death eighteen years later.\nshah jahan (1627-1658)\nshah jahan launched a prolonged\ncampaign in the northwest frontier to recover\nkandahar and other ancestral lands. the\nmughal army lost more than five thousand lives\nduring the successive invasions between 1639\nand 1647. then shah jahan realized the futility\nof his ambition and stopped fighting.\nhis deccan policy was more successful.\nhe defeated the forces of ahmadnagar and annexed it. both bijapur\nand golkonda signed a treaty with the emperor. shah jahan carved\nfour mughal provinces in the deccan – khandesh, berar, telungana\nand daulatabad. they were put under the control of his son\naurangazeb.\nshah jahan and \nmumtaj – a painting\n \nlowest rank was 10 and the highest was 5000 for the nobles. princes\nof royal blood received even higher ranks. the ranks were divided\ninto two – zat and sawar. zat means personal and it fixed the\npersonal status of a person. sawar rank indicated the number of\ncavalrymen of a person who was required to maintain. every sawar\nhad to maintain at least two horses. the mansab rank was not\nhereditary. all appointments and promotions as well as dismissals\nwere directly made by the emperor.\njahangir (1605-1627)\nwhen akbar died, prince salim\nsucceeded with the title jahangir (conqueror\nof world) in 1605. jahangir’s rule witnessed a\nspate of rebellions. his son khusrau revolted\nbut was defeated and imprisoned. one of his\nsupporters, guru arjun, the fifth sikh guru, was\nbeheaded.\nnur jahan\nin 1611, jahangir married mehrunnisa who was known as\nnur jahan (light of world). her father itimaduddauala was a\nrespectable person. he was given the post\nof chief diwan. other members of her family\nalso benefited from this alliance. nur jahan’s\nelder brother asaf khan was appointed as\nkhan-i-saman, a post reserved for the\nnobles. in 1612, asaf khan’s daughter,\narjumand banu begum (later known as\nmumtaj), married jahangir’s third son, prince\nkhurram (later shah jahan).\nit was believed by some historians that nur jahan formed a\ngroup of “junta” and this led to two factions in the mughal court.\njahangir \nnur jahan\n\n233 232\nwar of succession\n the last years of shah jahan’s reign were clouded by a bitter\nwar of succession among his four sons – dara shikoh (crown\nprince), shuja (governor of bengal), aurangazeb (governor of\ndeccan) and murad baksh (governor of malwa and gujarat).\ntowards the end of 1657, shah jahan fell ill at delhi for some time\nbut later recovered. but the princes started fighting for the mughal\nthrone.\naurangazeb emerged victorious in this struggle. he entered\nthe agra fort after defeating dara. he forced shah jahan to surrender.\nshah jahan was confined to the female apartments in the agra fort\nand strictly put under vigil. but he was not ill-treated. shah jahan\nlived for eight long years lovingly nursed by his daughter jahanara.\nhe died in 1666 and buried beside his wife’s grave in the taj mahal.\naurangazeb (1658-1707)\naurangazeb was one of the ablest of the\nmughal kings. he assumed the title alamgir, world\nconqueror. his military campaigns in his first ten\nyears of reign were a great success. he\nsuppressed the minor revolts. but he faced serious\ndifficulties in the latter part of his reign. the jats\nand satnamis and also the sikhs revolted against\nhim. these revolts were induced by his harsh\nreligious policy.\ndeccan policy\nthe deccan policy of the mughals started from the reign of\nakbar, who conquered khandesh and berar. jahangir fought against\nmalik amber of ahmadnagar. during the shah jahan’s reign,\naurangazeb, as governor of deccan, followed an aggressive deccan\npolicy. when he became the mughal emperor, for the first twenty\naurangazeb \naurangzeb’s empire\nkabul\npeshawar\npanipat\ndeli\nagra rajputs\nrajaputs\nallahabad\npatna\ngondwana\ndiu\nmumbai\ngoa\ncalicut\ncochinpolygarsbay of bengal\nindian ocean aribian seamarathas jats\n\n235 234\nhe was also against the sikhs and he executed the ninth sikh guru\ntej bahadur. this had resulted in the transformation of sikhs into a\nwarring community.\nhis religious policy was responsible for turning the rajputs,\nthe marathas and sikhs into the enemies of mughal empire. it had\nalso resulted in the rebellions of the jats of mathura and the satnamis\nof mewar. therefore, aurangazeb was held responsible for the\ndecline of the mughal empire.\npersonality and character of aurangazeb\nin his private life, aurangazeb was industrious and disciplined.\nhe was very simple in food and dress. he earned money for his\npersonal expenses by copying quran and selling those copies. he\ndid not consume wine. he was learned and proficient in arabic and\npersian languages. he was a lover of books. he was devoted to his\nreligion and conducted prayers five times a day. he strictly observed\nthe ramzan fasting.\nin the political field, aurangazeb committed serious mistakes.\nhe misunderstood the true nature of the maratha movement and\nantagonized them. also, he failed to solve the maratha problem\nand left an open sore. his policy towards shia deccan sultanates\nalso proved to be a wrong policy.\nhis religious policy was also not successful. aurangazeb was\nan orthodox sunni muslim. but his move to apply his religious\nthought rigidly in a non-muslim society was a failure. his antagonistic\npolicies towards non-muslims did not help him to rally the muslims\nto his side. on the other hand it had strengthened political enemies\nof the mughal empire. five years, he concentrated on the northwest frontier. at that time,\nthe maratha ruler, sivaji carved out an independent maratha\nkingdom in the territories of north and south konkan.\nto contain the spread of the marathas, aurangazeb decided\nto invade bijapur and golkonda. he defeated sikandar shah of\nbijapur and annexed his kingdom. then, he proceeded against\ngolkonda and eliminated the kutb shahi dynasty. it was also\nannexed by him. in fact, the destruction of the deccan kingdoms\nwas a political blunder on the part of aurangazeb. the barrier\nbetween the mughals and the marathas was removed and there\nensued a direct confrontation between them. also, his deccan\ncampaigns exhausted the mughal treasury. according to j.n. sarkar,\nthe deccan ulcer ruined aurangazeb.\nreligious policy\naurangazeb was a staunch and orthodox muslim in his\npersonal life. his ideal was to transform india into an islamic state.\nhe created a separate department to enforce moral codes under a\nhigh-powered officer called muhtasib. drinking was prohibited.\ncultivation and use of bhang and other drugs were banned.\naurangazeb forbade music in the mughal court. he discontinued\nthe practice of jarokhadarshan. he also discontinued the celebration\nof dasarah and royal astronomers and astrologers were also\ndismissed from service.\ninitially aurangazeb banned the construction of new hindu\ntemples and repair of old temples. then he began a policy of\ndestroying hindu temples. the celebrated temples at mathura and\nbenares were reduced to ruins. in 1679, he reimposed jiziya and\npilgrim tax. he was also not tolerant of other muslim sects. the\ncelebration of muharram was stopped. his invasions against the\ndeccan sultanates were partly due to his hatred of the shia faith.\n\n237 236\nmodel questions\ni. choose the correct answer.\n1. babur wrote tuzuk-i-baburi in the language of\n(a) persian(b) hindi\n(c) arabic(d) turki\n2. the original name of shah jahan was\n(a) salim(b) khurram\n(c) dara shikoh(d) farid\nii. fill in the blanks.\n1. the battle of chausa took place between ….. and …… in\nthe year …..\n2. in the battle of haldighati …….. was defeated by the mughal\narmy led by …….\n3. during the last years of his life shah jahan was lovingly nursed\nby his daughter …….\niii. match the following.\n1. battle of haldighati a) 1540\n2. second battle of panipat b) 1539\n3. battle of chausa c) 1576\n4. battle of bilgram d) 1556\niv. find out the correct statement. one statement alone is\nright.\na) the deccan policy of akbar led to the decline of the mughals.\nb) the religious policy of aurangazeb was one among the causes\nfor the decline of the mughal empire. causes for the downfall of the mughals\nthe mughal empire declined rapidly after the death of\naurangazeb. the mughal court became the scene of factions among\nthe nobles. the weakness of the empire was exposed when nadir\nshah imprisoned the mughal emperor and looted delhi in 1739.\nthe causes for the downfall of the mughal empire were varied. to\nsome extent, the religious and deccan policies of aurangazeb\ncontributed to its decline. the weak successors and demoralization\nof the mughal army also paved the way for it. the vastness of the\nempire became unwieldy. the financial difficulties due to continuous\nwars led to the decline. the neglect of the sea power by the mughals\nwas felt when the europeans began to settle in india. further, the\ninvasions of nadir shah and ahmad shah abdali weakened the\nmughal state. thus the decline and downfall of the mughal empire\nwas due to the combination of political, social and economic factors.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. political history of the mughal empire from babur to\naurangazeb.\n2. achievements of babur and the difficulties of humayun.\n3. sur interregnum – sher shah’s administration.\n4. the reign of akbar – his administration, mansabdari\nsystem and religious policy.\n5. jahangir, shah jahan and the war of succession.\n6. deccan policy of aurangazeb and his religious policy.\n7. decline of the mughal empire\n\n238\nc) aurangazeb had supported the muslim sultanates of deccan.\nd) the antagonistic policies of aurangazeb towards non-muslims\nhelped him to rally the muslims to his side.\nv. state whether the following statements are true or\nfalse.\n1. babur defeated the rajputs in the battle of gogra in bihar.\n2. the zabti system was further improved by raja todar mal.\n3. shah jahan executed the ninth sikh guru tej bahadur.\nvi. write short notes (any three points).\n1. tuzuk-i-baburi.\n2. sur interregnum.\n3. raja todar mal.\n4. din ilahi.\n5. nur jahan.\nvii. answer briefly (100 words).\n1. bring out the achievements of babur.\n2. write a brief not on the war of succession in the last years of\nshah jahan.\n3. analyse the causes for the decline of the mughal empire.\nviii.answer in detail (200 words).\n1. give an account of the salient features of the administration\nof sher shah.\n2. assess the achievements of akbar.\n3. evaluate the religious policy of aurangazeb.\n\n239\neconomic and social life\nthe mughal period saw important social and economic\ndevelopments. during this period, many european travelers and\ntraders came to india and their accounts contain a mine of information\nabout the socio-economic conditions of india. in general, they\ndescribed the wealth and prosperity of india and also the luxurious\nlife of the aristocratic classes. on the other side, they also mentioned\nthe poverty and sufferings of the ordinary people such as peasants\nand artisans.\nmughal nobility\nthe nobles of the mughal period formed a privileged class.\nmost of them were foreigners such as turks and afghans. but there\nwas tussle between them throughout this period. however, many of\nthem settled down in india and made it their permanent home. they\nlearning objectives\nstudents will acquire knowledge about\n1. the causes for the vellore mutiny.\n1. economic and social life under the mughal empire.\n2. mughal nobility and their way of life.\n3. agriculture and trade.\n4. cultural development – art and architecture.\n5. mughal paintings and literature.\nlesson 21\nindia under the mughals\n\n241 240\nred chillies came later in the eighteenth century. but, no new\nagricultural technique was introduced during this period. however,\nindia was able to export food items like rice and sugar to the\nneighbouring countries.\ngrowth of trade\nthe indian trading classes were large in numbers and spread\nthroughout the country. they were well organized and highly professional.\nseth, bohra traders specialized in long distance trade while local traders\nwere called banik. another class of traders was known as banjaras,\nwho specialized in carrying bulk goods. the banjaras used to move to\nlong distances with their goods on the back of oxen. bulk goods were\nalso taken through rivers on boats. the trading community did not belong\nto one caste or religion. the gujarathi merchants included the hindus,\njains and muslims. in rajasthan, oswals, maheshwaris and agarwals\ncame to be called the marwaris. multanis, khatris and afghanis\nconducted trade with central asia. in south india, the chettis on the\ncoramandal coast and the muslim merchants of malabar were the\nmost important trading communities.\nbengal exported sugar, rice as well as delicate muslin and\nsilk. the coramandal coast became a centre of textile production.\ngujarat was an entry point of foreign goods. from there, fine textiles\nand silk were taken to north india. indigo and food grains were\nexported from north india through gujarat. it was also the distribution\ncentre for the luxury products of kashmir such as shawls and carpets.\nthe major imports into india were certain metals such as tin and\ncopper, war horses and luxury items such as ivory. the balance of\ntrade was maintained by the import of gold and silver. the growth\nof foreign trade had resulted in the increased import of gold and\nsilver in the seventeenth century. the dutch and english traders who\ncame to gujarat during the seventeenth century, found that indian\ntraders were alert and brisk. readily assimilated themselves into the indian society and culture.\nat the same time they retained some of their personal traits. from\nthe time of akbar, the hindus, particularly the rajputs were included\nin the nobility. for example, mention may be made about raja man\nsingh, raja birbal and raja todar mal. later, the marathas also\njoined the mughal service and rose to the position of nobles.\nthe mughal nobles were paid high salaries but their expenses\nwere also very high. each noble maintained a large number of\nservants, horses, elephants, etc. the nobles tried follow the luxurious\nlife style of the mughal emperors. they wore fine clothes and ate\nimported fruits. costly jewels were worn by men and women. they\nalso made costly presents to the emperors.\nrural masses\nwhile the wealthy people wore silk and cotton clothes, the\npoor people wore the minimum cloths. they suffer from insufficient\nclothing even during the winter. nikitin observed that the people of\ndeccan were bare-footed. it might be due to high cost of leather.\nrice, millets and pulses were the staple food of the common people.\nfish was popular on the coastal region. while ghee and oil were\ncheaper, salt and sugar were more expensive. as plenty of cattle\nwere kept by the rural people, milk and milk products were available\nin plenty.\nagriculture\nan estimate claims that the population of india at the beginning\nof the seventeenth century was about 125 million. as plenty of land\nwas available for cultivation, agriculture was prosperous. a large\nvariety of crops such as wheat, rice, gram, barley, pulses were\ncultivated. commercial crops such as cotton, indigo, sugarcane and\noil-seeds were also cultivated. during the seventeenth century two\nnew crops, namely, tobacco and maize were added. potato and\n\n243 242\nakbar also built a palace-\ncum-fort complex at fatepur\nsikri (city of victory), 36\nkilometres from agra. many\nbuildings in gujarathi and\nbengali styles are found in this\ncomplex. gujarathi style\nbuildings were probably built for\nhis rajput wives. the most\nmagnificent building in it is the jama masjid\nand the gateway to it called buland darwaza\nor the lofty gate. the height of the gateway\nis 176 feet. it was built to commemorate\nakbar’s victory over gujarat. other\nimportant buildings at fatepur sikri are jodh\nbai’s palace and panch mahal with five\nstoreys.\n during akbar ’s reign, the humayun’s\ntomb was built at delhi and it had a massive\ndome of marble. it may be considered the\nprecursor of the taj mahal. akbar’s tomb at\nsikandara near agra was completed by jahangir. nur jahan built\nthe tomb of itimaddaulah at agra. it was constructed wholly of\nwhite marble with floral designs\nmade of semi-precious stones on\nthe walls. this type of decoration\nwas called pietra dura. this\nmethod became more popular\nduring the reign of shah jahan. the\npietra dura method was used on a\nlarge scale in the taj mahal by cultural development under the mughals\nthe mughal period witnessed a significant and widespread\ndevelopment in cultural activity. it was manifest in the sphere of art\nand architecture, painting, music and literature. in this cultural\ndevelopment, indian traditions were blended with turko-iranian\nculture which was brought into india by the mughals.\nart and architecture\nthe architecture of the mughals includes the magnificent forts,\npalaces, public buildings, mosques\nand mausoleums. the mughals\nwere fond of laying gardens with\nrunning water. some of the\nmughal gardens such as the nishat\nbagh in kashmir, the shalimar\nbagh at lahore and the pinjore\ngarden in the punjab have survived\neven today. during the reign of\nsher shah, the mausoleum at\nsasaram in bihar and the purana qila near delhi were built. these\ntwo monuments are considered as the architectural marvels of\nmedieval india.\nlarge scale construction of buildings started with the advent\nof akbar. he built many forts and the\nmost famous one was the agra fort.\nit was built in red sandstone. his other\nforts are at lahore and allahabad.\nthe climax of fort-building reached its\nclimax during the reign of shah jahan.\nthe famous red fort at delhi with its\nrang mahal, diwan-i-am and\ndiwan-i-khas was his creation.\ndiwan-i-khas \n \nfatepur sikri\n \nbuland  darwaza\npanch mahal \npurana qila\n\n245 244\nillustrations of persian versions of mahabharata and ramayana\nwere produced in miniature form. many other indian fables became\nthe miniature paintings in the art studio established by akbar.\nhistorical works such as akbar nama also remained the main themes\nof mughal paintings. the most important work is hamznama, which\nconsisted 1200 paintings. indian colours such as peacock blue,\nindian red began to be used.\nmughal paintings reached its climax during the reign of\njahangir. he employed a number of painters like abul hasan, bishan\ndas, madhu, anant, manohar, govardhan and ustad mansur. apart\nfrom painting the scenes of hunting, battles and royal courts, progress\nwas made in portrait painting and paintings of animals. many albums\ncontaining paintings and calligraphy were produced during the\nmughal period. later, the influence of european painting could be\nseen.\nmusic had also developed under the mughals. akbar\npatronized tansen of gwalior. tansen composed many ragas.\njahangir and shah jahan were also fond of music.\nlanguage and literature\npersian language became widespread in the mughal empire\nby the time of akbar’s reign. abul fazl was a great scholar and\nhistorian of his period. he set a style of prose writing and it was\nfollowed by many generations. many historical works were written\nduring this period. they include ain-i-akbari and akabar nama\nauthored by abul fazl. the leading poet of that period was his\nbrother abul faizi. the translation of mahabharata into the persian\nlanguage was done under his supervision. utbi and naziri were the\ntwo other leading persian poets.\njahangir’s autobiography, tuzuk-i-jahangiri was famous for\nits style. he also patronized many scholars like ghiyas beg, naqib shah jahan. taj mahal is considered\na jewel of the builder’s art. it\ncontains all the architectural forms\ndeveloped by the mughals. the\nchief glory of the taj is the massive\ndome and the four slender minarets.\nthe decorations are kept to the\nminimum.\nmosque building had reached its peak during shah jahan’s\nreign. the moti masjid at agra was built entirely in white marble.\nthe jama masjid at delhi was built in red stone.\nthe mughal architectural traditions continued in the eighteenth\nand early nineteenth century. their influence in the provincial\nkingdoms is clearly visible. many features of mughal tradition can\nbe seen in the golden temple at amritsar.\npaintings and music\nthe contribution of mughals to the\nart of painting was remarkable. the\nfoundation for the mughal painting was laid\nby humayun when he was staying in persia.\nhe brought with him two painters – mir\nsayyid ali and abdal samad to india.\nthese two painters became famous during\nakbar’s reign. akbar commissioned the\nillustrations of several literary and religious\ntexts. he invited a large number of painters\nfrom different parts of the country to his\ncourt. both hindus and muslims joined in\nthis work. baswan, miskina and daswant attained great positions\nas akabar ’s court artists.\ntaj mahal \n \nmughal gemstone\npainting\n\n247 246\nmodel questions\ni. choose the correct answer.\n1. panch mahal is at\n(a) delhi(b) agra\n(c) lahore (d) fatepur sikri\n2. tansen belonged to\n(a) persia (b) gujarat\n(c) ajmer(d) gwalior\nii. fill in the blanks.\n1. hamzanama is a compilation of …….\n2. akbar patronized the musician called ……\niii. match the following.\n1. abul fazl a) padshanama\n2. inayat khan b) akbar nama\n3. abdul hamid lahoric) translation of\n   mahabharata into persian\n4. abul faizi d) shah jahan nama\niv. find out the correct statement. one statement alone is\nright.\na) new agricultural technique was introduced during the mughal\nperiod.\nb) new crops like tobacco and maize were introduced in the\nseventeenth century.\nc) salt and sugar were cheaper in the mughal period.\nd) rice, barley and pulses were the commercial crops.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. socio-economic life under the mughals.\n2. the social and economic life of the nobles and also the\nrural masses.\n3. agriculture and trade under the mughals – chief exports\nand imports.\n4. cultural development during the mughals.\n5. art and architecture, palaces, forts, mosques and mughal\ngardens.\n6. development of mughal paintings and their significance.\n7. growth of language and literature.\nkhan and niamatullah. shah jahan also patronized many writers\nand historians like abdul hamid lahori, author of padshah nama\nand inayat khan who wrote shah jahan nama. his son dara shikoh\ntranslated the bhagavat gita and upanishads into the persian\nlanguage. many historical works were written during the reign of\naurangazeb. famous dictionaries of the persian language were also\ncompiled during the mughal period.\nregional languages such as bengali, oriya, rajasthani and\ngujarathi had also developed during this period. many devotional\nworks including the ramayana and mahabharata were translated\ninto regional languages. from the time of akbar, hindi poets were\nattached to the mughal court. the most influential hindi poet was\ntulsidas, who wrote the hindi version of the ramayana, the\nramcharitmanas.\n\n249 248\nthe rise of the marathas\nvarious factors contributed to the rise of marathas in the\nsixteenth and seventeenth centuries. the physical environment of\nthe maratha country shaped certain peculiar qualities among the\nmarathas. the mountainous region and dense forests made them\nbrave soldiers and adopt guerilla tactics. they built a number of\nforts on the mountains. the spread of the bhakti movement in\nmaharashtra inculcated a spirit of religious unity among them. the\nspiritual leaders like tukkaram, ramdas, vaman pandit and eknath\nfostered social unity. the political unity was conferred by shivaji.\nthe marathas held important positions in the administrative and\nmilitary systems of deccan sultanates of bijapur and ahmadnagar.\nthere were a number of influential maratha families such as the\nmores and nimbalkers. but the credit of establishing a powerful\nmaratha state goes to shahji bhonsle and his son shivaji.\nlearning objectives\nstudents will acquire knowledge about\n1. the rise of the marathas.\n2. life and achievements of shivaji.\n3. shivaji’s administration.\n4. rise of the peshwas.\nlesson 22\nthe marathas v. state whether the following statements are true or\nfalse.\n1. the mughal nobles were paid very low salary.\n2. milk and milk products were available in plenty during the\nmughal period.\nvi. write short notes (any three points).\n1. the mughal nobility.\n2. fatepur sikri.\n3. abul fazl.\n4. pietra dura.\nvii. answer briefly (100 words).\n1. mention the economic condition of the rural masses during\nthe mughal period.\n2. write a note on the internal and foreign trade under the\nmughals.\nviii.answer in detail (200 words).\n1. give an account of the cultural development under the\nmughals.\n2. examine the salient features of the mughal art and architecture.\n3. trace the growth of language and literature under the mughal\nrule.\n\n251 250\nof purander was signed in 1665. according to the treaty, shivaji\nhad to surrender 23 forts to the mughals out of 35 forts held by\nhim. the remaining 12 forts were to be left to shivaji on condition\nof service and loyalty to mughal empire. on the other hand, the\nmughals recognized the right of shivaji to hold certain parts of the\nbijapur kingdom. as shivaji asked to exempt him from personal\nservice to the mughals, his minor son shambaji was granted a\nmansab of 5000.\nshivaji visited agra in 1666 but he was imprisoned there.\nbut, he managed to escape from prison and made military\npreparations for another four years. then he renewed his wars\nagainst the mughals. surat was plundered by him for the second\ntime in 1670. he also captured all his lost territories by his conquests.\nin 1674 shivaji crowned himself at raigarh and assumed the title\nchatrapathi. then he led an expedition into the carnatic region and\ncaptured ginjee and vellore. after his return from this expedition,\nshivaji died in 1680.\nshivaji’s administration\nshivaji was also a great administrator. he laid the foundations\nof a sound system of administration. the king was the pivot of the\ngovernment. he was assisted by a council of ministers called\nashtapradhan. however, each minister was directly responsible to\nshivaji.\n1. peshwa – finance and general administration. later he became\nthe prime minister.\n2. sar-i-naubat or senapati – military commander, a honorary\npost.\n3. amatya – accountant general. shivaji (1627-1680): his life and conquests\nshivaji was born at shivner in 1627. his father was shahji\nbhonsle and mother jija bai. he inherited the jagir of poona from\nhis father in 1637. after the death of his\nguardian, dadaji kondadev in 1647, shivaji\nassumed full charge of his jagir. even before\nthat he conquered raigarh, kondana and\ntorna from the ruler of bijapur.\nhe captured javli from a maratha\nchief, chanda rao more. this made him the\nmaster of mavala region. in 1657, he\nattacked the bijapur kingdom and captured\na number of hill forts in the konkan region. the sultan of bijapur\nsent afzal khan against shivaji. but afzal khan was murdered by\nshivaji in 1659 in a daring manner.\nshivaji’s military conquests made him a legendary figure in\nthe maratha region. many came forward to join his army. the\nmughal emperor aurangazeb was anxiously watching the rise of\nmaratha power under shivaji. he sent the mughal governor of the\ndeccan, shaista khan against shivaji. shivaji suffered a defeat at\nthe hands of the mughal forces and lost poona. but shivaji once\nagain made a bold attack on shaista khan’s military camp at poona\nin 1663, killed his son and wounded khan. this daring attack\naffected the prestige of khan and he was recalled by aurangazeb.\nin 1664, shivaji attacked surat, the chief port of the mughals and\nplundered it.\nthis time aurangazeb sent raja jai singh of amber to fight\nagainst shivaji. he made elaborate preparations and succeeded in\nbesieging the purander fort where shivaji lodged his family and\ntreasure. shivaji opened negotiations with jai singh and the treaty\nshivaji\n\n253 252\nthe forts played an important role in the military operations\nof the marathas. by the end of his reign, shivaji had about 240\nforts. each fort was put under the charge of three officers of equal\nrank as a precaution against treachery.\nshivaji was really a constructive genius and nation-builder.\nhis rise from jagirdar to chatrapathi was spectacular. he unified\nthe marathas and remained a great enemy of the mughal empire.\nhe was a daring soldier and a brilliant administrator.\nsuccessors of shivaji\nthere ensued a war of succession after the death of shivaji\nbetween his sons, shambaji and rajaram. shambaji emerged\nvictorious but later he was captured and executed by the mughals.\nrajaram succeeded the throne but the mughals made him to flee to\nthe ginjee fort. he died at satara. he was succeeded by his minor\nson shivaji ii with his mother tara bai as regent. the next ruler was\nshahu in whose reign the peshwas rose to power.\nthe peshwas (1713-1818)\nbalaji viswanath (1713-1720)\nbalaji viswanath began his career as a small revenue official\nand became peshwa in 1713. as peshwa, he made his position the\nmost important and powerful as well as hereditary. he played a\ncrucial role in the civil war and finally made shahu as the maratha\nruler. he sought the support of all maratha leaders for shahu. in\n1719, balaji viswanath got certain rights from the then mughal\nemperor, farukh siyar. first, the mughal emperor recognized shahu\nas the maratha king. second, he allowed shahu to collect chauth\nand sardeshmukhi from the six mughal provinces of the deccan\nincluding the carnatic and mysore. 4. waqenavis – intelligence, posts and household affairs.\n5. sachiv – correspondence.\n6. sumanta – master of ceremonies.\n7. nyayadish – justice.\n8. panditarao – charities and religious administration.\nmost of the administrative reforms of shivaji were based on\nthe practices of the deccan sultanates. for example, peshwa was\nthe persian title.\nthe revenue system of shivaji was based on that of malik\namber of ahmadnagar. lands were measured by using the measuring\nrod called kathi. lands were also classified into three categories –\npaddy fields, garden lands and hilly tracks. he reduced the powers\nof the existing deshmuks and kulkarnis. he appointed his own\nrevenue officials called karkuns.\nchauth and sardeshmukhi were the taxes collected not in the\nmaratha kingdom but in the neighbouring territories of the mughal\nempire or deccan sultanates. chauth was one fourth of the land\nrevenue paid to the marathas in order to avoid the maratha raids.\nsardeshmukhi was an additional levy of ten percent on those lands\nwhich the marathas claimed hereditary rights.\nshivaji was a man of military genius and his army was well\norganized. the regular army consisted of about 30000 to 40000\ncavalry supervised by havaildars. they were given fixed salaries.\nthere were two divisions in the maratha cavalry – 1. bargirs,\nequipped and paid by the state; and 2. silahdars, maintained by the\nnobles. in the infantry, the mavli foot soldiers played an important\nrole. shivaji also maintained a navy.\n\n255 254\nafter the decline of the mughal empire, the marathas emerged\na great power in india but they could not succeed in preventing the\nestablishment of british power in india. the important causes for\nthe downfall were that there was lack of unity among the maratha\nchiefs like holkar, scindia and bhonsle. also, the superiority of the\nbritish army and fighting methods ultimately won.learning outcome\nstudents will understand\nafter learning this lesson the students will be able to explain\n1. causes for the rise of the marathas.\n2. early career and military achievements of shivaji.\n3. salient features of the maratha administration under\nshivaji.\n4. the rise of peshwas and the significance of the third\nbattle of panipat.\nbaji rao i (1720-1740)\nbaji rao was the eldest son of balaji viswanath. he\nsucceeded his father as peshwa at the age young age of twenty.\nthe maratha power reached its zenith under him. he initiated the\nsystem of confederacy among the maratha chiefs. under this system,\neach maratha chief was assigned a territory which could be\nadministered autonomously. as a result, many maratha families\nbecame prominent and established their authority in different parts\nof india. they were the gaekwad at baroda, the bhonsle at nagpur,\nthe holkars at indore, the scindias at gwalior, and the peshwas at\npoona.\nbalaji baji rao (1740-1761)\nbalaji baji rao succeeded his father as peshwa at the young\nage of nineteen. the maratha king shahu died in 1749 without issue.\nhis nominated successor ramraja was imprisoned by the peshwa\nbalaji baji rao at satara. the full control of the maratha kingdom\ncame under the peshwa.\npeshwa entered into an agreement with the mughal emperor\nin 1752. according to it the peshwa gave assurance to the mughal\nemperor that he would protect the mughal empire from internal\nand external enemies for which the chauth of the northwest provinces\nand the total revenue of the agra and ajmer provinces would be\ncollected by the marathas.\nthus when ahmad shah abdali invaded india, it became the\nresponsibility of the marathas to protect india. the marathas fought\nvery bravely against ahmad shah abdali in the third battle of\npanipat in 1761. but they got defeated. many maratha leaders and\nthousands of soldiers died in this battle. balaji baji rao also died\non hearing the sad end of this battle. also, this battle gave a death\nblow to the maratha power. thereafter, the maratha confederacy\nweakened due to internal conflicts among the maratha chiefs.\n\n257 256\nd) shivaji increased the powers of the existing revenue officials.\nv. state whether the following statements are true or\nfalse.\n1. when ahmad shah abdali invaded the mughal emperor faced\nhim.\n2. in the third battle of panipat nadir shah defeated the\nmaratha forces.\n3. mores and nimbalkers belonged to maratha family.\nvi. write short notes (any three points).\n1. treaty of purander.\n2. ashtapradhan.\n3. third battle of panipat.\nvii. answer briefly (100 words).\n1. trace the causes for the rise of marathas.\n2. write a note on balaji viswanath.\nviii.answer in detail (200 words).\n1. give an account of the life and achievements of shivaji.\n2. mention the salient features of the administration of shivaji.\n3. examine the rise of the peshwas and their achievements. model questions\ni. choose the correct answer.\n1. shivaji was born at\n(a) satara (b) poona\n(c) shivner (d) bijapur\n2. the treaty of purander was concluded in\n(a) 1660 (b) 1665\n(c) 1670 (d) 1675\nii. fill in the blanks.\n1. the guardian of shivaji was …..\n2. the immediate successor of shivaji was ….\n3. the third battle of panipat took place in the year …. between\n……and ……\niii. match the following.\n1. peshwaa) gwalior\n2. scindia b) poona\n3. holkar c) indore\n4. bhonsle d) nagpur\niv. find out the correct statement. one statement alone is\nright.\na) the revenue system of shivaji was based on that of cholas.\nb) lands were measured by using the measuring rod called kathi.\nc) lands were classified into four categories as under the\nmarathas.\n\n259 258\nthe ruler of calicut. he returned to portugal in the next year. pedro\nalvarez cabral arrived in 1500 and vasco da gama also made a\nsecond trip in 1502. they established trading stations at calicut,\ncannanore and cochin.\nthe first governor of the portuguese in india was francis de\nalmeida. later in 1509 albuquerque was made the governor of the\nportuguese territories in india. in 1510, he captured goa from the\nruler of bijapur. thereafter, goa became the capital of the\nportuguese settlements in india. albuquerque captured malacca and\nceylon. he also built a fort at calicut. he encouraged his countrymen\nto marry indian women. albuquerque died in 1515 leaving the\nportuguese as the strongest naval power in india.\nthe successors of albuquerque established portuguese\nsettlements at daman, salsette and bombay on the west coast and\nat san thome near madras and hugli in bengal on the east coast.\nhowever, the portuguese power declined in india by the end of the\nsixteenth century. they lost all their possessions in india except goa,\ndiu and daman in the next century.\nthe dutch\nthe dutch east india company was established in 1602. the\nmerchants of this company came to india and established their\nsettlements at masulipattinam, pulicat, surat, karaikal,\nnagapattinam, chinsura and kasimbazar. in the seventeenth century\nthey won over the portuguese and emerged the most dominant power\nin european trade in the east. pulicat was their main centre in india\nand later it was replaced by nagapattinam. in the middle of the\nseventeenth century the english began to emerge as a big colonial\npower. the anglo-dutch rivalry lasted for about seven decades\nduring which period the dutch lost their settlements to the british\none by one. the commercial contacts between india and europe were\nvery old via the land route either through the oxus valley or syria\nor egypt. but, the new sea route via the cape\nof good hope was discovered by vasco da\ngama in 1498. thereafter, many trading\ncompanies came to india and established their\ntrading centres. they entered india as traders\nat the outset but by the passage of time\nindulged in the politics of india and finally\nestablished their colonies. the commercial\nrivalry among the european powers led to\npolitical rivalry. ultimately, the british\nsucceeded in establishing their rule india.\nthe portuguese\nthe portuguese traveler vasco da gama reached the port of\ncalicut on 17 may 1498 and he was warmly received by zamorin,\nlesson 23\nthe coming of europeans\nlearning objectives\nstudents will acquire knowledge about\n1. the coming of the portuguese to india.\n2. establishment of the dutch, french, english and danish\ntrading centres in india.\n3. the anglo-french rivalry in the carnatic region.\n4. rise of british power in bengal.\nvasco da gama\n\n261 260\nthe danes\ndenmark also established trade settlements in india. their\nsettlement at tranquebar was founded in 1620. another important\ndanish settlement in india was serampore in bengal. serampore\nwas their headquarters in india. they failed to strengthen themselves\nin india and they sold all their settlement in india to the british in\n1845.\nanglo-french rivalry\nin the beginning of the eighteenth century, the english and the\nfrench were competing with each other to establish their supremacy\nin india. both of them used the political turmoil prevalent in india as\na result of the decline of the mughal empire in their favour and\nindulged in internal politics. the anglo-french rivalry in india was\nmanifest in the carnatic region and in bengal.\nthe carnatic wars\nthe downfall of the mughal empire led to the independence\nof deccan under nizam-ul-mulk. the carnatic region also formed\npart of the nizam’s dominion. the ruler of\nthe carnatic accepted the suzerainty of the\nnizam. in 1740, the austrian war of\nsuccession broke out in europe. in that war\nengland and france were in the opposite\ncamps. they came into conflict in india also.\nthe french governor of pondicherry,\ndupleix opened attack on the english in\n1746 and thus began the first carnatic war\n(1746-1748). the english sought help from the nawab of carnatic,\nanwar uddin. but the french concluded a treaty with his rival\nchanda sahib. the english army crushed a defeat on the french in\nthe battle of adyar, near madras. in the meantime, the treaty of\ndupleix \nthe english\nthe english east india company was established in 1600 and\nthe charter was issued by queen elizabeth of england. captain\nhawkins arrived at the royal court of jahangir in 1609 to seek\npermission to establish english trading centre at surat. but it was\nrefused by the mughal emperor due to portuguese pressure. later\nin 1612, jahangir issued a farman (permission letter) to the english\nand they established a trading factory at surat in 1613.\nsir thomas roe came to india as ambassador of james i, the\nking of england to the mughal court in 1615. he obtained permission\nfrom jahangir to establish english trading factories in different parts\nof india.\nthe english established their factories at agra, ahmadabad,\nbaroda and broach by 1619. the english east india company\nacquired bombay from charles ii, the then king of england. in 1639,\nfrancis day founded the city of madras where the fort st. george\nwas built. in 1690, an english factory was established at a place\ncalled sutanuti by job charnock. later it developed into the city of\ncalcutta where fort william was built. later, calcutta became the\ncapital of british india. thus bombay, madras, calcutta became\nthree presidency towns of the english settlements in india.\nthe french\nthe french east india company was formed in 1664 by\ncolbert, a minister under louis xiv. the first french factory in\nindia was established at surat by francis caron. later, maracara\nset up a factory at masulipattinam. francois martin founded\npondicherry in 1673. other french factories in india were\nchandranagore, mahe and karaikal. francois martin was the first\ngovernor of pondicherry, the headquarters of the french possessions\nin india.\n\n263 262\n3. french had support only in the deccan but the english had a\nstrong base in bengal.\n4. english had three important ports – calcutta, bombay and\nmadras but french had only pondicherry.\n5. difference of opinion between the french generals.\n6. england’s victory in the european wars decided the destiny\nof the french in india.\nestablishment of british power in bengal\nbengal remained one of the fertile and wealthy regions of india.\nthe english ascendancy in bengal proved to be the basis for the\nexpansion of english rule in india. the\nconflict between the nawab of bengal,\nsiraj-ud-daula and the english led to the\nbattle of plassey held on 23 june 1757.\nrobert clive, the commander of the british\ntroops emerged victorious by defeating the\nnawab’s army. the easy english victory\nwas due to the treachery of mir jabar, the\ncommander of nawab’s army. however,\nthe victory of the british in the battle of\nplassey marked the foundation of the british\nrule in india.\nin 1764, the english once again defeated the combined forces\nof the nawab of oudh, the mughal emperor and the nawab of\nbengal in the battle of buxar. the english military superiority was\ndecisively established. in 1765, robert clive was appointed as the\ngovernor of bengal. in the same year, the treaty of allahabad was\nconcluded by which the mughal emperor granted the diwani rights\nto the english east india company. thus the british power in india\nwas thoroughly established.\n \nrobert clive\naix-la-chappelle was concluded in 1748 to end the austrian\nsuccession war. thus the first carnatic war came to an end.\nbut the english and french continued to take opposite sides\nin the internal politics of india. this had resulted in the second\ncarnatic war (1749-1754). dupleix supported the cause of muzafar\njang, who wanted to become the nizam of hyderabad and chanda\nsahib, an aspirant for the throne of arcot. the troops of these three\ndefeated anwar uddin, who was with the british in the first carnatic\nwar, and killed him in the battle of ambur in 1749. after this victory,\nmuzafar jung became the nizam and chanda sahib the nawab of\narcot. muhammad ali, son of anwar uddin escaped to\ntiruchirappalli. the english sent troops in support of him. in the\nmeantime, the british commander robert clive captured arcot. he\nalso inflicted a severe defeat on the french at kaveripakkam.\nchanda sahib was captured and beheaded in tanjore. meanwhile\ndupleix was replaced by godeheu as the french governor. the\nwar came to an end by the treaty of pondicherry in 1754.\nthe outbreak of the seven years war (1756-1763) in europe\nled to the third carnatic war (1758-1763). count de lally was\nthe commander of the french troops. the british general sir eyre\ncoote defeated him at wandiwash in 1760. in the next year,\npondicherry was captured and destroyed by the british troops. the\nseven years war came to an end by the treaty of paris in1763.\nthe third carnatic war also ended. the french agreed to confine\nits activities in pondicherry, karaikkal, mahe and yenam. thus the\nanglo-french rivalry came to a close with british success and french\nfailure.\nthe causes for the french failure can be summed up as follows:\n1. commercial and naval superiority of the english.\n2. lack of support from the french government.\n\n265 264\nmodel questions\ni. choose the correct answer.\n1. the first portuguese governor in india\n(a) vasco da gama(b) almaida\n(c) albuquerque(d) francois martin\n2. the battle of plassey took place in\n(a) 1767 (b) 1757\n(c) 1764 (d) 1747\nii. fill in the blanks.\n1. captain hawkins arrived at the royal court of…….\n2. serampur was a ….. settlement.\n3. the treaty of paris led to end of ……..carnatic war.\niii. match the following.\n1. job charnock a) tranquebar\n2. the danes b) calcutta\n3. francis day c) pondicherry\n4. francois martin d) madras\niv. find out the correct statement. one statement alone is\nright.\na) the austrian succession war led to third carnatic war.\nb) the seven years war led to the second carnatic war.\nc) robert clive won the battle of plassey.\nd) the french were eliminated from bengal due to the carnatic\nwars.\nlearning outcome\nafter learning this lesson the students will be able to explain\n1. growth and decline of portuguese power in india.\n2. dutch, english, french and danish settlements in india.\n3. anglo-french rivalry and the three carnatic wars.\n4. growth of british power in bengal and the battle of\nplassey.\n\n267 266\nv. state whether the following statements are true or\nfalse.\n1. sir thomas roe came to india as ambassador of charles ii.\n2. dupleix was replaced by godeheu as the french governor.\nvi. write short notes (any three points).\n1. vasco da gama\n2. albuquerque\n3. dutch settlements in india\n4. battle of plassey\nvii. answer briefly (100 words).\n1. trace the rise and fall of portuguese power in india.\n2. write a note on the rise of british power in bengal.\nviii.answer in detail (200 words).\n1. give an account of the anglo-french rivalry in india.\ntime line\nfrom 1500 a.d to 1600 a.d.\n1 unit \n10 years\n15001510 - the portuguese captured goa\n1520\n1530 - death of babur1526 - first battle of panipat\n\n269 268\n15801590\n16001575 - constuction of ibatat khana\n1582 - din ilahi\n1540 - battle of kanauj1550\n156015701555 - death of humayun\n1556 - second pattle of panipat\n1565 - battle of talaikotta\n\n271 270\ntime line\nfrom : 1600 a.d to 1700 a.d.\n1 unit \n10 years\n1600 – establishment of english east\n  indian company1610\n1620\n16301627 - birth of shivaji\n16401650\n166016701665 - treaty of purandar 1605 - jahangir came to power\n1608 - captain hawkins arrived india\n1615 - arrival of sir thomas roa1639 - francis day founded the city of madras\n\n272\n1690\n17001674 - coronation of shivaji\n1680', 60, 'history', 1, '2017-02-08', 'letter', 'L', 'P', 57, 11, 0);
INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(10, 1, 'pal', '2017-02-08', 4, 1, 0, 2, 0, '1486552395.pdf', 91, 'this  is  a  sample  pdf  document.  if  you  successfully  accessed  this  file, \n adobe  acrobat  is  already  installed  on  your  computer.  congratulations! \n you  can  read  our  e - books  without  installing  any  software. \n achieve  small  biz  success  via  these  work - from - home  e - books\n how  much  would  you  spend  to  jumpstart  a  new  career?   $10,  $20,  $30.  for  less  than \n $10,  you  can  learn  what  it  takes  to  earn  a  full -   or  part - time  living  from  home.  first -\n hand  accounts  on  freelancing  and  marketing  from  real  entrepreneurs!  \n the  following  e - books  help  you  begin  your  quest  as  an  entrepreneur  —   whether  this  means  starting  a  full -\n time  business,  earning  extra  money  freelancing,  or  working  part - time  from  home.  f or  fastest  delivery,  e -\n books  are  published  as  .pdf  documents  (read  about  .pdf  docs  below).  it''s  fast  and  easy.  you  simply  pay  via \n paypal   and  a  file  will  automatically  be  e - mailed  to  you  with  a  link  to  the  e - book.  note:   if  you  can  access \n this   link,  you  do  not  need  to  r ead   about  .pdf  files  below .  \n  \n about  .pdf  files:   to  read  pdf  files,  you  need  the  adobe  acrobat  reader.  it  is  a  free  software  installed  on \n almost  all  computers  automatically.  if  you  don''t  have  it,  click  here   and  download  it  (version  4.0  or  higher).  it \n only  takes  about  a  minute,  and  again  —   it''s  free.\n ***************************************\n if  you  want  to  know  how  to  do  something,  ask  someone  who  is  already  doing  it.   this  is  the  vantage \n point  from  which  the  guides  are  written.  therefore,  all  material  is  first - hand,  contributed  by  real \n entrepreneurs.  this  allows  readers  the  benefit  of  learning  from  those  who  have  been  there.  \n offered  is  some  conventional  advice,  some  not - so - conventional  advice  and  authentic  accounts  of  why  one \n method  works  as  opposed  to  another.  \n want  to  make  extra  money?   wish  you  could  start  a  new  career?  \n would  you  like  to  work  from  home?   would  you  gladly  say  goodbye  to  your  job?  \n order  e - books  1  &  3 \n for  only  $14.95     how  to  really   make  a  living  as  an  editorial  freelancer  &\n advice  from  successful  editorial  freelancers  \n e - book  #1   $9.95  \n  \n how  to  really   make  a  living  as  an  editorial  freelancer:   editors,  human \n resources  professionals,  managing  editors  &  editorial  directors  contributed \n valuable  knowledge  on  how  to  get  your  foot  in  the  door;  skills  they  seek  & \n much  more!  read  an  excerpt ,  then  read  two  reviews:  review ;  review .  \n e - book  #2   $9.95  \n  \n how  to  get  your  biz  on  the  web  quickly  &  affordably:   an  easy - to - follow \n guide  in  plain  english  for  those  new  to  internet  terminology  &  web \n technology .   be  on  the  web  in  a  week  —   really!  it''s  easy  to  learn  the  ins  &  outs \n of  getting  your  biz  on  the  web.  read  excerpt   &  review .    \n e - book  #3   $9.95  \n    \n advice  from  successful  editorial  freelancers:   how  the  built  their  biz  & \n how  you  can  too!   stories  of  real  editorial  freelancers.  they  divulge,  in  detail, \n how  they  got  started;  why  they  decided  to  go  out  on  their  own;  how  they \n acquire  clients  —   and  more.  college  students,  single  moms  and  various \n professionals  all  contributed.  read  an  excerpt .   \n e - book  #4   $24.95  \n  \n the  small  biz  owner''s  complete  marketing  kit!   no  matter  what  type  of  biz \n you  have,  you  must  market  to  be  successful.  r ead  why   &  see  what''s  included .  \n in  this  guide,  i  divulge  7  free  &  low - cost,  easy - to - implement  methods  i''ve  used \n to  grow  two  small  businesses.  learn  how  to  i ncrease  sales  w/very  little  or  no \n money  (samples  included  every  step  of  the  way).  \n home\n phone consultation\n work from home e-books\n entrepredoer: the column\n intro for potential clients\n free/low-cost marketing\n how to increase sales\n faq: rates, deadlines, etc.\n articles/writing samples\n newsletter articles\n testimonials\n your questions answered\n about\n media\n   +  add  link\n\noffered  is  some  conventional  advice,  some  not - so - conventional  advice  and  authentic  accounts  of  why  one \n method  works  as  opposed  to  another.  \n whether  you  have  been  in  business  for  a  while,  are  just  beginning  or  are  curious  about  alternative  income -\n generating  opportunities,  you  will  find  the  information  informative  and  immediately  useful.\n upcoming  titles  (publishing  dates  subject  to  change  without  notice)  \n note:  all  orders  processed  through  inkwell  editorial,  parent  company  of  entrepredoer.biz.\n ********************\n terms  &  conditions\n payment:   no  partial  payments  accepted.  a  $25.00  bank  fee  will  be  charged  for  all  returned  checks. \n returns/refunds :   generally,  we  only  issue  refunds  if  we  fill  an  order  incorrectly.  otherwise,  refunds  are \n considered  on  a  case - by - case  basis  ( does  not  apply  to  marketing  manual,  which  comes  w/  a  one - year, \n money - back  guarantee).  \n medical  copyediting:  an  overview  of  what  it  takes   (projected  publishing  date:  3/04)  \n how  to  start  a  biz  doing  what  you  know  (projected  publishing  date:  4 /04)  \n how  to  start  &  grow  a  temporary  staffing  agency  (projected  publishing  date:  8 /04)  \n join  the  entrepredoer   mailing  list  to  receive  a  weekly  newsletter  full  of  tips  on  starting,  promoting \n and/or  expanding  your  small  business.  subscribe  now  and  receive  the  free  report,  the  three \n essentials  of  every   marketing  plan   (e - mailed  immediately  upon  sign  up) .  does  your  marketing  plan \n measure  up?  find  out  in  this  four - page,  in - depth  report.  \n finally,  marketing  help  for  the  cash - strapped  entrepreneur.   the  small  biz  owner''s  complete  marketing \n kit!   will  show  you  how  to  increase  sales  and  generate  leads  in  less  time,  on  a  shoe - string  budget  \n ( see  what''s  included ).  purchase  today  to  increase  your  sales.  you''ll  be  glad  you  did!  \n join  the  entrepredoer   mailing  list   \n email:     go    \n know  someone  who  needs  editorial  and  simple  web  design  help? \n we  will  pay  you  15%  of  of  the  total  invoice  price  for  each  individual  project  you  refer  to  us!  see  the  faq  section   for  details.\n questions,  comments,  requests  for  help :   now  you  can  consult   with  a  small  biz  expert  via  phone! ©  2003 - 2004  entrepredoer.biz.  all  rights  reserved.', 11, 'pal', 10, '2017-02-08', 'letter', 'L', 'M', 6, 3, 0),
(11, 1, 'mon', '2017-02-08', 0, 0, 1, 10, 1, '1486553430.pdf', 91, 'replacethislewith prentcsmacro.sty foryour meeting,\nor with entcsmacro.sty foryour meeting. bothcanbe\nfound atthe entcs macrohomepage .\nan example pap er\nmy name 1\n;2\nmy department\nmy university\nmy city, mycountry\nmy co-author 3\nmy co-author''s department\nmy co-author''s university\nmy co-author''s city,myco-author''s country\nabstract thisisashort example tosho wthe basics ofusing theentcs style macro les.\nample examples ofhowles should look ma ybe found among thepublished volumes\nof the series atthe entcs homepage http://www.elsevier.nl/ locate/ entcs.\nkey words: please listkeyw ords from your paperhere, separated\nb y commas.\n1 intro duction\nthis short noteprovides aguide tousing theentcs macropackage for\npreparing papers forpublication inyour conference proce edings .the pro-\nc eedings maybe prin ted and hard copies distributed toparticipan tsat the\nmeeting; thisisan option toconference organizersmaycho ose toexercise.\nthe proceedings alsowillbe par ofavolume inthe series electronic notes\nin the oretic alcomputer science(entcs), whichis published undertheaus-\npices ofelsevier scienceb.v., the publishers ofthe oretic alcomputer science.\nit''s home pageishttp://www.elsevier.nl/loc ate/entcs\nthe entcs macropackage consists oftw o les:\nentcs.cls ,the basic style le, and\n1\nthanks toevery one who should be thank ed\n2 email: myuserid@mydept. myins t.mye du\n3 email: couserid@codept. coins t.coe du\nc\n\r 2003 published by elsevier scienceb.v.\n\npleaselistyour lastname here\nentcsmacro.sty ,amacro lecontaining thedenitions ofsome ofthe theorem-\nlik een vironmen tsand afew other tidbits.\nthe formatting thesestyle les imposeshould notbe altered {the reason for\nusing themisto attain auniform formatforallpap ersinthe proceedings of\nwhic hyour paperisapart.\nadditional macrolescanbe added using\\usepackage{...} .the le\nentcsmacro.sty mustbe included inthe list, asisdone atthe start ofthe\nsource leforthis paper.\nthe entcs package requires arelativ elyup-to-date la\nt ex\nsystem inorder\nto be successfully used.thisisre\rected intw o other packages thatarecalled\nb y en tcs.cls, whichmust be available onyour machine. these are:\n the hyperref package. this package allowsthe use ofhyp erlinks inles\nprepared usingla\nt e x2e,\noneofthe main features ofadob e''sacrobat c\n\r\nreader software. besure that you have at least version 6.69dofthis pack-\nage.\n the ifpdf package. this isused by hyp erref todieren tiatebet ween the\nuse ofpdfl a\nt ex\nand la\nt e x2e,\nfollowed by dvips andthen ps2pdf.\nthe leinstraut.dvi contains information about theuse ofla\nt e xto\npre-\npare lesforonline publication by elsevier. thislerefers tothe older version\nof la\nt e x\nthat isno longer suppported, andthat isinadequate forpreparing\n.pdf lesforonline publication. readingthisleshould answermost ofthe\nbasic questions about la\nt ex\nthat mightarise.\n2 fron tmatter\nthe biggest dierence bet ween a\\usual" la\nt ex\nstyle suchas article.sty\nand theentcs package isthat theentcs macropackage requires thetitle,\nauthor''s nameornames, abstract, keyw ords and	hanks" alltobe included\nwithin thefrontmatter environmen t.at the beginning ofthe source lefor\nthis paper,you''ll notice this.also, you''ll notice thattheusual \\maketitle\nis absen t;itno longer isneeded. theentcs style package automatically\ngenerates thetitle, author''s nameandaddress, andrelated material atthe\nb eginning ofthe paper.note alsothat hyp erref hasbeen disabled inthis part\nof the entcs.cls le,soreferences tofootnotes aren''tlinkedtothe appropriate\nfo otenotes oraddresses. thisisan old problem withla\nt e x,\ninvolving thefact\nthat thereferences withinthefron tmatter aren''tpassed cleanly tothe linking\nsoft ware.\nf or those whohave used theentcs package before, theone new thing\nto note isthe inclusion ofkeywor ds;these arenow required by elsevier {\nthey''re alsorequired by acm''s computing reviews whichreviews entcs\npublications.\nthe entcs macropackage provides tw o alternativ esto listing authors\nnames andaddresses. thesearedescrib edindetail inthe leinstraut.dvi .\n2\n\npleaselistyour lastname here\nbasically ,listing eachauthor andhisorher address inturn, isthe simplest\nmetho d.but, ifthere areseveral authors andtw o or more share thesame\naddress (butnotallauthors areatthis address), thenthemetho dof listing\nauthors rst,andthen theaddresses, andofreferencing addressestoauthors\nshould be used.\nalso, notice thatackno wledgmen tof supp ort(the contentsof 	hanks )\nshould be done by aseparate listingof	hanks[nsf]{to thensf} withthe\noptional argument{ [nsf] {being used for	hanksref whichis attac hedto\nthose authors ackno wledging suchsupp ort.itisimp ortan tthat the	hanks\nnot be included withinthescop eof \\author{} orof	itle{} ,but itmust\nb e within thescop eof the environmen tfrontmatter .\nmore details about added termssuchas \\collab canbe found ininst.dvi ,\nif they areneeded.\nalso, notice thatthecommand \\lastname{my lastname}hasbeen in-\ncluded befor ethe frontmatter begins. thiscommand shouldcontain the\nlast names ofthe authors ofthe paper. ifthere arenomore thanthree au-\nthors, thentheyshould be listed withtheword \\and" bet ween thelast tw o;\nif more thanthree authors collaborated onthe paper,then therst author\nonly should be listed, together with\\emph{et al}.this command creates\nthe headline foreachpage after page1.\nfinally ,please be sure toinclude anabstract foryour paper.\n3 sectioning andenvironmen ts\nsince entcs ispublished throughtheauspices ofelsevier scienceb.v., their\nst yle les have been used tocreate theentcs macropackage. here''s apro of\nthat thispackage isnot muc hdieren tthan most ofthe ones oneencoun ters:\ndenition 3.1ale isderive dfrom another ifit isobtained withonlyafew\nmo dications fromtheoriginal le.\ntheorem 3.2the leentcs.cls isderive dfrom elsart.sty .\npro of.this isclear fromthesimilarit yof the output tothe output from\nelsevier''s style les. 2\nif one wan ts to start apro ofwith adescriptiv eword, suchas \\sk etch",\nthen onecanusethe\\begin{proof*}...\\end{pro of*}environmen t,as in\npro of(sk etch) this canbe deriv edfrom simple observations. 2\nthe main dierences bet ween theleentcs.cls andtheelsartr.cls le\nused by elsevier arethe more precise formatwe use {elsevier''s genericlesare\nmean tfor preliminary editing,andmore precise formatting isimp osed using\na macro ledesigned forthe specic elsevier journalinwhic hthe paperwill\nev en tually appear. theentcs.cls andentcsmacro.sty lesformat papers\n3\n\npleaselistyour lastname here\nuniformly sothat they allare easily recognizable asbeing from theseries\nele ctronic notes inthe oretic alcomputer science.\nall ofthe usual features ofla\nt e x\nare available withthese style les {\nit is only theformatting thathasbeen rigorously dened.thus, one has\na vailable thesectioning commands \\section,\\subsection, \\paragraphand\n\\subparagraph. thenum bering scheme usedisone under whichtheorem\n1.2.3 isthe third num bered item insecond subsection ofthe rst section of\nthe pap er.inorder tofacilitate cross-references, allofthe named environmen ts\ngiv en belo ware num bered, andalluse thesame num ber scheme.\nthe leentcsmacro.sty contains additional information thatisneeded to\nt yp eset apap er.italso hasthedenitions ofthe ams eulerandblackboard\nbold fontsbuiltin. ifyou wan tto use symbols forthe natural num bers, the\nreals, etc.,then we prefer thatyou use the blackboard bold fonts, and not\nplain bold fonts. this isaccomplished by using the\\mathbb font,as innor\nr .\nthe names oftheorem-lik een vironmen tsare provided inentcsmacro.sty .\nwith theexception ofthe environmen talgorithm, thenames ofall ofthese\nare full name, rather thanashortened version. theenvironmen tspro vided\nand their names are\n \\begin{theorem} ...\\end{theorem} fortheorems,\n \\begin{lemma} ...\\end{lemma} forlemmas,\n \\begin{corollary} ...\\end{corollary} forcorollaries,\n \\begin{proposition} ...\\end{proposition} forprop ositions,\n \\begin{criterion} ...\\end{criterion} forcriteria,\n \\begin{alg} ...\\end{alg} foralgorithms,\n \\begin{definition} ...\\end{definition} fordenitions,\n \\begin{conjecture} ...\\end{conjecture} forconjectures,\n \\begin{example} ...\\end{example} forexamples,\n \\begin{problem} ...\\end{problem} forproblems,\n \\begin{remark} ...\\end{remark} forremarks,\n \\begin{note} ...\\end{note} fornotes,\n \\begin{claim} ...\\end{claim} forclaims,\n \\begin{summary} ...\\end{summary} forsummary ,\n \\begin{case} ...\\end{case} forcases, and\n \\begin{ack} ...\\end{ack} forackno wledgemen ts.\nf or example,\n4\n\npleaselistyour lastname here\nalgorithm 1step 1:write thepap er\nstep 2:format itwith theentcs macropackage\nstep 3:ship thewhole thingtothe guest editors\n4 references andcross-references\nall the cross-referencing facilitiesofla\nt e x\nare supp orted, soone can use\n\ref{} and\\cite{} forcross-references withinthepaperand forreferences\nto bibliographic items.asisdone inthis note, thereferences section6can\nb e comp osed with \\begin{thebibliography}... \\end{thebibliograph y}.\nalternativ ely,bibt\nex\ncan be used tocompile thebibliograph y. whic hever\none isused, thereferences aretobe num bered consecutiv ely,rather thanby\nauthor-dened acronyms. ofcourse you can useyour own acron ymsforeasy\nreference toeac hof the items inthe bibliograph y, as has been done withthe\nlisting forthis short note.\nho wev er, note thatthereferences shouldnotbe started withanew \\section\ncommand.\nthe package hyperref isautomatically loadedby en tcs.cls, andthis makes\nall the cross-references withinthedocumen t\\activ e"when thepdf le ofthe\npap erisview edwith adobe''sacrobat c\n\r\nreader. theformat forincluding\na link issimple: simplyinsert\\href{url} {text}whereurlisthe url\nto whic hyou wan tthe link topoin t,and text isthe text you wan tto be\nhighligh ted,whichwhen clicked upon will bring upthe desired web page.\n4.1 particulars about .pdf les\nw eno w require that.pdf lesbe pro vided forpublication online.a.pdf\nle isview able by adob e''sacrobat c\n\r\nview er,whic hcan be congured toload\nautomatically withinabro wser. viewing aprop erlyformatted .pdflewith\nacrobat c\n\r\nallo wsthe cross-references andlinks tourls tobe activ e.in fact,\nelsevier utilizes.pdflesinorder totak ebetter advantage ofthe web''s ca-\npabilities.\nbut onepoin tw e wan tto emphasize isthat you should be sure touse typ e\n1 fon tswhen you typ eset your la\nt ex\nsource le.these fontsare scalable,\nmeaning thatthey carry information thatallowsthe devise viewing thenal\noutput toscale thefontsto suit theview erbeing used {from anonscreen\nview ersuc has adob e''sacrobat c\n\r\nreader, toprin ting theleonaprin ter.\ny ou can tellifyou have used therightfon tsby viewing thenal output on\ny our machine. itthe fontslook grain y, then you have not used typ e1 fon ts.\nthey canbe lo cated atthe ctan archiv ehttp://www.ctan.org {they are\npublic domain fonts, and don''t costanything toadd them toyour system.\nassuming you have typ e1 fon tsavailable, thenthere arethere metho ds\nfor producing .pdfles.\n5\n\npleaselistyour lastname here\nusing dvipsandps2pdf\nw elist this option rstsince itapp ears tobe the most reliable andthe\neasiest touse, especially ifyou include embedded postscript graphics(.eps\nles) inyour source le.simply runla\nt e x2e\nonyour source le,then apply\ndvips topro duce apostscript le,and nally applyps2pdf toobtain a.pdf\nle. the dvipdfm utility\nanother easymetho dfor producing acceptable .pdflesisvia the utilit y\ndvipdfm .this utilityis included indistributions ofmikt\nex,\nwhic hruns\non windo wsmac hines, butitprobably needstobe added toyour tet\nex\ndistribution, ifyou are running la\nt e x\non aunix machine. theutilit yand\nprecise information about installing iton your system canbe found atthe\nw eb page http://gaspra.kettering. edu/dvi pdfm/. in essence, thisutilit y\ncon verts a.dvi leinto a.pdf le.so,one canrst prepare the.dvi le\nusing la\nt e x,\nand then apply theutilit ydvipdfm topro duce theneeded .pdf\nle. 4\nthis utilitymak esinclusion ofgraphics particularly simple{those that\nare included inthe la\nt ex\nsource leare simply converted tothe .pdf format.\nas we note belo w, things arenot sosimple withthesecond alternativ e,whic h\nis to use pdfl a\nt e x.\np dfl a\nt e x\nan alternativ eto the rst possibilities topro duce .pdf lesisto pro cess\nthe source lewith pdfl a\nt ex.\nthis format isavailable fromthestandard\nct an sites http://www.ctan.org .it app ears that pdfl a\nt ex\nand hyperref\nha ve some problems whenusedtogether. itisnecessary touse pdfl a\nt ex\nv ersion 14dorlater inorder tominimize theseissues. ifyour system has\nan earlier version (mosttet\nex\ndistributions have version 13d),thenyou\ncan update your system by retrieving thelatest version ofpdfl a\nt e x\nfrom\nftp://ftp.cstug.cz/pub/tex/ local/c stug/thanh/pdft ex/.even ifthe\nrecen tversions areused, pdfl a\nt e x\nhas thesame dealing withreferences em-\nb edded withthefrontmatter sectiondescribedabov e for la\nt\ne x.\nbut there isone aspect ofpdfl a\nt ex\nthat creates problems. manyauthors\ninclude eps5\nles within theirpapers. while thisisfairly straigh tforward\nwith la\nt e x,\nthere areacouple ofpoin tsto note when attempting thiswith\np dfl a\nt e x.\nt o include apostscript imageina.pdf leproduced withpdfl a\nt ex,\ny ou rst have to con vert the image toa.pdf le,and then itcan be in-\ncluded usingthesame command sequenceasabov e. the conversion canbe\n4\nbewar e! the utilit ydvipdf does not produce acceptable .pdfles,andshould notbe\nused. onlydvipdfm shouldbe used topro duce .pdf les.\n5 eps stands forembedde dpostscript ,whic haords amec hanism forincluding pre-\nprepared postscript leswithin ala\nt\nex\ndocumen t.\n6\n\npleaselistyour lastname here\naccomplished mosteasily usingghostscript; you can simply viewthelein\nghostview andthen printthe image toa.pdf leusing thepdfwriter option\nwithin ghostview. theresult forastandard chess board thatispart ofthe\nghostview distribution isthe follo wing image:\nhereaswell isacop yof acolor image. whilepdfl a\nt ex\ncan handle imageles\nin other formats, la\nt ex\ncan only handle .epsimages reliably.\nitalso should be noted thatwe ha ve included tw o separate sourcelesfor\nthis example le{one forla\nt e x\nand oneforpdfl a\nt ex\n{because we wan t\n7\n\npleaselistyour lastname here\nto illustrate how to insert graphics imagesinto the le. ifyour paperdoes\nnot include suchimages, thenthesame source lecan be formatted by either\nl a\nt ex\norf by pdfl a\nt e x.\nusing entcs macroswithmacosx\nof course, ifyour ledoesn''t require .epsorother postscript les,then\ny ou can create therequired .pdfleusing anyof the standard t\nex\nimple-\nmen tations forthe macin tosh. ifyou need toinclude postscript les,andif\ny ou are using t\ne xshop,\nthenyou can specify touse dvips andghostview in\npro cessing your le, and then you can apply ps2pdf tocreate theneeded .pdf\nle. alternatib ely,the mac osxoperating systemisbased onunix, soit\nsupp ortstheuse oftet\nex\nas describ edabov e.\n5 summary\nthe entcs macropackage isrelativ elyeasy touse and provides auniform\nla yout forallthe papersthat appear inentcs.\nproblem 5.1finish yourpap er and getitto your progr am chairman on\ntime!\nwhen you have nished preparing your paper,send acop yof the sour ce le ,\ntogether withanymacro lesthat areneeded toyour program chairman. if\nthe les areextensiv e,you can place copies inthe pub/incoming sub-directory\nof the ftpdirectory onthe mac hine indicated by your program chairman using\nanon ymous ftp.ifyou dothis, please sendmeemail toalert methat thele(s)\nare here.\nassigning volume /issue numbers\none additional poin tworth mentioning isthat entcs ismo ving tosci-\nencedirect, elsevier''smainplatform forpublishing electronicseries,because\nsciencedirect must publish entire volumes atthe same time, we ha ve changed\nthe procedure forpreparing nalversions sothat volume num bers will not\nb e assigned until the nal versions areready .guest editors willnow have\nto receiv ethe nal version ofall pap ersintheir proceedings before avolume\nand issue num ber will be assigned forthe proceedings .ev en with themove to\nsciencedirect, thereference scheme already usedforpublications inentcs {\nhttp://www.elsevier/nl/loca te/entc s/nnnn.html remainsthevalid way\nto cite paperspublished inentcs, wherenndenotes thenum ber ofthe vol-\nume, andnndenotes theissue num ber. publications consistingofan entire\nv olume should use1as the issue num ber.\ncop yrigh ttransfer forms\none result ofthe move to sciencedirect isthat thecorresp onding author\nof eac hpap erpublished inentcs must submit asigned copyrigh ttransfer\n8\n\npleaselistyour lastname here\nf orm toelsevier inorder fortheir paperto be published. acop yof this form\nwill be sen tto eac hauthor by the guest editors ofeac hvolume. detailsabout\nthis agreemen tsp ecifying therightsof the authors andtherightsof elsevier\nare available atelsevier''s authorgateway .\npublication offinal versions\nbecause sciencedirect cannoteasilyaccommo datechanges topublished\nmaterial, theproceedings inits entiret ymust be ready before itcan be pub-\nlished. thisisone reason whythe volume andissue num ber isnot assigned\nun til the nal versions ofall pap ershave been sentto the guest editors for\nnal processing.\n6 bibliographical references\nentcs employsthe plain style ofbibliographic referencesinwhic hreferences\nare listed inalphab eticalorder, according thetherst author''s lastname, and\nare sequen tiallynum bered. please utilizethisstyle. weha ve a bibt\nex\nstyle\nle, forthose whowish touse it.itisthe leentcs.bst whichis included in\nthis package. thebasic ruleswe ha ve emplo yed are the follo wing:\n authors'' namesshould be listed inalphab eticalorder, withtherst author''s\nlast name being therst listing, followed by the author''s initialsorrst\nname, andwith theother authors nameslistedasrst name, lastname .\n titles ofarticles injournals shouldbe in emphasize dtyp e.\n titles ofbooks, monographs, etc.should be in quotations.\n journal namesshould be in plain roman typ e.\n journal volume num bers should be in boldface typ e,with theyear ofpub-\nlication immediately following inroman typ e,and enclosed inparen theses.\n references tourls onthe netshould be \\activ e"and theurl itselfshould\nb e in typ ewriter font.\n articles shouldinclude pagenum bers.\nthe criteria areillustrated inthe follo wing.\nreferences [1] civin, p., and b.yood, involutions onbanach algebras,pacic j.math. 9\n(1959), 415{436.\n[2] cliord, a.h., and g.b.preston, \\thealgebraic theoryofsemigroups,"\nmath. surveys7, amer. math.soc., pro vidence, r.i.,1961.\n[3] freyd, peter, peter o''hearn, johnpow er, rob ert tennen tand makoto\nt ak eyama, bire\re ctivity ,electronic notesintheoretical computerscience1\n(1995), url:http://www.elsevier.nl/loc ate/entcs/v olume1.html .\n9\n\npleaselistyour lastname here\n[4] easdo wn,d.,and w.d.munn, trac efunctions oninverse semigroupalgebr as,\nu. ofglasgo w,dept. ofmath., preprint93/52.\n[5] rosco e,a. w., \\the theory andpractice ofconcurrency ,"pren ticehall series\nin computer science,prentice hall publishers, london,newyork (1198),\n565pp. withassociated web site\nhttp://www.comlab.ox.ac. uk/oucl/pub lications/b ooks/concur rency/.\n[6] shehadah, a.a., \\em bedding theorems forsemigroups withinvolution, \\ph.d.\nthesis, purdue university, indiana, 1982.\n[7] weyl, h.,\\the classical groups," 2nded., princeton u.press, princeton, n.j.,\n1946.\n10', 0, 'qwert', 10, '2017-02-08', '', 'F', 'P', 7, 1, 0),
(12, 2, '098754', '2017-02-08', 0, 0, 11, 10, 1, '1486553862.pdf', 91, 'sample pdf document\nrobert maron\ngrzegorz grudzi ´\nnski\nfebruary 20, 1999\n\n2\n\ncontents\n1 template\n5\n1.1 how to compile a .texle to a .pdfle\n. . . . . . . . . . . . .\n5\n1.1.1 tools\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n5\n1.1.2 how to use the tools\n. . . . . . . . . . . . . . . . . . . .\n5\n1.2 how to write a document\n. . . . . . . . . . . . . . . . . . . . . .\n6\n1.2.1 the main document\n. . . . . . . . . . . . . . . . . . . . .\n6\n1.2.2 chapters\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n6\n1.2.3 spell-checking\n. . . . . . . . . . . . . . . . . . . . . . .\n6\n1.3 l a\nt\ne x and pdfl\na\nt\ne x capabilities\n. . . . . . . . . . . . . . . . . . .\n7\n1.3.1 overview\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n1.3.2 l a\nt\ne x\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n1.3.3 pdfl a\nt\ne x\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n1.3.4 examples\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n3\n\n4\ncontents\n\nchapter 1\ntemplate\n1.1 how to compile a .texle to a .pdfle\n1.1.1 tools\nto process the les you (may) need:\n\npdflatex (for example from tetexpackage 0.9-6 , which you can\nget from\nred hat 5.2\n);\n\nacroread (a pdf viewer, available from\nhttp://www.adobe.com/\n);\n\nghostscript 5.10 (for example from\nred hat contrib\n) and ghostview\nor gv (from redhat linux);\n\nefax package could be useful, if you plan to fax documents.\n1.1.2 how to use the tools\nfollow these steps:\n1.\nput all source .texles in one directory, then chdir to the directory (or put\nsome of them in the l a\nt\ne xsearch path — if you know how to do this);\n2.\nrun “ pdflatex file.tex ” on the main le of the document three times\n(three — to prepare valid table of contents);\n3.\nto see or print the result use acroread(unfortunately some versions of\nacroread may produce postscript which is too complex), or\n5\n\n6\nchapter 1. template\n4.\nrun ghostscript : “gv file.pdf ” to display or:\n“gs -dnopause -sdevice=pswrite -q -dbatch -soutputfile=le.ps le.pdf ”\nto produce a postscript le;\n5.\nrun “ fax send phone-number file.ps ” as root to send a fax, or — if you\nknow how to do this — modify the faxscript to be able to fax .pdfles directly\n(you have to insert “ |%pdf*” somewhere. . . ).\n1.2 how to write a document\n1.2.1 the main document\nchoose the name of the document, say document. copytemplate.tex to\ndocument.tex , then edit it, change the title, the authors and set proper in-\nclude(s) for all the chapters.\n1.2.2 chapters\neach chapter should be included in the main document as a separate le. you can\nchoose any name for the le, but we suggest adding a sufx to the name of the\nmain le. for our example we use the le name document_chapter1.tex.\nfirst, copy template_chapter.tex todocument_chapter1.tex\nand add the line\n\\include{document_chapter1}\nin the document.tex , then editdocument_chapter1.tex , change the\nchapter title and edit the body of the chapter appropriately.\n1.2.3 spell-checking\ndo use a spell-checker, please!\nyou may also want to check grammar, style and so on. actually you should\ndo it (if you have enough spare time). but you mustcheck spelling!\nyou can use the ispellpackage for this, from within emacs, or from the\ncommand line:\nispell -t document_chapter1.tex\n\n1.3. l a\nt\nex and pdfl\na\nt\nex capabilities\n7\n1.3 l a\nt\ne x and pdfl\na\nt\ne x capabilities\n1.3.1 overview\nfirst you edit your source .texle. in l a\nt\ne x you compile it using the\nlatex\ncommand to a .dvile (which stands for device-independent). the .dvile\ncan be converted to any device-dependent format you like using an appropriate\ndriver, for example dvips.\nwhen producing .pdfles you should use pdflatex, which produces di-\nrectly .pdf les out of .texsources. note that in the .texle you may need\nto use some pdf specic packages.\nfor viewing .texles use your favourite text editor, for viewing .dviles\nunder x window system use xdvicommand, .psles can be viewed with gv\n(or ghostview ) and.pdf les with acroread ,gv orxpdf .\n1.3.2 l a\nt\ne x\na lot of examples can be found in this document. you should also print\n\ndoc/latex/general/latex2e.dvi and\n\ndoc/latex/general/lshort2e.dvi\nfrom your tetexdistribution (usually in\n\n/usr/share/texmf or\n\n/usr/lib/texmf/texmf ).\n1.3.3 pdfl a\nt\ne x\nconsult doc/pdftex/manual.pdf from yourtetexdistribution for more\ndetails. very useful informations can be found in the hyperrefandgraphics\npackage manuals:\n\ndoc/latex/hyperref/manual.pdf and\n\ndoc/latex/graphics/grfguide.dvi .\n1.3.4 examples\nreferences\nmimuw\n\n8\nchapter 1. template\nhyperlinks\nthis is a target.\nand this is a link.\ndashes, etc.\nthere are three kinds of horizontal dash:\n\n- (use inside words; for example “home-page”, “x-rated”)\n\n– (use this one between numbers; for example “pages 2–22”)\n\n— (use this one as a sentence separator — like here)\nnational characters\n\nó, é, í, . . .\n\nè, à, ì, . . .\n\nô, ê, . . .\n\nõ, ñ, . . .\n\nö, ë, . . .\n\nz\n\na, e\n\n, ø, ß\nthere are other ways to do this, see the documentation for inputencpack-\nage.\nreserved characters\nsome characters have some special meaning, thus cannot be entered in the usual\nway.\n\n$ & % # _ { }\n\nn\n\n˜ ˆ\n\n1.3. l a\nt\nex and pdfl\na\nt\nex capabilities\n9\nmath\n\n1 2\n, 12\nn\n, . . .\n\ni\n1 ,\ni\n2 n , . . .\n\n1\n2 , 2\nn\n2 \0 3, . . .\n\n , ,\r ,\n , . . .\n\n! ,) , ,6\n= ,2 ,?, . . .\n\np\n2 , . . .\n\n2 + 2 , . . .\nfor more examples and symbols see chapter 3 of lshort2e.dvi.\nfonts\n\nroman\n\nemphasis\n\nmedium weight — the default\n\nboldface\n\nupright\n\nslanted\n\nsans serif\n\ns m a l l c a p s\n\ntypewriter\n\nand sizes:\n–\ntiny\n–\nscriptsize\n–\nfootnotesize\n–\nsmall\n–\nnormalsize\n\n10\nchapter 1. template\n–\nlarge\n–\nlarge\n–\nlarge\n–\nhuge\n–\nhuge', 0, 'dcshj', 10, '2017-02-08', '', 'F', 'P', 7, 11, 0);
INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(13, 2, '3265', '2017-02-08', 0, 0, 1, 34, 3, '1486554004.pdf', 53, 'hal-00197328, version 1 - 14 dec 2007  author manuscript, published in "international journal of artificial intelligence in education (ijaied) 12 (2001) 351-384"international journal of artificial intelligence in education (2001), 12, 351-384\n351\nelm-art: an adaptive versatile system for web-based\ninstruction\ngerhard weber1 and peter brusilovsky2\n1\ndepartment of psychology, university of education freiburg d-79117 freiburg, germany,2school of information sciences, university of pittsburgh, pittsburgh, pa 15260, usa,\ne-mail: webergeh@ph-freiburg.de, plb@sis.pitt.edu\nabstract: this paper discusses the problems of developing versatile adaptive and intelligent\nlearning systems that can be used in the context of practical web-based education. we argue\nthat versatility is an important feature of successful web-based education systems. we\nintroduce elm-art, an intelligent interactive educational system to support learning\nprogramming in lisp. elm-art provides all learning material online in the form of an\nadaptive interactive textbook. using a combination of an overlay model and an episodic student\nmodel, elm-art provides adaptive navigation support, course sequencing, individualized\ndiagnosis of student solutions, and example-based problem-solving support. results of an\nempirical study show different effects of these techniques on different types of users during the\nfirst lessons of the programming course. elm-art demonstrates how some interactive and\nadaptive educational components can be implemented in www context and how multiple\ncomponents can be naturally integrated together in a single system.\nintroduction\nthe maturity of the web presented both a new opportunity and a challenge for researchers and\ndevelopers working on all kinds of computer-supported educational applications. naturally, it\nhas also inspired a number of researchers in the area of adaptive and intelligent educational\nsystems. started in1995 from early efforts to move existing intelligent tutoring systems (its)\ntechnologies to the web (brusilovsky, 1995; nakabayashi et al., 1995) a small stream of\nresearch on web-based its has grown up into a steady broad current. dozens of adaptive web-\nbased educational systems have been reported at the time of writing this paper. a recent review\n(brusilovsky, 1999) has shown that all well-known technologies from the areas of its and\nadaptive hypermedia (ah) have already been re-implemented for the web. the context of\nweb-based education has inspired a number of new ideas in the areas of its and ah and even\nlead to the development of some new exciting adaptive technologies. overall, the marriage\nbetween adaptive educational systems (aes) and web-based education was very creative for\nthe aes.\nit was expected that this marriage would also be creative for another side -web-based\neducation as an application area. aes researchers believed that an ability to adapt is more\nimportant for web-based educational application than for all kinds of pre-web systems. a\nnumber of reasons were cited in aes literature. here we want to mention just two that we\nconsider most important. first, most web-based educational applications are used by a much\nwider variety of users than any standalone application. a web application designed with a\nparticular class of users in mind may not suit other users. second, students usually work with\nweb-based educational systems on their own (often from home) and can’t get an intelligent and\npersonalized assistance that a teacher or a peer student can provide in a normal classroom.\nhowever, regardless of many possible reasons for web-based education to employ adaptive\nand educational technologies, adaptive systems are not used in regular web-based education.\ninstead, almost all schools and colleges involved in web-based education rely on courseware\nmanagement systems (cms) - a new kind of systems emerged during the last few years. there\nare dozens of cms available from various companies, consortia, and universities. most popular\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n352 cms such as webct (webct, 1999) or blackboard courseinfo (blackboard, 2000) are used\nby hundred and thousands educational providers. these systems have zero adaptivity but they\nprovide something that their customers appreciate most - versatility.\nit turned out that versatility is more important for both teachers and administrators than\nany specific advance feature. just a few years ago most web-based educational systems were\nspecialized. some systems supported discussion forums, others supported web quizzes, yet\nothers let the teacher to place their course notes on the web (brusilovsky & miller, 2001). the\nrecent market-driven competition clearly showed that most users prefer a more versatile\nsystems to a less versatile even if the latter has some advanced features. modern cms that has\nsuccessfully survived this competition are able to support virtually any routine function of a\nteacher in the classroom. let us consider, for example, a programming course developed with\nblackboard courseinfo. this system will support the teacher to provide a hyperlinked course\nmaterial to read, programming examples to analyze, quizzes to take and programming problems\nto solve. moreover, it will auto-grade all web quizzes and will help the student to submit\nprogram solution to the teacher for grading. it will also let the student monitor their progress (in\nthe form of grades) and communicate with the teacher and each other using e-mail, forums, and\na chat room. yes, the system is completely static, but it does support most of the teacher’s real\nneeds without an overhead to install, support, and learn more than one system.\nversatility is the aspect where adaptive and intelligent web-based educational systems\n(aiwbes) lag very much behind cms. as we can see from the review cited above\n(brusilovsky, 1999), aiwbes can support virtually every function offered by modern cms\nmuch better than a cms due to the extra value provided by adaptive and intelligent\ntechnologies (see table 3). for example, it can provide adaptive navigation support for\nbrowsing the course notes (brusilovsky, eklund & schwarz, 1998), adaptive generation of\nquestions in quizzes (rios et al., 1999), or adaptive peer help in discussion forums (greer et al.,\n1998). however, each existing aiwbes can rarely support more than one function and it can\nhardly promote the use of these systems in practical web-based education.\nwe do not claim that the lack of versatility is the only problem that prevents aiwbes\nfrom being used in web-based education, but we do think that it is a major problem and that\nmore efforts should be devoted to the development of versatile aiwbes. a versatile system is\nmore appealing for practical web-based courses. it also has chances to provide better\nadaptation since various components of this system can collect more information about\nstudent’s knowledge, preferences, and interests. we consider it as a challenge to aied\ncommunity to develop versatile aiwbes with as many components as possible employing\nadaptive and intelligent technologies.\nto provide an example of a successful versatile aiwbes this paper presents elm-art,\none of the first and currently most comprehensive aiwbes. versatility was always one of the\ndriving forces in elm-art development due to the practical nature of the system. starting\nwith the first version developed in 1996 (brusilovsky, schwarz & weber, 1996a) and over the\nfollowing years the system was used for teaching real university course based on lisp\nprogramming language. version by version, the needs of practical web-based education have\nforced the development team to add some important features missed in the earlier versions. the\ncurrent paper summarizes briefly the history of elm-art development and then presents in\ndetail the most recent version of the system. since the focus of the paper is versatility, our goal\nwas not to concentrate on the single technology or aspect of elm-art, but to present all\nessential features of the system in context. we start with an overview of the system as a learner\nsees it (section 3) and then present the full dissection of the system (sections 4-9). for the\nfeatures that are based on adaptive and intelligent technologies we provide a comprehensive\ndescription covering both the functionality and the underlying knowledge organization. for the\nfeatures that are not yet adaptive we augment a brief description with some discussion on their\npossible adaptive implementation. finally, section 10 presents some empirical evaluations of\nelm-art. this section sheds some light on the value of adaptivity in the www context. in\nconclusion we discuss the role of www in the advancement of its research, the prospects of\nbringing its into practical web-based education, and the role of versatile systems in this\nprocess.\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n353 the history of elm-art\nthe www-based introductory lisp course elm-art (elm adaptive remote tutor) is\nbased on elm-pe (brusilovsky & weber, 1996; weber & möllenberg, 1995), an on-site\nintelligent learning environment that supports example-based programming, intelligent analysis\nof problem solutions, and advanced testing and debugging facilities. the intelligent features of\nelm-pe are based on the elm model (weber, 1996b). for several years, elm-pe was used in\nintroductory lisp courses at the university of trier. the course materials were presented to\nstudents in regular classes (along with printed materials) as well as to single students working\non their own with the printed materials only. students used elm-pe to practice the new\nknowledge by working on exercises. in this way, they were able to acquire the necessary\nprogramming skills.\nelm-pe was limited by the platform-dependent implementation of the user interface, the\nlarge size of the application, and the requirement for powerful computers available at\nuniversities only. these limitations hindered a wider distribution and usage of the system. so,\nwe decided to build a www-based version of elm-pe. the first step was to translate the text\nof the printed materials into www-readable form (html files), dividing it into small\nsubsections and text pages that are associated with concepts to be learned. these concepts were\nrelated to each other by describing the concepts‘ prerequisites and outcomes, building up a\nconceptual network. when presenting text pages in the www browser, links shown in section\nand subsection pages and in the overview were annotated corresponding to a simple traffic\nlights metaphor referring to information from the individual learner model (schwarz,\nbrusilovsky & weber, 1996).\nthe second step was to port elm-pe functionality to the web. it enabled the very first\nversion elm-art to provide live examples and intelligent diagnoses of problem solutions.\nwhen the learner clicked on such a live example link, the evaluation of the function call was\nshown in an evaluator window similar to a listener in ordinary lisp environments. users could\ntype solutions to a programming problem into an editable window and then send it to the\nserver.\nthe approach of converting printed textbooks to electronic textbooks used in the first\nversion of elm-art has been developed further in interbook (brusilovsky, schwarz &\nweber, 1996b), an authoring tool for creating electronic textbooks with adaptive annotation of\nlinks. however, from our first experiences with using elm-art, we understood that printed\ntextbooks are not suitable for being transformed to hypertext pages in electronic textbooks in a\none-to-one manner. textbooks are usually written in sequential order so that single pages\ncannot be read easily when they are accessed from any page within the course. additionally,\nthe simple adaptive annotation technique used in elm-art had to be improved. users should\nget more information about the state of different concepts that they had already visited and\nlearned or had to learn. and, perhaps most importantly, inferring the knowledge state of a\nparticular user from only visiting (and possibly reading) a new page is not appropriate (as\ncorrectly pointed out by eklund, 1996). these objections and shortcomings were the motivation\nfor enhancing elm-art.\nin elm-art ii (weber & specht, 1997), exercises and tests were added to the system.\nresults of working at these exercises and tests allowed the system to assess the student’s\nknowledge more carefully and to infer the user’s knowledge state. the student model was\nenhanced in a way that the annotation of links informed learners of whether they successfully\nworked at a page, whether the system inferred (form more complex or advanced knowledge\nunits) that the learner already possessed the knowledge to be learned on a page, and whether\nthe users already had visited the page. additionally, communication tools were added. first,\nlearners could send messages or questions to tutors. tutors were informed by email and could\nrespond via email, too, or could send a message to the user’s student model so that the\nmessages were displayed when they entered the next page. second, learners could correspond\ndirectly with other learners via a chat room.\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n354\nfigure 1. part of the table of contents of the lisp-course elm-art.\nthere are some other aiwbes inspired by elm-art ii. first, the statistics tutor ast\n(specht et al., 1997) used exercises and tests, too. the information system on drugs, adi\n(schöch, specht & weber, 1998), was done by the same authors as ast and added another\nfeature, the inspectable and editable user model. the feature was added and enhanced in the\nnext version of elm-art. and a first attempt was made to create an authoring system that\nsupports building adaptive web-based courses. it resulted in the ace-system (specht &\noppermann, 1998).\nin the next version of elm-art, the multi-layered overlay model was introduced and\nenhanced (weber, 1999). besides the knowledge states described above, now users were able\nto declare knowledge units as already known. all information on the user’s knowledge state\nwas held in parallel by the system so users could change their user model whenever they\nwanted or switch back to the original state without any loss of information. and two new\ncommunication tools were added. first, users can enter a discussion list where they can post\nmessages that can be read by all other users of the course. the discussion lists are maintained\nby tutors. second, users can communicate in a user group and can post and fetch documents\namong members of the group they belong to. however, this feature only works for users that\nare pre-registered by a tutor.\nthis latest version of elm-art was the basis of the new authoring system netcoach\n(http://www.net-coach.de). with netcoach (weber, kuhl & weibelzahl, 2001), authors can\ncreate adaptive web-based courses that are based on the multi-layered overlay model, that\nsupport different types of test items, and that include all the communication tools mentioned\nabove. netcoach can be used via the web and offers templates to describe and link pages, to\nadd exercises and test items, to adjust the interface and to set parameters that influence\ndifferent features of the courses. with netcoach, authors can create fully adaptive and\ninteractive web-based courses without being required to program or to learn a programming\nlanguage.\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n355\nfigure 2. a fragment of elm-art on-line manual explaining the meaning of main navigation\nbuttons and some toolbar buttons.\nall versions of elm-art as well as all its direct descendant systems from interbook to\nnetcoach were implemented with the programmable common lisp www server cl-http\n(mallery, 1994). some implementation details can be found in (brusilovsky et al., 1996a).\nelm-art can be accessed via the following url: http://apsymac33.uni-trier.de:8080/lisp-\ncourse.\noverview of elm-art\nas we have mentioned above, elm-art has been originally designed as an integrated system\nsupporting a range of features. we think that one of the most important problems in the design\nof an integrated system is the proper choice of a metaphor for the system organization. current\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n356 cms use a loose integration approach that we can name as "bag of features": different\nfunctionalities of the system are accessible using different items in a top-level menu. in contrast\nto this approach we have proposed a tight integration approach using an easy to understand\nmetaphor of a textbook. a traditional programming textbook is a well-organized learning tool\nand our users did feel familiar with its features. a good programming textbook has a\nhierarchically structured content with a detailed table of contents and sections filled with\ntextual presentation, figures, and programming examples. it also has a section with questions\nand programming exercises at the end of each section that presents new material. best\ntextbooks also include a glossary of all programming constructs with brief explanations. we\nhave originally designed elm-art as a textbook of new generation that is built upon strength\nof the existing textbook model, but also adds new features that are unavailable in a printed\ntextbook - interactivity and intelligence (schwarz et al., 1996).\nfigure 3. example of a textbook page with an exercise. all lisp expressions are formatted as\nlinks providing one-click access to the evaluator code. the upper part of the window is the\nnavigation center that shows the location of the page in the textbook and provides additional\nnavigation choices. colored folder and bullet icons provide and example of adaptive navigation\nsupport. links on the sidebar connect this page to relevant glossary pages and example pages.\nfor a user of elm-art, the system can be viewed as an interactive intelligent textbook\nthat is represented electronically in hypertext form. like any programming textbook it is\norganized as a tree of sections from chapters on the top level to units on the bottom "leaf" level.\neach section forms a separate page in the hyperspace. elm-art provides a detailed table of\ncontents (toc) that also serves as a navigation tool enabling users to get to any section of the\nbook in one click (figure 1). in addition to the tree of sections, the hyperspace also contains a\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n357 smaller tree for the glossary of constructs - one page for each lisp construct (figure 2). elm-\nart supports several types of navigation including sequential (page-by-page) and hierarchical\n(parent-child), and glossary navigation. each section of the textbook (figure 3) contains the\nnavigation bar with links to sequentially previous and next sections and the parent section (see\nexplanation of navigation links on figure 4). above the section content the system provides a\nnavigation center that clearly shows the position of the current page in the hierarchy and allows\none-click navigation to all ancestor pages and to sibling pages on the same level. on the right\nsidebar of a section, elm-art generates links to all glossary pages and all program examples\nrelated to the current page. thus from navigation point of view elm-art can be compared\nwith the very best hierarchical electronic textbooks.\nfigure 4. a fragment of the elm-art on-line manual explaining the meaning of the main\nnavigation buttons and some toolbar buttons.\nunlike typical hypertext electronic books elm-art’s textbook is not a tree of static\npages. its pages include several types of interactive activities. first, elm-art pages may\ninclude live examples. a live example is visible to users as an underlined lisp expression\ninside a book or a glossary page (figures 2, 3, 8). a click on this expression brings a user to the\ninteractive lisp evaluator (see section 8) that immediately evaluates this expression and\nreturns the result. the user can further explore this example using the evaluator by editing it\nand executing it again. in addition to simple evaluation mode, the evaluator includes a stepping\nmode that provides a visual step-by-step execution of the example (figure 11). another kind of\nlive examples are problem-solving examples - a statement of a problem followed by a complete\nfunction definition that solves this problem (figure 5). users can explore the example solution\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n358 using the lisp evaluator by stepping through one of the sample function calls suggested in the\nproblem statement or constructing own function calls.\nfigure 5. a page with an analysis of a problem-solving example. using links to the evaluator\nstudents can explore the example program.\nin addition to live examples, book pages may contain simple questions (figure 3) and\nprogramming problems to solve (figure 8). users can test their knowledge by answering\nquestions and solving programming problems. the system can automatically evaluate the\ncorrectness of answers and program solutions and provide immediate feedback. for\nprogramming problems, elm-art can also provide a detailed diagnosis of an incorrect\nsolution (complete or incomplete) identifying student’s errors and providing hints. moreover,\nelm-art provides example-based problem solving support: the user who does not even know\nhow to start the solution can ask elm-art about a reminder (a program example analyzed or\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n359 developed by this student in the past). the system is able to suggest up the most helpful\nreminder - the one that provides most help for solving the given problem. naturally, the learner\ncan extensively use the interactive evaluator when developing a solution for the programming\nproblem. elm-art also provides some editing support by properly formatting student\nprograms, to end the list of interactive features of the textbook, we should add that the user can\nadd a personal remark (annotation) to every section of the textbook (figure 3).\nthe electronic textbook in elm-art is also intelligent. it provides several kinds of\nsupport usually provided only by a human teacher. the most advanced features of the system\nare the already mentioned intelligent problem solving support and the intelligent reminder\nselection. these features are based on years or research and make elm-art unique among\nothers web-based educational systems in the area of programming. another intelligent feature\nof elm-art is an ability to build adaptively the most relevant learning path for every learner.\nelm-art is always able to determine what is the best next learning activity for the user.\nwithin a unit the system can challenge the learner with a sequence of questions that is adapted\nto the learner’s current level of knowledge. for a unit-to-unit navigation, elm-art provides a\nspecial "next" link that is connected to the most relevant next unit for the given user (naturally,\nit can be different units for learners with different knowledge). in critical points elm-art can\ngenerate special navigation hints advising or discouraging the user to proceed with a particular\npage. for a learner who is interested to navigate between units on his or her own, elm-art\nprovides adaptive navigation support in the form of colored bullets placed next of all links to\nunits. the color of this bullet informs the learner of the educational status of the unit, for\nexample, is it ready to be learned, does it contain any new knowledge. these adaptive visual\ncues help the learners to make an informed navigational choice at every point.\nas one can see, elm-art’s electronic textbook is very different from existing electronic\ntextbooks in many aspects. the last aspect that we want to stress is that this textbook is not\nstatic - it is different for different learners. the system itself personalized the book to each user.\non the same page the learners with different knowledge can get different questions, different\nnavigation advises and different visual cues. the users also participate in making their books\npersonalized. they can customize the book’s look and feel (figure 7). they fill book pages with\npersonal remarks and unique problem solutions. as an additional support to this process the\nsystem enables users to view and navigate their personal "portfolio" - the set of all analyzed\nexamples and all problem solutions. the system automatically structures this portfolio in a\nhyperspace of examples where each analyzed example of a solution is shown on a separate\npage (figure 10). each program analyzed or written by the student is automatically inserted\ninto this portfolio. to connect this new page to the rest of the elm-art hyperspace, the\nsystem automatically generates bi-directional links from any new program to all similar\nprograms and also to glossary pages of constructs used in this example (figures 2 and 10).\nfinally, learners are even able to edit their "learner models" (figure 6) thus implicitly changing\nnavigation cues, sequence of examples, and other system-driven personalization.\nadaptive electronic textbook\na word about knowledge in elm-art\naccording to self (1995), different levels of knowledge have to be distinguished in intelligent\nlearning environments. in his dormorbile framework, self postulates that each agent (e.g.,\nlearner, teaching system) encompasses four knowledge levels. learning processes in intelligent\nlearning environments consist of interactions between agents at specific knowledge levels. the\nknowledge levels represent a hierarchy with higher levels including the capabilities of the\nlower levels. the four levels are domain knowledge, reasoning knowledge, meta-knowledge,\nand reflective knowledge, in increasing order. the elm-art framework mainly works on the\nlower two levels. domain knowledge (we also refer to it as conceptual knowledge) consists of\nall the predicates, functions, and symbols an agent knows (asserts to be true) that are required\nto solve problems in the given domain. domain knowledge is declarative and is assumed to be\nindependent of any particular problem. the next higher level, the reasoning knowledge,\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n360 concerns procedural knowledge which uses domain knowledge to solve problems. these\ndistinctions allow us to separate single units of knowledge from their use.\nin elm-art, this distinction manifests itself in two different types of knowledge\nrepresentation. on the one side, the electronic textbook with all the lessons, sections, and test\nunits is founded mainly on domain knowledge and deals with acquiring this knowledge. on the\nother side, the episodic learner model elm deals with procedural knowledge necessary to solve\nparticular programming problems. sections 4 and 5 describe the representation of the domain\nknowledge level and the functionality supported by this level of knowledge. the reasoning\nknowledge level with the elm model and the supported functionality will be described in\nsection 6. section 7 presents some features of the system that are supported by both domain\nand reasoning level of knowledge.\nthe electronic textbook: knowledge representation\nelm-art represents knowledge about units to be learned with the electronic textbook in\nterms of a conceptual network (brusilovsky et al., 1996a). units are organized hierarchically\ninto lessons, sections, subsections, and terminal pages (units). terminal pages can introduce\nnew concepts, present lists of test items to be worked at, offer problem-solving examples or\nsuggest problems to be solved. each unit is represented as an object containing slots for the text\nunit to be presented with the corresponding page and for information that can be used to relate\nunits and concepts to each other. static slots store information on prerequisite concepts,\ninference links, and outcomes of the unit (the concepts that the system assumes to be known\nwhen the user worked on that unit successfully). units have a tests slot that may contain the\ndescription of a group of test items the learner has to perform (described in section 5). when\ntest items have been solved successfully the system can infer that the user possesses the\nknowledge about the concepts explained in this unit. problem pages have a slot for storing a\ndescription of a programming problem.\nthe user model related to this declarative conceptual domain knowledge is represented as\na multi-layered overlay model.\n• visited state. the first layer describes whether the user has already visited a page\ncorresponding to a unit. this information is updated whenever the learner enters a\npage.\n• learned state. the second layer contains information on which exercises or test items\nrelated to this particular unit the user has worked at and whether he or she successfully\nworked at the test items up to a criterion or solved the programming problem.\n• inferred state. the third layer describes whether a unit could be inferred as known via\ninference links from more advanced units the user already worked at successfully.\nwhenever a unit has been recognized as learned, this information will be updated in all\ninferred units (via inference links). this is a recursive process that stops whenever a\nunit already has been marked as learned or inferred.\n• known state. the fourth layer describes whether a unit has been marked as already\nknown. this can be done explicitly via the collaborative student modeling approach\n(see next section) or implicitly by selecting a specific learning goal (not used in the\ncurrent version of elm-art).\ninformation in the different layers of the learner model is updated independently during\neach interaction with elm-art. so, information from each source does not override others. in\nsection 6, we describe another type of student model (elm) that is used for individualizing\nproblem solving support.\ncollaborative student modeling for the electronic textbook\none objection to intelligent tutoring systems is the possible inadequacy of automatic student\nmodeling. one can not be sure that the information a system has gathered is sufficient to model\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n361 the learners’ knowledge and skills correctly. this may be especially true in the case of learning\na programming language where students may have very different starting level of knowledge\nand speed of learning. it is not surprising that one of the first known its for programming bip\n(barr, beard & atkinson, 1976) let the students provide their own estimation of knowledge of\nthe subject. for the same reason we have decided to include a tool for inspecting and modifying\nthe student model into elm-art.\nin elm-art a learner is able to inspect his or her current student model to see what the\nsystem actually assumes to be true about him or her and, possibly, to modify the model’s\nassumptions. on each page of the course, the learner can select the model button in the toolbar\nframe at the top of the window. the current browser window displays information about the\nstatus of the current page and, in case the page is not a terminal page, information about all\npages directly below this level will be shown (see figure 6).\nfigure 6. the open and editable student model in elm-art lets the students observe the state\nof the model and provide own estimation of their knowledge.\nfor each page, the system shows a table with columns for the name of the page with its\ncurrent annotation, the explanation of the annotation, the learning status (in case of a page with\nexercises or tests), and, in the last column, the user’s appreciation. in this last column, the user\ncan mark that he or she already knows the content of this page and all subsequent pages.\nsimilarly, the user can remove the mark. if a page is marked as known by the learner, the\nsystem will trust him or her and annotate the page accordingly. when guiding the user, the\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n362 system will not lead the learner to a page that he or she marked as already known. however,\nthis information coexists with the system’s knowledge about the user. if the user successfully\nworked at a unit‘s exercises or tests, the system will annotate the page as successfully solved.\nadditionally, if the user removes the mark from the page, the system’s previous estimation will\nbe used for annotating the page. with these multiple sources of information about the learning\nstatus of page from the multi-layered overlay model, no information will get lost and the user\ncan revise the model back and forth at any time.\na viewable and editable student model in elm-art is not a complete innovation. even\nbefore we have started to work on elm-art, this concept has been discussed and investigated\nby two groups of researchers in the uk and australia (bull & pain, 1995; kay, 1995). we\nhold, however, that in the context of a practical web-based its this kind of student model is\nnot a research issue, but a necessity. with the emerging importance of life-long education,\nwww-based instructional systems will be used by learners who have some prior knowledge of\nthe domain to refresh or extend their understanding. other students may have experiences in\nrelated domains and, therefore, will have some initial understanding by analogy. finally, with a\ngreater variety of students even very good student modeling techniques may fail to maintain a\nprecise student model. an open student model let the students and the system collaborate in the\nprocess of maintaining the most up-to-date information about student knowledge.\nwhat is adaptive in the electronic textbook\nvisual adaptive annotation of links\nthe multi-layered overlay model supports adaptive annotation of links. links that are shown in\nan overview on each page or in the table of contents are visually annotated according to the\nlearning state of the corresponding unit. elm-art uses an extension of the traffic lights\nmetaphor to annotate links visually (see figures 1, 3, 7 and 8). green, red, white, and orange\nballs are used to annotate the links (additionally, the texts of the links are outlined in different\nstyles to aid color-blind users).\na green ball means that the system suggests visiting the page behind the annotated link\nand the concepts taught on this page are ready to be learned. that is, all prerequisites to this\nconcept have been learned already or inferred to be known.\na red ball means that this page is not ready to be visited. in this case, the learner does not\nknow at least one of the prerequisite concepts (that is, the system cannot infer from\nsuccessfully solved tests and programming problems that the user will possess the required\nknowledge). however, elm-art does not restrict learner''s navigation. a learner is allowed to\nvisit this page and in the case that he or she solves the corresponding test or programming\nproblem correctly, the system infers backwards that all of the necessary prerequisites are\nknown that are declared by different inference relations. this is a very strong assumption in\ndiagnosing the learner''s knowledge state.\na white ball has different meanings depending on the type of the page the link points to. in\nthe case of a terminal page with exercises, a test page, or a problem page, the white ball means\nthat the exercises, tests, or the problem have been solved correctly. in the case of any other\nterminal page, the white ball indicates that this page has been visited already. in the case of a\nlesson, section, or subsection link, the white ball means that all subordinate pages have been\nlearned or visited.\nan orange ball has different meanings, too. in the case of a terminal page, an orange ball\nmeans that the system inferred from other successfully learned pages that the contents of this\npage are known to the learner (as described above). in the case of a lesson, section, or\nsubsection link, an orange ball means that this page has been visited already but not all\nsubordinate pages have been visited or solved successfully. if the user informed the system that\nhe or she already knows the content of the section or the page, the link will be colored orange\nunless the system has enough evidence (from solving exercises, tests, or programming\nproblems) that the user already mastered the concepts connected with this link (then the link is\ncolored white).\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n363 in browsers supporting javascript, the different meanings of a state of a link are explained\nin the status line at the bottom of the window when the cursor is located over the link.\nadditional information (the current learning state of test items) is shown with links to\npages that have tests or exercises. a horizontal bar indicates the percentage of points (up to a\ncriterion) already reached by solving test items related to this unit (figures 1, 3 and 6).\nadaptive navigation support with colored balls was pioneered by elm-art in 1996 and\nsince that used in many adaptive aiwbes (brusilovsky et al., 1998; henze & nejdl, 2001;\nschöch et al., 1998; specht & oppermann, 1998; specht et al., 1997; weber et al., 2001).\nempirical studies have shown several benefits of this kind of adaptation (brusilovsky &\neklund, 1998; brusilovsky & pesin, 1998). note that the meaning of different colors may not\nbe the same in different systems using this technology.\nindividual curriculum sequencing.\nwhile adaptive annotation of links is a powerful technique to aid learners when navigating\nthrough the pages of the course, some users may be confused about what the best next step\nshould be to continue with the course. this may happen when the learner moves around in the\nhyperspace and loses orientation. in other cases, the learner may want to follow an optimal path\nthrough the curriculum in order to learn as fast and as completely as possible. to meet these\nneeds, a next topic button in the navigation bar of the text pages allows the user to ask the\nsystem for the best next step, depending on the current knowledge state of the particular learner\n(see figures 3, 5, and 8). in addition, at the end of each unit the system may present an explicit\nsuggestion of what should be learned next.\nthe algorithm to select the best next step for a particular user works as follows: starting\nfrom the current learning goal, the system recursively computes all prerequisites that are\nnecessary to fulfill the goal. the first concept belonging to the set of prerequisites that is not\nlearned or solved already will be selected and offered to the learner. the learner completes the\ncourse successfully when all prerequisites to the current goal are fulfilled and no further goal\ncan be selected.\nwhat is adaptable in the electronic textbook\nbesides the importance of adaptivity in computer-based instructional systems, adaptable\nfeatures that allow the user to tailor the learning system to his or her needs are necessary to\nmake the system user friendly (oppermann, 1994). the special architecture of elm-art\ncomputes each page individually. this allows the learner to specify preferences that are stored\nwith the individual student model. these preferences will be considered by the system when\ngenerating a new page. in the current version of elm-art, the learner can specify, for\nexample, whether they want to work with frames, whether the background will be colored,\nwhether an overview of the current hierarchy of concepts will be shown at the top of each page,\nwhether this overview will show the current learning state of test items of the page, whether\nlinks should be annotated, whether the user wants to be guided automatically, whether a frame\nwith a personal annotation for the current page will be shown, and whether the text and the\ninterface will be presented in english or german (figure 7).\nmany of these preferences were suggested by users when asking the tutor for help or when\ngiving feedback. this is one of the advantages of a server-based learning system. the behavior\nof the system can be changed directly without updating the applications at each site or\nproducing a new cd-rom.\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n364\nfigure 7. students can adapt the look and feel of the electronic textbook to their individual\npreferences.\nadaptive testing in elm-art\nobjective tests or quizzes is one of the most important features of modern web-based\neducational systems (brusilovsky & miller, 2001). especially in adaptive learning systems,\ntesting has at least two means. first, testing is essential for an optimal learning process\n(anderson, conrad & corbett, 1989) because it is accompanied with feedback on the\ncorrectness of the answers and with reasons why an answer is wrong. immediate feedback\nallows the user to correct erroneous knowledge and misconceptions so that errors will not\nmanifest in his or her knowledge and skills. second, testing results are the most reliable source\nof evidence that a user has learned a concept. this information can be most trusted when\ncomputing the annotation of links and when computing the individual curriculum and guiding\nthe learner to the next best page to be learned.\ntest items\nelm-art was one of the first intelligent educational systems that has considered testing very\nseriously and included it into its core. it supports five different types of test items: yes-no test\nitems, forced-choice test items, multiple-choice test items, free-form test items, and gap-filling\ntest items. in yes-no test items users simply have to answer yes-no questions by clicking the\n“yes” or the “no” button. in forced-choice test items, users have to answer a question by\nselecting one of the alternative answers, and in multiple-choice test items users have to answer\na question by selecting all correct answers provided by the system. in free-form test items,\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n365 users can type an answer to the question asked freely into a form. in gap-filling test items, users\nhave to type in characters or numbers to complete a word or a sentence.\ntest items are objects that contain information on the question text, the correct answers,\nthe name of the function that checks the correctness of the user response in relation to the\nexpected correct answers, a parameter that determines the difficulty of the test item, a slot with\ntext describing a hint in case of an error, and a slot listing related concepts. the difficulty\nparameter determines how much evidence is added to the confidence value of related concepts\nwhen the test item is solved correctly. test items are stored in a separate list and can be\nassociated to test groups individually.\ntest groups are collections of test items that are associated with a specific unit. therefore,\ntest items can occur in different test groups. if a test item has been solved on one page it will\nnot be presented in a first run on another page (e.g., in a final quiz), but may be considered in\ntest repetitions.\na unit will be considered as mastered when the confidence value of the unit has reached or\nexceeded the critical value of the unit. the confidence value of each unit can be set with as a\nparameter  of the unit’s test group. the algorithm of computing the confidence value is as\nfollows. each test item has a fixed difficulty value. in a test group, each test item that belongs\nto the test group is given a weight that will be multiplied with the test item’s difficulty value. in\ncase a test item is solved correctly, the product of the difficulty value and the weight is added to\nthe unit’s confidence value. in case the answer to a test item is wrong, the product of the\ndifficulty value and the weight is multiplied by an error factor and then subtracted from the\nunit’s confidence value.\nadditionally, test items can influence concepts other than the unit of the current test group.\ndepending on whether a test item is solved correctly or not, the confidence values of all\nconcepts listed in the related concepts slot of the test item are increased or decreased with a\nweighted proportion of the difficulty value, respectively. this mechanism gives the system the\npower of a very simple connectionist system.\nin the lisp course, test items play a twofold role. on the one hand, test items are used to\ncheck whether the user possesses the correct declarative knowledge. this is especially useful in\nthe beginning of the course when a lot of new concepts (data types and function definitions) are\nintroduced. on the other hand, test items can be used in evaluation tasks to check whether users\nare able to evaluate lisp expressions correctly. skills used in evaluation are the inverse of the\nskills used to generate function calls and function definitions. evaluation skills are needed to\ndecide whether programs work correctly and to find errors in programming code. program\ncreation skills are practiced in special tasks. they are supported by the episodic learner model\napproach described in section 6.1.\ntest groups\nthere are three different situations in which test items from test groups are presented to a user.\nfirst, test items can be used as exercises when learning a new concept. second, test items can\nbe used as a final test in extra test pages at the end of a section or lesson. and third, on a non-\nterminal page, test items selected from subordinate unit pages can be composed into an\nintroductory test.\nexercises\nwhen learning new concepts, test items can serve as exercises. this both helps the learner get\nfeedback on his or her understanding of the new concept and provides the learning system with\ninformation about the knowledge state of the concept. this information is more valid compared\nto only inferring the learning state from simply visiting the page like in the first version of\nelm-art (schwarz et al., 1996) or in interbook (brusilovsky et al., 1996b). the learner will\nbe requested by the system to work at more exercise items as long as the confidence value does\nnot reach the critical value. this is similar to knowledge tracing technology (corbett &\nanderson, 1992). the system starts with presenting one test item (figure 3) from the test group\nwith medium difficulty. in case of an error, the system will randomly select another test item\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n366 with lower difficulty, in case of no error, the system will randomly select two test items from\nthe test group with higher difficulty.\nthe system gives feedback on the number of errors on the test items presented on the last\npage and presents all erroneous test items with both the users’ answers and the correct answers.\nnext to the test item, a help button enables the user to access all pages that have information\nrelated to this test item. additionally, an explanation is given as to why the answer provided by\nthe system is the correct one.\nstarting with the second exercise on a particular concept, exercise items are shown\nwithout the text of the unit page. the text of that page and all other related pages can be\naccessed by pushing a help button located near the test item. in this way, the learner is not\noverwhelmed by all the information and can easily access it if needed.\nwhen the system has enough evidence that the unit is learned, no further exercises will be\npresented to the learner automatically. however, the learner can continue working at exercises\nby pushing the more exercises link displayed with the feedback to the last answers.\nfinal tests\ntest items can be used to wrap up a lesson, section, or subsection. the mechanism is similar to\nexercises in a unit page. however, a larger group of items (usually in the range of 6 to 10 items)\nis presented simultaneously, and there are no associated help buttons with each test item. more\ngeneral help can be accessed via the help button from the button panel in the top frame of the\nwindow.\nas with exercises, test items in final tests are linked to related concepts. so, solving final\ntest items will lead to upgrading the confidence values of related concepts (or lowering it in\ncase of errors). therefore, working at a final test before working at the related concepts will\nimplicitly influence the learning status of related concepts. when the final test is completed\nsuccessfully, the system will infer that all prerequisites to these pages (as stated in the\nprerequisites slot) are known. inferring a concept as being known to the learner does not have\nthe same importance as the confidence value of the concept. if there is enough confidence that\na concept is already learned, this information will be preferred. only if the confidence value is\nbelow threshold will the inferred information be used. that is, indirectly inferring a concept as\nalready known will not override the confidence information. the two kinds of information are\nstored in different layers in the learner model.\nintroductory tests\na user may be interested in showing the learning system that he or she already knows at least\nsome parts of the topics to be learned in a lesson, section, or subsection. similarly, he or she\nmay want to see what type of questions have to be answered in the subsequent pages. to meet\nthese needs, on a section level, a user can decide to start working at exercises before going\ndeeper into subsequent pages by clicking on a link to a pretest section. the pretests will be\ngathered from the exercises from all subsequent unit pages. for practical reasons, the total\nnumber of items in a pretest is limited to about 25 test items with a maximum of 5 test items for\neach concept involved. the system assumes that a learner will be able to solve all the test items\nonly if he or she already knows about the underlying concepts. for this reason, test items do not\nhave to be practiced as long as exercises and the difficulty value is given higher weighting. if\nthere are not too many concepts in the section, solving all test items correctly will raise the\nconfidence value of most involved concepts above threshold, and the system will conclude that\nthese concepts are already learned.\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n367 problem solving support with episodic student modeling\nepisodic student modeling\nthe system’s knowledge consists of both lisp domain knowledge (described above) and\nepisodic knowledge about a particular learner. both types of knowledge are highly interrelated.\nthat is, on the one hand, the system is able to consider individual, episodic information for\ndiagnosing code and for explaining errors in addition to using the common domain knowledge.\non the other hand, when explaining individual errors and examples from the learner’s\nindividual learning history, the system can combine episodic information with information\nfrom the domain knowledge.\nthe representation of the domain knowledge used in episodic modeling consists of a\nheterarchy of concepts and rules (weber, 1996a). concepts comprise knowledge about the\nprogramming language lisp (concrete lisp procedures as well as superordinate semantic\nconcepts) and schemata of common algorithmic and problem solving knowledge (e.g.,\nrecursion schemata). these concept frames contain information about plan transformations\nleading to semantically equivalent solutions and about rules describing different ways to solve\nthe goal stated by this concept. additionally, there are bug rules describing errors observed by\nother students or buggy derivations of lisp concepts which, e.g., may result from confusion\nbetween semantically similar concepts.\nthe individual learner model consists of a collection of episodes that are descriptions of\nhow problems have been solved by a particular student. these descriptions are explanation\nstructures (in the sense of explanation-based generalization, mitchell, keller & kedar-cabelli,\n1986) of how a programming tasks has been solved by the student. that is, stored episodes\ncontain all the information about which concepts and rules were needed to produce the program\ncode the students offered as solutions to programming tasks. episodes are not stored as a\nwhole. they are distributed into snippets (kolodner, 1993) with each snippet describing a\nconcept and a rule that was used to solve a plan or sub-plan of the programming task. these\nsnippets are stored as episodic instances with respect to the concepts of the domain knowledge.\nin this way, the individual episodic learner model is interrelated with the common domain\nknowledge.\nto construct the learner model, the code produced by a learner is analyzed in terms of the\ndomain knowledge on the one hand and a task description on the other hand. this cognitive\ndiagnosis results in a derivation tree of concepts and rules the learner might have used to solve\nthe problem. these concepts and rules are instantiations of units from the knowledge base. the\nepisodic learner model is made up of these instantiations. in elm, only examples from the\ncourse materials are pre-analyzed and the resulting explanation structures are stored in the\nindividual case-based learner model. elements from the explanation structures are stored with\nrespect to their corresponding concepts from the domain knowledge base, so cases are\ndistributed in terms of instances of concepts. these individual cases—or parts of them—are\nused by elm-art to provide two important kinds of problem-solving support. first, episodic\ninstances can be used during further analyses as shortcuts if the actual code and plan match\ncorresponding patterns in episodic instances. it enables the system to diagnose incorrect and\neven incomplete student programs. the elm model and the diagnosis of program code is\ndescribed in more detail in (weber, 1996a). second, cases can be used by the analogical\ncomponent to show similar examples and problems for reminding purposes (weber, 1996b).\nthis is the technology behind elm-art''s example-based programming feature.\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n368\nfigure 8. a page with a programming problem. the upper part of the window shows the\nproblem location in the course. links on the right sidebar offer one-click navigation to learned\nlisp concepts and to earlier explored or constructed functions. buttons and links on the bottom\noffer problem-solving help.\ndiagnosing and testing function definitions\nprogramming in lisp mainly consists of coding function calls and defining new functions.\nelm-art has more than fifty such programming problems at its disposal. each programming\nproblem is presented on a separate page (see figure 8). for function definitions, learners are\nencouraged to test each function definition on their own. after defining the function, the\nlearner can select an example call of this function with typical arguments. these function calls\n(together with the expected result of the function call) are displayed in a list below the input\narea. the learner can simply select a function call. the evaluator window opens and shows the\nresult of the function call (this is discussed in more detail in section 8.4.1). in case of an error\nor if the result is not as expected, the learner should try to find the error on his/her own.\nif the student failed to complete the solution to the problem, or if the student cannot find\nan error that was reported when evaluating the code in the evaluator window, he or she can ask\nthe system to diagnose the code of the solution. the system gives feedback by providing a\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n369 sequence of help messages with increasingly detailed explanation of the error or suboptimal\nsolution (figure 9). the sequence starts with a very vague hint on what is wrong and ends with\na code-level suggestion of how to correct the error or how to complete the solution. in many\ncases, the student can understand from the very first messages where the error is or what can be\nthe next step and does not need any more explanations. the solution can be corrected or\ncompleted, checked again, and so forth. the student can use this kind of help as many times as\nrequired to solve the problem correctly. in this context, the option to provide the code-level\nsuggestion is a very important feature of elm-art as a distance learning system. it ensures\nthat all students will ultimately solve the problem without the assistance of a human teacher.\nfigure 9. a diagnosis of an incorrect solution. the student can ask the system to diagnose his\nor her solution by pressing the "diagnose" button on a programming problem page.\nexample-based programming\nelm-art supports example-based programming. that is, it encourages students to re-use the\ncode of previously analyzed examples when solving a new problem. the hypermedia form of\nthe course and, especially, similarity links between examples help the learner to find relevant\nexamples from his or her previous experience. as an important feature, elm-art can predict\nthe student‘s way of solving a particular problem and find the most relevant example from the\nindividual learning history. this kind of problem solving support is very important for students\nwho have problems with finding relevant examples. answering the help request, elm-art\nselects the most helpful examples, sorts them corresponding to their relevance, and presents\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n370 them to the student as an ordered list of hypertext links. the most relevant example is always\npresented first, but, if the student is not happy with this example for some reason, he or she can\ntry the second and the following suggested examples. the implementation of this feature was\nadopted directly from elm-pe (brusilovsky & weber, 1996; burow & weber, 1996).\nadditionally, users can navigate the hyperspace of examples to find the most relevant example.\nboth issues will be presented in more detail in the following sections.\ncomputing an ordered list of relevant examples\nto support the student selecting the proper example, elm-art is able to generate an ordered\nlist of relevant examples. this list is generated by the explanation-based retrieval (ebr)\nalgorithm which is described in detail in (weber, 1996b). at the first step, the system uses its\nknowledge about the problem and the individual elm to generate the most probable solution\nfor the given problem. on the basis of concepts and rules that will be used to generate the new\nsolution, the case memory can be probed for cases most similar to this solution. concepts from\nthe resulting explanation structure are inserted temporarily into the existing concept hierarchy\nof the episodic learner model. all episodic frames that are neighbors to the temporarily inserted\nframes contribute to computing weights for similar episodes. competition among episodes is\nintroduced by normalizing episodic weights with respect to the sum of weights of all\norganizationally similar neighbor frames. for each episode, the system computes the similarity\nvalue by summing up the resulting weights for all of its constituent episodic frames.\nfinally, the system selects the episodes with the highest similarity values and presents a\nlist of links to examples and reminders ordered according to their similarity values to the\nstudent. the most relevant example is always first in the list so the students who rely on the\nsystem’s choice can easily use it. however, with this interface they have also a possibility to try\nthe “second best” and other examples in the list. to give students more information for\nselecting an example, the system shows the similarity value for each example in the list.\nfigure 10. example-based programming in elm-art. a window with the most relevant\nexample from the student''s own past experience is popped up after the student clicked the\n"example" link on a programming problem page.\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n371 similarity-based navigation between examples\nanother level of support for selecting the proper example is provided by the hyperspace of\nlisp functions and examples described in section 7. starting from the ordered list of examples\nsuggested by elm-art or starting from the hypermedia manual (if the goal is to find an\nexample related to a particular lisp-function) the student can explore this hyperspace with\nsemantic and similarity links. the most interesting feature here is the similarity link. some\nhypermedia-based information retrieval systems are able to generate similarity links between\nstored items of information (tudhope, taylor & benyon-davies, 1995). experience with these\nsystems shows that similarity-based navigation is a very powerful tool for searching in the\nhyperspace. in elm-art, the similarity links between examples are computed using a variant\nof the ebr-algorithm. as we mentioned above, this algorithm can generate the list of\nstructurally similar example episodes and compute the similarity value for each of them. this\nlist is presented to the student as a list of links from the given example to related examples. for\neach related example, the similarity value is shown and the list is ordered according to these\nvalues (see figure 10). this interface provides the student with navigation support in similarity-\nbased navigation. the navigation support in elm-art is adaptive because the similarity\nvalues are computed using the individual elm.\nthe hyperspace of lisp functions and example descriptions\nthe hyperspace of learning material in elm-art is not limited to a human-authored electronic\ntextbook. in addition to the hierarchy of units and pages described above, elm-art lets the\nstudent browse a hyperspace of lisp functions and code examples. the set of examples\nincludes all function definitions that the students has created when solving a problem or\nexplored as a problem-solving example. the set of functions includes all lisp functions used\nin the course. each page of this generated hyperspace presents one object (a function or an\nexample) providing a description of this object and links to related other objects (figures 2 and\n10). unlike human-authored course pages, the pages in the hyperspace of functions and\nexamples are completely generated from the system’s internal knowledge about functions and\nexamples. for each type of object we have simply provided a presentation function that extracts\nvarious slots from a frame-like description of an object and place them in predefined position in\nan html presentation pattern. in elm-art the content of a function description is not\nadaptive (figure 2). however, we want to stress that computer-generated glossaries are\ngenerally a good object for adaptation. recent research on adaptive text generation in\nelectronic encyclopedias (bontcheva, 2001; milosavljevic & oberlander, 1998) has presented a\nnumber of very useful adaptation techniques.\nthe lisp function pages form a subset of this hyperspace with a predefined structure. the\ngoal of these pages is to provide a small lisp reference manual with a hypermedia interface.\nlinks between lisp functions correspond to semantic relations between them (such as\nbelonging to the same class of functions). the example part is completely dynamic. new\nexample pages are added as soon as a student explores a new example or solves a new problem.\nlinks from a newly added example to other examples and functions are established on the fly.\nan example is connected by bi-directional links to all functions, which are used in this\nexample. this means that the student can navigate from a function to any existing example,\nwhich uses this function and backwards, from an example to all functions used in it. in\naddition, each example is connected to other examples by adaptive similarity-based links\ndescribed above.\na user has several ways to jump into the hyperspace of functions and examples. first of\nall, the lisp reference manual with a list of links to all represented lisp functions is available\nfor users at any moment. second, in a problem-solving situation, the user can get a list of links\nto examples that are relevant to the task at hands ("show example" link on figure 8). third,\ncourse pages provide links to functions and examples that are relevant in its context (right\nsidebar on figures 3, 5, and 8). starting from any of these points, the user can follow numerous\nsemantic links to explore all the hyperspace of functions and examples.\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n372 following a link to a lisp function brings the student to the function glossary window\n(figure 2). this window shows a short description of the concept’s meaning and syntax, a list of\npositive and negative examples, links to related concepts, and links to examples of function\ndefinitions (including self-defined functions) that use this lisp concept. following a link to an\nexample brings the student to the same example window that is used for example-based\nprogramming (figure 10). all lisp functions used in the example and similar examples are\nshown as links. following such a link, the learner will get to the description of a concept or\nanother example as described above.\nfigure 11. the interactive lisp evaluator can provide both the result of evaluation of a lisp\nexpression and a step-by-step visualization of the evaluation process.\ninteractive lisp evaluator\nelm-art combines the features of guidance by an intelligent tutoring system and of support\nby an open learning environment. in an open learning environment, a learner should be able to\nengage into exploration of domain concepts on his or her own. elm-art is an open learning\nenvironment in the way that it provides an interactive lisp evaluator. learners can explore\nworking in lisp by evaluating lisp expressions. the evaluator window can be accessed by\npushing the eval button from the toolbar frame or by clicking on a “live” code example\nwithin a text page. in the evaluator window, lisp expressions can be typed directly into an\ninput field (see figure 11). the user can decide whether to simply evaluate the expression or to\nevaluate the expression in stepper mode. in stepper mode, the evaluator not only displays the\nresult of the evaluation but also all evaluation steps performed to evaluate the code. this\nstepper mode is especially useful for understanding how lisp evaluates expressions and for\nfinding run time errors. in case of an error, not only the error message is displayed but also an\nexplanation of why this error may have happened. these explanations are especially useful for\nbeginners, who can be confused by the usual error messages.\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n373 the server application simulates the evaluation of lisp expressions. it only supports\nfunctions and concepts needed in the programming course. with this simulation of lisp\n(within lisp) it is possible simply to catch run-time errors, endless loops, and non-terminating\nrecursions. additionally, a user will not be able to program the server because there is no direct\naccess to the complete lisp environment the server (cl-http server) is running in.\nin elm-art an interactive evaluator is an important, but non-adaptive component.\nhowever, we can clearly see a natural way to make it adaptive using the same learner’s model.\nthe evaluator can simply take into account the strident knowledge level of lisp functions and\nconstructs and provide adaptive levels of details in visualization. in brief, the constructs that are\nnot learned yet can be visualized in detail, while the constructs that are already well learned -\nwith no detail. this approach was successfully used in the past in item/ip-ii system\n(brusilovsky, 1994).\ncommunication tools\ncomputer-based learning systems usually lack two important aspect of a learning situation:\ndirect interaction with a human teacher or tutor and discussion with other learners. modern\ncms compensate the lack of face-to-face communication by including various communication\ntools such as e-mail, discussion forums, chat sessions, and video conferencing. we added some\nsimilar tools to elm-art to support most necessary human-to-human communication in the\notherwise completely computer-based learning system. the communication page can be entered\nvia the communication button.\nfigure 12. communication with a tutor.\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n374 communication with a human tutor\nat any moment during working with elm-art, users can send a message to the human\ntutors supporting the learning course via the communication tool. usually, the communication\npage opens with the tutor interface (figure 12). in case another communication tool is\ndisplayed, the tutor interface can be accessed by clicking the “tutor” button from the toolbar\n(figures 3 and 12). optionally, the learner can add an e-mail address (in case he or she did not\nprovide the address when first logging in to elm-art). the server stores the message in the\nindividual student model and directly sends e-mail with the messages to the tutors.\nthe tutors can react in two ways: by sending a message to the student model or by sending\nthe message directly to the user via e-mail. sending a message to the student model is very\nsimple and works even if the user did not provide an e-mail address. when the user enters a\nnew page while working with the learning course, the system checks whether the learner''s\nrecord contains a message to the user. if there is one, a link is displayed at the top and at the\nend of the text frame. following this link, the user will get into the tutor window. the editor\nwindow displays the message and then offers the possibility to respond to the tutors (see fig.\n8). additionally, the user can mark the message as already read so the message will not be\ndisplayed again.\nif the learner provided an e-mail address, the tutor can respond directly to the learner via e-\nmail. the advantage of this method is that the learner will be informed as soon as the tutor\nresponded to his or her question, even if the learner is not currently working with elm-art.\nour experience with this communication tool shows that learners are using the message\nsystem to ask questions as well as to give feedback to the developers of the system. most\nlearners preferred to provide their e-mail address, however, some learners preferred to keep\ntheir anonymity.\nfigure 13. communication in the chat room.\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n375 chatting\nelm-art’s chat room is no different from many other chat rooms used in web-based\neducational systems. learners can get into the chat room via the communication link. first, the\nuser gets an introductory dialog window where he or she can select an icon that will be\ndisplayed together with his or her name. alternatively, the user can provide the url to a\npicture (e.g., from his or her personal home page). this will make correspondence in the chat\nroom livelier. additionally, a short description of how to use the chat room is provided. in the\nnext step, the user enters the chat room. there, icons or pictures of all users currently visiting\nthe chat room are displayed along with the most recent messages. the user can type in a\nmessage into an input window and send it to the server (see figure 13). at any time, the user\ncan redisplay all current messages or ask the system to redisplay the most recent message\nautomatically.\nthe chat room is particularly useful if some learners arrange to meet in the chat room in\nadvance. participants in the chat room can decide to send a message directly to a particular user\n(called whispering). when whispering, only the specified user will receive the message and no\nother user will see it. in this way, a type of privacy can be achieved even in the public chat\nroom. from our own first experiences with using the chat room we learned that it is used very\noften for some type of social communication similar to private talks in traditional classroom\nsituations. however, these are impressions only, because discussions in the chat room are not\nstored permanently or recorded in any way. each message is erased after one hour.\nusers are urged to exit the chat room actively.  messages from users that are no longer\nactively in the chat room are displayed with a special icon. if a user has not interacted with the\nserver for longer than half an hour, the server will remove that user from the chat room.\ndiscussion lists\nchatting is only useful if learners want to discuss on the fly problems with other users or want\nto get into some social contact with users at distant places. however, some discussion may be\nuseful for other learners and may even be relevant at later times. therefore, a discussion list\n(also known as a discussion forum) is available in the current version of elm-art. users can\nenter the discussion list via the communication link.\nusers can add new contributions to different topics in the discussion list or respond to\ncontributions directly. tutors of the course can edit the discussion list. they can add new topics\nto the discussion list or can change already existing contributions to topics.\ntowards adaptive communication support\nas already mentioned, communication facilities are implemented in elm-art on the minimal\nlevel and without any kind of adaptation. in this aspect elm-art is no different from the\nmajority of modern cms. however, recent research on adaptive wbes has shown several\nways to make discussion groups and collaboration over the distance intelligent and adaptive.\nthe group from the university of saskatchevan has extended their original workplace-oriented\npeer-help technology to the wbe context in their intelligent helpdesk system (greer et al.,\n1998). another similar system was developed and evaluated at the university of central\nflorida (morelos-borja, 1998). in addition to that, a group at the university of duisburg known\nfor their pioneering work on adaptive collaboration support (hoppe, 1995) have recently\nsuggested a complete framework for implementation of intelligent support techniques for\ndistributed internet-based education. in all these cases, an ability to use and match the models\nof multiple learners connected to a system is the key of adaptive collaboration support.\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n376 experiences with elm-art\nadaptive annotation and curriculum sequencing\nwith the introduction of the second version of elm-art, we started an accompanying\nempirical study to look at the effects of combining the new adaptive annotation technique used\nin elm-art with the guidance offered by the next button. as this study is reported in\nanother paper already (weber & specht, 1997), we only will present the most important results\nhere.\nin a first study, two treatments with two levels each were investigated simultaneously. the\nfirst treatment contrasted the adaptive annotation of links as described above with simply\nannotating links as visited (yellow ball) and not visited (orange ball). this second type of\nannotation used in the control group is comparable to the usual annotation performed by www\nbrowsers that annotate links that have already been visited and that are cached. the second\ntreatment contrasted providing a next best step button with a version without this navigation\nbutton. the results of this study showed some hint of how these adaptive techniques may\ninfluence the learning process. subjects who had no previous experience with any\nprogramming language tried to learn longer with elm-art when they were guided by the\nsystem using a next button. this can be easily interpreted when one looks at the navigation\nbehavior of the complete beginners more closely. all but one of the beginners had no\nexperience in using a www browser. that is, these subjects profited from being guided\ndirectly by the system when using the next button. without such a button, they had to\nnavigate through the course materials on their own. learning to navigate through hypertext in\naddition to learning the programming language may have been too difficult. so individual\nadaptive guidance by the system is especially helpful for the complete beginners. in turn, most\nsubjects who were already familiar with at least one other programming language (and also\nwere familiar with web browsers) were not affected by adaptive guidance. they were more\npleased with the link annotation and stayed with the learning system longer when links were\nannotated adaptively. these results suggest that different adaptation technologies may be\nrelevant to the users with different starting knowledge level of the subject. similar results on\nthe connection between starting level of knowledge and relevant adaptation techniques were\npresented in (specht & kobsa, 1999).\nthe hypothesis in the second study postulates that both adaptive navigation support and\nindividual curriculum sequencing with the next button reduce the number of navigation\nsteps. both techniques should have an additive effect on the navigation process. data seem to\nsupport the hypothesis only partially. subjects that are individually guided by using a next\nbutton needed fewer steps to finish the first lesson than subjects without such an option did.\nthe adaptive link annotation does not seem to have any systematic effect on the number of\nnavigation steps. these very small effects observed from the first lesson fade away during the\nfollowing lessons. that is, only in the beginning does individual guidance by the system help\nlearners to follow an optimal path through the curriculum. later on, all subjects understand the\nsimple hierarchical architecture of the programming course and most of them follow the best\nlearning path without any guidance.\nthese results do not mean that adaptive link annotation and adaptive curriculum\nsequencing are not as important as expected. as could be shown in the data above, these\ntechniques are especially useful in the starting phase when users, especially beginners, are\noften frustrated. and, these techniques will presumably be helpful to advanced users who\nalready posses some of the to-be-learned knowledge. in this case, a system that is able to adapt\nto the particular user will be helpful in navigating him or her around all the pages that the\nsystem infers to be known. however, this has to be shown in a different study.\nresults of learning with elm-art\ncrucial to a learning situation is how successful and how fast learners complete the course. as\nelm-art directly stems from the on-site learning environment elm-pe (weber &\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n377 möllenberg, 1995), comparing results of learning with elm-art to previous results from\nlearning with elm-pe will give an idea of how well one can learn with a web-based learning\nsystem. we compared 28 subjects learning with elm-pe with 23 subjects using elm-art. in\neach case, subjects completed the first six lessons of our introductory lisp-course at the\nuniversity of trier and worked at three final programming tasks: a simple cdr-end-recursion\na-list-test (problem 1), a typical tree-recursion count-item (problem 2), and a cdr-\nrecursion list-up-to-atom (problem 3). the third task was more difficult than the other\nones because an atypical type of terminal case had to be coded. in these final programming\ntasks, learners could not use the intelligent diagnosis of the program code and there was no\nindication (e.g., by annotation) of whether the solution was correct or not. therefore, learners\nhad to test the programs on their own. the number of correct solutions to the programming\ntasks is a direct measure of whether users of the different systems were able to learn to program\nrecursive functions in lisp.\ntable 1 shows a comparison of the results of both groups learning with elm-pe and\nelm-art, respectively. it has to be remarked that most of the subjects are students in\npsychology at the university of trier and that the programming course is optional. that is,\nstudents are not required to attend this course. one can see (table 1) that results in problem 1\nand problem 2 are similar in both groups. this may be a ceiling effect. e.g., in the elm-art\ngroup only one subject did not solve the problems. the more difficult problem 3 was solved\nmore often in the elm-art group than in the elm-pe group.\ntable 1. percentage of correct solution of the three final programming problems after lesson 6\nin elm-pe and elm-art.\ncourses problem 1\n(a-list-test)problem 2\n(count-item)problem 3\n(list-up-to-atom)\nelm-pe (n=28) 100 % 93 % 54 %\nelm-art (n=23) 96 % 96 % 87 %\nit may be argued that learners with more previous experiences profit more from intelligent\nsupport systems than learners without previous knowledge. therefore, we looked more\ncarefully at the results of problem 3 and distinguished learners with previous knowledge in\nother programming languages from learners without knowledge in any programming language\n(table 2).\ntable 2. percentage of correct solution of the third final programming task with respect to\nprevious programming knowledge.\nproblem 3 previous programming knowledge\ncourses with without\nelm-pe64.4 %\n(n=14)42.9 %\n(n=14)\nelm-art91.7 %\n(n=12)81.8 %\n(n=11)\nresults of this comparison show that learners without previous programming knowledge\nprofited more from the learning system in the elm-art group than in the elm-pe group\n(f(1,47)=7.09, p=0.011). this finding is supported by feedback from users stressing the ease of\nuse and of learning with elm-art.\nthere is one more finding that supports the success of elm-art. students participating\nin our introductory lisp course at the university of trier completed the first six lessons more\nquickly. more than two thirds of all students working with elm-art completed the first six\nlessons within six weeks or less, while more than two thirds of all students working with elm-\npe needed more than seven weeks. the main reason for this remarkable difference is the\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n378 availability of computers. the on-site learning environment elm-pe was available only on\nspecially equipped macintosh computers in our department. these computers were reserved\ntwo hours a week for each student. conversely, elm-art could be accessed from most\ncomputers in the university (and even from home). we observed students starting work in the\nmorning before classes started, continuing during the lunch hour, and proceeding in the\nevening. therefore, a lot of students finished the course within a very short period of time. this\nmay be one reason for the very good results in the final programming tasks. students were able\nto concentrate on learning lisp much more than with the more occasional learning and practice\nsessions required by elm-pe.\nfeedback from users learning with elm-art\nelm-art now is running in the www for several years with hundreds of users from all over\nthe world learning the first steps of programming in lisp with elm-art as well in german as\nin english. after finishing the course, many of the learners filled in an optional feedback\nquestionnaire and submitted it. the overall results are very good and in many cases even\nenthusiastic. almost all learners answered affirmatively that they suggested elm-art to other\npeople to learn with the system. they confirmed that it was easy to navigate in elm-art and\nthat working with the system in the internet was fast enough (even from the opposite side of the\nworld). the interactive lisp-evaluator was of much help. the diagnosis was helpful in most\ncases though in some cases the diagnosis failed to present understandable feedback. the\nadaptive examples were used not very often, however, in case it examples were used they\nturned out to be very helpful. many users criticized that no parentheses matcher was offered to\nsupport coding programs. most users wished to get more lessons and to have a similar system\nfor other programming languages and many users did not need the frame on the right side of the\nwindow, especially they did not need the field to note individual remarks.\nto sum up this summary on the feedback messages the following statements show the\npower of an adaptive versatile learning system in the www: “ it was great fun for me”, “\ngood, concise and useful”, “hot stuff”, “finally, i understand how this programming language\nfunctions. our teacher missed it up to now in the lectures (translated from german)”, “ i think\nthis is an very efficient tutorial, i think i am able to grasp the main idea of programming in\nlisp in a relative short time”, “ this is an excellent example of how software for teaching\npurposes should work”, “ i was very impressed with this tutorial.  it provided the equivalent of\nalmost a full course with teacher help which was still quickly completed and not at all\nfrustrating”, “ this is one of the best web sites i’ve ever seen.  i’ve been trying to learn lisp for\nquite a number of years, and have never been able to grok it.  this seems unusual, since i had\nwritten several compilers and interpreters for the forth programming language (kind of the\nanti-lisp, where everything is post-fix, rather than pre-fix)”.\ndiscussion\nthe main result of the evaluation studies already done with elm-art and reported with this\npaper is the finding that web-based educational systems can be as effective as traditional\nelaborated its. at the same time, the results of our investigations on the adaptive features of\nelm-art are ambiguous. users with some previous knowledge (from another programming\nlanguage and from browsing the web) profited from link annotation, very often looked around\nin the course and then proceeded with learning. the more a user already knew with respect to\nthe new domain and to the type of learning environment, the more this user will profit from the\nfreedom to adapt the system to his or her needs and to explore the new environment (where\nannotation and other forms of adaptivity can be of much help).  on the contrary, novice\nprogrammers (mostly without extensive experience in web-browsing) more often followed the\nideal learning path pointed out by the system and used the system‘s guidance. therefore, they\nwere not so much influenced by the other adaptive features (like link annotation).\nthese effects faded away the longer users worked with the course. a more general\nconsequence of these results is that adaptive annotation and individual guidance is especially\nhelpful and effective when starting in a new environment. this leads to the assumption that\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n379 these adaptive features will be especially useful in continuing education, where users start with\nat least some previous knowledge and the system can help the learner to concentrate on those\nsections and units of the domain in question that are new to the learner. however, these effects\nhave not been addressed in the studies reported in this paper. there is an empirical study by\nspecht and weber (1997) showing that users retaking a statistics course profited from adaptive\nfeatures of the learning system. learners had to fulfill an introductory questionnaire to show\nwhat they already knew. the group that was guided by the system to only those parts of the\ncourse that they had to repeat profited more from the repetition course than learners who had to\nread and work at all pages without adaptive guidance.\nit remains an open question how adaptive systems can be tested and evaluated effectively.\na lot of first investigations on this topic either was not able to show any effects or only had\nsmall or ambiguous effects. especially in complex systems (like elm-art), adaptivity has to\ncompete with other features designed to aid the user or learner. therefore, it is difficult to\npartial out the effects of one single feature. on the other hand, more controlled psychological\nexperiments, that concentrate on one or two single effects within a specially designed\nexperimental environment may not be ecologically valid. we hope that in the future a\nmethodological paradigm can be found that offers both controlled and ecologically valid\nexperiments.\nlessons learned: from its to web-based education\nthe system, elm-art, described in this paper is an example of how an its can be re-\nconsidered and redesigned when being converted from a standalone to a web-based system.\ninstead of developing a web-based "copy" of its ancestor system elm-pe (the way chosen by\nseveral research teams) we have tried to make elm-pe benefit as much as possible from being\na web-based system and to integrated it into the context of web-based education (table 3).\nsince the web is a natural platform for developing hypertext learning materials, we have\ndecided to extend the original system with an electronic textbook component, added a\nhyperspace of functions and examples, and provided adaptive navigation support. since\nstudents in a web-based education context have to be able to communicate with each other and\nwith the teachers, we have provided several ways of communication and collaboration support.\nsince the variety of students who can access the system on the web is much larger than in a\nhomogeneous university classroom, we have added an open and editable student model and\ncomprehensive customization. to avoid the problem of installing lisp environments on\ndifferent computers used by "web students" we have provided a lisp interpreter with\nadvanced visualization as a part of the system. the resulting system integrates the features of\ncourseware management systems, electronic textbooks, learning environments, and intelligent\ntutoring systems.\nelm-art clearly shows a number of benefits provided by a web-based system. from the\ndeveloper’s prospect, the web nature of the system makes the job of maintaining and enhancing\nthe system much easier. first, the web context provides a seamless connection between users\nand developers. with indirect feedback (log analysis) and direct feedback from the users the\nsystem can be improved permanently. this is the experience we had in developing elm-art\nover a long period of time. a lot of features were initiated by suggestions from users and the\ncontent of the course has been improved by getting feedback on a lot of shortcomings in the\nfirst versions. these revisions easily could be made available to all users because elm-art,\nas a web-based learning environment, is a centralized learning system implemented on one\nserver only. therefore, changing the system on the server directly affected all learners. with\non-site systems, new versions would have to be installed on each site, and with cd-rom-based\nlearning systems, distributing a new version is much more complicated and expensive.\nfrom the student’s prospect, the system provides a better support in the process of\nlearning. to fit the original elm-pe system to the web context (for example, to fit several\nstudent models to the memory space of a single server-based system) we have to reduce the\n"intelligence" of some features. however, the comparison of elm-art and elm-pe\ndescribed in section 10.2 demonstrated the ability to learn "anyplace anywhere" and the\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n380 integrated textbook more than compensate for the decrease in "intelligence" - the students’\nperformance with elm-art is better than with elm-pe.\ntable 3. feature-by-feature comparison of web-based systems used for teaching programming-\nrelated subjects. bold font is used to stress features implemented with adaptive and intelligent\ntechnologies. italicised font is used to stress other advanced technologies. the table shows that\ntypical courseware management systems (cms) such as blackboard courseinfo (blackboard,\n2000) or webct (webct, 1999) can support almost all basic features though on a very\nprimitive level. existing adaptive and intelligent web-based systems described in brusilovsky\n(1999) and some other advanced web-based systems can support the whole range of features,\nthough typical systems support one feature only. elm-art can support all key features while\nsupporting the majority of them on the currently most advanced level.\ntypical cms elm-art other advanced web-based systems\nhierarchically\norganized course\nmaterialnon-adaptive\nadaptive link\nannotation and\ndirect guidanceinterbook (brusilovsky et al., 1998),\nkbs-hyperbook (henze et al., 1999)\nauto-evaluated\nquestionsnon-adaptive\nadaptive siette (rios et al., 1999)\nexecutable\nprogram examplesnon-adaptive, not-\nexecutable: example\ncode onlyadaptive example\nrecommendation\nnon-adaptive visual\nexecutionnon-adaptive visual execution: jeliot\n(haajanen et al., 1997), isvl\n(domingue & mulholland, 1998)\nprogramming\nproblems to be\nsubmitted and\nevaluatedprogram submission\nonly (to be\nevaluated by a\nhuman tutor)intelligent diagnosis\ntest-based automatic\nevaluationintelligent diagnosis: vc prolog\ntutor (peylo et al., 2000)\ntest-based automatic evaluation: web-\nceilidh: (foxley et al., 1998)\nstudent portfolio:\nanalysed examples\nand own solutionscould be accessed,\nbut no special\nconvenient toolsknowledge-based\naccess, adaptive\nnavigation supportknowledge-based access: kbs-\nhyperbook (henze & nejdl, 2001)\ncommunication\nand collaborationannouncements, e-\nmail, chat, forumse-mail, chat, forums\nadaptive peer help: ihd (greer et al.,\n1998), debugging chat:(domingue &\nmulholland, 1998)\ncourse monitoring grades and page\naccessconcept level\nprogressadaptive monitoring:\nhyperclassroom (oda, satoh &\nwatanabe, 1998)\noverall, our experience of developing and using elm-art shows the need to move from\nsmall its supporting limited set of functionalities to versatile learning environments suitable\nfor practical web-based education.  unlike many others web-based its that were never being\nused in real web-based education for more than a trial period, elm-art was able to survive\nsuccessfully several years of practical use in teaching a real university course over the web. it\nwas not due to the fact that every feature in elm-art was implemented on the most advance\nlevel or with the use of ai techniques. as we see from table 3, it is true only for a subset of\nfeatures. other known systems, for example, can support collaboration or course monitoring\nbetter than elm-art. but it was in large extent due to the fact that in elm-art we have\ntried to provide support for as many needs of a student and a teacher as possible. users do\nappreciate comprehensive versatile system. the recent competition between specialized and\nintegrated course management systems in web-based education context  (see introduction) has\ndemonstrated this fact again.\nwe think that the web can greatly benefit its (as a research field) and can help its to\nmove from laboratories (where most of these “intelligent” system are used, due to the enormous\nrequirements in computing power and capacity) to classrooms and to permanent availability in\nweb-based learning. however, we also think that on the way to the practical web-based\neducation existing its has to migrate from "single weapon" systems to comprehensive versatile\nenvironments. we have tried to start this process in 1996 with the first version of elm-art.\nmore recently we were very pleased to see other emerging versatile aiwbes that provide on-\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n381 line learning material, support interactive problem solving and evaluate student’s progress\n(heift & nicholson, 2001; melis et al., 2001; peylo et al., 2000). we hope that together with\nthese systems, elm-art that stands between its and commercial cms (table 5) can provide\na convincing example for the researchers and developers who works on advanced systems for\nweb-based instruction.\nacknowledgments\npart of this work is supported by a grant from “stiftung rheinland-pfalz für innovation” grant\nto the first author and by fellowships from “alexander von humboldt-stiftung” and james s.\nmcdonnell foundation to the second author.\nreferences\nanderson, j. r., conrad, f. g., and corbett, a. t. (1989) skill acquisition and the lisp tutor.\ncognitive science  13, 467-505.\nbarr, a., beard, m., and atkinson, r. c. (1976) the computer as tutorial laboratory: the\nstanford bip project. international journal on the man-machine studies  8 (5), 567-596.\nblackboard (2000) courseinfo 3.0, blackboard inc.\nhttp://company.blackboard.com/courseinfo/index.html (accessed 25 december, 2000)\nbontcheva, k. (2001) tailoring the content of dynamically generated explanations. in: m.\nbauer, p. j. gmytrasiewicz and j. vassileva (eds.) user modeling 2001. lecture notes on\nartificial intelligence, vol. 2109, (proceedings of 8th international conference on user\nmodeling, um 2001, sonthofen, germany, july 13-17, 2001) berlin: springer-verlag, pp.\n213-215.\nbrusilovsky, p. (1994) explanatory visualization in an educational programming environment:\nconnecting examples with general knowledge. in: b. blumenthal, j. gornostaev and c.\nunger (eds.) human-computer interaction. lecture notes in computer science, vol. 876,\n(proceedings of 4th international conference on human-computer interaction,\newhci''94, st. petersburg, russia, august 2-5, 1994) berlin: springer-verlag, pp. 202-\n212.\nbrusilovsky, p. (1995) intelligent tutoring systems for world-wide web. in: r. holzapfel (ed.)\nproceedings of third international www conference, darmstadt, darmstadt, april 10-\n14, 1995, fraunhofer institute for computer graphics, pp. 42-45, also available at\nhttp://www.igd.fhg.de/archive/1995_www95/proceedings/posters/48/index.html.\nbrusilovsky, p. (1999) adaptive and intelligent technologies for web-based education. in c.\nrollinger and c. peylo (eds.), künstliche intelligenz   (4), special issue on intelligent\nsystems and teleteaching, 19-25, http://www2.sis.pitt.edu/~peterb/papers/ki-review.html.\nbrusilovsky, p. and eklund, j. (1998) a study of user-model based link annotation in\neducational hypermedia. in p. carlson (ed.) journal of universal computer science  4 (4),\nspecial issue on assessment issues for educational software, 429-448,\nhttp://www.iicm.edu/jucs_4_4/a_study_of_user.\nbrusilovsky, p., eklund, j., and schwarz, e. (1998) web-based education for all: a tool for\ndeveloping adaptive courseware. computer networks and isdn systems  (proceedings of\nseventh international world wide web conference, 14-18 april 1998) 30 (1-7), 291-300.\nbrusilovsky, p. and miller, p. (2001) course delivery systems for the virtual university. in: t.\ntschang and t. della senta (eds.): access to knowledge: new information technologies\nand the emergence of the virtual university. amsterdam: elsevier science, pp. 167-206.\nbrusilovsky, p. and pesin, l. (1998) adaptive navigation support in educational hypermedia:\nan evaluation of the isis-tutor. journal of computing and information technology 6 (1),\n27-38.\nbrusilovsky, p., schwarz, e., and weber, g. (1996a) elm-art: an intelligent tutoring system\non world wide web. in: c. frasson, g. gauthier and a. lesgold (eds.) intelligent\ntutoring systems. lecture notes in computer science, vol. 1086, (proceedings of third\ninternational conference on intelligent tutoring systems, its-96, montreal, june 12-14,\n1996) berlin: springer verlag, pp. 261-269.\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n382 brusilovsky, p., schwarz, e., and weber, g. (1996b) a tool for developing adaptive electronic\ntextbooks on www. in: h. maurer (ed.) proceedings of webnet’96,  world conference\nof the web society, san francisco, ca, october 15-19, 1996, aace, pp. 64-69, also\navailable at http://www.contrib.andrew.cmu.edu/~plb/webnet96.html.\nbrusilovsky, p. and weber, g. (1996) collaborative example selection in an intelligent\nexample-based programming environment. in: d. c. edelson and e. a. domeshek (eds.)\nproceedings of international conference on learning sciences, icls’96, evanston, il,\nusa, aace, pp. 357-362, also available at\nhttp://www2.sis.pitt.edu/~peterb/papers/icls96.html.\nbull, s. and pain, h. (1995) "did i say what i think i said, and do you agree with me?"\ninspecting and questioning the student model. in: j. greer (ed.) proceedings of ai-ed’95,\n7th world conference on artificial intelligence in education, washington, dc, 16-19\naugust 1995, aace, pp. 501-508.\nburow, r. and weber, g. (1996) example explanation in learning environments. in: c.\nfrasson, g. gauthier and a. lesgold (eds.) intelligent tutoring systems. lecture notes in\ncomputer science, vol. 1086, (proceedings of third international conference on\nintelligent tutoring systems, its ’96, montréal, june 12-14) berlin: springer-verlag, pp.\n457-465.\ncorbett, a. t. and anderson, j. a. (1992) knowledge tracing in the act programming tutor.\nin:  proceedings of 14-th annual conference of the cognitive science society.\ndomingue, j. and mulholland, p. (1998) an effective web based software visualization\nlearning environment. journal of visual languages and computing  9 (5), 485-508.\neklund, j. (1996) knowledge-based navigation support in hypermedia courseware using\nwest. australian educational computing  11 (2), 10-14.\nfoxley, e., benford, s., burke, e., and ceillidh development team (1998) webceilidh,\nuniversity of nottingham. http://www.cs.nott.ac.uk/~ceilidh (accessed 28 july, 1998)\ngreer, j., mccalla, g., cooke, j., collins, j., kumar, v., bishop, a., and vassileva, j. (1998)\nthe intelligent helpdesk: supporting peer-help in a university course. in: b. p. goettl, h.\nm. halff, c. l. redfield and v. j. shute (eds.) intelligent tutoring systems. lecture notes\nin computer science, vol. 1452, (proceedings of 4th international conference, its-98,\nsan antonio, tx, august 16-19, 1998) berlin: springer-verlag, pp. 494-503.\nhaajanen, j., pesonius, m., sutinen, e., tarhio, j., teräsvirta, t., and vanninen, p. (1997)\nanimation of user algorithms on the web. in:  proceedings of vl ''97, ieee symposium\non visual languages, , ieee, pp. 360-367, also available at\nhttp://www.cs.helsinki.fi/research/aaps/jeliot/vl.ps.gz.\nheift, t. and nicholson, d. (2001) web delivery of adaptive and interactive language tutoring.\ninternational journal of artificial intelligence in education  12 (this issue).\nhenze, n., naceur, k., nejdl, w., and wolpers, m. (1999) adaptive hyperbooks for\nconstructivist teaching. in c. rollinger and c. peylo (eds.), künstliche intelligenz (4), 26-\n31.\nhenze, n. and nejdl, w. (2001) adaptation in open corpus hypermedia. international journal\nof artificial intelligence in education 12 (this issue).\nhoppe, u. (1995) use of multiple student modeling to parametrize group learning. in: j. greer\n(ed.) proceedings of ai-ed''95, 7th world conference on artificial intelligence in\neducation, washington, dc, 16-19 august 1995, aace, pp. 234-249.\nkay, j. (1995) the um toolkit for cooperative user models. user modeling and user-adapted\ninteraction  4 (3), 149-196.\nkolodner, j. l. (1993) case-based reasoning. san mateo, ca: morgan kaufmann.\nmallery, j. c. (1994) a common lisp hypermedia server. in:  proceedings of the first\ninternational conference on the world-wide web, may 25, 1994.\nmelis, e., andres, e., büdenberder, j., frishauf, a., goguadse, g., libbrecht, p., pollet, m.,\nand ullrich, c. (2001) a generic and adaptive web-based learning environment.\ninternational journal of artificial intelligence in education 12 (this issue).\nmilosavljevic, m. and oberlander, j. (1998) dynamic hypertext catalogues: helping users to\nhelp themselves. in: k. grønbæk, e. mylonas and f. m. shipman iii (eds.) proceedings of\n\nhal-00197328, version 1 - 14 dec 2007elm-art: an adaptive versatile system for web-based instruction\n383 ninth acm international hypertext conference (hypertext’98), pittsburgh, usa, june 20-\n24, 1998, acm press, pp. 123-131.\nmitchell, t. m., keller, r. m., and kedar-cabelli, s. t. (1986) explanation-based\ngeneralization: a unifying view. machine learning  1 (1), 47-80.\nmorelos-borja, h. (1998) effects of automatic assignment of peers to tutor/tutee roles in\nweb-based distance education, report, report, school of computer science, university\nof central florida, http://www.cs.ucf.edu/~morelos/papers/fall98techreport.rtf.\nnakabayashi, k., koike, y., maruyama, m., touhei, h., ishiuchi, s., and fukuhara, y. (1995)\nan intelligent tutoring system on world-wide web: towards an integrated learning\nenvironment on a distributed hypermedia. in: h. maurer (ed.) proceedings of ed-\nmedia’95 - world conference on educational multimedia and hypermedia, graz, austria,\njune 17-21, 1995, aace, pp. 488-493.\noda, t., satoh, h., and watanabe, s. (1998) searching deadlocked web learners by measuring\nsimilarity of learning activities. in:  proceedings of workshop "www-based tutoring" at\n4th international conference on intelligent tutoring systems (its’98), san antonio, tx,\naugust 16-19, 1998, also available at\nhttp://www.sw.cas.uec.ac.jp/~watanabe/conference/its98workshop1.ps.\noppermann, r. (1994) adaptively supported adaptability. international journal on human-\ncomputer studies  40, 455-472.\npeylo, c., thelen, t., rollinger, c., and gust, h. (2000) a web-based intelligent educational\nsystem for prolog. in:  proceedings of workshop on adaptive and intelligent web-\nbased education systems at 5th international conference on intelligent tutoring systems\n(its’2000), montreal, canada, june 19, 2000 published as report,, institute for semantic\ninformation processing, university of osnabrück, osnabrück. pp. 85-96.\nrios, a., millán, e., trella, m., j.l., p., and conejo, r. (1999) internet based evaluation\nsystem. in: s. p. laojie and m. and vivet (eds.) artificial intelligence in education: open\nlearning environments. (proceedings of ai-ed''99, le mans, france) amsterdam: ios\npress, pp. 387-394.\nschöch, v., specht, m., and weber, g. (1998) "adi" - an empirical evaluation of a tutorial\nagent. in: t. ottmann and i. tomek (eds.) proceedings of ed-media/ed-telecom’98 -\n10th world conference on educational multimedia and hypermedia and world\nconference on educational telecommunications, freiburg, germany, june, 20-25, 1998,\naace, pp. 1242-1247.\nschwarz, e., brusilovsky, p., and weber, g. (1996) world-wide intelligent textbooks. in:\nproceedings of ed-telecom’96 - world conference on educational\ntelecommunications, boston, ma, june 17-22, 1996, aace, pp. 302-307, also\navailable at http://www.contrib.andrew.cmu.edu/~plb/ed-media-96.html.\nself, j. (1995) dormorbile: a vehicle for metacognition. in: t. w. chan and j. a. self (eds.):\nemerging computer technologies in education. charlottesville: aace.\nspecht, m. and kobsa, a. (1999) interaction of domain expertise and interface design in\nadaptive educational hypermedia. in: p. brusilovsky and p. d. bra (eds.) proceedings of\nsecond workshop on adaptive systems and user modeling on the world wide web,\ntoronto and banff, canada, may 11 and june 23-24, 1999 published as computer science\nreport, no. 99-07, eindhoven university of technology, eindhoven. pp. 89-93.\nspecht, m. and oppermann, r. (1998) ace - adaptive courseware environment. in p.\nbrusilovsky and m. milosavljevic (eds.), the new review of hypermedia and multimedia\n4, special issue on adaptivity and user modeling in hypermedia systems, 141-161.\nspecht, m. and weber, g. (1997) kognitive lernermodellierung. kognitionswissenschaft  6\n(4), 165-176.\nspecht, m., weber, g., heitmeyer, s., and schöch, v. (1997) ast: adaptive www-\ncourseware for statistics. in: p. brusilovsky, j. fink and j. kay (eds.) proceedings of\nworkshop "adaptive systems and  user modeling on the world wide web" at 6th\ninternational conference on user modeling, um97, chia laguna, sardinia, italy, june 2,\n1997, pp. 91-95, also available at\nhttp://www.contrib.andrew.cmu.edu/~plb/um97_workshop/specht.html.\n\nhal-00197328, version 1 - 14 dec 2007weber and brusilovsky\n384 tudhope, d., taylor, c., and benyon-davies, p. (1995) navigation via similarity in hypermedia\nand information retrieval. in: r. kuhlen and m. ritterberg (eds.) proceedings of him’95,\nkonstanz, konstanz, april 1995, universitätverlag konstanz, pp. 203-218.\nwebct (1999) world wide web course tools 1.3.1, webct educational technologies,\nvancouver, canada. http://www.webct.com (accessed 15 february, 1999)\nweber, g. (1996a) episodic learner modeling. cognitive science  20 (2), 195-236.\nweber, g. (1996b) individual selection of examples in an intelligent learning environment.\njournal of artificial intelligence in education  7 (1), 3-31.\nweber, g. (1999) adaptive learning systems in the world wide web. in: j. kay (ed.)\nproceedings of 7th international conference on user modeling, um99, banff, canada,\njune 20-24, 1999, wien: springerwiennewyork, pp. 371-378.\nweber, g., kuhl, h.-c., and weibelzahl, s. (2001) developing adaptive internet based courses\nwith the authoring system netcoach. in: p. d. bra, p. brusilovsky and a. kobsa (eds.)\nproceedings of third workshop on adaptive hypertext and hypermedia, sonthofen,\ngermany, july 14, 2001, technical university eindhoven, pp. 35-48, also available at\nhttp://wwwis.win.tue.nl/ah2001/papers/gweber-um01.pdf.\nweber, g. and möllenberg, a. (1995) elm-programming-environment: a tutoring system for\nlisp beginners. in: k. f. wender, f. schmalhofer and h.-d. böcker (eds.): cognition and\ncomputer programming. norwood, nj: ablex, pp. 373-408.\nweber, g. and specht, m. (1997) user modeling and adaptive navigation support in www-\nbased tutoring systems. in: a. jameson, c. paris and c. tasso (eds.): user modeling:\nproceedings of the sixth international conference, um97. vienna, new york: springer,\npp. 289-300.', 0, 'xzsa', 1, '2017-02-08', '', 'F', 'P', 57, 9, 0);
INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(14, 2, '098754', '2017-02-08', 0, 0, 21, 10, 1, '1486554096.pdf', 91, 'sample pdf document\nrobert maron\ngrzegorz grudzi ´\nnski\nfebruary 20, 1999\n\n2\n\ncontents\n1 template\n5\n1.1 how to compile a .texle to a .pdfle\n. . . . . . . . . . . . .\n5\n1.1.1 tools\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n5\n1.1.2 how to use the tools\n. . . . . . . . . . . . . . . . . . . .\n5\n1.2 how to write a document\n. . . . . . . . . . . . . . . . . . . . . .\n6\n1.2.1 the main document\n. . . . . . . . . . . . . . . . . . . . .\n6\n1.2.2 chapters\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n6\n1.2.3 spell-checking\n. . . . . . . . . . . . . . . . . . . . . . .\n6\n1.3 l a\nt\ne x and pdfl\na\nt\ne x capabilities\n. . . . . . . . . . . . . . . . . . .\n7\n1.3.1 overview\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n1.3.2 l a\nt\ne x\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n1.3.3 pdfl a\nt\ne x\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n1.3.4 examples\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n3\n\n4\ncontents\n\nchapter 1\ntemplate\n1.1 how to compile a .texle to a .pdfle\n1.1.1 tools\nto process the les you (may) need:\n\npdflatex (for example from tetexpackage 0.9-6 , which you can\nget from\nred hat 5.2\n);\n\nacroread (a pdf viewer, available from\nhttp://www.adobe.com/\n);\n\nghostscript 5.10 (for example from\nred hat contrib\n) and ghostview\nor gv (from redhat linux);\n\nefax package could be useful, if you plan to fax documents.\n1.1.2 how to use the tools\nfollow these steps:\n1.\nput all source .texles in one directory, then chdir to the directory (or put\nsome of them in the l a\nt\ne xsearch path — if you know how to do this);\n2.\nrun “ pdflatex file.tex ” on the main le of the document three times\n(three — to prepare valid table of contents);\n3.\nto see or print the result use acroread(unfortunately some versions of\nacroread may produce postscript which is too complex), or\n5\n\n6\nchapter 1. template\n4.\nrun ghostscript : “gv file.pdf ” to display or:\n“gs -dnopause -sdevice=pswrite -q -dbatch -soutputfile=le.ps le.pdf ”\nto produce a postscript le;\n5.\nrun “ fax send phone-number file.ps ” as root to send a fax, or — if you\nknow how to do this — modify the faxscript to be able to fax .pdfles directly\n(you have to insert “ |%pdf*” somewhere. . . ).\n1.2 how to write a document\n1.2.1 the main document\nchoose the name of the document, say document. copytemplate.tex to\ndocument.tex , then edit it, change the title, the authors and set proper in-\nclude(s) for all the chapters.\n1.2.2 chapters\neach chapter should be included in the main document as a separate le. you can\nchoose any name for the le, but we suggest adding a sufx to the name of the\nmain le. for our example we use the le name document_chapter1.tex.\nfirst, copy template_chapter.tex todocument_chapter1.tex\nand add the line\n\\include{document_chapter1}\nin the document.tex , then editdocument_chapter1.tex , change the\nchapter title and edit the body of the chapter appropriately.\n1.2.3 spell-checking\ndo use a spell-checker, please!\nyou may also want to check grammar, style and so on. actually you should\ndo it (if you have enough spare time). but you mustcheck spelling!\nyou can use the ispellpackage for this, from within emacs, or from the\ncommand line:\nispell -t document_chapter1.tex\n\n1.3. l a\nt\nex and pdfl\na\nt\nex capabilities\n7\n1.3 l a\nt\ne x and pdfl\na\nt\ne x capabilities\n1.3.1 overview\nfirst you edit your source .texle. in l a\nt\ne x you compile it using the\nlatex\ncommand to a .dvile (which stands for device-independent). the .dvile\ncan be converted to any device-dependent format you like using an appropriate\ndriver, for example dvips.\nwhen producing .pdfles you should use pdflatex, which produces di-\nrectly .pdf les out of .texsources. note that in the .texle you may need\nto use some pdf specic packages.\nfor viewing .texles use your favourite text editor, for viewing .dviles\nunder x window system use xdvicommand, .psles can be viewed with gv\n(or ghostview ) and.pdf les with acroread ,gv orxpdf .\n1.3.2 l a\nt\ne x\na lot of examples can be found in this document. you should also print\n\ndoc/latex/general/latex2e.dvi and\n\ndoc/latex/general/lshort2e.dvi\nfrom your tetexdistribution (usually in\n\n/usr/share/texmf or\n\n/usr/lib/texmf/texmf ).\n1.3.3 pdfl a\nt\ne x\nconsult doc/pdftex/manual.pdf from yourtetexdistribution for more\ndetails. very useful informations can be found in the hyperrefandgraphics\npackage manuals:\n\ndoc/latex/hyperref/manual.pdf and\n\ndoc/latex/graphics/grfguide.dvi .\n1.3.4 examples\nreferences\nmimuw\n\n8\nchapter 1. template\nhyperlinks\nthis is a target.\nand this is a link.\ndashes, etc.\nthere are three kinds of horizontal dash:\n\n- (use inside words; for example “home-page”, “x-rated”)\n\n– (use this one between numbers; for example “pages 2–22”)\n\n— (use this one as a sentence separator — like here)\nnational characters\n\nó, é, í, . . .\n\nè, à, ì, . . .\n\nô, ê, . . .\n\nõ, ñ, . . .\n\nö, ë, . . .\n\nz\n\na, e\n\n, ø, ß\nthere are other ways to do this, see the documentation for inputencpack-\nage.\nreserved characters\nsome characters have some special meaning, thus cannot be entered in the usual\nway.\n\n$ & % # _ { }\n\nn\n\n˜ ˆ\n\n1.3. l a\nt\nex and pdfl\na\nt\nex capabilities\n9\nmath\n\n1 2\n, 12\nn\n, . . .\n\ni\n1 ,\ni\n2 n , . . .\n\n1\n2 , 2\nn\n2 \0 3, . . .\n\n , ,\r ,\n , . . .\n\n! ,) , ,6\n= ,2 ,?, . . .\n\np\n2 , . . .\n\n2 + 2 , . . .\nfor more examples and symbols see chapter 3 of lshort2e.dvi.\nfonts\n\nroman\n\nemphasis\n\nmedium weight — the default\n\nboldface\n\nupright\n\nslanted\n\nsans serif\n\ns m a l l c a p s\n\ntypewriter\n\nand sizes:\n–\ntiny\n–\nscriptsize\n–\nfootnotesize\n–\nsmall\n–\nnormalsize\n\n10\nchapter 1. template\n–\nlarge\n–\nlarge\n–\nlarge\n–\nhuge\n–\nhuge', 0, 'dcshj', 10, '2017-02-08', '', 'F', 'P', 7, 11, 0),
(15, 1, 'water', '2017-02-08', 0, 0, 31, 5, 1, '1486554419.pdf', 91, 'the p df9 95  s u it e  o f p ro ducts  -  p df9 95,  p dfe dit 9 95 , a n d s ig na tu re 99 5 -  is  a  c o m ple te  s o lu tio n fo r y o ur d ocu m ent p ublis h in g n ee ds. it \np ro vid es e ase  o f u se , fle xib ilit y  in  fo rm at,  a nd  in d ustr y -s ta nd ard  s e cu rit y - a nd a ll  a t n o  c o st to  y o u. \np df9 95 m ake s it  e a sy a nd  a ffo rd able  to  c re ate  p ro fe ssio nal- q u alit y  d o cu m en ts  in  th e p o pula r p d f file  fo rm at. i ts  e asy-to -u se  in te rfa ce  \nh elp s y o u to  c re a te  p d f file s b y s im ply  s e le ctin g t h e " p rin t"  c o m mand f r o m  a ny a pp lic a tio n,  c re atin g d ocu m ents  w hic h  c a n  b e v ie w ed \no n a ny c o m pute r w it h  a  p d f v ie w er. p df9 95 s u pp orts  n etw ork  file  s a vin g, f a st u se r s w it c h in g  o n x p , c it r ix /t erm in al  s erv e r, c u sto m  \np age s iz e s a nd la rg e fo rm at  p rin tin g . p df9 95 is  a  p rin te r d riv e r th at w ork s w it h  a ny p osts crip t to  p d f c o nve rte r. t he p df9 95  p rin te r \nd riv e r a nd a  fr e e c onve rte r a re  a va ila b le  fo r e a sy d ow nlo ad . \np dfe dit 9 95 o ffe rs  a  w ealt h  o f a ddit io na l  fu n ctio na lit y , s u ch  a s: c o m bin in g d o cu m en ts  in to  a  s in g le  p d f;  a uto m atic  lin k in se rtio n; \nh ie ra rc h ic a l  b ookm ark  in se rtio n ; p d f c o nve rs io n to  h tm l o r d o c ( te xt o nly ); in te gra tio n w it h  w ord  to olb ar w it h  a u to m atic  ta ble  o f \nc o nte nts  a nd lin k g enera tio n ; a u to atta ch  to  e m ail;  s ta tio ne ry  a n d s ta m pin g.  \ns ig natu re 99 5 o ffe rs  s ta te -o f- th e-a rt s e cu rit y  a n d e n cry p tio n t o  p ro te ct y o u r d ocu m ents  a n d a dd d ig it a l  s ig n atu re s. \n    \nt he p df9 9 5 s uit e  o ffe rs  t h e f o llo w in g f e a tu re s,  a ll a t n o c o st: \na uto m atic  in se rtio n o f e m bedde d lin ks \nh ie ra rc h ic a l  b ookm ark s  \ns upp ort fo r d ig it a l  s ig natu re s \ns upp ort fo r t rip le  d es e ncry p tio n \na ppe nd a nd d ele te  p d f p ages \nb atc h  p rin t fr o m  m ic ro so ft o ffic e  \na sia n a nd c yrillic  fo nts  \ni n te gra tio n w it h  m ic ro so ft  w ord  to olb ar \np d f s ta tio nery  \nc om bin in g m ult ip le  p d f''s  in to  a  s in gle  p d f \nt hre e a uto -n am e o ptio ns to  b yp ass s ave  a s d ia lo g \ni m posit io n o f d ra ft/ c onfid entia l  s ta m ps \ns upp ort fo r la rg e fo rm at a rc h it e ctu ra l  p rin tin g \nc onve rt p d f to  j p eg , t if f, b m p, p c x fo rm ats  \nc onve rt p d f to  h tm l a n d w ord  d o c c o nve rs io n \nc onve rt p d f to  te xt \na uto m atic  t able  o f c onte nts  g enera tio n \ns upp ort fo r x p f ast u se r s w it c h in g a nd m ult ip le  u se r \ns e ssio ns \ns ta nd ard  p d f e ncry p tio n ( re str ic te d p rin tin g, m odif y in g, \nc o pyin g te xt a nd im ag es) \ns upp ort fo r o ptim iz e d p d f \ns upp ort fo r c u sto m  p age s iz e s  o\nptio n to  a tta ch  p d fs to  e m ail  a fte r c re atio n  \na uto m atic  te xt s u m mariz a tio n o f p d f \nd ocu m ents  \ne asy in te gra tio n w it h  d ocu m ent m ana gem ent \na nd w ork flo w  s ys te m s \nn -u p p rin tin g \na uto m atic  p age n um berin g \ns im ple  p ro gra m mers  in te rfa ce  \no ptio n to  a uto m atic a lly  d is p la y p d fs a fte r \nc re atio n \nc usto m  r e siz in g o f p d f o utp ut \nc onfig ura ble  f ont e m bed din g \ns upp ort fo r c it r ix /t erm in al  s erv e r \ns upp ort fo r w in dow s 2 003 s erv e r \ne asy p s to  p d f p ro ce ssin g \ns pecif y  p d f d ocu m ent p ro pertie s \nc ontr o l  p d f o p enin g m ode \nc an b e c o nfig ure d to  a d d fu nctio nalit y  to  \na cro bat d is til le r \nf re e: c re ate s p d fs w it h out a nn oyin g \nw ate rm ark s \nf re e: f ully  fu nctio nal,  n ot a  tr ia l  a nd d oes n ot \ne xp ir e  \no ve r 5  m illio n s a tis fie d c u sto m ers  \no ve r 1 00 0 e nte rp ris e  c usto m ers  w orld w id e \n \np le ase  v is it u s a t w ww.p df9 95.c o m t o  l e arn  m ore . \n \nt his  d ocu m en t illu str a te s s e ve ra l  f e atu re s o f th e p df9 9 5 s uit e  o f p ro d ucts .\n\nappr o ved\nin tr o d uctio n\nt he v ir tu al r ea li t y m od elin g lan gu age (v rm l)is a la n gu ag e fo r desc rib in g m ulti -\np artic ip an t in te ra cti v e sim ula tio ns -- vir tu al w orld s netw ork ed via th e glo bal in te rn et an d\nh yp erlin ked with th e w orld w id e w eb .a ll asp ec ts of vir tu al w orld dis p la y , in te ra cti o n\na n d in te rn etw ork in g ca n be sp ecif ie d usin g vrm l.it is th e in te n tio n of its desig n ers th at\nv rm lbec o m eth e sta n dard la n gu ag e fo r in te ra ctiv e sim ula ti o n with in th e w orld w id e\nw eb .\nt he fir s t vers io n of v rm lall o w sfo r th e cre a tio n of vir tu al w orld s w it h li m ite d\ni n te ra ctiv e beh av io r. t hese w orld s ca n co nta in obje cts w hic h hav e hyp erli n ks to oth er\nw orld s, h tm ldocu m en ts or oth er vali d m im ety p es. w hen th e use r se le cts an obje c t\nw ith ahyp erlin k,th e ap pro pria te m im evie w er is la u nch ed .w hen th e use r se le cts a li n k\nt o av rm ldocu m en t fr o m with in aco rre ctl y co nfig u re d w w w bro w se r, a v rm l\nv ie w er is la u nch ed .t hus v rm lvie w ers are th e perf e c t co m pan io n ap plic a tio ns to\ns ta n dard w ww bro w se rs fo r nav ig atin g an d vis u aliz in g th e w eb .f utu re vers io ns of\nv rm lwill allo w fo r ric h er beh av io rs , in clu din g an im atio ns, m oti o n physic s an d re a l-\nt im em ulti - u se r in te ra cti o n.\nt his docu m en t sp ec if ie s th e fe atu re s an d sy n ta x of v ers io n 1.0 of v rm l.\nv rm lm is s io n sta te m en t\nt he his to ry of th e dev elo pm en t of th e in te rn et has had th re e dis tin ct phase s; fir s t, th e\nd ev elo pm en t of th e tc p/i p in fra str u ctu re w hic h all o w ed docu m en ts an d data to be sto re d\ni n apro x im ally in dep en den t w ay ; th at is , in te rn et pro vid ed ala y er of ab str a c ti o n betw ee n\nd ata se ts an d th e hosts w hic h m an ip ula te d th em .w hile th is ab str a cti o n was use fu l, it w as\na ls o co nfu sin g; w ith out an y cle ar se n se of "w hat w en t w here ", acc ess to in te rn et w as\nr e str ic te d to th e cla ss of sy so ps/n et su rfe rs w ho co uld m ain ta in in te rn al co gn itiv e m ap s of\nt h e data sp ac e.\nn ex t, t im bern ers -l ee ''s w ork at c er n ,w here he dev elo ped th e hyp erm ed ia sy ste m\nk no w n as w orld w id e w eb ,ad ded an oth er la y er of ab str a c ti o n to th e ex is tin g str u ctu re .\nt his ab str a c tio n pro vid ed an "a d dre ssin g" sc h em e, a uniq ue id en tif ie r (th e u niv ers a l\nr eso urc e loca to r), w hic h co uld te ll an yo ne "w here to go an d how to get th ere " fo r an y\np ie c e of data w ith in th e w eb .w hile use fu l, it la c k ed dim en sio nali ty ; th ere ''s no th ere\nt h ere w ith in th e w eb ,an d th e only ty p e of nav ig atio n perm is sib le (o th er th an su rfin g) is\nb y dir e c t re fe re n ce. in oth er w ord s, i can only te ll yo u how to get to th e v rm lforu m\nh om epag e by sa y in g, "h ttp ://w w w.w ir e d .c o m /" , w hic h is not hum an -c en te re d data . in\n\nappr o ved\nfa c t, i need to m ak e an effo rt to re m em ber it at all . s o,w hile th e w orld w id e w eb\np ro vid es a re tr ie v al m ec h an is m to co m ple m en t th e ex is ti n g sto ra g e m ech an is m ,it le a v es\na lo t to be desir e d ,parti c u la rly fo r hum an bein gs.\nf in ally , w em ove to "p erc ep tu aliz ed " in te rn etw ork s, w here th e data has been se n su aliz ed ,\nt h at is , re n dere d se n su ally . if so m eth in g is re p re se n te d se n su ally , it is possib le to m ak e\ns e n se of it. v rm lis an atte m pt (h ow su cc essfu l, only ti m ean d effo rt w il l te ll) to pla ce\nh um an s at th e cen te r of th e in te rn et, ord erin g its univ ers e to our w him s. in ord er to do\nt h at, th e m ost im porta n t sin gle ele m en t is a sta n dard th at defin es th e partic u la riti e s of\np erc e p tio n.v ir tu al r ealit y m odelin g lan gu ag e is th at sta n dard ,desig n ed to be a\nu niv e rs a l desc rip ti o n la nguage fo r m ult i- p artic ip ant sim ula ti o ns.\nt hese th re e phase s, sto ra g e, re tr ie v al, an d perc ep tu aliz ati o n are an alo go us to th e hum an\np ro cess of co nsc io usn ess, as ex pre ss e d in te rm sof se m an tic s an d co gn it iv e sc ie n ce .\ne ven ts occu r an d are re co rd ed (m em ory ); in fe re n ce s are dra w n fro m mem ory\n( a sso cia tio ns), an d fro m se ts of re la te d ev en ts , m ap s of th e univ ers e are cre a te d (c o gn iti v e\np erc ep tio n). w hat is im porta n t to re m em ber is th at th e m ap is not th e te rr it o ry , an d we\ns h ould av oid beco m in g tr a p ped in an y sin gle re p re se n ta ti o n or w orld -v ie w .a lth ough we\nn ee d to desig n to avo id dis o rie n ta ti o n,w esh ould alw ay s push th e en velo pe in th e kin ds\no f ex perie n ce w eca n brin g in to m an if e sta tio n!\nt his docu m en t is th e liv in g pro of of th e su cce ss of a pro cess th at w as co m mitt e d to bein g\no pen an d fle x ib le , re sp onsiv e to th e need s of a gro w in g w eb co m munit y . r ath er th an re -\ni n ven t th e w hee l, w ehav e ad ap te d an ex is tin g sp ecif ic atio n (o pen in ven to r) as th e basis\nf r o m whic h our ow n work ca n gro w ,sa v in g years of desig n work an d perh ap s m an y\nm is ta k es. n ow our re al w ork can beg in ; th at of re n derin g our noosp heric sp ace .\nh is to ry\nv rm lwas co nce iv ed in th e sp rin g of 1994 at th e fir s t an nual w orld w id e w eb\nc onfe re n ce in gen ev a, s w it z erla n d.t im bern ers -l ee an d dav e rag gett org an iz ed a\nb ir d s-o f- a -f ea th er (b o f) se ssio n to dis c u ss v ir tu al r ea li ty in te rfa ce s to th e w orld w id e\nw eb .s ev era l b o f att e n dees desc rib ed pro je cts alr e a d y underw ay to buil d th re e\nd im en sio nal gra p hic al vis u aliz atio n to ols w hic h in te ro pera te w ith th e w eb .a tte n dee s\na g re e d on th e need fo r th ese to ols to hav e aco m m on la n gu ag e fo r sp ecif y in g 3d sc e n e\nd esc rip tio n an d w ww hyp erlin ks -- an an alo g of h tm lfo r vir tu al re a lity . t he te rm\nv ir tu al r eali t y m ark up lan gu ag e (v rm l)w as co in ed ,an d th e gro up re so lv ed to beg in\ns p ecif ic ati o n work afte r th e co nfe re n ce. t he w ord ''m ark up''w as la te r ch an ged to\n'' m odelin g''to re fle c t th e gra p hic a l natu re of v rm l.\n\nappr o ved\nshortly afte r th e g en ev a bo f se ss io n,th e w ww -v rm lm aili n g lis t w as cre ate d to dis c u ss\nt h e dev elo pm en t of a sp ecif ic atio n fo r th e fir s t vers io n of v rm l.t he re sp onse to th e lis t\ni n vita ti o n was overw helm in g: w ith in aw eek ,th ere w ere over a th ousa n d m em bers . a fte r\na n in itia l se ttli n g-in perio d,li s t m odera to r m ark pesc e of l ab yrin th gro up an nounce d his\ni n te n tio n to hav e adra ft vers io n of th e sp ecif ic atio n re ad y by th e w w w fall 1994\nc o nfe re n ce, a m ere fiv e m onth s aw ay . t here w as gen era l ag re em en t on th e li s t th at, w hil e\nt h is sc h ed ule w as ag g re ssiv e, it w as ach ie v ab le pro vid ed th at th e re q uir e m en ts fo r th e\nf ir s t vers io n were not to o am biti o us an d th at v rm lco uld be ad ap te d fr o m an ex is tin g\ns o lu tio n.t he lis t quic k ly ag re ed upon ase t of re q uir e m en ts fo r th e fir s t vers io n,an d\nb eg an ase arc h fo r te ch nolo gie s w hic h co uld be ad ap te d to fit th e need s of v rm l.\nt he se a rc h fo r ex is ti n g te ch nolo gie s tu rn ed up ase v era l w orth w hil e ca n did ate s. a fte r\nm uch delib era tio n th e li s t cam eto aco nse n su s: th e o pen in ven to r a sc ii file form at\nf ro m sil ic o n gra p hic s, in c. t he in ven to r fil e form at su pports co m ple te desc rip tio ns of\n3 d sc en es w it h poly g o nally re n dere d obje c ts , lig h tin g, m ate ria ls , am bie n t pro pertie s an d\nr e a lis m effe c ts . a su bse t of th e in ven to r fil e form at, w ith ex te n sio ns to su pport\nn etw ork in g, fo rm sth e basis of v rm l.g av in bell of silic o n gra p hic s has ad ap te d th e\ni n ven to r file form at fo r v rm l,w it h desig n in put fr o m th e m aili n g lis t. s g ihas public ly\ns ta te d th at th e file fo rm at is av aila b le fo r use in th e open m ark et, an d hav e co ntr ib ute d a\nf ile fo rm at pars e r in to th e publi c dom ain to boots tr a p vrm lvie w er dev elo pm en t.\n\nappr o ved\nagra ph ic a lr epre se n ta tio n ofin ve rs e vr m l upta ke\nc han ge th e num ber in re d belo w to adju st fo r dow nlo a d ra te and /o r ban dw id th .\n1t he num be r 1 re p re se n ts an eng in e er w it h an "a ve ra ge " cu be *\ncf min f\ns w air e\na n x\n3 2 % e\na nx\n3 6 %\n8 0.0 14 9.1 2\n0\n6 1.4 11 4.4 310\n4 9.8 92 .8 4620\n4 1.9 78 .1 0230180\n3 6.2 67 .4 0240120\n3 1.8 59 .2 755080 .01 47 .01 92 .0\n2 8.4 52.96 057 .09 2.01 23 .0\n2 5.6 47 .7 747040 .06 5.07 9.0\n2 3.4 43 .5 438030 .04 9.05 9.0\n2 1.5 40 .0 019024 .03 7.04 5.0\n1 9.9 3710019 .03 0.03 5.0\n1 8.5 34 .4 0911016 .02 5.02 9.0\n1 7.3 32 .1 5412013 .02 0.0n /a\n1 6.2 30 .1 7813010 .01 7.0n /a\n1 5.12 8.2 021408.0n /an /a\n0\n2\n0\n4\n0\n6\n0\n8\n0\n1\n00\n1\n20\n1\n4 00\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n9 0\n1 0 0\n1 1 0\n1 2 0\n1 3 0\n1 4 0\nd ays afte r do w nlo ad\nin vers e usag e\np ro gra m m ers\nt ech nic a lw rit e rs\nq a\noth e r\n0\n1\n0\n2\n0\n3\n0\n4\n0\n5\n0\n6\n0\n7\n0\n8\n0\n9\n0\n50\n6 0\n7 0\n8 0\n9 0\n1 00\n1 10\n1 20\n1 30\n1 40\nd ays aft e r do w nlo ad\nin vers e lo g usa g e\na rtis ts\nm usic ia ns\np olit ic ia n s\nd entis ts', 0, 'apoi', 10, '2017-02-08', '', 'F', 'P', 7, 6, 0);
INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(16, 2, '213', '2017-02-08', 0, 0, 11, 9, 3, '1486554437.pdf', 53, 'an intelligent simulator for\ntelerobotics training\nkhaled belghith, roger nkambou, froduald kabanza, and leo hartman\nabstract—roman tutor is a tutoring system that uses sophisticated domain knowledge to monitor the progress of students and\nadvise them while they are learning how to operate a space telerobotic system. it is intended to help train operators of the space\nstation remote manipulator system (ssrms) including astronauts, operators involved in ground-based control of ssrms and\ntechnical support staff. currently, there is only a single training facility for ssrms operations and it is heavily scheduled. the training\nstaff time is in heavy demand for teaching students, planning training tasks, developing teaching material, and new teaching tools. for\nexample, all ssrms simulation exercises are developed by hand and this process requires a lot of staff time. once in an orbit iss\nastronauts currently have only simple web-based material for skill development and maintenance. for long duration space flights,\nastronauts will require sophisticated simulation tools to maintain skills. roman tutor addresses these challenges by providing a\nportable training tool that can be installed anywhere and anytime to provide “just in time” training. it incorporates a model of the system\noperations curriculum, a kinematic simulation of the robotics equipment, and the iss, a high performance path planner and an\nautomatic task demonstration generator. for each element of the curriculum that the student is supposed to master, roman tutor\ngenerates example tasks for the student to accomplish within the simulation environment and then monitors its progression to provide\nrelevant feedback when needed. although motivated by the ssrms application, roman tutor remains applicable to any telerobotics\nsystem application.\nindex terms—telerobotics training, intelligent tutoring, robot manipulation, path planning, demonstration generation.\nÇ\n1introduction\nr\nomantutor (robot manipulation tutor) is a\nsimulation-based tutoring system to support astronauts\nin learning how to operate the space station remote\nmanipulator (ssrms), an articulated robot arm mounted\non the international space station (iss). once in orbit, iss\nastronauts currently have only simple web-based material\nfor skill development and maintenance. for long duration\nspace flights, astronauts will require sophisticated simula-\ntion tools to maintain skills. roman tutor addresses these\nchallenges by providing a portable training tool that can be\ninstalled anywhere and anytime to provide “just in time”\ntraining. fig. 1 includes a image of the ssrms on the iss.\nastronauts operate the ssrms from a robotic workstation\nlocated inside one of the iss compartments. fig. 1 also\nshows the workstation which has an interface with three\nmonitors, each of which can be connected to any of the 14\ncameras placed at strategic locations on the exterior of the\niss. roman tutor’s user interface in fig. 2 includes the most\nimportant features of the robotic workstation.\nthe ssrms is a key component of the iss and is used in\nthe assembly, maintenance, and repair of the station, andalso for moving payloads from visiting shuttles. operators\nmanipulating the ssrms on orbit receive support from\nground operations. part of this support consists of visualiz-\ning and validating maneuvers before they are actually\ncarried out on the iss. operators have in principle\nrehearsed the maneuvers many times on the ground prior\nto the mission, but unexpected changes are frequent during\nthe mission. in such cases, ground operators may have to\ngenerate 3d animations for the new maneuvers and upload\nthem to the operator on the station. so far, the generation of\nthese 3d animations are done manually by computer\ngraphic programmers and thus are very time consuming.\nssrms can be involved in various tasks on the iss,\nincluding moving a load from one place of the station to\nanother, inspecting the iss structure (using a camera on the\narm’s end effector) and making repairs. these tasks must be\ncarried out very carefully to avoid collisions with the iss\nstructure and to maintain safety-operating constraints on\nthe ssrms (such as avoiding self-collisions and singula-\nrities). at different phases of a given manipulation, the\nastronaut must choose a setting of cameras that provides\nhim with the best visibility while maintaining awareness of\nhis progress on the task. thus, astronauts are trained not\nonly to operate the arm itself, but also to recognize visual\ncues on the station that are crucial in mentally reconstruct-\ning the actual working environment from the partial and\nrestricted views provided by the three monitors, and to\nselect cameras depending on the task and other parameters.\none challenge in developing a good training simulator is,\nof course, to build it so that one can reason about it. this is\neven more important when the simulator is built for training\npurposes [1]. until now, simulation-based tutoring is\nieee transactions on learning technologies, vol. 5, no. 1, january-march 2012 11\n.k. belghith and f. kabanza are with the department of computer science,\nuniversity of sherbrooke, sherbrooke, qc j1k 2r1, canada.\ne-mail: {khaled.belghith, kabanza}@usherbrooke.ca.\n.r. nkambou is with the department of computer science, university of\nquebec at montreal, 201, av. pr\nzsident-kennedy, montreal, qc h2x 3y7,\ncanada. e-mail: nkambou.roger@uqam.ca.\n.l. hartman is with the canadian space agency, 6767 airport rd.,\nst-hubert, qc j3y 8y9, canada. e-mail: leo.hartman@asc-csa.gc.ca.\nmanuscript received 30 may 2010; revised 16 nov. 2010; accepted 4 feb.\n2011; published online 30 mar. 2011.\nfor information on obtaining reprints of this article, please send e-mail to:\nlt@computer.org, and reference ieeecs log number tlt-2010-05-0083.\ndigital object identifier no. 10.1109/tlt.2011.19.\n1939-1382/12/$31.002012 ieee published by the ieee cs & es\n\npossible only if there is an explicit model or representation\nof the problem space associated with training tasks. the\nexplicit representation is required in order to track student\nactions, to identify if these actions are still on a path to a\nsolution and to generate relevant tutoring feedback [2], [3].\nknowledge and model tracing are only possible in these\nconditions [4]. it is not always possible to develop an explicit\ncomprehensive task structure in complex domains, espe-\ncially in domains where spatial knowledge is used, as there\nare many possible ways to solve a given problem. the robot\nmanipulation that roman tutor focuses on is an example of\nsuch a domain. for each robot manipulation task, there is a\ncombinatorial explosion of possible solutions for moving\nssrms from one place to another in the iss environment.\nsuch domains has been identified as “ill-structured” [5], [6].\nconventional tutoring approaches such as model-tra-\ncing [7] or constraint-based modeling [8] are very limited\nwhen applied on “ill-structured” domains. a model-\ntracing approach consists of comparing a predefined task\nmodel with a student’s solution. in the context of robot\nmanipulations, because of the infinity of solutions we have\nassociated with each task, designing a task model by hand\nbecomes practically infeasible. applying a constraint-based\nmodeling approach in the context of robot manipulations\nwill also face the same kind of limitations. here, identify-\ning the constraints associated with robot manipulation\ntasks can be difficult and very time consuming. since a\nhuge number of constraints is required to achieve an\nadequate level of tutoring assistance [6], the approach\nbecomes impractical.\nto overcome these limitations, we propose a solution to\nthis issue by integrating a sophisticated path planner\nfadprm [9] as a domain expert system to support spatial\nreasoning within the simulator and make model tracing\ntutoring possible without any explicit task structure.\nflexible anytime dynamic prm path planner (fadprm)\nis an extension to the prm planning framework [10] to\nhandle regions to which we assign preferences within\ncomplex workspaces. by being flexible in this way,\nfadprm not only computes collision free paths but also\ncapable of taking into account the placement of cameras on\nthe iss, the lighting conditions and other safety constraints\non operating the ssrms. this allows the generation of\ncollision-free trajectories in which the robot stays within\nregions visible through cameras and in which the manip-\nulation is, therefore, safer and easier. fadprm also\nimplements a dynamic strategy to adapt efficiently to\ndynamic changes in the environment and replan on the fly\nby exploiting results from previous planning phases.fadprm also implements an anytime strategy to provide\na correct but likely suboptimal solution very quickly and\nthen incrementally improve the quality of this solution if\nmore planning time is allowed.\nroman tutor uses the different capabilities implemented\nwithin the fadprm path planner to provide useful\nfeedback to a student operating the ssrms simulation. to\nillustrate, when a student is learning to move a payload\nwith the robot, roman tutor invokes the fadprm path-\nplanner periodically to check whether there is a path from\nthe current configuration to the target and provides feed-\nback accordingly. by using fadprm as a robot manipula-\ntion domain expert, we follow an “expert system approach”\nto support the tutoring process within roman tutor. this\napproach has proven successful and has been used within\ndifferent well-known intelligent tutoring systems such as\nsophie i [11] and guidon [12]. but in our case, we are\napplying it in the context of robot manipulations, an “ill-\nstructured” domain.\nwe also developed within roman tutor an automatic\ntask demonstration generator (atdg) [13], which gener-\nates 3d animations that demonstrate how to perform a\ngiven task with the ssrms. the atdg is integrated with\nthe fadprm path planner and can contribute to ground\nsupport of ssrms operations by generating useful task\ndemonstrations on the fly that help the student carry out\nhis tasks. atdg includes a component based on tlplan\n[14] for camera planning and uses linear temporal logic\n(ltl) as the language for specifying cinematographic\nprinciples and filming preferences. a robot trajectory is\nfirst generated by fadprm and tlplan is then called to\nfind the best sequence of camera shots following the robot\non its path.\nin the next section, we start by presenting fadprm and\natdg in detail. we then describe roman tutor’s internal\narchitecture and outline its basic functionalities. after\nenumerating the tasks on which a student is trained within\nroman tutor, we describe the approaches followed to\nprovide the tutoring assistance. in a following section, we\nshow how the use of fadprm as a domain expert within\nthe simulator helped in providing very relevant tutoring\nfeedback to the student. we finally conclude with a\ndiscussion on related work.\n12 ieee transactions on learning technologies, vol. 5, no. 1, january-march 2012\nfig. 1. ssrms on the iss (left) and the robotic workstation (right).\nfig. 2. roman tutor interface.\n\n2 fadprm pathplanner\nin its traditional form, the path planning problem is to plan\na path for a moving body (typically a robot) from a given\nstart configuration to a given goal configuration in a\nworkspace containing a set of obstacles. the basic constraint\non solution paths is to avoid collision with obstacles, which\nwe call hereby a hard constraint. there exist numerous\napproaches for path planning under this constraint [10],\n[15], [16], [17], [18]. in order to take into account the\nvisibility constraints we have in the ssrms environment,\nwe developed a new class of flexible path planners\nfadprm [9] able to express and take into account\npreferences in the navigation of the robot within very\ncomplex environments. in addition to the obstacles the\nrobot must avoid, our approach takes account of desired\nand undesired (or dangerous) zones. this will make it\npossible to take into account the placement of cameras on\nthe station. thus, our planner will try to keep the robot in\nzones offering the best possible visibility of progress on the\ntask while trying to avoid zones with reduced visibility.\nthe robot free workspace is segmented into zones with\neach zone having an associated degree of desirability (dd),\nthat is, a real number in the interval [0 1], depending on the\ntask, visual cue positions, camera positions, and lighting\nconditions. the closer the dd is to 1, the more the zone is\ndesired. safe corridors are zones with dd near to 1, whereas\nunsafe corridors are those with dd in the neighborhood of 0.\na zone covering the field of view of a camera will be\nassigned a high dd and will have a cone shape; whereas, a\nzone with very limited lighting conditions will be con-\nsidered as an nondesired zone with a dd near 0 and will\ntake an arbitrary polygonal shape. fig. 3 illustrates a\ntrajectory of the ssrms going through three cameras fields\nof view (three cones) and avoiding a nondesired zone\n(rectangular box).\nfor efficient path planning, we preprocess the robot\nworkspace into a roadmap of collision-free robot motions in\nregions with highest desirability degree. more precisely, the\nroadmap is a graph such that every node n in the graph is\nlabeled with its corresponding robot configuration n.q. and\nits degree of desirability n.dd, which is the average of dd of\nzones overlapping with n.q. an edge (n, n’) connecting two\nnodes is also assigned a dd equal to the average of dd of\nconfigurations in the path segment (n.q, n’.q). the dd of apath (i.e., a sequence of nodes) is an average of dd of\nits edges.\nfollowing probabilistic roadmap methods (prm) [19],\nwe build the roadmap by picking robot configurations\nprobabilistically, with a probability that is biased by the\ndensity of obstacles. a path is then a sequence of collision\nfree edges in the roadmap, connecting the initial and goal\nconfiguration. following the anytime dynamic a\n(ad)\napproach [20], to get new paths when the conditions\ndefining safe zones have dynamically changed, we can\nquickly replan by exploiting the previous roadmap. on the\nother hand, paths are computed through incremental\nimprovements so the planner can be stopped at anytime to\nprovide a collision-free path (i.e., anytime after the first such\npath has been found) and the more time it is given, the more\nthe path is optimized to move through desirable zones.\nfadprm works as follows: the input is an initial\nconfiguration, a goal configuration, a 3d model of obstacles\nin the workspace, a 3d specification of zones with\ncorresponding dd, and a 3d model of the robot. given\nthis input:\n.to find a path connecting the initial and goal\nconfigurations, we search backward from the goal\ntoward the initial (current) robot configuration.\nbackward search instead of forward search is done\nbecause the robot moves and, hence, its current\nconfiguration is not in general the initial configura-\ntion; we want to recompute a path to the same goal\nwhen the environment changes before the goal\nis reached.\n.a probabilistic queue open contains nodes of the\nfrontier of the current roadmap (i.e., nodes are\nexpanded because they are new or because they\nhave previously been expanded but are no longer up\nto date w.r.t. to the desired path) and a list closed\ncontains nonfrontier nodes (i.e., nodes already\nexpanded).\n.search consists of repeatedly picking a node from\nopen, generating its predecessors and putting the\nnew ones or out of date ones in open.\n.the density of a node is the number of nodes in the\nroadmap with configurations that are a short\ndistance away (proximity being an empirically set\nparameter, taking into account the obstacles in an\napplication domain). the distance estimate to the\ngoal takes into account the node’s dd and the\neuclidean distance to the goal. a node n in open\nis selected for expansion with probability propor-\ntional to\nð1Þ=densityðnÞþgoaldistance\nestimateðnÞwith01:\nthis equation implements a balance between fast-\nsolution search and best-solution search by choosing\ndifferent values for. withnear to 0, the choice of\na node to be expanded from open depends only on\nthe density around it. that is, nodes with lower\ndensity will be chosen first, which is the heuristic\nused in traditional prm approaches to guarantee the\nbelghith et al.: an intelligent simulator for telerobotics training13\nfig. 3. ssrms going through three different cameras fields of view\n(cones) and avoiding a nondesired zone (rectangular box).\n\ndiffusion of nodes and to accelerate the search for a\npath [19]. asapproaches 1, the choice of a node to\nbe expanded from open will rather depend on its\nestimated distance to the goal. in this case, we are\nseeking optimality rather than the speed of finding a\nsolution.\n.to increase the resolution of the roadmap, a new\npredecessor is randomly generated within a small\nneighborhood radius (that is, the radius is fixed\nempirically based on the density of obstacles in the\nworkspace) and added to the list of successors in the\nroadmap generated so far. the entire list of\npredecessors is returned.\n.collision is delayed: detection of collisions on the\nedges between the current node and its predecessors\nis delayed until a candidate solution is found; if\nthere is a collision, we backtrack. collisions that\nhave already been detected are stored in the road-\nmap to avoid doing them again.\n.the robot may start executing the first path found.\n.concurrently, the path continues being improved by\nreplanning with an increased value of.\n.changes in the environment (moving obstacles or\nchanges in dd for zones) cause updates of the\nroadmap and replanning.\nthe calculation of a configuration dd and a path dd is a\nstraightforward extension of collision checking for config-\nurations and path segments. for this, we customized the\nproximity query package (pqp) [21]. the 3d models for the\niss, the ssrms, and zones are implemented using a\ncustomization of silicon graphics’ open inventor. the\nrobot is modeled using motion planning kit (mpk), that\nis, an implementation of sanchez and latombe’s prm\nplanner [19].\n3theautomatictaskdemonstration\ngenerator\nthe automatic task demonstration generator [13] takes as\ninput a start and a goal configuration of the ssrms. atdg\nwill generate a movie\n1demonstration of the required\nmanipulations that bring the ssrms from the start config-\nuration to the goal configuration. the top figure in fig. 4\nshows the internal architecture of the atdg. the bottom\none shows the different steps the data go through in order\nto transform the two given configurations into a complete\nmovie demonstration.\nfirst, atdg calls the fadprm path planner to generate\na collision free path between the two given configurations.\nthe path is then passed to the trajectory parser which\nseparates it into categorized segments. this will turn the\ncontinuous trajectory into a succession of scenes, where\neach scene can be filmed by a specific group of idioms. an\nidiom is a succession of shots that represents a stereotypical\nway to film a scene category. the parser looks for\nuniformity in the movements of the ssrms to detect and\nrecognize the category of scenes. once the path is parsed, acall is made to the camera planner tlplan to find the best\nshots that best convey each scene, while making sure the\nwhole is pleasing and comprehensive.\nthe use of tlplan as a camera planner within atdg\nprovides two advantages. first, linear temporal logic, the\nlanguage used by tlplan is more expressive, yet with a\nsimpler defined semantics, than previous camera planning\nlanguages such as dccl [22]. for instance, we can express\narbitrary temporal conditions about the order in which\nobjects should be filmed, which objects should remain in the\nbackground until some condition become true, and more\ncomplex constraints that the ltl language can express.\nsecond, tlplan is more powerful than other camera\nplanners presented in the literature such as [22], [23], [24],\n[25] because with tlplan, ltl shot composition rules\nprovide a search pruning capability. in atdg, each shot in\nthe idiom is distinguished by three key attributes: shot type,\ncamera placement mode, camera zooming mode.\n.shot types: five shot types are currently defined in\nthe atdg system: static, goby, pan, track, and pov.\na static shot is done from a static camera when the\nrobot is in a constant position or moving slowly. a\ngoby shot has the camera in a static position\nshowing the robot in movement. for a pan shot,\nthe camera is in a static position but doing\nincremental rotations following the movement of\nthe robot. a track shot has the camera following the\nrobot and keeping a constant position relative to it.\nfinally, the pov shot has the camera placed directly\non the ssrms, moving with the robot.\n.camera placements: for each shot type, the camera\ncan be placed in five different ways according to\nsome given line of interest: external, parallel,\ninternal, apex, and external ii. currently, we take\nthe trajectory of the robot’s center of gravity as the\nline of interest which allows filming of a number\nof many typical maneuvers. for larger coverage\n14 ieee transactions on learning technologies, vol. 5, no. 1, january-march 2012\nfig. 4. atdg architecture.\n1. this paper has three supplemental movie files, which can be found on\nthe computer society digital library at http://doi.ieeecomputersociety.\norg/10.1109/tlt.2011.19.\n\nof maneuvers, additional lines of interest will be\nadded later.\n.zoom modes: for each shot type and camera\nplacement, the zoom of the camera can be in five\ndifferent modes: extreme close up, close up,\nmedium view, full view, and long view.\nfig. 5 shows an idiom illustrating the anchoring of a new\ncomponent on the iss. it starts with a track shot following\nthe robot while moving on the truss. then, another track\nshot follows that shows the rotation of one joint on the robot\nto align with the iss structure. and finally there is a static\nshot focusing on the anchoring operation. in tlplan, idioms\nare specified in the planning definition language (pddl\n3.0). intuitively, a pddl operator specifies preferences\nabout shot types in time and in space depending on the\nrobot maneuver. parsing the trajectory of the robot with the\nsuccessive scenes performed, tlplan will try to find a\nsuccession of shots that captures the best possible idioms.\ntlplan also takes into account cinematic principles to\nensure consistency of the resulting movie. idioms and\ncinematic principles are in fact encoded in the form of\ntemporal logic formulas within the planner. tlplan uses\nalso an occlusion detector to make sure the ssrms is visible\nall the time. once tlplan is done, we are left with a list of\nshots that is passed to the rendering system to create the\nanimation. the renderer uses both the shots given by\ntlplan and the ssrms trajectory in order to position the\ncameras in relation with the ssrms, generating the final\ntask demonstration.\nfor each ssrms movement type (or scene), we have\nseveral idioms (from 6 to 10 in the current implementation)\nand each idiom is defined by taking into account the\ncomplexity of the movement, the geometry of the iss, the\nvisual cues on the iss, and the preferences of the viewer.\nfor example, if the ssrms and the mobile base are moving\nalong the main truss of the iss, it is important that the\ncamera shows not only the entire arm but also some visual\ncues on the iss so the operator can get a sense of situational\nawareness for the relocation of the base of the arm.\nconsequently, the idioms for this manipulation will involve\nshots with a full or long view zoom. in contrast, move-\nments involving the end effector require a high precision, so\nan extreme close up zoom will be involved. some of these\nparameters can also be set directly by the user’s preferences.\nthe user can choose, for example, to always prefer a precise\nset of cameras to use for the filming. the user can also\nchoose some parts of the ssrms the film should focus on\nthe more possible.\n4romantutorarchitecture andbasic\nfunctionalities\n4.1 architecture and main components\nroman tutor works with any robot manipulator provided a\n3d model of the robot and its workspace are specified.\nroman tutor’s architecture includes the following compo-\nnents (fig. 6): the graphic user interface, the state reflector,\nthe fadprm path planner, the automatic task demonstra-\ntion generator, the tutoring module and the simulator core\nwith several third-party libraries: proximity query package\n[21], open inventor from silicon graphics, and motion\nplanning kit [19].\nas shown in fig. 2, roman tutor’s user interface has\nthree screens (for the three monitors). the keyboard is used\nto operate the robot (the ssrms in our case). in command\nmode, one controls the joints directly; in automatic mode,\none moves the end effector, small increments at a time,\nrelying on inverse kinematics to calculate the joint rotations.\nin fig. 2, different cameras are selected, displaying the same\nrobot configuration from different viewpoints. the per-\nspective camera (on the left) can inspect the entire iss 3d\nmodel. it is used in training tasks aimed at helping a\nstudent to develop a mental 3d model of the iss even\nthough there is no such camera on the iss. normal training\nuses small physical models of the iss for the same purpose.\nin roman tutor students could carry out several kinds of\ntraining tasks that we describe more formally in the next\nsection. the state reflector periodically updates the\nstudent’s actions (i.e., keyboard inputs) and their effects\non the iss environment (robot configuration, cameras\nmapped to the monitors, their view angles, and the\noperation mode). it also monitors lighting conditions.\n4.2 training tasks\ntraining tasks can be classified as open, recognition,\nlocalization, or robot manipulation. open tasks are those\nin which the student interacts with the simulator, without\nany formally set goal, with minimal assistance configured\nin the system’s preferences (e.g., collision warning and\navoidance). recognition tasks train to recognize the\ndifferent elements in the workspace. an example is to\nshow a picture of an element of the iss and ask the student\nto name it and describe its function. localization tasks train\nto locate visual cues or iss elements and to relate them\nbelghith et al.: an intelligent simulator for telerobotics training15\nfig. 5. idiom to film the ssrms anchoring a new component on the iss.\nfig. 6. roman tutor architecture.\n\nspatially to other elements. an example is to show a picture\nof a visual cue and ask the student to make it visible on the\nscreen using an appropriate selection of cameras; or we can\nask to name elements that are above another element shown\non the screen.\nrobot manipulation tasks deal with moving the manip-\nulator (avoiding collision and singularities, using the\nappropriate speed, switching cameras as appropriate, and\nusing the right operation mode at different stages),\nberthing, or mating. an illustration is to move the arm\nfrom one position to another, with or without a payload.\nanother example is to inspect an indicated component of\nthe iss using a camera on the end effector. these tasks\nrequire the student to be able to define a corridor in a free\nworkspace for a safe operation of the robot and follow it.\nthe student must do this based on the task, the location of\ncameras and visual cues, and the current lighting condi-\ntions. therefore localization and navigation are important\nin robot operations. robot manipulation tasks are made\nmore or less unpredictable by dynamically changing the\nlighting conditions, thus requiring the revalidation of\nsafe corridors.\n4.3 tutoring approaches in roman tutor\nthe feedback generator inside the tutoring module\n(fig. 6) periodically checks the current state to trigger\nfeedback to the student, using rules that are precondi-\ntioned on the current state information and the current\ngoal. for the case of open, recognition and localization\ntasks, these rules are “pure domain-dependent pedagogical\nrules” related to task models designed by hand. for robot\nmanipulation tasks with a goal, they are generic pedago-\ngical rules. feedback rules take into account how long the\nstudent has been trying on a subtask and how good or bad\nhe is progressing on it.\nin the context of open, recognition, and localization\ntasks, providing tutoring assistance seems straight for-\nward. the domain knowledge is well defined: what\nelement or cue of the iss to recognize or to localize?\nwhat camera to choose and when?, etc. here, we follow a\nmodel-tracing approach and define for each category of\ntasks a well structured task model to support the tutoring\nprocess. task models are designed by hand starting from\nrecommendations provided by human experts and are\nstructured in the form of a graph encoding if-then rules.\nthe feedback generator uses the predefined task graphs\nto validate student actions, identify gaps and provide\nfeedback accordingly.\nas we stated previously in an early section, the domain\nof robot manipulations is an “ill-structured” domain where\nclassical tutoring approaches start to loose efficiency and\nshow limitations. to overcome these limitations, we choose\nto follow an “expert system approach” and use the\nfadprm path planner as a domain expert in our system\nto support the tutoring process. in the context of robot\nmanipulation tasks, the feedback generator evaluates\nstudent actions by comparing it to the optimal solutions\nfound by fadprm and provides useful feedback accord-\ningly. the tutoring process that uses fadprm as an expert\nof the domain knowledge is described in more details in the\nnext section.one of the very important early results in intelligent\ntutoring research is the importance of the cognitive fidelity\nof the domain knowledge module. that is, it is important\nfor the tutor to reason about the problem in the same way\nthat humans do [26]. approaches for modeling a domain\nexpert within intelligent tutoring systems can be grouped\ninto three main categories: black box models, glass box\nmodels, and cognitive models [27]. the main difference\nbetween these models lies in the cognitive fidelity with\nwhich each model represents the expert domain knowledge.\na black box model describes problem states differently\nthan the student. the classic example of such a system is\nsophie i [11]. sophie i is a tutor for electronic trouble-\nshooting that used its expert system to evaluate the\nmeasurements students were making in troubleshooting a\ncircuit. the expert system made its decisions only by\nsolving sets of equations. a glass box model is an\nintermediate model that reasons in terms of the same\ndomain constructs as the human expert. however, the\nmodel reasons with a different control structure than the\nhuman expert. a classic example of such a system is\nguidon [12], a tutoring system for medical diagnosis. this\nsystem was built around mycin, an expert system for the\ntreatment of bacterial infections. a cognitive approach, on\nthe other hand, aims to develop a cognitive model of the\ndomain knowledge that captures the way knowledge is\nrepresented in the human mind in order to make the tutor\nrespond to problem-solving situations in a way very similar\nto humans. this approach, in contrast to the other\napproaches, has as an objective to support cognitively\nplausible reasoning [27]. a good example for such a\ntutoring system is sherlock [28], another practice\nenvironment for electronics troubleshooting. sherlock\nused a procedural domain knowledge representation based\non a cognitive analysis of human skill acquisition.\nat different phases of a given manipulation such as\nmoving a payload using the ssrms (fig. 5), the astronaut\nmust choose the best setting of cameras that provides him\nwith the best visibility while keeping a good appreciation of\nhis evolution in the task. thus, astronauts are trained not\nonly to manipulate the arm per se, but also to recognize the\nbest cameras suitable to film a given configuration of the\nssrms within the iss environment. here, astronauts need\nto mentally reconstruct the actual working environment\nfrom just three monitors each giving a partial and\nrestricted view.\nthe fadprm planner tries to keep the ssrms in zones\noffering the best possible visibility of the progress on the\ntask while trying to avoid zones with reduced visibility. by\ntaking into account the placement of cameras on the iss,\nfadprm reasons about actions in a way very similar to\nstudents: for each portion of the path, fadprm tries the\nenter the field of view of the best suitable camera available.\nthus, the use of fadprm as a domain expert in roman\ntutor results in a tutoring approach that lies in between a\nglass box approach and a cognitive approach. even if we\nare applying it in the context of an “ill-structured” domain,\nwe believe that this will guarantee good quality of the\ntutoring provided to the student, at least at the same level as\nthe one provided by a glass box model like guidon. in the\n16 ieee transactions on learning technologies, vol. 5, no. 1, january-march 2012\n\nnext section, we describe and evaluate the tutoring\nprovided using fadprm as an expert of the domain to a\nstudent working on robot manipulation tasks.\n5fadprm as adomainexpert inromantutor\nroman tutor initiates a robot manipulation task and\nmonitors the student’s progress toward accomplishing it.\nstudents begin the task and can ask roman tutor for help\nor for a recommendation about what to do next. students\ncan ask roman tutor about how to avoid a collision with a\nnearby obstacle, how to go to a desired location in the\nworkspace or how to go through a desired zone. in this\nsituation, the feedback generator calls the atdg (which\ncalls the fadprm planner) to compute and show a movie\nillustrating how to complete the manipulation task. if the\nobjective is to give the operator a sense of the task as he will\nbe seeing it from the command and control workstation,\nthen virtual camera positions will be selected from the 14\ncameras on the exterior of the iss. but if the objective is to\nconvey some cognitive awareness of the task, then virtual\ncameras are selected around the robot while moving on its\ntrajectory to best help the operator gain a maximal cognitive\nawareness. the objective is set manually by the learner\nthrough roman tutor’s interface to one of the following\nvalues “use cameras on iss” or “use virtual cameras.”\nusing the real time dynamic capability of the fadprm\npath planner, the feedback generator monitors the stu-\ndent’s activity in the state reflector to validate incremen-\ntally student’s action or sequence of actions, give\ninformation about the next relevant action or sequence of\nactions. the feedback generator regularly evaluates\nwhether the task can be completed from the current\nconfiguration of the manipulator and whether it can be\ncompleted efficiently. at the point at which it discovers that\nthe student would have to backtrack from the current\nposition or that achieving the task takes more than the time\nplanned for it, the feedback generator will intervene and\nbegin to show the student a more efficient trajectory. once a\nbetter initial trajectory has been demonstrated, the student\ncan take control and resume the task. this error-prompted\nturn taking repeats until the task is completed (fig. 7). we\nsee here the importance of having fadprm as a planner in\nour system to guide the operations by the student. by taking\ninto account the placement of the cameras on the station, weare assured that the plan shown to the student passes\nthrough zones that are visible from cameras placed in the\niss environment and can then be followed by the student.\nto evaluate the tutoring mechanics we implemented to\nsupport a student working on robot manipulation tasks, we\ncompare the types of feedback we provide in our applica-\ntion to those provided by a classic intelligent tutoring\nsystem sherlock [28] that is known to be efficient.\nsherlock is a practice environment for electronics\ntroubleshooting and provides advice on problem solving\nsteps upon student request. four types of feedback are\navailable [26]:\n1.advice on what test action to carry out and how,\n2.advice on how to read the outcome of the test,\n3.advice on what conclusion can be drawn from the\ntest, and\n4.advice on what option to pursue next.\nas described earlier, our “fadprm as a domain expert”\ntutoring approach provides feedback not only upon request\nbut also intervenes automatically when it detects errors or\ndifficulties experienced by the student. different types of\nfeedback are also available:\n1.advice on what current action (or manipulation) to\nexecute and how by showing a valid path to the\ncurrent goal or by showing a movie computed\nwith atdg;\n2.advice on how to avoid errors while progressing on\na task by showing paths that avoid a nearby\nobstacle or by showing movies recorded from the\nmost useful cameras.\n3.advice on what conclusion can be drawn from the\nerrors made by detecting incorrect choices made by\nthe student and by proposing the right path to\nfollow, and\n4.advice on what future action or sequence of actions\nto pursue next in order to reach the goal.\nfor the feedback of types 2 and 3, the current trace of\nactions (robot manipulations and camera selections) made\nby the learner in order to reach the current configuration is\nsaved. a call is then made to fadprm and atdg to\nevaluate the current trace, to diagnosis and identify errors\nand propose improvements: better manipulations to do,\nbetter cameras to select, etc. the list of these improvements\nis then displayed to the learner with a video illustrating\nthem. the call to this diagnosis loop is made if requested by\nthe learner after accessing the “ask menu” within the\nsimulator interface or every time the system detects a\nnearing collision or a dangerous manipulation with the\nssrms too close to an obstacle on the iss. in the current\nimplementation of roman tutor, immediate feedback is\nprovided to the learner every time he attempts to execute a\ndangerous path. also, the feedback provided always\nconsists in showing the correct solution to the learner based\non the diagnosis made. hence, the tutoring behavior inside\nroman tutor remains limited. this issue will be addressed\nin future versions of roman tutor in order to investigate\nthe use of different levels of intervention. depending on the\nuser’s skills, his preferences and on the task being executed,\nan appropriate level of intervention should be applied.\nbelghith et al.: an intelligent simulator for telerobotics training17\nfig. 7. roman tutor showing a robot trajectory to the student.\n\nin summary, the types of feedback provided by roman\ntutor are quite similar to those provided by sherlock.\nthe main difference is in the level of detail of the feedback\nprovided. since we are working in an ill-defined domain,\nthe feedback provided by fadprm remains less expressive\nand not as precise as the feedback provided by sherlock.\nthis issue can be addressed if the problem space generated\nby fadprm can be manually edited to add, where needed,\nmore information that can be used to enhance the quality\nand the precision of the tutoring. conversely, one of the\nmain advantages of roman tutor is that, it operates in a\ndomain where a cognitive approach like the one used\nwithin sherlock cannot work due to the ill definess of\nthe domain. in this perspective, by using fadprm as\nexpert of the domain, we succeeded in achieving a good\nlevel of quality for the tutoring.\n6conclusion\nin this paper, we presented a real-time flexible approach for\nrobot path planning called fadprm and showed how it\ncan be used efficiently to provide very helpful feedback to a\nstudent on a robot manipulation training simulator.\nfadprm supports spatial reasoning and makes model\ntracing tutoring possible without any explicit task structure.\nby using fadprm as a domain expert within the simulator,\nwe showed how to achieve a high-quality level for the\ntutoring assistance without planning in advance what\nfeedback to give to the student and without creating a\ncomplex task graph to support the tutoring process.\nwe also detailed the architecture of the intelligent\ntraining simulator roman tutor in which fadprm is\nintegrated. among other components, roman tutor con-\ntains an automatic task demonstration generator used for\nthe on the fly generation of useful task demonstrations\nthat help the student carry on his manipulation tasks on\nthe simulator.\nroman tutor’s benefits to future training strategies are\n1) the simulation of complex tasks at a low cost (e.g., using\ninexpensive simulation equipment and with no risk of\ninjuries or equipment damage) and 2) the installation\nanywhere and anytime to provide “just in time” training.\ncrew members would be able to use it onboard the iss, for\nexample, to study complex maintenance or repair opera-\ntions. for very long missions, they would be able to use it to\ntrain regularly in order to maintain their skills. in particular\nroman tutor is able to generate as many training examples\nas the student wants. this capacity provides important\nlearning challenges and opportunities that are not possible\nwith the current system based on a fixed set of manually\ngenerated examples. although motivated by the ssrms\napplication, roman tutor with its innovative components\n(fadprm and atdg) remains applicable to any other\ntelerobotics system application.\nalthough roman tutor brings some interesting solutions\nfor training in highly complex environments, a number of\nenhancements and extensions are still possible. first of all,\nits pedagogical value has to be evaluated. we are negotiat-\ning an evaluation of the system in collaboration with the\ncanadian space agency. second, the diagnosis process can\nbe improved by explicitly connected declarative knowledgeof the domain to the paths provided by fadprm. this will\nallow a deep knowledge tracing, thus a fine grained\ncognitive diagnosis.\nacknowledgments\nthe work presented herein was supported by the natural\nsciences and engineering research council (nserc) of\ncanada.\nreferences\n[1] k. forbus, “articulate software for science and engineering\neducation,”smart machines in education: the coming revolution in\neducational technology,vol. 1, no. 1, pp. 235-267, 2001.\n[2]r. angros, w. johnson, j. rickel, and a. scholer, “learning\ndomain knowledge for teaching procedural skills,”proc. first\nint’l conf. autonomous agents and multiagent systems (aamas),\npp. 1372-1378, 2002.\n[3]k. vanlehn, “the advantages of explicity representing problem\nspaces,”proc. ninth int’l conf. user modeling (um),p. 3, 2003.\n[4]r. crowley, e. legowski, o. medvedeva, e. tseytlin, e. roh, and\nd. jukic, “an its for medical classification problem-solving:\neffects of tutoring and representations,”proc. 12th int’l conf.\nartificial intelligence in education,pp. 192-199, 2005.\n[5]h. simon, “the structure of ill structured problems,”artificial\nintelligence,vol. 4, no. 3, pp. 181-201, 1973.\n[6]p. fournier-viger, r. nkambou, and e.m. nguifo, “supporting\ntutoring services in ill-defined domains,”advances in intelligent\ntutoring systems,nkambou et al., eds., springer, 2010.\n[7]k. koedinger, j. anderson, w. hadley, and m. mark, “intelligent\ntutoring goes to school in the big city,”int’l j. artificial\nintelligence in education,vol. 8, no. 9, pp. 30-43, 1997.\n[8]a. mitrovic, m. mayo, p. suraweera, and b. martin, “contraint-\nbased tutors: a success story,”proc. 14th int’l conf. industrial,\neng. and other applications of applied intelligent systems (iea/aie),\npp. 931-940, 2001.\n[9]k. belghith, f. kabanza, l. hartman, and r. nkambou, “anytime\ndynamic path-planning with flexible probabilistic roadmaps,”\nproc. ieee int’l conf. robotics and automation (icra),pp. 2372-\n2377, 2006.\n[10]l. kavraki, p. svestka, j.c. latombe, and m. overmars,\n“probabilistic roadmaps for path planning in high dimensional\nconfiguration spaces,”ieee trans. robotics and automation,\nvol. 12, no. 4, pp. 566-580, aug. 1996.\n[11]j. brown, r. burton, and f. zdybel, “a model-driven question-\nanswering system for mixed initiative computer-assisted\ninstruction,”ieee trans. systems, man and cybernetics,vol. 3,\nno. 3, pp. 248-257, may 1973.\n[12]w. clancey,tutoring rules for guiding a case method dialogue,\nd. sleeman and j. brown, eds. academic, 1982.\n[13]f. kabanza, k. belghith, p. bellefeuille, b. auder, and l. hartman,\n“planning 3d task demonstrations of a teleoperated space robot\narm,”proc. 18th int’l conf. automated planning and scheduling\n(icaps),pp. 164-173, 2008.\n[14]f. bacchus and f. kabanza, “using temporal logics to express\nsearch control knowledge for planning,”artificial intelligence,\nvol. 116, nos. 1/2, pp. 123-191, 2000.\n[15]h. choset, k. lynch, s. hutchinson, g. kantor, w. burgard, l.\nkavraki, and s. thrun,principles of robot motion: theory,\nalgorithms, and implementations.mit , 2005.\n[16]m. likhachev, d. ferguson, g.j. gordon, a. stentz, and s. thrun,\n“anytime search in dynamic graphs,”artificial intelligence,\nvol. 172, no. 14, pp. 1613-1643, 2008.\n[17]m. saha, j. latombe, y. chang, and f. prinz, “finding narrow\npassages with probabilistic roadmaps: the small-step retraction\nmethod,”j. autonomous robots,vol. 19, no. 3, pp. 301-319, 2005.\n[18]s.m. lavalle,planning algorithms.cambridge univ., 2006.\n[19]g. sanchez and j. latombe, “a single-query bi-directional\nprobabilistic roadmap planner with lazy collision checking,”\nproc. 10th int’l symp. robotics research (isrr),pp. 403-417, 2001.\n[20]m. likhachev, d.i. ferguson, g.j. gordon, a. stentz, and s. thrun,\n“anytime dynamic a\n: an anytime, replanning algorithm,”\nproc. 15th int’l conf. automated planning and scheduling (icaps),\npp. 262-271, 2005.\n18 ieee transactions on learning technologies, vol. 5, no. 1, january-march 2012\n\n[21]e. larsen, s. gottshalk, m. lin, and d. manocha, “fast proximity\nqueries with swept sphere volumes,”proc. ieee int’l conf.\nrobotics and automation (icra),pp. 3719-3726, 2000.\n[22]d. christianson, s. anderson, l. he, d. salesin, d. weld, and\nc.m.f., “declarative camera control for automatic cinemato-\ngraphy,”proc. 13th nat’l conf. artificial intelligence (aaai/iaai),\npp. 148-155, 1996.\n[23]w. bares, l. zettlemoyer, d. rodriguez, and j. lester, “task-\nsensitive cinematography interfaces for interactive 3d learning\nenvironments,”proc. third int’l conf. intelligent user interfaces\n(iui),pp. 81-88, 1998.\n[24]d. friedman and y. feldman, “automated cinematic reasoning\nabout camera behavior,”j. expert systems with applications,\nvol. 30, no. 4, pp. 694-704, 2006.\n[25]a. jhala and r. young, “a discourse planning approach to\ncinematic camera control for narratives in virtual environ-\nments,”proc. 20th nat’l conf. artificial intelligence (aaai/iaai),\npp. 307-312, 2005.\n[26]a. corbett, k. koedinger, and j. anderson, “intelligent tutoring\nsystems,”handbook of human-computer interaction,m. helander,\nt.k. landauer, p. prabhu, eds., elsevier science, 1997.\n[27]r. nkambou, “modeling the domain: an introduction to the\nexpert module,”advances in intelligent tutoring systems,nkambou\net al., eds., springer, 2010.\n[28]a. lesgold, g. eggan, s. katz, and g. rao, “possibilities for\nassessment using computer-based apprenticeship environ-\nments,”cognitive approaches to automated instruction,j. regian\nand v. shute, eds., lawrence eribaum assoc., 1992.\nkhaled belghithreceived the electrical engi-\nneering diploma (d\0ˆ\nplome inge´\nnieur) from l’\necole\nnationale d’inge´\nnieurs de monastir, tunisia, in\n2002, the msc degree in computer science from\nthe university of quebec at montreal in 2004, the\nexecutive mba degree from the university of\nquebec at montreal in 2007, and the phd degree\nin computer science from the university of\nsherbrooke in june 2010. his thesis is about a\nsimulator prototype for telerobotics training to\ntrain astronauts on the manipulation of the canadian robot arm within\nthe international space station. he has worked since 2007 as an ai\nsoftware engineer at ubisoft. he took part in the development of several\ngames produced at ubisoft montreal’s studio.roger nkamboureceived the phd degree in\n1996 in computer science from the university of\nmontreal. he is currently a full professor of\ncomputer science at the university of quebec at\nmontreal and the director of the gdac labora-\ntory (http://gdac.dinfo.uqam.ca). he is also the\nchair of graduate studies (phd program in\ncognitive computing). his research interests\ninclude knowledge representation, intelligent\ntutoring systems, intelligent software agents,\nontology engineering, student modeling, and affective computing. he\nalso serves as a member of the program committees of the most\nimportant international conferences in artificial intelligence in education.\nfroduald kabanzais a professor of computer\nscience at the universite´\nde sherbrooke. his\nresearch concerns artificial intelligence (ai),\nmainly in the areas of automated planning, ai\narchitectures, intelligent decision support sys-\ntems, and intelligent tutoring systems. he has\nled various successful research projects on\nthese topics. he is currently developing ai\ntechniques with applications to training medical\nstudents on clinical diagnosis, training astro-\nnauts on robot manipulation, supporting the optimal prescription of\nantibiotics in hospitals, and controlling mobile robots. he founded\nmenya solutions, a company that offers software developments and\nservices in artificial intelligence (www.menyasolutions.com).\nleo hartmanreceived the phd degree in\ncomputer science from the university of\nrochester in 1990. his dissertation investi-\ngates the use of decision theory for allocating\ncomputational resources in deductive planning.\nafter a postdoc at the university of waterloo,\nhe joined the canadian space agency in 1993\nas a research scientist. his work there focuses\non computing, networking, and automation for\nspace missions.\nbelghith et al.: an intelligent simulator for telerobotics training19', 0, 'fdsew', 1, '2017-02-08', '', 'F', 'P', 57, 1, 0);
INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(17, 2, 'hss', '2017-02-08', 0, 0, 36, 10, 1, '1486554693.pdf', 91, 'sample pdf document\nrobert maron\ngrzegorz grudzi ´\nnski\nfebruary 20, 1999\n\n2\n\ncontents\n1 template\n5\n1.1 how to compile a .texle to a .pdfle\n. . . . . . . . . . . . .\n5\n1.1.1 tools\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n5\n1.1.2 how to use the tools\n. . . . . . . . . . . . . . . . . . . .\n5\n1.2 how to write a document\n. . . . . . . . . . . . . . . . . . . . . .\n6\n1.2.1 the main document\n. . . . . . . . . . . . . . . . . . . . .\n6\n1.2.2 chapters\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n6\n1.2.3 spell-checking\n. . . . . . . . . . . . . . . . . . . . . . .\n6\n1.3 l a\nt\ne x and pdfl\na\nt\ne x capabilities\n. . . . . . . . . . . . . . . . . . .\n7\n1.3.1 overview\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n1.3.2 l a\nt\ne x\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n1.3.3 pdfl a\nt\ne x\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n1.3.4 examples\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n3\n\n4\ncontents\n\nchapter 1\ntemplate\n1.1 how to compile a .texle to a .pdfle\n1.1.1 tools\nto process the les you (may) need:\n\npdflatex (for example from tetexpackage 0.9-6 , which you can\nget from\nred hat 5.2\n);\n\nacroread (a pdf viewer, available from\nhttp://www.adobe.com/\n);\n\nghostscript 5.10 (for example from\nred hat contrib\n) and ghostview\nor gv (from redhat linux);\n\nefax package could be useful, if you plan to fax documents.\n1.1.2 how to use the tools\nfollow these steps:\n1.\nput all source .texles in one directory, then chdir to the directory (or put\nsome of them in the l a\nt\ne xsearch path — if you know how to do this);\n2.\nrun “ pdflatex file.tex ” on the main le of the document three times\n(three — to prepare valid table of contents);\n3.\nto see or print the result use acroread(unfortunately some versions of\nacroread may produce postscript which is too complex), or\n5\n\n6\nchapter 1. template\n4.\nrun ghostscript : “gv file.pdf ” to display or:\n“gs -dnopause -sdevice=pswrite -q -dbatch -soutputfile=le.ps le.pdf ”\nto produce a postscript le;\n5.\nrun “ fax send phone-number file.ps ” as root to send a fax, or — if you\nknow how to do this — modify the faxscript to be able to fax .pdfles directly\n(you have to insert “ |%pdf*” somewhere. . . ).\n1.2 how to write a document\n1.2.1 the main document\nchoose the name of the document, say document. copytemplate.tex to\ndocument.tex , then edit it, change the title, the authors and set proper in-\nclude(s) for all the chapters.\n1.2.2 chapters\neach chapter should be included in the main document as a separate le. you can\nchoose any name for the le, but we suggest adding a sufx to the name of the\nmain le. for our example we use the le name document_chapter1.tex.\nfirst, copy template_chapter.tex todocument_chapter1.tex\nand add the line\n\\include{document_chapter1}\nin the document.tex , then editdocument_chapter1.tex , change the\nchapter title and edit the body of the chapter appropriately.\n1.2.3 spell-checking\ndo use a spell-checker, please!\nyou may also want to check grammar, style and so on. actually you should\ndo it (if you have enough spare time). but you mustcheck spelling!\nyou can use the ispellpackage for this, from within emacs, or from the\ncommand line:\nispell -t document_chapter1.tex\n\n1.3. l a\nt\nex and pdfl\na\nt\nex capabilities\n7\n1.3 l a\nt\ne x and pdfl\na\nt\ne x capabilities\n1.3.1 overview\nfirst you edit your source .texle. in l a\nt\ne x you compile it using the\nlatex\ncommand to a .dvile (which stands for device-independent). the .dvile\ncan be converted to any device-dependent format you like using an appropriate\ndriver, for example dvips.\nwhen producing .pdfles you should use pdflatex, which produces di-\nrectly .pdf les out of .texsources. note that in the .texle you may need\nto use some pdf specic packages.\nfor viewing .texles use your favourite text editor, for viewing .dviles\nunder x window system use xdvicommand, .psles can be viewed with gv\n(or ghostview ) and.pdf les with acroread ,gv orxpdf .\n1.3.2 l a\nt\ne x\na lot of examples can be found in this document. you should also print\n\ndoc/latex/general/latex2e.dvi and\n\ndoc/latex/general/lshort2e.dvi\nfrom your tetexdistribution (usually in\n\n/usr/share/texmf or\n\n/usr/lib/texmf/texmf ).\n1.3.3 pdfl a\nt\ne x\nconsult doc/pdftex/manual.pdf from yourtetexdistribution for more\ndetails. very useful informations can be found in the hyperrefandgraphics\npackage manuals:\n\ndoc/latex/hyperref/manual.pdf and\n\ndoc/latex/graphics/grfguide.dvi .\n1.3.4 examples\nreferences\nmimuw\n\n8\nchapter 1. template\nhyperlinks\nthis is a target.\nand this is a link.\ndashes, etc.\nthere are three kinds of horizontal dash:\n\n- (use inside words; for example “home-page”, “x-rated”)\n\n– (use this one between numbers; for example “pages 2–22”)\n\n— (use this one as a sentence separator — like here)\nnational characters\n\nó, é, í, . . .\n\nè, à, ì, . . .\n\nô, ê, . . .\n\nõ, ñ, . . .\n\nö, ë, . . .\n\nz\n\na, e\n\n, ø, ß\nthere are other ways to do this, see the documentation for inputencpack-\nage.\nreserved characters\nsome characters have some special meaning, thus cannot be entered in the usual\nway.\n\n$ & % # _ { }\n\nn\n\n˜ ˆ\n\n1.3. l a\nt\nex and pdfl\na\nt\nex capabilities\n9\nmath\n\n1 2\n, 12\nn\n, . . .\n\ni\n1 ,\ni\n2 n , . . .\n\n1\n2 , 2\nn\n2 \0 3, . . .\n\n , ,\r ,\n , . . .\n\n! ,) , ,6\n= ,2 ,?, . . .\n\np\n2 , . . .\n\n2 + 2 , . . .\nfor more examples and symbols see chapter 3 of lshort2e.dvi.\nfonts\n\nroman\n\nemphasis\n\nmedium weight — the default\n\nboldface\n\nupright\n\nslanted\n\nsans serif\n\ns m a l l c a p s\n\ntypewriter\n\nand sizes:\n–\ntiny\n–\nscriptsize\n–\nfootnotesize\n–\nsmall\n–\nnormalsize\n\n10\nchapter 1. template\n–\nlarge\n–\nlarge\n–\nlarge\n–\nhuge\n–\nhuge', 0, 'uyy', 10, '2017-02-08', '', 'F', 'P', 7, 7, 0),
(18, 3, 'csas', '2017-02-08', 0, 0, 21, 5, 3, '1486555150.pdf', 57, 'the p df9 95  s u it e  o f p ro ducts  -  p df9 95,  p dfe dit 9 95 , a n d s ig na tu re 99 5 -  is  a  c o m ple te  s o lu tio n fo r y o ur d ocu m ent p ublis h in g n ee ds. it \np ro vid es e ase  o f u se , fle xib ilit y  in  fo rm at,  a nd  in d ustr y -s ta nd ard  s e cu rit y - a nd a ll  a t n o  c o st to  y o u. \np df9 95 m ake s it  e a sy a nd  a ffo rd able  to  c re ate  p ro fe ssio nal- q u alit y  d o cu m en ts  in  th e p o pula r p d f file  fo rm at. i ts  e asy-to -u se  in te rfa ce  \nh elp s y o u to  c re a te  p d f file s b y s im ply  s e le ctin g t h e " p rin t"  c o m mand f r o m  a ny a pp lic a tio n,  c re atin g d ocu m ents  w hic h  c a n  b e v ie w ed \no n a ny c o m pute r w it h  a  p d f v ie w er. p df9 95 s u pp orts  n etw ork  file  s a vin g, f a st u se r s w it c h in g  o n x p , c it r ix /t erm in al  s erv e r, c u sto m  \np age s iz e s a nd la rg e fo rm at  p rin tin g . p df9 95 is  a  p rin te r d riv e r th at w ork s w it h  a ny p osts crip t to  p d f c o nve rte r. t he p df9 95  p rin te r \nd riv e r a nd a  fr e e c onve rte r a re  a va ila b le  fo r e a sy d ow nlo ad . \np dfe dit 9 95 o ffe rs  a  w ealt h  o f a ddit io na l  fu n ctio na lit y , s u ch  a s: c o m bin in g d o cu m en ts  in to  a  s in g le  p d f;  a uto m atic  lin k in se rtio n; \nh ie ra rc h ic a l  b ookm ark  in se rtio n ; p d f c o nve rs io n to  h tm l o r d o c ( te xt o nly ); in te gra tio n w it h  w ord  to olb ar w it h  a u to m atic  ta ble  o f \nc o nte nts  a nd lin k g enera tio n ; a u to atta ch  to  e m ail;  s ta tio ne ry  a n d s ta m pin g.  \ns ig natu re 99 5 o ffe rs  s ta te -o f- th e-a rt s e cu rit y  a n d e n cry p tio n t o  p ro te ct y o u r d ocu m ents  a n d a dd d ig it a l  s ig n atu re s. \n    \nt he p df9 9 5 s uit e  o ffe rs  t h e f o llo w in g f e a tu re s,  a ll a t n o c o st: \na uto m atic  in se rtio n o f e m bedde d lin ks \nh ie ra rc h ic a l  b ookm ark s  \ns upp ort fo r d ig it a l  s ig natu re s \ns upp ort fo r t rip le  d es e ncry p tio n \na ppe nd a nd d ele te  p d f p ages \nb atc h  p rin t fr o m  m ic ro so ft o ffic e  \na sia n a nd c yrillic  fo nts  \ni n te gra tio n w it h  m ic ro so ft  w ord  to olb ar \np d f s ta tio nery  \nc om bin in g m ult ip le  p d f''s  in to  a  s in gle  p d f \nt hre e a uto -n am e o ptio ns to  b yp ass s ave  a s d ia lo g \ni m posit io n o f d ra ft/ c onfid entia l  s ta m ps \ns upp ort fo r la rg e fo rm at a rc h it e ctu ra l  p rin tin g \nc onve rt p d f to  j p eg , t if f, b m p, p c x fo rm ats  \nc onve rt p d f to  h tm l a n d w ord  d o c c o nve rs io n \nc onve rt p d f to  te xt \na uto m atic  t able  o f c onte nts  g enera tio n \ns upp ort fo r x p f ast u se r s w it c h in g a nd m ult ip le  u se r \ns e ssio ns \ns ta nd ard  p d f e ncry p tio n ( re str ic te d p rin tin g, m odif y in g, \nc o pyin g te xt a nd im ag es) \ns upp ort fo r o ptim iz e d p d f \ns upp ort fo r c u sto m  p age s iz e s  o\nptio n to  a tta ch  p d fs to  e m ail  a fte r c re atio n  \na uto m atic  te xt s u m mariz a tio n o f p d f \nd ocu m ents  \ne asy in te gra tio n w it h  d ocu m ent m ana gem ent \na nd w ork flo w  s ys te m s \nn -u p p rin tin g \na uto m atic  p age n um berin g \ns im ple  p ro gra m mers  in te rfa ce  \no ptio n to  a uto m atic a lly  d is p la y p d fs a fte r \nc re atio n \nc usto m  r e siz in g o f p d f o utp ut \nc onfig ura ble  f ont e m bed din g \ns upp ort fo r c it r ix /t erm in al  s erv e r \ns upp ort fo r w in dow s 2 003 s erv e r \ne asy p s to  p d f p ro ce ssin g \ns pecif y  p d f d ocu m ent p ro pertie s \nc ontr o l  p d f o p enin g m ode \nc an b e c o nfig ure d to  a d d fu nctio nalit y  to  \na cro bat d is til le r \nf re e: c re ate s p d fs w it h out a nn oyin g \nw ate rm ark s \nf re e: f ully  fu nctio nal,  n ot a  tr ia l  a nd d oes n ot \ne xp ir e  \no ve r 5  m illio n s a tis fie d c u sto m ers  \no ve r 1 00 0 e nte rp ris e  c usto m ers  w orld w id e \n \np le ase  v is it u s a t w ww.p df9 95.c o m t o  l e arn  m ore . \n \nt his  d ocu m en t illu str a te s s e ve ra l  f e atu re s o f th e p df9 9 5 s uit e  o f p ro d ucts .\n\nappr o ved\nin tr o d uctio n\nt he v ir tu al r ea li t y m od elin g lan gu age (v rm l)is a la n gu ag e fo r desc rib in g m ulti -\np artic ip an t in te ra cti v e sim ula tio ns -- vir tu al w orld s netw ork ed via th e glo bal in te rn et an d\nh yp erlin ked with th e w orld w id e w eb .a ll asp ec ts of vir tu al w orld dis p la y , in te ra cti o n\na n d in te rn etw ork in g ca n be sp ecif ie d usin g vrm l.it is th e in te n tio n of its desig n ers th at\nv rm lbec o m eth e sta n dard la n gu ag e fo r in te ra ctiv e sim ula ti o n with in th e w orld w id e\nw eb .\nt he fir s t vers io n of v rm lall o w sfo r th e cre a tio n of vir tu al w orld s w it h li m ite d\ni n te ra ctiv e beh av io r. t hese w orld s ca n co nta in obje cts w hic h hav e hyp erli n ks to oth er\nw orld s, h tm ldocu m en ts or oth er vali d m im ety p es. w hen th e use r se le cts an obje c t\nw ith ahyp erlin k,th e ap pro pria te m im evie w er is la u nch ed .w hen th e use r se le cts a li n k\nt o av rm ldocu m en t fr o m with in aco rre ctl y co nfig u re d w w w bro w se r, a v rm l\nv ie w er is la u nch ed .t hus v rm lvie w ers are th e perf e c t co m pan io n ap plic a tio ns to\ns ta n dard w ww bro w se rs fo r nav ig atin g an d vis u aliz in g th e w eb .f utu re vers io ns of\nv rm lwill allo w fo r ric h er beh av io rs , in clu din g an im atio ns, m oti o n physic s an d re a l-\nt im em ulti - u se r in te ra cti o n.\nt his docu m en t sp ec if ie s th e fe atu re s an d sy n ta x of v ers io n 1.0 of v rm l.\nv rm lm is s io n sta te m en t\nt he his to ry of th e dev elo pm en t of th e in te rn et has had th re e dis tin ct phase s; fir s t, th e\nd ev elo pm en t of th e tc p/i p in fra str u ctu re w hic h all o w ed docu m en ts an d data to be sto re d\ni n apro x im ally in dep en den t w ay ; th at is , in te rn et pro vid ed ala y er of ab str a c ti o n betw ee n\nd ata se ts an d th e hosts w hic h m an ip ula te d th em .w hile th is ab str a cti o n was use fu l, it w as\na ls o co nfu sin g; w ith out an y cle ar se n se of "w hat w en t w here ", acc ess to in te rn et w as\nr e str ic te d to th e cla ss of sy so ps/n et su rfe rs w ho co uld m ain ta in in te rn al co gn itiv e m ap s of\nt h e data sp ac e.\nn ex t, t im bern ers -l ee ''s w ork at c er n ,w here he dev elo ped th e hyp erm ed ia sy ste m\nk no w n as w orld w id e w eb ,ad ded an oth er la y er of ab str a c ti o n to th e ex is tin g str u ctu re .\nt his ab str a c tio n pro vid ed an "a d dre ssin g" sc h em e, a uniq ue id en tif ie r (th e u niv ers a l\nr eso urc e loca to r), w hic h co uld te ll an yo ne "w here to go an d how to get th ere " fo r an y\np ie c e of data w ith in th e w eb .w hile use fu l, it la c k ed dim en sio nali ty ; th ere ''s no th ere\nt h ere w ith in th e w eb ,an d th e only ty p e of nav ig atio n perm is sib le (o th er th an su rfin g) is\nb y dir e c t re fe re n ce. in oth er w ord s, i can only te ll yo u how to get to th e v rm lforu m\nh om epag e by sa y in g, "h ttp ://w w w.w ir e d .c o m /" , w hic h is not hum an -c en te re d data . in\n\nappr o ved\nfa c t, i need to m ak e an effo rt to re m em ber it at all . s o,w hile th e w orld w id e w eb\np ro vid es a re tr ie v al m ec h an is m to co m ple m en t th e ex is ti n g sto ra g e m ech an is m ,it le a v es\na lo t to be desir e d ,parti c u la rly fo r hum an bein gs.\nf in ally , w em ove to "p erc ep tu aliz ed " in te rn etw ork s, w here th e data has been se n su aliz ed ,\nt h at is , re n dere d se n su ally . if so m eth in g is re p re se n te d se n su ally , it is possib le to m ak e\ns e n se of it. v rm lis an atte m pt (h ow su cc essfu l, only ti m ean d effo rt w il l te ll) to pla ce\nh um an s at th e cen te r of th e in te rn et, ord erin g its univ ers e to our w him s. in ord er to do\nt h at, th e m ost im porta n t sin gle ele m en t is a sta n dard th at defin es th e partic u la riti e s of\np erc e p tio n.v ir tu al r ealit y m odelin g lan gu ag e is th at sta n dard ,desig n ed to be a\nu niv e rs a l desc rip ti o n la nguage fo r m ult i- p artic ip ant sim ula ti o ns.\nt hese th re e phase s, sto ra g e, re tr ie v al, an d perc ep tu aliz ati o n are an alo go us to th e hum an\np ro cess of co nsc io usn ess, as ex pre ss e d in te rm sof se m an tic s an d co gn it iv e sc ie n ce .\ne ven ts occu r an d are re co rd ed (m em ory ); in fe re n ce s are dra w n fro m mem ory\n( a sso cia tio ns), an d fro m se ts of re la te d ev en ts , m ap s of th e univ ers e are cre a te d (c o gn iti v e\np erc ep tio n). w hat is im porta n t to re m em ber is th at th e m ap is not th e te rr it o ry , an d we\ns h ould av oid beco m in g tr a p ped in an y sin gle re p re se n ta ti o n or w orld -v ie w .a lth ough we\nn ee d to desig n to avo id dis o rie n ta ti o n,w esh ould alw ay s push th e en velo pe in th e kin ds\no f ex perie n ce w eca n brin g in to m an if e sta tio n!\nt his docu m en t is th e liv in g pro of of th e su cce ss of a pro cess th at w as co m mitt e d to bein g\no pen an d fle x ib le , re sp onsiv e to th e need s of a gro w in g w eb co m munit y . r ath er th an re -\ni n ven t th e w hee l, w ehav e ad ap te d an ex is tin g sp ecif ic atio n (o pen in ven to r) as th e basis\nf r o m whic h our ow n work ca n gro w ,sa v in g years of desig n work an d perh ap s m an y\nm is ta k es. n ow our re al w ork can beg in ; th at of re n derin g our noosp heric sp ace .\nh is to ry\nv rm lwas co nce iv ed in th e sp rin g of 1994 at th e fir s t an nual w orld w id e w eb\nc onfe re n ce in gen ev a, s w it z erla n d.t im bern ers -l ee an d dav e rag gett org an iz ed a\nb ir d s-o f- a -f ea th er (b o f) se ssio n to dis c u ss v ir tu al r ea li ty in te rfa ce s to th e w orld w id e\nw eb .s ev era l b o f att e n dees desc rib ed pro je cts alr e a d y underw ay to buil d th re e\nd im en sio nal gra p hic al vis u aliz atio n to ols w hic h in te ro pera te w ith th e w eb .a tte n dee s\na g re e d on th e need fo r th ese to ols to hav e aco m m on la n gu ag e fo r sp ecif y in g 3d sc e n e\nd esc rip tio n an d w ww hyp erlin ks -- an an alo g of h tm lfo r vir tu al re a lity . t he te rm\nv ir tu al r eali t y m ark up lan gu ag e (v rm l)w as co in ed ,an d th e gro up re so lv ed to beg in\ns p ecif ic ati o n work afte r th e co nfe re n ce. t he w ord ''m ark up''w as la te r ch an ged to\n'' m odelin g''to re fle c t th e gra p hic a l natu re of v rm l.\n\nappr o ved\nshortly afte r th e g en ev a bo f se ss io n,th e w ww -v rm lm aili n g lis t w as cre ate d to dis c u ss\nt h e dev elo pm en t of a sp ecif ic atio n fo r th e fir s t vers io n of v rm l.t he re sp onse to th e lis t\ni n vita ti o n was overw helm in g: w ith in aw eek ,th ere w ere over a th ousa n d m em bers . a fte r\na n in itia l se ttli n g-in perio d,li s t m odera to r m ark pesc e of l ab yrin th gro up an nounce d his\ni n te n tio n to hav e adra ft vers io n of th e sp ecif ic atio n re ad y by th e w w w fall 1994\nc o nfe re n ce, a m ere fiv e m onth s aw ay . t here w as gen era l ag re em en t on th e li s t th at, w hil e\nt h is sc h ed ule w as ag g re ssiv e, it w as ach ie v ab le pro vid ed th at th e re q uir e m en ts fo r th e\nf ir s t vers io n were not to o am biti o us an d th at v rm lco uld be ad ap te d fr o m an ex is tin g\ns o lu tio n.t he lis t quic k ly ag re ed upon ase t of re q uir e m en ts fo r th e fir s t vers io n,an d\nb eg an ase arc h fo r te ch nolo gie s w hic h co uld be ad ap te d to fit th e need s of v rm l.\nt he se a rc h fo r ex is ti n g te ch nolo gie s tu rn ed up ase v era l w orth w hil e ca n did ate s. a fte r\nm uch delib era tio n th e li s t cam eto aco nse n su s: th e o pen in ven to r a sc ii file form at\nf ro m sil ic o n gra p hic s, in c. t he in ven to r fil e form at su pports co m ple te desc rip tio ns of\n3 d sc en es w it h poly g o nally re n dere d obje c ts , lig h tin g, m ate ria ls , am bie n t pro pertie s an d\nr e a lis m effe c ts . a su bse t of th e in ven to r fil e form at, w ith ex te n sio ns to su pport\nn etw ork in g, fo rm sth e basis of v rm l.g av in bell of silic o n gra p hic s has ad ap te d th e\ni n ven to r file form at fo r v rm l,w it h desig n in put fr o m th e m aili n g lis t. s g ihas public ly\ns ta te d th at th e file fo rm at is av aila b le fo r use in th e open m ark et, an d hav e co ntr ib ute d a\nf ile fo rm at pars e r in to th e publi c dom ain to boots tr a p vrm lvie w er dev elo pm en t.\n\nappr o ved\nagra ph ic a lr epre se n ta tio n ofin ve rs e vr m l upta ke\nc han ge th e num ber in re d belo w to adju st fo r dow nlo a d ra te and /o r ban dw id th .\n1t he num be r 1 re p re se n ts an eng in e er w it h an "a ve ra ge " cu be *\ncf min f\ns w air e\na n x\n3 2 % e\na nx\n3 6 %\n8 0.0 14 9.1 2\n0\n6 1.4 11 4.4 310\n4 9.8 92 .8 4620\n4 1.9 78 .1 0230180\n3 6.2 67 .4 0240120\n3 1.8 59 .2 755080 .01 47 .01 92 .0\n2 8.4 52.96 057 .09 2.01 23 .0\n2 5.6 47 .7 747040 .06 5.07 9.0\n2 3.4 43 .5 438030 .04 9.05 9.0\n2 1.5 40 .0 019024 .03 7.04 5.0\n1 9.9 3710019 .03 0.03 5.0\n1 8.5 34 .4 0911016 .02 5.02 9.0\n1 7.3 32 .1 5412013 .02 0.0n /a\n1 6.2 30 .1 7813010 .01 7.0n /a\n1 5.12 8.2 021408.0n /an /a\n0\n2\n0\n4\n0\n6\n0\n8\n0\n1\n00\n1\n20\n1\n4 00\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n9 0\n1 0 0\n1 1 0\n1 2 0\n1 3 0\n1 4 0\nd ays afte r do w nlo ad\nin vers e usag e\np ro gra m m ers\nt ech nic a lw rit e rs\nq a\noth e r\n0\n1\n0\n2\n0\n3\n0\n4\n0\n5\n0\n6\n0\n7\n0\n8\n0\n9\n0\n50\n6 0\n7 0\n8 0\n9 0\n1 00\n1 10\n1 20\n1 30\n1 40\nd ays aft e r do w nlo ad\nin vers e lo g usa g e\na rtis ts\nm usic ia ns\np olit ic ia n s\nd entis ts', 0, 'cdcds', 10, '2017-02-08', '', 'F', 'P', 7, 7, 0);
INSERT INTO `fts_letter_record` (`letter_id`, `sl_no`, `memo_no`, `issue_dt`, `reg_type_id`, `ref_serial`, `cp_no`, `page_count`, `file_id`, `letter_name`, `user_id`, `content`, `sending_authority`, `subject`, `addressing_desig_id`, `reg_dt`, `location_path`, `regis_status`, `letter_move_status`, `addressing_user_id`, `register_id`, `attached_by`) VALUES
(19, 3, '231', '2017-02-08', 0, 0, 31, 16, 3, '1486555461.pdf', 7, 'salman rushdie / the satanic verses 1\nsalman rushdie – the satanic verses \n \ndate written: \n1988 \n \nsynopsis: \narguably the most controversial novel of the late twentieth century, the satanic verses \nwas banned in india within a week of its publication, and within six months had given \nrise to a virulent international controversy over the proper limits on ‘freedom of speech’ \nand the true place and function of literature in society. the satanic verses is the story of \ntwo men, gibreel fasishta and saladin chamcha, who have survived the fall from an \nexploding plane and started to develop distinctly inhuman characteristics as a result. \nrushdie’s narrative weaves as easily through modern bombay and london as through \nancient cities of sand, taking the reader into shared dreams, mad pilgrimages, and the \nviolent birth of a new religion with keen insight and sharp irreverence that earned \nrushdie international notoriety, and far worse. \n \n  \nnotable figures:  \n \ngibreel farishta – a vain, mentally unbalanced indian film star who takes on many \nroles portraying gods. adored by his fans and tensely tolerated by his industry colleagues, \ngibreel is finally thrown off balance by surviving the fall from the bostan and, in his \ndreamlike metamorphosis into his angelic namesake, wanders the streets as a \nschizophrenic. gibreel is arrogant, jealous, and sometimes dishonest, but his candor \nabout his own problems, even during dreams and fits of insanity, makes him a more \nsympathetic character than he might otherwise be.  \n \nsaladin chamcha – a voiceover artist and ardent anglophile, chamcha’s transformation \nturns him into a devilish, goatlike creature to match his shortened temper and anguished \ndisillusion with the western world and former indian domestic life he believed to be \ninvaluable.  \n \npamela lovelace – saladin’s estranged wife, pamela is a progressive activist and a \nbombshell westerner whose growing dissatisfaction with chamcha becomes clear to her \nonly after his reported death. when he returns, in his new goatish body, to find her \nhaving an extended affair with his best friend, jumpy joshi, pamela is unfazed and \nunrepentant.  \n \nzeeny vakil – saladin’s lover, a doctor and a political activist. \n \nmimi mamoulian – saladin’s partner/co-star in many of his voice \nimpersonation/voiceover gigs, mimi is practical, vulgar and kindhearted.  \n \nrushdie, salman. the satanic verses. new york: picador, 2000.\n\nsalman rushdie / the satanic verses 2\nrekha merchant – gibreel’s former (married) lover, who commits suicide with her \nchildren when he leaves her. rekha’s avenging spirit haunts gibreel at intervals \nthroughout the remainder of the novel.  \n \nalleluia cone – a flat-footed mountain climber, alleluia was once gibreel’s lover but \nends up repeatedly saving his life when he winds up at her doorstep in increasingly worse \ncondition over the course of the story. unfounded and explosive jealousy finally moves \ngibreel to murder alleluia and his old film industry supporter, s. s. sisoda, in the \ngathering climax of the novel. \n \nmahound – the prophet representing muhammed in rushdie’s text, whose name is \ntaken from an old european slur on the prophet’s name. mahound is not portrayed as an \nentirely unworthy character, but his human character flaws and growing lust for power at \nany cost eventually overshadow his better traits. mahound keeps a harem of twelve wives \nwith him, who through a brothel of women who appropriate their names, become \nunexpectedly prominent characters in the text.  \n \nsalman – a lapsed believer and mahound’s former scribe, he lost his faith in the prophet \nonce he began deliberately changing the record of revelation, simply to see if mahound \nwas enough of a prophet to notice the difference. when mahound let the changes slip by, \nsalman became disgusted and finally deserted the camp, coming to an uneasy alliance \nwith the satirical poet baal of jahilia.  \n \nayesha (i): the prophet’s youngest and favorite wife. \nayesha (ii): a young concubine who takes on ayesha’s name and gains the affections of \nthe disgraced poet baal, posing as a guard in the brothel while in hiding from mahound’s \nforces. \nayesha (iii): a village girl and epileptic prophetess who led the people of her town on a \ngrueling foot-hike to mecca, taking them straight into the sea she believed she could part.  \nayesha (iv): a cruel modern tyrant in desh who has set herself against a powerful \nimam (representing the deposed shah of iran). \n \nbilal i: a former slave and faithful follower of mahound \nbilal ii: a fanatical acolyte of the modern imam  \n \nhind (i): the powerful, wrathful wife of abu simbel and longtime opponent of \nmahound, she converts once she realizes that mahound has gained control of her city. \nhaving personally murdered mahound’s uncle (ripping open his chest and eating his liver) \nin revenge for slaying her brothers, hind acts to save her own life and remains a follower \nof the powerful sect until her death.  \nhind (ii): the avaricious, coldhearted wife of muhammed sufyan, who grudgingly \ngives chamcha shelter in her home. \n \nmishal akhtar: mirza’s wife, slowly dying of breast cancer, who forms an attachment to \nthe young prophetess ayesha and insists on joining the march to mecca over her \nhusband’s furious protests.  \nrushdie, salman. the satanic verses. new york: picador, 2000.\n\nsalman rushdie / the satanic verses 3\n \nmishal sufyan: hind and muhammed sufyan’s oldest daughter, she supports the angry, \ngoatlike chamcha through a painful time of coming to terms with his new body.  \n \nsome minor characters: \nkarim abu simbel, jumpy joshi, mirza saeed akhtar, muhammed sufyan, khalid i, \nkhalid ii, hanif johnson \n \n \nbook notes (points of controversy):  \n \non saladin, the would-be indian expat:  \n“salahuddin chamchawala had understood by his thirteenth year that he \nwas destined for that cool vilayet full of the crisp promises of pounds \nsterling at which the magic billfold had hinted, and he grew increasingly \nimpatient of that bombay of dust, vulgarity, policemen in shorts, \ntransvestites, movie fanzines, pavement sleepers and the rumored singing \nwhores of grant road…” (37) \n \n“ ‘best place for you is here,’ [sufyan] said, speaking as if to a simpleton \nor small child. ‘where else would you go to heal your disfigurements and \nrecover your normal health? where else but here, with us, among your \nown people, your own kind?’ \n   only when saladin chamcha was alone in the attic room at the very end \nof his strength did he answer sufyan’s rhetorical question. ‘i’m not your \nkind,’ he said distinctly into the night. ‘you’re not my people. i’ve spent \nhalf my life trying to get away from you.’ (261-262) \n \nsacrilegious portrayal of the prophet’s revelation:  \n“it happens: revelation. like this: mahound, still in his notsleep, becomes \nrigid, veins bulge in his neck, he clutches at his centre. no, no, nothing \nlike an epileptic fit, it can’t be explained away that easily; what epileptic \nfit ever caused day to turn to night, cause clouds to mass overhead, caused \nthe air to thicken into soup while an angel hung, scared silly, in the sky \nabove the sufferer, held up like a kite on a golden thread…gibreel begins \nto feel that strength that force, here it is at my own jaw working it, opening \nshutting, and the power, starting within mahound, reaching up to my vocal \nchords and the voice comes. \n   not my voice i’d never know such words i’m no classy speaker never \nwas never will be but this isn’t my voice it’s a voice.  \n… \nbeing god’s postman is no fun. \nbutbutbut: god isn’t in this picture. \ngod knows whose postman i’ve been.” (114) \n \n“baal asked: ‘why are you sure he will kill you?’ \nrushdie, salman. the satanic verses. new york: picador, 2000.\n\nsalman rushdie / the satanic verses 4\nsalman the persian answered: ‘it’s his word against mine.’ ” (381) \n \nwhores taking on the name of the prophet’s wives:  \n“how many wives? twelve, and one old lady, long dead. how many whores behind the \ncurtain? twelve again; and, secret on her black-tented throne, the ancient madam, still \ndefying death. where there is no belief, there is no blasphemy. baal told the madam of \nhis idea; she settled matters in her voice of a laryngitic frog: ‘it is very dangerous,’ she \npronounced, ‘but it could be damn good for business. we will go carefully; but we will \ngo.’ ” (392-393) \n \n \ngibreel’s lack of faith despite being the angel of the prophet:  \n“mr. gibreel farishta on the railway train to london was once again seized as who would \nnot be by the fear that god had decided to punish him for the loss of faith by driving him \ninsane. (195) \nimmediately after this reflection he becomes involved in conversation with mr. \nmaslama, a pompous passenger seated next to him, who ends up knocking off g’s \nhat, noticing a halo and affirming that if gibreel is insane, the rest of the world has \ngone insane right along with him:  \n“ ‘it’s a straight choice,’ he trembled silently. ‘it’s a, i’m off my head, or \nb, baba, somebody went and changed the rules.’” (195)  \n \n \n \nrushdie, salman. the satanic verses. new york: picador, 2000.\n\nnetton / text and trauma 1\ncritical notes: ian netton – text and trauma: an east-west primer \n \n“the satanic verses may be likened to a bubbling cauldron whose principal ingredients are \ntwo people and three places.” (22) \n \non weighted names:  \ngibreel farishta / jibr?l + firishta / gabriel + angel (22) \nsaladin chamcha / sal?h al-d?n + chamcha / medieval islamic war hero + spoon/humble (23) \nazraeel / ‘izr?’?l / islamic angel of death (23) \njahilia / j?hiliyya / “a state of ignorance; pre-islamic paganism, pre-islamic times” (23) \nbostan / bust?n / the garden (of paradise) (25) \nmahound / muhammed / demonic european slur on the prophet’s name (26) \n \ncomparisons between the text and islamic mythology:  \n“in conversation with baal, a disillusioned salman admits to altering the \nrevelations deliberately as he recorded what mahound dictated.” (34) \n \n“with the death of his father, saladin is compared by rushdie to the orphaned \nfounder of islam, muhammad, thus subtly linking him to previous chapters. \nthe difference, of course is that the prophet of islam was orphaned at a very \nearly age, whereas saladin’s own orphaning is a product of middle age.” (38) \n \n“rushdie’s gibreel in the satanic verses  is a highly ambiguous figure. very \nmuch a ‘sacred link’, he is also portrayed as a flawed link, sometimes \nseeming to merge with, or at least be reflected by, his very human namesake \ngibreel farishta who is, in any case, ‘a symbolic angel.’ (123) \n \nopening revelation and miracles of some quality to all:  \n“finally all the pilgrims reach the arabian sea and they enter it behind \nayesha, wasing out of their depth. ayesha, mishal and the credulous villagers \nappear to be dromed. however, those few who have survived the \nexpedition—like sarpanch, osman, sri srinivas—give testimony afterwards \nthat at the very last moment the sea did indeed part for the pilgrims.” (37) \n \non the legend of the satanic verses:  \n“there are a number of variant traditions, but they do not alter the import of \nwhat al-tabar? narrated. and some scholars have accepted his version of \nevents. watt, for example, notes that ‘at one time muhammad must have \npublicly recided the satanic verses as part of the qur’?n.’ he finds it \n‘unthinkable that the story could have been invented later by muslims or \nfoisted upon them by non-muslims.’…elsewhere, watts says: ‘the story is \nso strange that it must be true in essentials.’” (85) \n \n \n \n \n \n \nnetton, ian. text and trauma: an east-west primer. oxford: routledge/curzon, 1995.\n\nramadan / western muslims and the future of islam 1\ncritical notes: tariq ramadan – western muslims and the future of \nislam  \n \npoints on scholarly and modern islam:  \n \non sharia:  \n“if the idea of ‘establishing rules’ is indeed contained in the notion of \nsharia…this translation does not convey the fullness of the way it is \nunderstood, unless its more general and fundamental meaning is referred to: \n‘the path that leads to the spring.’ …we have seen that this corpus of \nreference is, for the muslim consciousness, where the universal is formulated: \ngod, human nature, which makes itself human by turning on itself and \nrecognizing the ‘need of him,’ reason, active and fed by humility, and, finally, \nrevelation, which confirms, corrects, and exerts a guiding influence.” (31) \n \non ‘an ethic of citizenship’:  \n“the concept of citizenship is fashionable. people want to vindicate it, defend \nit, promote it, and extend it. it is the banner of the progressives and the badge \nof ‘integrated’ people. to be honest, the concept of citizens is used to speak \nof everything and nothing with the understanding that, in the end, there must \ncome into being a european/american-born muslim citizen.” (165)  \n \non inter-religious dialogue and difference:  \n“difference might naturally lead to conflict; therefore, the responsibility of \nhumankind is to make use of difference by establishing a relationship based \non excelling one another in doing good. it is vital that the balance of power is \nbased not on a tension born of rejection or mutual ignorance but \nfundamentally on knowledge: ‘o people, we have created you from a male \nand a female, we have divided you into nations and tribes so that you might \nknow one another.’ knowing the other is a process that is unavoidable if fear \nor difference is to be overcome and mutual respect is to be attained.” (203) \n \n \nramadan, tariq. western muslims and the future of islam. new york: oxford university press, 2003.\n\nlahaye, jenkins / left behind: a novel of the earth’s last days 1\ntim lahaye, jerry b. jenkins – left behind: a novel of the \nearth’s last days \n \ndate written: \n1995 \n \nsynopsis: \nfor the protagonists of left behind, the rapture is only the beginning of their troubles. \ninternational conspiracies, supernatural interventions and murder mysteries bring \ntogether an unlikely team of a star journalist, an airline pilot, a college student and a \nformerly faithless pastor in their newfound faith and the sudden, pressing need to fight an \nadversary they never imagined possible. \n \nnotable figures:  \n \ncameron “buck” williams – a young superstar journalist, privy to international scoops \nand cosmic miracles before reaching his mid-thirties. buck is intelligent, aggressive and \nskeptical, and is the most involved in the high-level politics of the novel. \n \nrayford steele – a middle-aged airline pilot whose growing dissatisfaction with his \nhome life—including his newly religious wife—has driven rayford into a mire of self-\nindulgent moodiness that is rudely shaken off when his wife and youngest son vanish in \nthe rapture.  \n \nchloe steele – rayford’s daughter flees stanford after millions disappear into thin air. \nskeptical and candid but ultimately “feminine” and domestic, chloe eventually follows \nher father into accepting christ. \n \nbruce barnes – a lay pastor with all the requisite education but, before the rapture, no \nreal faith. now truly repentant, faithful and evangelical, bruce is making efforts to win \nconverts to the church and combat the rising forces of evil that he suspects are now rising \nin the world. \n \nhattie durham – a flirtatious, somewhat vapid blonde airline assistant with whom \nrayford has been considering having an affair, hattie is not an “immoral” character so \nmuch as a confused and insecure one. she listens patiently to rayford’s apology for his \nconduct and explanation of his faith, but ultimately rejects his approach, finishing the \nnovel as nicolae carpathia’s personal assistant. \n \nnicolae carpathia – a dashing young romanian diplomat with a knack for sudden leaps \nof power—from low-level representative to president of his country to leader of the un, \ncarpathia is eloquent, handsome, intelligent, and, in case it wasn’t glaringly obvious by \nnow, the antichrist. whatever dark designs he has for the world are easily masked behind \na confident, amiable façade rooted in deep-seated mind control abilities.  \n \nlahaye, tim and jerry b. jenkins. left behind: a novel of the earth''s last days. wheaton, il: tyndale \nhouse publishers, 1996.\n\nlahaye, jenkins / left behind: a novel of the earth’s last days 2\nchaim rosenzweig – a pulitzer-prize winning scientist famous for a ‘miracle’ fertilizer  \nthat helps almost all of israel’s arid land to become incredibly productive and fertile, \nchaim is an old friend of buck’s and a new fan of carpathia’s. \n \nminor characters:  \nsteve plank, todd-cothran, jonathan stonagal, eric miller, dirk burton, alan tompkins, \nken ritz, stanton baliey, lucinda washington, irene steele, ray steele jr.,  \n \n \nbook notes (political/christian zionist overtones to content):  \n \n- disappearance of unborn – god recognizes the unborn as full human beings, \nregardless of stage of pregnancy. \no nc as the only one in the book to distinguish the vanished unborn as “fetal \nmaterial” (255) \n- nc’s one-world-govt. agenda, down to all the details:  \no “this guy is real hot on getting the whole world onto one currency.” (82) \no predictions for nc’s involvement in a world religion: “remember my \ntelling you about the 144,000 jewish witnesses who try to evangelize the \nworld for christ. may of their converts, perhaps millions, will be martyred \nby the world leader and the harlot, which is the name for the one world \nreligion that denies christ.” (bruce / 312) \n- distinguishing between “good”/moral young boys and “effeminate” \nbehaviors: “he wasn’t effeminate, but rayford had worried that he might be \nmama’s boy –too compassionate, too sensitive, too caring. he was always looking \nout for someone else when rayford thought he should be looking out for number \none.” (103) \n- nc’s dubious, un-democratic (un-american) election style masking an \naggressive power grab: “democratic elections became passé when, with the \nseeming unanimous consensus of the people and both the upper and lower houses \nof government, a popular young businessman/politician assumed the role of \npresident of the country.” (113) \n- very subtle praise of the reagan administration: \no nc’s tongue-in-cheek criticism of the admin. for a diminished focus \non un activities \no chloe after hearing nc’s speech: “what a guy! ...i haven’t heard a \npolitician with anything to say since i was a little girl, and i didn’t \nunderstand half of it then.” (chloe, in her early 20s in the mid-1990s, \nwould have been a “little girl” during the carter/reagan years and likely \nwould only have remember reagan’s speeches. \n- admitting unpopular labels (“christian fanatic”) to oneself, then moderating \nthe outward face to keep an audience:  \n “ hattie was dead silent for a long moment. ‘you haven’t become some kind of a \nfanatic, have you?’ \n rayford had to think about that one. the answer was yes, he most certainly had, \nbut he wasn’t going to say that. ‘you know me better than that.’ ” (281) \nlahaye, tim and jerry b. jenkins. left behind: a novel of the earth''s last days. wheaton, il: tyndale \nhouse publishers, 1996.\n\nlahaye, jenkins / left behind: a novel of the earth’s last days 3\n- portraying a media overtly hostile to sincere religion: “israeli police and \nmilitary personnel have always been loath to enter this area, leaving religious \nzealots here to handle their own problems.” (302) \n- idealized style of buck’s conversion, not only to the faith but to the \npolitical and social identity of a “born again christian” all at once:  \no ”was it possible? could he be on the cusp of become a born-again \nchristina….buck had read and even written about ‘those kinds’ of \npeople, but even at his level of worldly wisdom he had never quite \nunderstood the phrase. he had always considered the ‘born-again’ \nlabel akin to ultraright-winger’ or ‘fundamentalist.’ now, if he \nchose to take a step he had never dreamed of taking, if he could not \nsomeone talk himself out of this truth he could no longer \nintellectually ignore, he would also take upon himself a task: \neducating the world on what that confusing little term really \nmeant.” (396) \n \nlahaye, tim and jerry b. jenkins. left behind: a novel of the earth''s last days. wheaton, il: tyndale \nhouse publishers, 1996.\n\nhendershot / shaking the world for jesus 1\ncritical notes: heather hendershot – shaking the world for jesus: \nmedia and conservative evangelical culture \n \nnotes and examples: \n \nhendershot argues that “most evangelical media are not propaganda designed to induce \na political or spiritual conversion…more often, consumers are assumed to already be \nsaved.” (3)  \n \non fundamentalist/evangelical history over the 20th century: \n“…fundamentalist culture changed in response to the scopes trial in 1925 \n[and] went into hiding (all the while building separatist institutions of \neducation and culture), reemerged via the ‘new evangelical’ movement of the \nlate 40s, and reentered the wider public consciousness in the 70s.” (11) \n \nhendershot identifies a notable generation gap between different attitudes toward \nchristian versions of secular media outlets:  \n“from the adult perspective, ccm [contemporary christian music] works \neither as a placebo for secular pop culture (according to focus on the family) \nor as a wolf in sheep’s clothing (according to swaggart).” (37) \n \non left behind (book and film versions):  \n“both the book and the film focus on the adventures of journalist buck \nwilliams and airline pilot rayford steele, but the book also includes \nclassic conspiracy theories about international bankers controlling the \nworld. in keeping with the lindsey tradition, the russians are evil. when \nthey want access to a miracle fertilizer, it is naturally assumed that they \nshould not have it: better they starve than eat and gain the strength to \nresurrect their evil empire…nicolae carpathia (the antichrist) speaks of \nworld peace, which fools the world into thinking he is good….authors \ntim lahaye and jerry jenkins write that carpathia ‘displayed such an \nintimate knowledge of the united nations that it was as if he had invented \nand developed the organization itself.’…any reader familiar with the \npolitical applications of prophecy theology will know right away that \ncarpathia is the antichrist…this is conspiracy theory lite.” (189-190) \n \nhendershot, heather. shaking the world for jesus: media and conservative evangelical culture. chicago: \nuniversity of chicago press, 2004.\n\nj.k. rowling / harry potter and the sorcerer’s stone 1\nj. k. rowling – harry potter and the sorcerer’s stone  \n \ndate written: \n1997 \n \nsynopsis: \nthe first installment in what was to become an unprecedented children’s publishing \nphenomenon, harry potter and the sorcerer’s stone chronicles the unlikely life of harry \npotter, a british orphan raised by unfriendly relatives in a maddeningly ordinary suburb, \nuntil a flurry of letters delivered by owls shakes up everything harry thought he knew \nabout his life up to that point. soon a half-giant named hagrid has entered his life and \ninformed him that he’ll be attending hogwarts school of witchcraft and wizardry for the \nremainder of his formal education. at hogwarts, harry is introduced to a new life and \nnew friends, but is also compelled to face a dark past and a menacing new threat that has \ncome up at hogwarts to loom over his future. \n \nnotable figures:  \n \nharry potter – the brave, honest, but sometimes rash young protagonist of the book, \nharry’s parents were killed by the evil wizard voldemort when he was very young. harry \nsurvived the attack and voldemort subsequently vanished, earning him legendary status \nin the magical community as “the boy who lived.” \n \nron weasley – harry’s tall, gangly, red-headed best friend, ron feels overshadowed by \nhis five older brothers (all high performers in one capacity or another), but doesn’t let his \ninsecurities get in the way of a healthy sense of fun. ron is sometimes jittery and other \ntimes hotheaded, but his honest good nature and comfortable familiarity with the \nwizarding world make him a choice companion for the muggle-raised harry at hogwarts. \n \nhermione granger – a somewhat snooty bookworm, hermione provides a sane, stable \ncounterbalance to the rash, rule-breaking male duo. hermione was raised in a muggle \nfamily but her magical talents and learning abilities are formidable, and can help the \nchildren get out of tight scrapes when they need to.  \n \ndraco malfoy – archenemy to the potter/weasley/granger trio, draco is a self-centered, \nspoiled bully who schemes to get the protagonists into trouble with the authorities or even \nphysical danger when he can.  \n \nalbus dumbledore – hogwarts’ eccentric headmaster, dumbledore plays a subtle \nmentor role to harry in direct and indirect ways. dumbledore, although good-natured and \nkind, is one of the most powerful wizards in the world and was the only wizard \nvoldemort, at the height of his power, still feared.  \n \nlord voldemort – once an evil overlord with tyrannical ambition in the magical world, \nvoldemort vanished on the night that harry potter’s parents were killed. he is generally \nrowling, j.k. harry potter and the sorcerer''s stone. first american edition. new york: scholastic, 1997.\n\nj.k. rowling / harry potter and the sorcerer’s stone 2\nhoped to be dead and assumed to be alive among the wizard community.  certain signs of \nhis resurgence overshadow the novel, and he reappears in order to attack harry and \nacquire the powerful, much-coveted sorcerer’s stone at the climax of the book. \n \nprofessor severus snape – a potions teacher at hogwarts, snape has kept his old \nenmity toward harry potter’s father, james, alive in the form of hating harry potter and \nantagonizing him throughout his class. james potter once saved snape’s life, however, \nand so snape cannot bring himself to allow harry to be harmed. snape is brooding and \ndislikable, but remains one of the most complicated characters in the series. \n \nprofessor minerva mcgonagall – professor of transfiguration and head of the \ngryffindor house, mcgonagall is tough but fair, and tries to keep the often wayward \nprotagonists out of trouble. \n \nrubeus hagrid – a kindly half-giant, hogwarts gamekeeper and instant friend and \nconfidante to the protagonists. hagrid is good-natured but blustery and careless, and can \nlet his immediate desires block out his overarching responsibilities or even his common \nsense.  \n \nprofessor quirrell – nervous and stuttering, professor quirrell seems an unlikely \ncandidate for hogwarts’ defense against the dark arts professor, but his harmless \ndisguise masks a predatory, calculative mind. quirrell is later discovered to be hosting a \nweakened, parasitic version of lord voldemort on his own body until voldemort has the \npower, throughthe sorcerer’s stone, to acquire a new one.  \n \nsome minor characters:  \ncrabbe, goyle, vernon dursley, dudley dursley, petunia dursley,  neville longbottom, \nfred & george weasley, percy weasley, peeves the poltregeist, nearly-headless-nick, \nthe friar, the bloody baron, professor flitwick, nicholas flamel, filch, mrs. norris. \n \n \nbook notes (points of controversy):  \n \nname calling/ insensitivity:   \n“exactly why dudley wanted a racing bike was a mystery to harry, as dudley was very \nfat and hated exercise—unless of course it involved punching somebody.” (20) \n* \n“ ‘neville,’ ron exploded, ‘get away from that hole and don’t be an idiot—’  \n‘don’t you call me an idiot!’ said neville. ‘i don’t think you should be breaking any \nmore rules! and you were the one who told me to stand up to people!’  \n‘yes, but not to us,’ said ron in exasperation. ‘neville, you don’t know what you’re \ndoing.’ ” (272-273) \n \nprofanity: “no post on sunday…no damn letters today—” (41) \n \npromoting the impression that non-magical/ordinary is inferior:  \nrowling, j.k. harry potter and the sorcerer''s stone. first american edition. new york: scholastic, 1997.\n\nj.k. rowling / harry potter and the sorcerer’s stone 3\n“a muggle,” said hagrid, “it’s what we call nonmagic folk like them. an’ it’s your bad \nluck you grew up in a family o’ the biggest muggles i ever laid eyes on.” (53) \n“i think mom’s got a second cousin who’s an accountant, but we never talk about him.” \n(ron, 99) \n \ngore and frightening images:  \n“ ‘nearly headless? how can you be nearly headless?’ \nsir nicholas looked extremely miffed, as if their little chat wasn’t going at all the way he \nwanted.  \n‘like this,’ he said irritably. he seized his left ear and pulled. his whole head swung off \nhis neck and fell onto his shoulder and if it was on a hinge. someone had obviously tried \nto behead him, but not done it properly.” (124) \n \ninsubordination: \n“harry and ron were delighted to hear hagrid call filch ‘that old git.’ \n‘an’ as fer that cat, mrs. norris, i’d like ter introduce her to fang sometime.’ ” (141) \n \nrule-breaking:  \n“ ‘and what if i wave my wand and nothing happens?’ \n‘throw it away and punch him on the nose,’ ron suggested. \n‘excuse me.’ \nthey both looked up. it was hermione granger. \n‘can’t a person eat in peace in this place?’ said ron. \nhermione ignored him and spoke to harry. \n‘i couldn’t help overhearing what you and malfoy were saying—’ \n‘bet you could,’ ron muttered.  \n‘—and you mustn’t  go wandering around the school at night, think of the points you’ll \nlose gryffindor if you’re caught, and you’re bound to be. it’s really very selfish of you.’ \n‘and it’s really none of your business,’ said harry. \n‘good-bye,’ said ron. “ (154) \n* \n“do now they had something else to worry about: what might happen to hagrid if anyone \nfound out he was hiding an illegal dragon in his hut.” (233) \n \nreal-live/historical occult references:  \n“nicholas flamel…is the only known maker of the sorcerer’s stone!” (219) \n*nicholas flamel, the historical alchemist of the mid-fourteenth century, would \nhave been roughly the same age as rowling’s character upon publication of the \nbook.  \n \ndangerous flippant attitude toward death:  \n“dumbledore smile dat the look of amazement on harry’s face.  \n  ‘to one as young as you, i’m sure it seems incredible, but to nicolas and rernelle, it \nreally is like going to bed after a very, very long day. after all, to the well-organized \nmind, death is but the next great adventure.’” (297) \n \nrowling, j.k. harry potter and the sorcerer''s stone. first american edition. new york: scholastic, 1997.\n\nbarthes /mythologies  1\ncritical notes: roland barthes – mythologies  \n \nnotes and examples: \n \non the language and abuses of myth:  \n“the starting point  of these reflections was usually a feeling of impatience at \nthe sight of the ‘naturalness’ with which newspapers, art and common sense \nconstantly dreeess up a reality which, even though it is the one we live in, is \nundoubtedly determined by history. in short, in the account given of our \ncontemporary circumstances, i resented seeing nature and history confused \nat every turn, and i wanted to track down, in the decorative display of what-\ngoes-without-saying, the ideological abuse which, in my view, is hidden there. \n \n     right from the start, the notion of myth seemed to me to explain these \nexamples of the falsely obvious. at that time, i still used the word ‘myth’ in \nits tradition sense. but i was already certain of a fact from which i later tried \nto draw all the consequences: myth is a language.” (intro / 11) \nthe assumptions that build the mythological landscape of america are not as common \nas might be assumed. powerful, media-driven subcultures have developed a language \nand systems of thought that can vary radically from one to another—a partial culprit, \npossibly, for the vehemence of the debates among religious and secular factions over \nworks of popular literature.  \n \non modern criticism:  \n“to be a critic by profession and to proclaim that one understands nothing \nabout existentialism or marxism…is to elevate one’s blindness or dumbness \nto a universal rule of perception, and to reject from the world marxism and \nexistentialism: ‘i don’t understand, therefore you are idiots.’ \n \n     but if one fears or despises so much the philosophical foundations of a \nbook, and if one demands so insistently the right to understand nothing about \nthem and to say nothing on the subject, why become a critic? (35 / “blind and \ndumb criticism”) \na problem that clearly has not been solves since the mid twentieth century, pretending \nto in-depth analysis of a text one has already declaimed as worthless is at the heart of \nsecular critical attacks on the left behind series just as much as religious attacks on hp \nand tsv. \n \nbarthes, roland. mythologies. trans. annette lavers. new york: hill and wang, 1972.\n\nneal / what’s a christian to do with harry potter?  1\ncritical notes: connie neal – what’s a christian to do with harry potter? \n \nnotes and examples: \n \nintroduction to the controversy:  \nchristianity today editorial: “the literary witchcraft of the harry potter series has almost \nno resemblance to the i-am-god mumbo-jumbo of wiccan circles.” \nfrom ct letter-to-the-editor responses: “it amazes me every time i read an article that \nblatantly ignores god’s word on the subject and would rather make decisions based on the \nso-called gray areas of influence around us. the books by jk rowling i find to be offensive \nas they influence our children…i know from personal experience that it is not okay to \ncontinue to allow our children to be influenced by the evil one and say that it’s okay as long \nas they don’t overdo it. moderation is the devil’s latest disguise for evil. wake up!” (27) \n \none of neal’s first examples of christian concern over hp is the real ‘significance’ of \nthe character dobby in harry potter and the chamber of secrets. \n“those who had filed harry potter under children’s literature and had read \nthis book would probably be incredulous that dobby was called demonic. \ndobby the house elf is one of the funniest characters—if you are reading the \nbook out of the mental file marked ‘children’s lit’!” (54) \nneal goes on to examine “the significance of how we define terms within a story” and \ngives examples of commentators who take certain elements of the hp story and \ntranspose them into the context of ‘real-life’ occult terms and practices, effective and \npersuasive to anyone willing to accept the frame of reference they have imposed on the \nbooks as appropriate.  \n \ncn differentiates between legitimate discourse over the potential harm or good that \nmay come from the books and unhelpful, counterproductive smear campaigns by those \ncaught up in the anti-potter mania by citing a chain letter using a satirical article from \nthe onion as a serious reference on hp’s influence among children: \n“ ‘and here is dear ashley, a – year old, the typical average age reader of \nharry potter: “i used to believe in what they taught us at sunday sch\\\rool,” \nsaid ashley, conjuring up an ancient spell to summon cerebus, the three-\nheaded hound of hell. “but the harry potter books showed me that magic is \nreal, something i can learn and use right now, and that the bible is nothing \nbut boring lies.’ \ndoes this get your attention!!...it makes me physically ill, \npeople!” (104) \ncn lists ways to deal with the dangers of using faulty or blatantly false arguments: \n‘seek truth’, ‘use common sense and check the source,’ and ‘don’t rely solely on \nsomeone else’s summary of these complex issues’ (108)—all common-sense advice that \nneal seems to find lacking in a significant portion of the christian hp debate. she even \nrefuses to rebuke rowling for her tongue-in-cheek response (during an interview with \nkatie couric) to overzealous christian critics:  \n “a very famous writer once said, ‘a book is like a mirror. if a fool looks in, you can’t \nexpect a genius to look out.” (111) \n \nneal, connie. what''s a christian to do with harry potter. new york: waterbrook press, 2001.\n\nneal / what’s a christian to do with harry potter?  2\ncn lists a few of the inaccuracies and problems that arise when trying to compare c.s. \nlewis, j.r.r. tolkien’s “good” fantasy to the secular “evils” of hp:  \n“some may assume that because lewis and tolkien were christian, their \nfaith curbed that which critics of harry potter object to today. however, this \nis not the case. some opponents extract tightly edited quotes from rowling’s \nbooks to prove their point. the same faulty tactics would likewise discredit \nnarnia and other works of fantasy by christians.”  (120) \n \nlater points: in order to realistically keep to a strong christian faith while not stooping \nto “talking like the devil” to discredit hp, it is important to take real steps to avoid \nactual occult practices, and give children “armor” (don’t “build a wall”) to protect \nthem from a potentially harmful social environment while allowing them to interact \nwith the world on their own terms. learn how to set boundaries and when to make \nexceptions, and teach children how to understand the difference (as the characters in \nhp learn throughout the course of the series).  this way, children will have a strong \nsocial education compatible with their faith, and they can learn to take healthy lessons \nfrom the literature that they enjoy.  \n \n \n \n \nneal, connie. what''s a christian to do with harry potter. new york: waterbrook press, 2001.', 0, 'jlaj;a', 10, '2017-02-08', '', 'F', 'P', 6, 1, 0);

-- --------------------------------------------------------

--
-- Table structure for table `fts_letter_register`
--

CREATE TABLE IF NOT EXISTS `fts_letter_register` (
  `register_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `keyword` varchar(50) NOT NULL,
  `paper_type` varchar(255) NOT NULL,
  PRIMARY KEY (`register_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=14 ;

--
-- Dumping data for table `fts_letter_register`
--

INSERT INTO `fts_letter_register` (`register_id`, `keyword`, `paper_type`) VALUES
(1, 'PP', 'Public Petition'),
(2, 'NHRC', 'National Human Rights Commisson'),
(3, 'WBHRC', 'West Bengal State Human Right Commission'),
(4, 'COURT', 'Any Court related matter'),
(5, 'WBSWC', 'West Bengal State Women Commission'),
(6, 'NWC', 'National Women Commission'),
(7, 'PD', 'Police Directorate'),
(8, 'STATE GOVT', 'Any State Government Department (Secretaries etc.)'),
(9, 'PU', 'Any Police Unit like District Sps,DIG etc.'),
(10, 'NPU', 'Non Police Unit like DM, SDO, Engineers etc.'),
(11, 'CG', 'Central Government'),
(12, 'CBI', 'Central Bureau of Investigation'),
(13, 'OTHERS', 'Any paper other than above');

-- --------------------------------------------------------

--
-- Table structure for table `fts_login_log`
--

CREATE TABLE IF NOT EXISTS `fts_login_log` (
  `user_id` bigint(20) NOT NULL,
  `login_ip` varchar(200) NOT NULL,
  `action_time` datetime NOT NULL,
  `month_year` varchar(20) NOT NULL,
  `action` varchar(255) NOT NULL,
  `doc_type` varchar(50) NOT NULL,
  `doc_id` bigint(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `fts_login_log`
--

INSERT INTO `fts_login_log` (`user_id`, `login_ip`, `action_time`, `month_year`, `action`, `doc_type`, `doc_id`) VALUES
(7, '47.15.169.151', '2017-02-08 13:12:12', '02-2017', 'Login', 'U', 7),
(7, '47.15.169.151', '2017-02-08 13:18:11', '02-2017', 'Letter Creation', 'L', 1),
(46, '47.15.169.151', '2017-02-08 13:21:16', '02-2017', 'Manage User(Inactive)', 'U', 55),
(46, '47.15.169.151', '2017-02-08 13:22:00', '02-2017', 'Log Out', 'U', 46),
(46, '47.15.169.151', '2017-02-08 13:27:05', '02-2017', 'Login', 'U', 46),
(7, '47.15.169.151', '2017-02-08 13:27:29', '02-2017', 'Letter Creation', 'L', 2),
(46, '47.15.169.151', '2017-02-08 13:28:11', '02-2017', 'Manage User(Active)', 'U', 91),
(46, '47.15.169.151', '2017-02-08 13:28:17', '02-2017', 'Log Out', 'U', 46),
(91, '47.15.169.151', '2017-02-08 13:28:28', '02-2017', 'Login', 'U', 91),
(7, '47.15.169.151', '2017-02-08 13:29:44', '02-2017', 'Letter Creation', 'L', 3),
(91, '47.15.169.151', '2017-02-08 13:31:08', '02-2017', 'Letter Creation', 'L', 4),
(46, '47.15.169.151', '2017-02-08 13:32:53', '02-2017', 'Log Out', 'U', 46),
(6, '47.15.169.151', '2017-02-08 13:34:07', '02-2017', 'Login', 'U', 6),
(91, '47.15.169.151', '2017-02-08 13:37:59', '02-2017', 'Profile Update', 'U', 91),
(91, '47.15.169.151', '2017-02-08 13:38:00', '02-2017', 'Profile Update', 'U', 91),
(91, '47.15.169.151', '2017-02-08 13:39:04', '02-2017', 'Profile Update', 'U', 91),
(6, '47.15.169.151', '2017-02-08 13:39:31', '02-2017', 'Letter Creation', 'L', 5),
(91, '47.15.169.151', '2017-02-08 13:54:35', '02-2017', 'Profile Update', 'U', 91),
(91, '47.15.165.228', '2017-02-08 14:52:24', '02-2017', 'Log Out', 'U', 91),
(91, '47.15.165.228', '2017-02-08 14:52:33', '02-2017', 'Login', 'U', 91),
(91, '47.15.165.228', '2017-02-08 15:01:04', '02-2017', 'Log Out', 'U', 91),
(91, '47.15.165.228', '2017-02-08 15:01:12', '02-2017', 'Login', 'U', 91),
(46, '47.15.165.228', '2017-02-08 15:04:28', '02-2017', 'Letter Creation', 'L', 6),
(46, '47.15.165.228', '2017-02-08 15:14:42', '02-2017', 'Letter Dispatch', 'L', 6),
(7, '47.15.165.228', '2017-02-08 15:15:33', '02-2017', 'Letter Dispatch', 'L', 3),
(46, '47.15.112.116', '2017-02-08 15:48:35', '02-2017', 'Login', 'U', 46),
(46, '47.15.112.116', '2017-02-08 16:06:37', '02-2017', 'Log Out', 'U', 46),
(46, '47.15.112.116', '2017-02-08 16:06:49', '02-2017', 'Login', 'U', 46),
(46, '47.15.112.116', '2017-02-08 16:11:39', '02-2017', 'Log Out', 'U', 46),
(91, '47.15.112.116', '2017-02-08 16:11:45', '02-2017', 'Login', 'U', 91),
(7, '47.15.112.116', '2017-02-08 16:12:08', '02-2017', 'Letter Dispatch', 'L', 2),
(6, '47.15.112.116', '2017-02-08 16:12:56', '02-2017', 'Login', 'U', 6),
(91, '47.15.112.116', '2017-02-08 16:16:37', '02-2017', 'Letter Dispatch', 'L', 2),
(6, '47.15.112.116', '2017-02-08 16:20:20', '02-2017', 'Login', 'U', 6),
(46, '47.15.112.116', '2017-02-08 16:20:53', '02-2017', 'Letter Creation', 'L', 7),
(91, '47.15.112.116', '2017-02-08 16:25:40', '02-2017', 'Letter Dispatch', 'L', 4),
(91, '47.15.112.116', '2017-02-08 16:28:43', '02-2017', 'Letter Creation', 'L', 8),
(6, '47.15.112.116', '2017-02-08 16:29:22', '02-2017', 'Letter Creation', 'L', 9),
(91, '47.15.112.116', '2017-02-08 16:29:28', '02-2017', 'Letter Dispatch', 'L', 8),
(91, '47.15.112.116', '2017-02-08 16:30:50', '02-2017', 'Log Out', 'U', 91),
(91, '47.15.112.116', '2017-02-08 16:30:56', '02-2017', 'Login', 'U', 91),
(91, '47.15.112.116', '2017-02-08 16:31:19', '02-2017', 'Log Out', 'U', 91),
(46, '47.15.112.116', '2017-02-08 16:31:34', '02-2017', 'Login', 'U', 46),
(46, '47.15.112.116', '2017-02-08 16:32:07', '02-2017', 'Log Out', 'U', 46),
(91, '47.15.112.116', '2017-02-08 16:32:14', '02-2017', 'Login', 'U', 91),
(91, '47.15.112.116', '2017-02-08 16:36:31', '02-2017', 'Log Out', 'U', 91),
(91, '47.15.112.116', '2017-02-08 16:36:40', '02-2017', 'Login', 'U', 91),
(91, '47.15.112.116', '2017-02-08 16:43:16', '02-2017', 'Letter Creation', 'L', 10),
(91, '47.15.112.116', '2017-02-08 16:43:46', '02-2017', 'Letter Dispatch', 'L', 10),
(7, '47.15.112.116', '2017-02-08 16:46:29', '02-2017', 'Letter Dispatch', 'L', 10),
(6, '47.15.112.116', '2017-02-08 16:47:56', '02-2017', 'Log Out', 'U', 6),
(91, '47.15.112.116', '2017-02-08 16:50:27', '02-2017', 'File Creation', 'F', 1),
(53, '47.15.112.116', '2017-02-08 16:53:05', '02-2017', 'Login', 'U', 53),
(91, '47.15.112.116', '2017-02-08 16:53:35', '02-2017', 'File Dispatch', 'F', 1),
(53, '47.15.112.116', '2017-02-08 16:55:37', '02-2017', 'File Creation', 'F', 2),
(91, '47.15.112.116', '2017-02-08 17:00:30', '02-2017', 'Letter Attach To File', 'F', 1),
(53, '47.15.112.116', '2017-02-08 17:06:17', '02-2017', 'File Creation', 'F', 3),
(91, '47.15.112.116', '2017-02-08 17:07:42', '02-2017', 'Letter Attach To File', 'F', 1),
(53, '47.15.112.116', '2017-02-08 17:10:04', '02-2017', 'Letter Attach To File', 'F', 3),
(91, '47.15.112.116', '2017-02-08 17:11:36', '02-2017', 'Letter Attach To File', 'F', 1),
(91, '47.15.112.116', '2017-02-08 17:17:00', '02-2017', 'Letter Attach To File', 'F', 1),
(53, '47.15.112.116', '2017-02-08 17:17:17', '02-2017', 'Letter Attach To File', 'F', 3),
(53, '47.15.112.116', '2017-02-08 17:18:42', '02-2017', 'File Dispatch', 'F', 3),
(53, '47.15.112.116', '2017-02-08 17:19:19', '02-2017', 'File Dispatch', 'F', 3),
(53, '47.15.112.116', '2017-02-08 17:20:44', '02-2017', 'Log Out', 'U', 53),
(57, '47.15.112.116', '2017-02-08 17:20:55', '02-2017', 'Login', 'U', 57),
(91, '47.15.112.116', '2017-02-08 17:21:33', '02-2017', 'Letter Attach To File', 'F', 1),
(91, '47.15.112.116', '2017-02-08 17:21:57', '02-2017', 'Log Out', 'U', 91),
(57, '47.15.112.116', '2017-02-08 17:22:00', '02-2017', 'Letter Dispatch', 'L', 10),
(57, '47.15.112.116', '2017-02-08 17:22:14', '02-2017', 'Login', 'U', 57),
(57, '47.15.112.116', '2017-02-08 17:22:26', '02-2017', 'Log Out', 'U', 57),
(58, '47.15.112.116', '2017-02-08 17:23:03', '02-2017', 'Login', 'U', 58),
(58, '47.15.112.116', '2017-02-08 17:24:42', '02-2017', 'Log Out', 'U', 58),
(57, '47.15.112.116', '2017-02-08 17:28:05', '02-2017', 'File Receive', 'F', 3),
(57, '47.15.112.116', '2017-02-08 17:29:11', '02-2017', 'Letter Attach To File', 'F', 3),
(57, '47.15.112.116', '2017-02-08 17:29:47', '02-2017', 'File Dispatch', 'F', 3),
(7, '47.15.112.116', '2017-02-08 17:30:13', '02-2017', 'File Receive', 'F', 3),
(7, '47.15.112.116', '2017-02-08 17:30:18', '02-2017', 'Almirah', 'F', 3),
(7, '47.15.165.228', '2017-02-08 17:33:08', '02-2017', 'Login', 'U', 7),
(7, '47.15.165.228', '2017-02-08 17:34:21', '02-2017', 'Letter Attach To File', 'F', 3),
(53, '47.15.165.228', '2017-02-08 17:38:06', '02-2017', 'Login', 'U', 53),
(57, '47.15.165.228', '2017-02-08 17:38:06', '02-2017', 'Log Out', 'U', 57),
(91, '47.15.165.228', '2017-02-08 17:38:22', '02-2017', 'Login', 'U', 91),
(53, '47.15.165.228', '2017-02-08 17:38:54', '02-2017', 'Shadow File Creation', 'F', 4),
(91, '47.15.165.228', '2017-02-08 17:39:04', '02-2017', 'Shadow File Creation', 'F', 5),
(53, '47.15.165.228', '2017-02-08 17:40:22', '02-2017', 'File Edit', 'F', 2),
(91, '47.15.165.228', '2017-02-08 17:44:43', '02-2017', 'File Edit', 'F', 1),
(53, '47.15.165.228', '2017-02-08 17:46:11', '02-2017', 'File Edit', 'F', 2),
(53, '47.15.165.228', '2017-02-08 17:47:07', '02-2017', 'File Edit', 'F', 2),
(91, '47.15.165.228', '2017-02-08 17:50:25', '02-2017', 'File Edit', 'F', 1),
(53, '47.15.165.228', '2017-02-08 17:58:51', '02-2017', 'Log Out', 'U', 53),
(7, '47.15.165.228', '2017-02-08 17:59:20', '02-2017', 'Log Out', 'U', 7),
(46, '47.15.24.249', '2017-02-08 20:00:06', '02-2017', 'Login', 'U', 46),
(46, '47.15.24.249', '2017-02-08 20:01:01', '02-2017', 'File Creation', 'F', 8),
(46, '47.15.24.249', '2017-02-08 20:02:28', '02-2017', 'Shadow File Creation', 'F', 9),
(46, '47.15.24.249', '2017-02-08 20:08:24', '02-2017', 'File Edit', 'F', 8),
(46, '47.15.24.249', '2017-02-08 20:08:41', '02-2017', 'File Edit', 'F', 8);

-- --------------------------------------------------------

--
-- Table structure for table `fts_personel_info`
--

CREATE TABLE IF NOT EXISTS `fts_personel_info` (
  `emp_desig_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `gpf_id` varchar(255) NOT NULL,
  `desig_id` varchar(255) NOT NULL,
  `sec_id` varchar(255) NOT NULL,
  PRIMARY KEY (`emp_desig_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=93 ;

--
-- Dumping data for table `fts_personel_info`
--

INSERT INTO `fts_personel_info` (`emp_desig_id`, `user_id`, `gpf_id`, `desig_id`, `sec_id`) VALUES
(1, 1, '', '10', '10'),
(2, 2, '', '10', '11'),
(3, 3, '', '10', '12'),
(4, 4, '', '10', '13'),
(5, 5, '', '10', '14,15,20'),
(6, 6, '', '10', '16'),
(7, 7, '', '10', '1'),
(8, 8, '', '10', '3'),
(9, 9, '', '10', '2'),
(10, 10, '', '10', '17'),
(11, 11, '', '10', '18'),
(12, 12, '', '10', '19'),
(13, 13, '', '10', '8'),
(14, 14, '', '10', '4'),
(15, 15, '', '10', '21'),
(16, 16, '', '10', '22'),
(17, 17, '', '10', '23'),
(18, 18, '', '10', '24'),
(19, 19, '', '10', '5'),
(20, 20, '', '10', '25'),
(21, 21, '', '10', '26'),
(22, 22, '', '10', '7'),
(23, 23, '', '10', '27'),
(24, 24, '', '10', '6'),
(25, 25, '', '10', '9'),
(26, 26, '', '10', '29'),
(27, 27, '', '12', '30'),
(28, 28, '', '12', '31'),
(29, 29, '', '12', '32'),
(30, 30, '', '12', '33'),
(31, 31, '', '12', '34'),
(32, 32, '', '12', '35'),
(33, 33, '', '12', '36'),
(34, 34, '', '12', '37'),
(35, 35, '', '12', '38'),
(36, 36, '', '12', '39'),
(37, 37, '', '12', '40'),
(38, 38, '', '12', '41,50'),
(39, 39, '', '12', '42'),
(40, 40, '', '12', '43'),
(41, 41, '', '12', '44'),
(42, 42, '', '12', '45'),
(43, 43, '', '12', '46'),
(44, 44, '', '12', '47'),
(45, 45, '', '12', '49'),
(46, 46, '', '13', '51'),
(47, 47, '', '10', '52'),
(48, 48, '', '10', '53'),
(49, 49, '', '10', '54'),
(50, 50, '', '10', '55'),
(51, 51, '', '10', '57'),
(52, 52, '', '10', '56'),
(53, 53, '', '10', '58'),
(54, 54, '', '10', '59'),
(55, 55, '', '9', '51'),
(56, 56, '', '14', '58'),
(57, 57, '', '1', '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59'),
(58, 58, '', '2', '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59'),
(59, 59, '', '5', '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59'),
(60, 60, '', '3', '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59'),
(61, 61, '', '4', '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59'),
(62, 62, '', '6', '30,31,42,43,48'),
(63, 63, '', '7', '10,11,18,20,22'),
(64, 64, '', '8', '8,14,15,16,19,24,25,26,37,39,49,51,52,55,56'),
(65, 65, '', '32', '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59'),
(66, 66, '', '33', '2,3,4,17,32,33,36,38'),
(67, 67, '', '34', '5,9,21,23,29,45,46,47'),
(68, 68, '', '35', '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59'),
(69, 69, '', '36', '34,35,40'),
(70, 70, '', '37', '41,44,50'),
(71, 71, '', '38', '8,16,51,56,60'),
(72, 72, '', '39', '14,15,52,55,57'),
(73, 73, '', '40', '24,25'),
(74, 74, '', '41', '61'),
(75, 75, '', '42', '19,37,39,49'),
(76, 76, '', '43', '30,31,42,43,48'),
(77, 77, '', '44', '4,17,23'),
(78, 78, '', '45', '32,33,36,38'),
(79, 79, '', '46', '1,5,9,21,62'),
(80, 80, '', '48', '41,44,50'),
(81, 81, '', '49', '34,35,40'),
(82, 82, '', '50', '13,18'),
(83, 83, '', '51', '2,3,10,11,20'),
(84, 84, '', '52', '29,45,46,47'),
(85, 85, '', '53', '61'),
(86, 86, '', '54', '63'),
(87, 87, '', '55', '63'),
(88, 88, '', '56', '29,36,45'),
(89, 89, '', '57', '22,30,31,48'),
(90, 90, '', '58', '5'),
(91, 91, '123ABC', '1', '10'),
(92, 92, '12vc', '2', '56');

-- --------------------------------------------------------

--
-- Table structure for table `fts_register_type`
--

CREATE TABLE IF NOT EXISTS `fts_register_type` (
  `reg_type_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `category_register` varchar(50) NOT NULL,
  PRIMARY KEY (`reg_type_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=8 ;

--
-- Dumping data for table `fts_register_type`
--

INSERT INTO `fts_register_type` (`reg_type_id`, `category_register`) VALUES
(1, 'A'),
(2, 'B'),
(3, 'D'),
(4, 'E'),
(5, 'F'),
(6, 'I'),
(7, 'N');

-- --------------------------------------------------------

--
-- Table structure for table `fts_section`
--

CREATE TABLE IF NOT EXISTS `fts_section` (
  `sec_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `sec_name` varchar(255) NOT NULL,
  `sec_code` varchar(50) NOT NULL,
  `parent_sec` bigint(20) NOT NULL,
  PRIMARY KEY (`sec_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=78 ;

--
-- Dumping data for table `fts_section`
--

INSERT INTO `fts_section` (`sec_id`, `sec_name`, `sec_code`, `parent_sec`) VALUES
(1, 'Cyber Crime ', 'CYBER', 0),
(2, 'Homicide', 'HOMISIDE', 0),
(3, 'D.R.BT', 'DRBT', 0),
(4, 'M.T.S', 'MTS', 0),
(5, 'S.O.G', 'SOG', 0),
(6, 'R.O.', 'RO', 0),
(7, 'R.I', 'RI', 0),
(8, 'M.T Section', 'MT-SEC', 0),
(9, 'ATS', 'ATS', 0),
(10, 'A.H.T.U', 'AHTU', 0),
(11, 'POWC', 'POWC', 0),
(12, 'B.D.D.S', 'BDDS', 0),
(13, 'C & F', 'CF', 0),
(14, 'C.I. Sec', 'CI-SEC', 0),
(15, 'C.I.W', 'CIW', 0),
(16, 'Computer Section', 'COM-SEC', 0),
(17, 'Rly.& Hgy.', 'RLYHGY', 0),
(18, 'E.O.W', 'EOW', 0),
(19, 'Law Cell', 'LAW', 0),
(20, 'M.P.B', 'MPB', 0),
(21, 'M.Unit', 'MUNIT', 0),
(22, 'Narcotic', 'NARCOTIC', 0),
(23, 'SCU', 'SCU', 0),
(24, 'Photo Section', 'PHOTO-SEC', 0),
(25, 'QDEB', 'QDEB', 0),
(26, 'FPB', 'FPB', 0),
(27, 'CID CR', 'CID-CR', 0),
(29, 'DD Bankura', 'DD-BANKURA', 0),
(30, 'DD Barasat', 'DD-BARAST', 0),
(31, 'DD Barrackpur', 'DD-BARRACKPUR', 0),
(32, 'DD Birbhum', 'DD-BIRBHUM', 0),
(33, 'DD Burdwan', 'DD-BURDWAN', 0),
(34, 'DD Coochbehar', 'DD-COCHBEHAR', 0),
(35, 'DD Darjeeling', 'DD-DARJEELING', 0),
(36, 'DD Durgapur / Asansol', 'DD-DURGAPUR-ASANSOL', 0),
(37, 'DD Diamond Harbour', 'DD-DIAMONDHARBOUR', 0),
(38, 'DD Hooghly', 'DD-HOOGLY', 0),
(39, 'DD Howrah', 'DD-HOWRAH', 0),
(40, 'DD Jalpaiguri', 'DD-JALPAIGURI', 0),
(41, 'DD Malda', 'DD-MALDA', 0),
(42, 'DD Murshidabad', 'DD-MURSHIDABAD', 0),
(43, 'DD Nadia', 'DD-NADIA', 0),
(44, 'DD North Dinajpur', 'DD-NORTHDIBAJPUR', 0),
(45, 'DD Purulia', 'DD-PURULIA', 0),
(46, 'DD Purba MDP', 'DD-PURBO-MDP', 0),
(47, 'DD Paschim MDP', 'DD-PACHIM-MDP', 0),
(48, 'DD Salt Lake', 'DD-SALTLAKE', 0),
(49, 'DD Sadar (Alipore)', 'DD-SADAR-ALIPORE', 0),
(50, 'DD South Dinajpur', 'DD-SOUTHDINAJPUR', 0),
(51, 'Police Office', 'POLICEOFFICE', 0),
(52, 'Lock UP', 'LOCKUP', 0),
(53, 'P.A. to A.D.G. CID', 'PA-ADG-CID', 0),
(54, 'Tele-Comm', 'TELECOM', 0),
(55, 'Control Room', 'CONTROLROOM', 0),
(56, 'Armourary Sec', 'ARMOURARYSEC', 0),
(57, 'Library Sec', 'LIBRARYSEC', 0),
(58, 'O.S. Police Office', 'OS-POLICEOFFICE', 0),
(59, 'Data Base Section', 'DATABASE-SEC', 0),
(60, 'DDO', 'DDO', 0),
(61, 'Finger Print Bureau', 'FINGER-PRINT', 0),
(62, 'Cyber Patrol Cell', 'CYBER-PATROL', 0),
(63, 'TRAIL MONITORING', 'TRAIL-MONITORING', 0),
(64, 'REFERENCE SECTION', 'REFERENCE-SEC', 51),
(65, 'DESPATCH SECTION', 'DESPATCH-SEC', 51),
(66, 'CRIME SECTION', 'CRIME-SEC', 51),
(67, 'ACCOUNTS PAYBILL', 'ACCOUNTS-PAYBILL', 51),
(68, 'GAZETTED OFFICERS CELL', 'GO-CELL', 51),
(69, 'MODERNISATION', 'MODERNISATION', 51),
(70, 'GL-I', 'GL-I', 51),
(71, 'GL-II', 'GL-II', 51),
(72, 'LEAVE SECTION', 'LEAVE-SEC', 51),
(73, 'ACCOUNTS GPF', 'ACCOUNTS-GPF', 51),
(74, 'ACCOUNTS CC', 'ACCOUNTS-CC', 51),
(75, 'ACCOUNTS TA', 'ACCOUNTS-TA', 51),
(76, 'ACCOUNTS MEDICAL', 'ACCOUNTS-MEDICAL', 51),
(77, 'ACCOUNTS PENSION', 'ACCOUNTS-PENSION', 51);

-- --------------------------------------------------------

--
-- Table structure for table `fts_subject`
--

CREATE TABLE IF NOT EXISTS `fts_subject` (
  `subject_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `subject_name` varchar(255) NOT NULL,
  PRIMARY KEY (`subject_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=8 ;

--
-- Dumping data for table `fts_subject`
--

INSERT INTO `fts_subject` (`subject_id`, `subject_name`) VALUES
(1, 'Allotment of Fund'),
(2, 'Ammunition'),
(3, 'Arms'),
(4, 'Assembly Questions'),
(5, 'Audit'),
(6, 'Advertisement'),
(7, 'RECRUITMENT OF DEO');

-- --------------------------------------------------------

--
-- Table structure for table `fts_user`
--

CREATE TABLE IF NOT EXISTS `fts_user` (
  `user_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `gpf_id` varchar(100) NOT NULL,
  `name` varchar(255) NOT NULL,
  `gender` enum('M','F') NOT NULL,
  `user_name` varchar(100) NOT NULL,
  `phone` varchar(18) NOT NULL,
  `email` varchar(100) NOT NULL,
  `password` varchar(100) NOT NULL,
  `last_login` datetime NOT NULL,
  `user_type` varchar(11) NOT NULL,
  `reg_date` datetime NOT NULL,
  `is_active` enum('Y','N') NOT NULL,
  `is_deleted` enum('N','Y') NOT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=93 ;

--
-- Dumping data for table `fts_user`
--

INSERT INTO `fts_user` (`user_id`, `gpf_id`, `name`, `gender`, `user_name`, `phone`, `email`, `password`, `last_login`, `user_type`, `reg_date`, `is_active`, `is_deleted`) VALUES
(1, '', 'A.H.T.U. OC', 'F', 'sarbari', '9836250868', 'sarbari@gmail.com', '440434ebadbfbb311aad991d3d0f48dc', '2017-01-20 14:33:11', 'normal_user', '2017-01-11 23:03:56', 'Y', 'N'),
(2, '', 'POWC OC', 'F', 'kakali', '9830501201', 'kakali@gmail.com', 'c9db8225de88c92c3d0e85527082a7d7', '2017-01-20 12:17:11', 'normal_user', '2017-01-11 23:05:37', 'Y', 'N'),
(3, '', 'B.D.D.S. OC', 'M', 'sambhu', '8697985191', 'sambhu@gmail.com', 'c618511b8d8da2bb0f60638bba569cd5', '2017-01-20 12:18:11', 'normal_user', '2017-01-11 23:07:31', 'Y', 'N'),
(4, '', 'C & F OC', 'M', 'arindrajit', '9432070393', 'arindrajit@gmail.com', 'ea9bcf4d694aea7054e27603521392a2', '0000-00-00 00:00:00', 'normal_user', '2017-01-11 23:09:16', 'Y', 'N'),
(5, '', 'C.I. Sec OC', 'M', 'aparna', '9433187409', 'aparna@gmail.com', '46aab74d298e13f19d28aa38dda7277f', '2017-02-08 12:12:06', 'normal_user', '2017-01-11 23:11:03', 'Y', 'N'),
(6, '', 'Computer Section OC', 'M', 'maharshi', '9331159489', 'mahershi@gmail.com', 'dd942dcaceb40438a09b809d3101ece4', '2017-02-08 16:20:20', 'normal_user', '2017-01-11 23:44:27', 'Y', 'N'),
(7, '', 'Cyber Crime OC', 'M', 'rajarshi', '9836769722', 'rajarshi@gmail.com', '49249158d7c1f79ebe942bd24e7ae926', '2017-02-08 17:33:08', 'normal_user', '2017-01-11 23:46:43', 'Y', 'N'),
(8, '', 'D.R.BT OC', 'M', 'bijoy', '9475433955', 'bijoy@gmail.com', '605ab26297d84bf9ff5344870dd8a85a', '2017-01-20 12:18:59', 'normal_user', '2017-01-11 23:48:24', 'Y', 'N'),
(9, '', 'Homicide OC', 'M', 'pallab', '9051515997', 'pallab@gmail.com', 'd5e323ab460b1453ead64258b2db5456', '0000-00-00 00:00:00', 'normal_user', '2017-01-11 23:49:53', 'Y', 'N'),
(10, '', 'Rly. & Hgy. OC', 'M', 'drubajyoti', '9836114449', 'drubajyoti@gmail.com', '7efa8695aee1cfbe3f1c37d3fe53ea26', '0000-00-00 00:00:00', 'normal_user', '2017-01-11 23:52:05', 'Y', 'N'),
(11, '', 'E.O.W. OC', 'M', 'tirthankar', '9830609052', 't@gmail.com', '6145ff69aa2c9dfc9a493125dae37da2', '0000-00-00 00:00:00', 'normal_user', '2017-01-11 23:54:07', 'Y', 'N'),
(12, '', 'Law Cell OC', 'M', 'asoke', '9433133442', 'a@gmail.com', '4a7e6cd940b871bae52d7b592f09c686', '0000-00-00 00:00:00', 'normal_user', '2017-01-11 23:55:47', 'Y', 'N'),
(13, '', 'M.T.Sec OC', 'M', 'amitava', '9836064334', 'ami@gmail.com', '095d611f2ced24942461da530e62b07d', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:04:36', 'Y', 'N'),
(14, '', 'M.T.S. OC', 'M', 'manas', '9432126319', 'ma@gmail.com', '5d45c58ea1ef37f17c2f885219215426', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:06:09', 'Y', 'N'),
(15, '', 'M.Unit OC', 'M', 'ashim', '8145201051', 'ashim@gmail.com', '1babd634c07d6ac0d35ecfe06e5cc1a6', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:07:45', 'Y', 'N'),
(16, '', 'Narcotic OC', 'M', 'krishnendu', '9836943332', 'krish@gmail.com', '71d802c9fdfb1f8d6a4f47db73d79742', '2017-01-16 13:08:04', 'normal_user', '2017-01-12 00:10:50', 'Y', 'N'),
(17, '', 'SCU OC', 'M', 'somendra', '9874221904', 'som@gmail.com', '1a8273e7476ae3d923b6663552c8e000', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:12:29', 'Y', 'N'),
(18, '', 'Photo Sec. OC', 'M', 'gopal', '9874752175', 'gopal@gmail.com', 'e123edb488db303fde7b3ad19134361d', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:13:41', 'Y', 'N'),
(19, '', 'S.O.G. OC', 'M', 'sougata', '9434123560', 'sou@gmail.com', 'c24dbe383c82b93997d244fc9ead3f10', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:15:00', 'Y', 'N'),
(20, '', 'QDEB OC', 'M', 'ujjalendra', '9874760788', 'ujjal@gmail.com', 'c16eec645aca0253e1f1f8851fd9e6cb', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:16:59', 'Y', 'N'),
(21, '', 'FPB OC', 'M', 'debasis', '9051096664', 'deba@gmail.com', 'd813946bc12f2e3a8d87192582fd78e6', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:18:44', 'Y', 'N'),
(22, '', 'R.I OC', 'M', 'avijit', '9831110707', 'avijit@gmail.com', '028d296f6c0bab381e401515be8eb9e4', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:20:20', 'Y', 'N'),
(23, '', 'CID CR OC', 'M', 'sunil', '9434187286', 'sunil@gmail.com', 'b0b86080c976aa7651bffe0801644d74', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:21:41', 'Y', 'N'),
(24, '', 'R.O. OC', 'M', 'goutam', '9051025729', 'goutam@gmail.com', '67b47334b0acbe725e3a15ddca14f7a9', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:23:23', 'Y', 'N'),
(25, '', 'ATS OC', 'M', 'sudip', '9830024251', 'sudip@gmail.com', '550bbf0991fd493d1afaa2bdd246af6a', '2017-01-12 02:08:32', 'normal_user', '2017-01-12 00:24:36', 'Y', 'N'),
(26, '', 'Bankura DD', 'M', 'manik', '9474184351', 'manik@gmail.com', 'e2e735edee93b141f8db7d861af5ba90', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:34:38', 'Y', 'N'),
(27, '', 'BARASAT DD', 'M', 'salim', '9830326430', 'salim@gmail.com', 'ca6b147b8fbdd688d8ebcaa3b803c22a', '2017-01-20 14:37:06', 'normal_user', '2017-01-12 00:41:42', 'Y', 'N'),
(28, '', 'Barrackpur DD', 'M', 'simul', '9434142177', 'simul@gmail.com', 'b43ff3bdf49a21cf04ffb82df19ffc4a', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:46:11', 'Y', 'N'),
(29, '', 'Birbhum DD', 'M', 'prasanta', '9474632211', 'prasanta@gmail.com', '29fe2f755ccc23b62f1702dbc644eed4', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:47:42', 'Y', 'N'),
(30, '', 'Burdwan DD', 'M', 'bichitra', '9734909204', 'bichitra@gmail.com', '7beb92acb62f43d617bc39baa96d86a6', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:49:10', 'Y', 'N'),
(31, '', 'Coochbehar DD', 'M', 'ashis', '9434174255', 'ashis@gmail.com', '7945ff32978d89dc5ecdc23a44251700', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:50:35', 'Y', 'N'),
(32, '', 'Darjeeling DD', 'M', 'prasanna', '9474963305', 'prasanna@gmail.com', 'adf825e70a5bd444872f83e35086a851', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:52:16', 'Y', 'N'),
(33, '', 'Durgapur/ Asansol DD', 'M', 'shyamal', '9933455548', 'shyamal@gmail.com', '0c7d73764986d70ae7af208f6ef0509f', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:53:41', 'Y', 'N'),
(34, '', 'Diamon Harbour DD', 'M', 'atibur', '9830092544', 'ati@gmail.com', '1e6a6f243a568787bc8327d7aefeba2f', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:54:50', 'Y', 'N'),
(35, '', 'Hoogly DD', 'M', 'narayan', '9475051107', 'narayan@gmail.com', '762a8f47e2a15a321a3f0472c6d1cb6d', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:56:33', 'Y', 'N'),
(36, '', 'Howrah DD', 'M', 'subhas', '9836348897', 'subhas@gmail.com', '57ee47677feccae1c67291c373d5fb9a', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:57:39', 'Y', 'N'),
(37, '', 'Jalpaiguri DD', 'M', 'suraj', '7586989677', 'suraj@gmail.com', '4dd49f4f84e4d6945e3bc6d14812004e', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 00:58:51', 'Y', 'N'),
(38, '', 'Malda DD', 'M', 'raju', '9434449616', 'raju@gmail.com', '03c017f682085142f3b60f56673e22dc', '2017-01-12 01:39:46', 'normal_user', '2017-01-12 01:00:28', 'Y', 'N'),
(39, '', 'Murshidabad DD', 'M', 'sudipta', '9830176188', 'sudipta@gmail.com', '82482e6d4b367c8bacb569dbaab76cab', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 01:01:44', 'Y', 'N'),
(40, '', 'Nadia DD', 'M', 'bibek', '9733612129', 'bibek@gmail.com', 'b52100c453228b8eadd4a3642fc412f0', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 01:03:01', 'Y', 'N'),
(41, '', 'North Dinajpur DD', 'M', 'rakesh', '9564245446', 'rakesh@gmail.com', '67a05e3822ce48a6386746388e6c81f5', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 01:04:21', 'Y', 'N'),
(42, '', 'Purulia DD', 'M', 'sujit', '8001010666', 'sujit@gmail.com', 'e68adc58f2062f58802e4cdcfec0af2d', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 01:05:27', 'Y', 'N'),
(43, '', 'Prubo MDP DD', 'M', 'shrisudip', '9434990948', 'sudipbnr@gmail.com', '6ccdfab3beb2309b4720ca70dee25b10', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 01:08:32', 'Y', 'N'),
(44, '', 'Paschim MDP DD', 'M', 'debasispahari', '8436697270', 'debasis@gmail.com', 'e76c5118aafa321faf85e4e1a79e5f14', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 01:10:50', 'Y', 'N'),
(45, '', 'Sadar (Alipore) DD', 'M', 'satyabrata', '9434021717', 'satyabrata@gmail.com', '9cd6fdd682973ba6f3b506ad0cef469e', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 01:14:01', 'Y', 'N'),
(46, '', 'ADMIN', 'M', 'admin', '1234567890', 'admin@gmail.com', 'ee10c315eba2c75b403ea99136f5b48d', '2017-02-08 20:00:06', 'admin', '2017-01-12 01:26:42', 'Y', 'N'),
(47, '', 'OC LOCKUP', 'M', 'oclockup', '1234567890', 'lock@gmail.com', '8885d4bc39a0b84533798bd714451a4b', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 01:55:37', 'Y', 'N'),
(48, '', 'OC PA ADG', 'M', 'pa', '2123456789', 'pa@gmail.com', 'e529a9cea4a728eb9c5828b13b22844c', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 01:56:52', 'Y', 'N'),
(49, '', 'OC TELECOM', 'M', 'telecom', '3212345678', 'telecom@gmail.com', '29e7396b6b7e8b8ab20daabcde1c7732', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 01:57:53', 'Y', 'N'),
(50, '', 'OC CONTROL', 'M', 'control', '4212345678', 'control@gmail.com', 'fc5364bf9dbfa34954526becad136d4b', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 01:59:04', 'Y', 'N'),
(51, '', 'OC LIBRARY', 'M', 'library', '5432123456', 'lib@gmail.com', 'd521f765a49c72507257a2620612ee96', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 02:00:09', 'Y', 'N'),
(52, '', 'OC ARMOURARY', 'M', 'armourary', '6543123456', 'armourary@gmail.com', '25cc679b418a0f960875ba65b8021caf', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 02:01:30', 'Y', 'N'),
(53, '', 'OS POLICE', 'M', 'ospolice', '7654321234', 'os@gmail.com', '833469d82f4b29edf0e5df3962cff141', '2017-02-08 17:38:06', 'admin', '2017-01-12 02:02:51', 'Y', 'N'),
(54, '', 'OC DATABASE', 'M', 'tapan', '9876543210', 'tapan@gmail.com', '40909d4fa936ef6397fb8f6439cb7555', '0000-00-00 00:00:00', 'normal_user', '2017-01-12 02:03:46', 'Y', 'N'),
(55, '', 'PARTHA PROTIM SARKAR', 'M', 'parthaprotim', '9836527295', 'partha68pps@gmail.com', '48b9803d55887976945ab373a2a18779', '2017-01-20 15:28:43', 'admin', '2017-01-17 13:21:42', 'N', 'N'),
(56, '', 'SHARMILA TALUKDER', 'F', 'Sharmila', '8698697706', 'sharmila@gmail.com', 'd84cdb668ae6ba4872a3bbae9639d3cc', '2017-01-20 15:25:14', 'normal_user', '2017-01-17 15:23:37', 'Y', 'N'),
(57, '', 'ADGP CID', 'M', 'adgcid', '1234567890', 'adgp@yahoo.in', '8737cb8dd9ce72985fa590d8dafad3ad', '2017-02-08 17:22:14', 'normal_user', '2017-01-19 13:52:20', 'Y', 'N'),
(58, '', 'IGP I CID', 'M', 'igpi', '1234567890', 'igpi@yahoo.in', '5f2eada2918862680e4cfa7754c17e0d', '2017-02-08 17:23:03', 'normal_user', '2017-01-19 13:53:33', 'Y', 'N'),
(59, '', 'IGP II CID', 'M', 'igpii', '1234567890', 'igpii@yahoo.in', 'ae5af062f94704135e4fb3afd415c29b', '0000-00-00 00:00:00', 'normal_user', '2017-01-19 13:54:40', 'Y', 'N'),
(60, '', 'DIG OPS', 'M', 'digops', '1234567890', 'digpos@yahoo.in', '0d700a9a6528faf3ae2c78d032d1533c', '0000-00-00 00:00:00', 'normal_user', '2017-01-19 13:55:43', 'Y', 'N'),
(61, '', 'DIG CID', 'M', 'digcid', '1234567890', 'digcid@yahoo.in', '5098fb20281134fcfe7de96b4701a3ea', '0000-00-00 00:00:00', 'normal_user', '2017-01-19 13:56:41', 'Y', 'N'),
(62, '', 'SS SOUTH', 'M', 'sssouth', '1234567890', 'sssouth@yahoo.in', '744cd575070769e5ff8ac09c0f560a2c', '2017-01-19 15:36:58', 'normal_user', '2017-01-19 13:57:42', 'Y', 'N'),
(63, '', 'SS SPECIAL', 'M', 'ssspecial', '1234567890', 'ssspecial@yahoo.in', '479a341a3ae56855c21bcea0ea3d9228', '2017-01-25 10:48:13', 'normal_user', '2017-01-19 13:59:08', 'Y', 'N'),
(64, '', 'SS HQ', 'M', 'sshq', '1234567890', 'sshq@yahoo.in', '7e7c9cc36dea8877c4637217425f0195', '2017-01-19 15:30:11', 'normal_user', '2017-01-19 13:59:54', 'Y', 'N'),
(65, '', 'DIG SPECIAL', 'M', 'digspecial', '1234567890', 'digspecial@yahoo.in', 'bcfdef95574135a0aac828a53c21d039', '0000-00-00 00:00:00', 'normal_user', '2017-01-19 14:01:12', 'Y', 'N'),
(66, '', 'SS WEST', 'M', 'sswest', '1234567890', 'sswest@yahoo.in', '6f91edd3be84418bda4f9c2474291114', '2017-01-19 15:57:33', 'normal_user', '2017-01-19 14:02:09', 'Y', 'N'),
(67, '', 'SS OPS', 'M', 'ssops', '1234567890', 'ssops@yahoo.in', 'a33843d3e5f9cd56012f66c530e58c94', '2017-01-19 23:08:01', 'normal_user', '2017-01-19 14:03:01', 'Y', 'N'),
(68, '', 'SS N/B', 'M', 'ssnb', '1234567890', 'ssnb@yahoo.in', '27526ffe2d3c4a346ee3a308823635e1', '0000-00-00 00:00:00', 'normal_user', '2017-01-19 14:04:04', 'N', 'N'),
(69, '', 'SS NORTH', 'M', 'ssnorth', '1234567890', 'ssnorth@yahoo.in', '3918a97f4846261e3765d718474f72e0', '2017-01-19 23:12:43', 'normal_user', '2017-01-19 14:05:19', 'Y', 'N'),
(70, '', 'SS MALDA', 'M', 'ssmalda', '1234567890', 'ssmalda@yahoo.in', '0341d7d3b32f732aa713c5acb3c38f13', '2017-01-19 17:16:57', 'normal_user', '2017-01-19 14:06:22', 'Y', 'N'),
(71, '', 'DS HQRS & DDO', 'M', 'dshq', '1234567890', 'dshqrs@yahoo.in', 'bbfb33e73f0cb96f788b76a304d70b58', '2017-01-20 14:11:05', 'normal_user', '2017-01-19 17:04:19', 'Y', 'N'),
(72, '', 'DS HQRS II', 'M', 'dshqii', '1234567890', 'dshqrsii@yahoo.in', '55991146f14b9814097e5cdcadcc2622', '0000-00-00 00:00:00', 'normal_user', '2017-01-19 23:18:57', 'Y', 'N'),
(73, '', 'DIRECTOR QDEB', 'M', 'diqdeb', '1234567890', 'diqdeb@yahoo.in', '78f82a8179dfdc72b6899fbf450095f8', '0000-00-00 00:00:00', 'normal_user', '2017-01-19 23:21:19', 'Y', 'N'),
(74, '', 'DIRECTOR FPB', 'M', 'difpb', '1234567890', 'difpb@yahoo.in', '9fabd410f27aaaf1f30f557a2e158f86', '0000-00-00 00:00:00', 'normal_user', '2017-01-19 23:23:48', 'Y', 'N'),
(75, '', 'DS SOUTH', 'M', 'dssouth', '1234567890', 'dssouth@yahoo.in', '3bf32c43acebfba20f8ffda85696ce01', '0000-00-00 00:00:00', 'normal_user', '2017-01-19 23:31:44', 'Y', 'N'),
(76, '', 'DS MURSHIDABAD', 'M', 'dsmushidabad', '1234567890', 'dsmurshi@yahoo.in', '278ee24f5d32e5000227259c964a9f8e', '0000-00-00 00:00:00', 'normal_user', '2017-01-19 23:34:52', 'Y', 'N'),
(77, '', 'DS HIGHWAY', 'M', 'dshighway', '1234567890', 'dshigh@yahoo.in', '46e22fb895297bbed0054ba133743cce', '0000-00-00 00:00:00', 'normal_user', '2017-01-19 23:36:57', 'Y', 'N'),
(78, '', 'DS BURDWAN', 'M', 'dsburdwan', '1234567890', 'dsburd@yahoo.in', '5487931d79c415e3575e481ac0e7340e', '0000-00-00 00:00:00', 'normal_user', '2017-01-19 23:39:21', 'Y', 'N'),
(79, '', 'DS ATS', 'M', 'dsats', '1234567890', 'dsats@yahoo.in', '0aefbbc5fd452771f4e770e9a9155a26', '2017-01-19 23:43:50', 'normal_user', '2017-01-19 23:43:23', 'Y', 'N'),
(80, '', 'DS MALDA', 'M', 'dsmalda', '1234567890', 'dsmalda@yahoo.in', 'd8c603a73f09e4f645b95cb569bf5659', '0000-00-00 00:00:00', 'normal_user', '2017-01-19 23:55:17', 'Y', 'N'),
(81, '', 'DS SILIGURI', 'F', 'dssiliguri', '1234567890', 'dssiliguri@yahoo.in', '02980384f904bd44767a5bb915a3f8e2', '0000-00-00 00:00:00', 'normal_user', '2017-01-20 00:00:35', 'Y', 'N'),
(82, '', 'DS ANTI CHEATING AND FRAUD', 'M', 'dsacf', '1234567890', 'dsacf@yahoo.in', '9779ad1279c8541e98be432854d0954f', '0000-00-00 00:00:00', 'normal_user', '2017-01-20 00:03:20', 'Y', 'N'),
(83, '', 'DS (SPL) & DS T/C', 'M', 'dssptc', '1234567890', 'dssptc@yahoo.in', 'e96944fb2b3018e2e99f1fb558898edb', '0000-00-00 00:00:00', 'normal_user', '2017-01-20 11:19:52', 'Y', 'N'),
(84, '', 'OSD MEDINAPUR', 'M', 'osdmed', '1234567890', 'osdmed@yahoo.in', 'c44bab0ea72d458c93426878ecea02f1', '0000-00-00 00:00:00', 'normal_user', '2017-01-20 11:22:03', 'Y', 'N'),
(85, '', 'OSD FPB', 'M', 'osdfpb', '1234567890', 'osdfpb@yahoo.in', '2d08748ff5e9a75a1a1f6959a4b0068e', '0000-00-00 00:00:00', 'normal_user', '2017-01-20 11:23:28', 'Y', 'N'),
(86, '', 'OSD TRAINING', 'M', 'osdtrain', '1234567890', 'osdtraining@yahoo.in', 'e6d26817c32c91f7bf99b6565d14a314', '0000-00-00 00:00:00', 'normal_user', '2017-01-20 11:30:17', 'Y', 'N'),
(87, '', 'OSD TRAIL MONITORING', 'M', 'osdtrail', '1234567890', 'osdtrail@yahoo.in', '097c61e15af51065521fd975f745bc0d', '0000-00-00 00:00:00', 'normal_user', '2017-01-20 11:32:27', 'Y', 'N'),
(88, '', 'DS BANKURA', 'M', 'dsbankura', '1234567890', 'dsbankura@yahoo.in', '9831ca5c9705d1596584ddd480734f45', '0000-00-00 00:00:00', 'normal_user', '2017-01-20 11:36:36', 'Y', 'N'),
(89, '', 'DS NORTH 24 PGS', 'M', 'dsnorthpgs', '1234567890', 'dsnorth24pgs@yahoo.in', '72eae67e1d4751f6509d7428f15893d5', '0000-00-00 00:00:00', 'normal_user', '2017-01-20 11:40:31', 'Y', 'N'),
(90, '', 'DS (SPL) SILIGURI', 'M', 'dssplsiliguri', '1234567890', 'dssplsiliguri@yahoo.in', '3e5ce7292d43fedb95eb104a00033a12', '0000-00-00 00:00:00', 'normal_user', '2017-01-20 11:44:00', 'Y', 'N'),
(91, '123ABC', 'SHILPA CHAKRABORTY', 'F', 'SHILPA', '1234567898', 'SHILPA@GMAIL.COM', '202cb962ac59075b964b07152d234b70', '2017-02-08 17:38:22', 'admin', '2017-02-08 13:25:41', 'Y', 'N'),
(92, '12vc', 'SUPRAVA ROY', 'F', 'sup', '0987654321', 'suprava@yahoo.com', '202cb962ac59075b964b07152d234b70', '0000-00-00 00:00:00', 'normal_user', '2017-02-08 13:33:40', 'N', 'N');

-- --------------------------------------------------------

--
-- Table structure for table `test`
--

CREATE TABLE IF NOT EXISTS `test` (
  `id` int(11) NOT NULL,
  `txt` longtext NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
